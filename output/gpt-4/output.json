[{"id": "1", "llm_annotated_code": "class AreaCalculator:\n    \"\"\"\n    This is a class for calculating the area of different shapes, including circle, sphere, cylinder, sector and annulus.\n    \"\"\"\n\n    def __init__(self, radius):\n        \"\"\"\n        Initialize the radius for shapes.\n        :param radius: float\n        \"\"\"\n        # Store the radius for the shapes\n        self.radius = radius\n\n    def calculate_circle_area(self):\n        \"\"\"\n        calculate the area of circle based on self.radius\n        :return: area of circle, float\n        >>> areaCalculator = AreaCalculator(2)\n        >>> areaCalculator.calculate_circle_area()\n        12.566370614359172\n        \"\"\"\n        # Calculate and return the area of a circle using the formula pi*r^2\n        return math.pi * self.radius ** 2\n\n    def calculate_sphere_area(self):\n        \"\"\"\n        calculate the area of sphere based on self.radius\n        :return: area of sphere, float\n        >>> areaCalculator = AreaCalculator(2)\n        >>> areaCalculator.calculate_sphere_area()\n        50.26548245743669\n        \"\"\"\n        # Calculate and return the surface area of a sphere using the formula 4*pi*r^2\n        return 4 * math.pi * self.radius ** 2\n\n    def calculate_cylinder_area(self, height):\n        \"\"\"\n        calculate the area of cylinder based on self.radius and height\n        :param height: height of cylinder, float\n        :return: area of cylinder, float\n        >>> areaCalculator = AreaCalculator(2)\n        >>> areaCalculator.calculate_cylinder_area(3)\n        62.83185307179586\n        \"\"\"\n        # Calculate and return the surface area of a cylinder using the formula 2*pi*r*(r+h)\n        return 2 * math.pi * self.radius * (self.radius + height)\n\n    def calculate_sector_area(self, angle):\n        \"\"\"\n        calculate the area of sector based on self.radius and angle\n        :param angle: angle of sector, float\n        :return: area of sector, float\n        >>> areaCalculator = AreaCalculator(2)\n        >>> areaCalculator.calculate_sector_area(math.pi)\n        6.283185307179586\n        \"\"\"\n        # Calculate and return the area of a sector using the formula r^2*angle/2\n        return self.radius ** 2 * angle / 2\n\n    def calculate_annulus_area(self, inner_radius, outer_radius):\n        \"\"\"\n        calculate the area of annulus based on inner_radius and out_radius\n        :param inner_radius: inner radius of sector, float\n        :param outer_radius: outer radius of sector, float\n        :return: area of annulus, float\n        >>> areaCalculator.calculate_annulus_area(2, 3)\n        15.707963267948966\n        \"\"\"\n        # Calculate and return the area of an annulus using the formula pi*(R^2-r^2)\n        return math.pi * (outer_radius ** 2 - inner_radius ** 2)"}, {"id": "2", "llm_annotated_code": "class ArgumentParser:\n    \"\"\"\n    This is a class for parsing command line arguments to a dictionary.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the fields.\n        self.arguments is a dict that stores the args in a command line\n        self.requried is a set that stores the required arguments\n        self.types is a dict that stores type of every arguments.\n        \"\"\"\n        self.arguments = {}  # Dictionary to store command line arguments\n        self.required = set()  # Set to store required arguments\n        self.types = {}  # Dictionary to store the type of each argument\n\n    def parse_arguments(self, command_string):\n        \"\"\"\n        Parses the given command line argument string and stores the parsed result in the arguments dictionary.\n        Checks for missing required arguments, if any, and returns False with the missing argument names, otherwise returns True.\n        :param command_string: str, command line argument string, formatted like \"python script.py --arg1=value1 -arg2 value2 --option1 -option2\"\n        :return tuple: (True, None) if parsing is successful, (False, missing_args) if parsing fails,\n            where missing_args is a set of the missing argument names which are str.\n        \"\"\"\n\n        # Split the command string into a list of arguments\n        args = command_string.split()[1:]\n        for i in range(len(args)):\n            arg = args[i]\n            # Check if the argument starts with '--'\n            if arg.startswith('--'):\n                # Split the argument into key and value\n                key_value = arg[2:].split('=')\n                # If the argument has a value, convert the value to the appropriate type and store it in the arguments dictionary\n                if len(key_value) == 2:\n                    self.arguments[key_value[0]] = self._convert_type(key_value[0], key_value[1])\n                # If the argument does not have a value, store it in the arguments dictionary with a value of True\n                else:\n                    self.arguments[key_value[0]] = True\n            # Check if the argument starts with '-'\n            elif arg.startswith('-'):\n                key = arg[1:]\n                # If the next argument does not start with '-', it is the value of the current argument\n                if i + 1 < len(args) and not args[i + 1].startswith('-'):\n                    self.arguments[key] = self._convert_type(key, args[i + 1])\n                # If the next argument starts with '-', the current argument does not have a value and is stored in the arguments dictionary with a value of True\n                else:\n                    self.arguments[key] = True\n\n        # Check for missing required arguments\n        missing_args = self.required - set(self.arguments.keys())\n        if missing_args:\n            return False, missing_args\n\n        return True, None\n\n    def get_argument(self, arg):\n        \"\"\"\n        Retrieves the value of the specified argument from the arguments dictionary and returns it.\n        :param arg: str, argument name\n        :return: The value of the argument, or None if the argument does not exist.\n        \"\"\"\n\n        # Return the value of the specified argument from the arguments dictionary\n        return self.arguments.get(arg)\n\n    def add_argument(self, arg, required=False, arg_type=str):\n        \"\"\"\n        Adds an argument to self.types and self.required.\n        Check if it is a required argument and store the argument type.\n        If the argument is set as required, it wull be added to the required set.\n        The argument type and name are stored in the types dictionary as key-value pairs.\n        :param arg: str, argument name\n        :param required: bool, whether the argument is required, default is False\n        :param arg_type:str, Argument type, default is str\n        \"\"\"\n\n        # If the argument is required, add it to the required set\n        if required:\n            self.required.add(arg)\n        # Store the type of the argument in the types dictionary\n        self.types[arg] = arg_type\n\n    def _convert_type(self, arg, value):\n        \"\"\"\n        Try to convert the type of input value by searching in self.types.\n        :param value: str, the input value in command line\n        :return: return corresponding value in self.types if convert successfully, or the input value oherwise\n        \"\"\"\n\n        # Try to convert the value to the type specified in the types dictionary\n        # If the conversion fails or the argument is not in the types dictionary, return the original value\n        try:\n            return self.types[arg](value)\n        except (ValueError, KeyError):\n            return value"}, {"id": "3", "llm_annotated_code": "class ArrangementCalculator:\n    \"\"\"\n    The Arrangement class provides permutation calculations and selection operations for a given set of data elements.\n    \"\"\"\n\n    def __init__(self, datas):\n        \"\"\"\n        Initializes the ArrangementCalculator object with a list of datas.\n        :param datas: List, the data elements to be used for arrangements.\n        \"\"\"\n        # Store the input data elements in the instance variable self.datas\n        self.datas = datas\n\n    @staticmethod\n    def count(n, m=None):\n        \"\"\"\n        Counts the number of arrangements by choosing m items from n items (permutations).\n        If m is not provided or n equals m, returns factorial(n).\n        :param n: int, the total number of items.\n        :param m: int, the number of items to be chosen (default=None).\n        :return: int, the count of arrangements.\n        \"\"\"\n\n        # If m is not provided or n equals m, return the factorial of n\n        # Otherwise, return the factorial of n divided by the factorial of (n - m)\n        if m is None or n == m:\n            return ArrangementCalculator.factorial(n)\n        else:\n            return ArrangementCalculator.factorial(n) // ArrangementCalculator.factorial(n - m)\n\n    @staticmethod\n    def count_all(n):\n        \"\"\"\n        Counts the total number of all possible arrangements by choosing at least 1 item and at most n items from n items.\n        :param n: int, the total number of items.\n        :return: int, the count of all arrangements.\n        \"\"\"\n\n        # Initialize total to 0\n        # For each number i from 1 to n (inclusive), add the count of arrangements by choosing i items from n items to total\n        total = 0\n        for i in range(1, n + 1):\n            total += ArrangementCalculator.count(n, i)\n        \n        # Return the total count of all arrangements\n        return total\n\n    def select(self, m=None):\n        \"\"\"\n        Generates a list of arrangements by selecting m items from the internal datas.\n        If m is not provided, selects all items.\n        :param m: int, the number of items to be chosen (default=None).\n        :return: List, a list of arrangements.\n        \"\"\"\n\n        # If m is not provided, set m to the number of data elements\n        if m is None:\n            m = len(self.datas)\n\n        # Initialize an empty list to store the result\n        # For each permutation of m elements from the data elements, add the permutation to the result list\n        result = []\n        for permutation in itertools.permutations(self.datas, m):\n            result.append(list(permutation))\n        \n        # Return the result list\n        return result\n\n    def select_all(self):\n        \"\"\"\n        Generates a list of all arrangements by selecting at least 1 item and at most the number of internal datas.\n        :return: List, a list of all arrangements.\n        \"\"\"\n\n        # Initialize an empty list to store the result\n        # For each number i from 1 to the number of data elements (inclusive), extend the result list with all arrangements by selecting i items from the data elements\n        result = []\n        for i in range(1, len(self.datas) + 1):\n            result.extend(self.select(i))\n        \n        # Return the result list\n        return result\n\n    @staticmethod\n    def factorial(n):\n        \"\"\"\n        Calculates the factorial of a given number.\n        :param n: int, the number to calculate the factorial.\n        :return: int, the factorial of the given number.\n        \"\"\"\n\n        # Initialize result to 1\n        # For each number i from 2 to n (inclusive), multiply result by i\n        result = 1\n        for i in range(2, n + 1):\n            result *= i\n        # Return the result\n        return result"}, {"id": "4", "llm_annotated_code": "class AssessmentSystem:\n    \"\"\"\n    This is a class as an student assessment system, which supports add student, add course score, calculate GPA, and other functions for students and courses.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the students dict in assessment system.\n        \"\"\"\n        # Initialize an empty dictionary to store student information\n        self.students = {}\n\n    def add_student(self, name, grade, major):\n        \"\"\"\n        Add a new student into self.students dict\n        :param name: str, student name\n        :param grade: int, student grade\n        :param major: str, student major\n        \"\"\"\n\n        # Add a new student to the students dictionary with their name, grade, major, and an empty dictionary for their courses\n        self.students[name] = {'name': name, 'grade': grade, 'major': major, 'courses': {}}\n\n    def add_course_score(self, name, course, score):\n        \"\"\"\n        Add score of specific course for student in self.students\n        :param name: str, student name\n        :param course: str, course name\n        :param score: int, course score\n        \"\"\"\n\n        # Check if the student exists in the students dictionary\n        if name in self.students:\n            # Add the course and score to the student's courses dictionary\n            self.students[name]['courses'][course] = score\n\n    def get_gpa(self, name):\n        \"\"\"\n        Get average grade of one student.\n        :param name: str, student name\n        :return: if name is in students and this students have courses grade, return average grade(float)\n                    or None otherwise\n        \"\"\"\n\n        # Check if the student exists in the students dictionary and if they have any courses\n        if name in self.students and self.students[name]['courses']:\n            # Calculate and return the average of the student's course scores\n            return sum(self.students[name]['courses'].values()) / len(self.students[name]['courses'])\n        else:\n            # Return None if the student does not exist or if they have no courses\n            return None\n\n    def get_all_students_with_fail_course(self):\n        \"\"\"\n        Get all students who have any score blow 60\n        :return: list of str ,student name\n        \"\"\"\n\n        # Initialize an empty list to store the names of students who have failed a course\n        students = []\n        # Iterate over each student in the students dictionary\n        for name, student in self.students.items():\n            # Iterate over each course and score in the student's courses dictionary\n            for course, score in student['courses'].items():\n                # Check if the score is below 60\n                if score < 60:\n                    # Add the student's name to the list of students who have failed a course and break the inner loop\n                    students.append(name)\n                    break\n        # Return the list of students who have failed a course\n        return students\n\n    def get_course_average(self, course):\n        \"\"\"\n        Get the average score of a specific course.\n        :param course: str, course name\n        :return: float, average scores of this course if anyone have score of this course, or None if nobody have records.\n        \"\"\"\n\n        # Initialize variables to store the total score and the number of students who have taken the course\n        total = 0\n        count = 0\n        # Iterate over each student in the students dictionary\n        for student in self.students.values():\n            # Check if the student has taken the course\n            if course in student['courses']:\n                # Get the student's score for the course\n                score = student['courses'][course]\n                # Check if the score is not None\n                if score is not None:\n                    # Add the score to the total and increment the count\n                    total += score\n                    count += 1\n        # Return the average score for the course if any students have taken it, or None otherwise\n        return total / count if count > 0 else None\n\n    def get_top_student(self):\n        \"\"\"\n        Calculate every student's gpa with get_gpa method, and find the student with highest gpa\n        :return: str, name of student whose gpa is highest\n        \"\"\"\n\n        # Initialize variables to store the name of the top student and their GPA\n        top_student = None\n        top_gpa = 0\n        # Iterate over each student in the students dictionary\n        for name, student in self.students.items():\n            # Calculate the student's GPA using the get_gpa method\n            gpa = self.get_gpa(name)\n            # Check if the GPA is not None and if it is higher than the current top GPA\n            if gpa is not None and gpa > top_gpa:\n                # Update the top GPA and the name of the top student\n                top_gpa = gpa\n                top_student = name\n        # Return the name of the top student\n        return top_student"}, {"id": "5", "llm_annotated_code": "class AutomaticGuitarSimulator:\n\n    # This class is an automatic guitar simulator that can interpret and play based on the input guitar sheet music.\n\n    def __init__(self, text) -> None:\n        \"\"\"\n        Initialize the score to be played\n        :param text:str, score to be played\n        \"\"\"\n        # Store the input text (guitar sheet music) in the instance variable play_text\n        self.play_text = text\n\n    def interpret(self, display=False):\n        \"\"\"\n        Interpret the music score to be played\n        :param display:Bool, representing whether to print the interpreted score\n        :return: list of dict, The dict includes two fields, Chord and Tune, which are letters and numbers, respectively. If the input is empty or contains only whitespace, an empty list is returned.\n        >>> context = AutomaticGuitarSimulator(\"C53231323 Em43231323 F43231323 G63231323\")\n        >>> play_list = context.interpret(display = False)\n        [{'Chord': 'C', 'Tune': '53231323'}, {'Chord': 'Em', 'Tune': '43231323'}, {'Chord': 'F', 'Tune': '43231323'}, {'Chord': 'G', 'Tune': '63231323'}]\n\n        \"\"\"\n\n        # If the input text is empty or contains only whitespace, return an empty list\n        if not self.play_text.strip():\n            return []\n        else:\n            # Initialize an empty list to store the interpreted score\n            play_list = []\n            # Split the input text into segments based on whitespace\n            play_segs = self.play_text.split(\" \")\n            for play_seg in play_segs:\n                pos = 0\n                # Iterate through each character in the segment\n                for ele in play_seg:\n                    # If the character is a letter, increment the position counter and continue to the next character\n                    if ele.isalpha():\n                        pos += 1\n                        continue\n                    # If the character is not a letter, break the loop\n                    break\n                # Extract the chord and the tune from the segment based on the position counter\n                play_chord = play_seg[0:pos]\n                play_value = play_seg[pos:]\n                # Append the chord and the tune as a dictionary to the play list\n                play_list.append({'Chord': play_chord, 'Tune': play_value})\n                # If the display parameter is True, call the display method to print the chord and the tune\n                if display:\n                    self.display(play_chord, play_value)\n            # Return the play list\n            return play_list\n\n    def display(self, key, value):\n        \"\"\"\n        Print out chord and play tune with following format: Normal Guitar Playing -- Chord: %s, Play Tune: %s\n        :param key:str, chord\n        :param value:str, play tune\n        :return: str\n        >>> context = AutomaticGuitarSimulator(\"C53231323 Em43231323 F43231323 G63231323\")\n        >>> context.display(\"C\", \"53231323\")\n        Normal Guitar Playing -- Chord: C, Play Tune: 53231323\n\n        \"\"\"\n\n        # Return a formatted string that includes the chord and the tune\n        return \"Normal Guitar Playing -- Chord: %s, Play Tune: %s\" % (key, value)"}, {"id": "6", "llm_annotated_code": "class AvgPartition:\n    \"\"\"\n    This is a class that partitions the given list into different blocks by specifying the number of partitions, with each block having a uniformly distributed length.\n    \"\"\"\n\n    def __init__(self, lst, limit):\n        \"\"\"\n        Initialize the class with the given list and the number of partitions, and check if the number of partitions is greater than 0.\n        \"\"\"\n        # Store the input list and limit (number of partitions) as instance variables\n        self.lst = lst\n        self.limit = limit\n\n    def setNum(self):\n        \"\"\"\n        Calculate the size of each block and the remainder of the division.\n        :return: the size of each block and the remainder of the division, tuple.\n        >>> a = AvgPartition([1, 2, 3, 4], 2)\n        >>> a.setNum()\n        (2, 0)\n\n        \"\"\"\n\n        # Calculate the size of each block by integer division of the list length by the limit\n        size = len(self.lst) // self.limit\n        # Calculate the remainder of the division\n        remainder = len(self.lst) % self.limit\n        # Return the size and remainder as a tuple\n        return size, remainder\n\n\n    def get(self, index):\n        \"\"\"\n        calculate the size of each block and the remainder of the division, and calculate the corresponding start and end positions based on the index of the partition.\n        :param index: the index of the partition,int.\n        :return: the corresponding block, list.\n        >>> a = AvgPartition([1, 2, 3, 4], 2)\n        >>> a.get(0)\n        [1, 2]\n\n        \"\"\"\n\n        # Get the size of each block and the remainder by calling the setNum method\n        size, remainder = self.setNum()\n        # Calculate the start position of the block based on the index, size and remainder\n        start = index * size + min(index, remainder)\n        # Calculate the end position of the block based on the start position, size and whether the index is less than the remainder\n        end = start + size\n        if index + 1 <= remainder:\n            end += 1\n        # Return the block of the list from the start position to the end position\n        return self.lst[start:end]"}, {"id": "7", "llm_annotated_code": "class BalancedBrackets:\n    \"\"\"\n    This is a class that checks for bracket matching\n    \"\"\"\n\n    def __init__(self, expr):\n        \"\"\"\n        Initializes the class with an expression.\n        :param expr: The expression to check for balanced brackets,str.\n        \"\"\"\n        # Initialize an empty list to use as a stack for checking bracket balance\n        self.stack = []\n        \n        # Define the left and right brackets\n        self.left_brackets = [\"(\", \"{\", \"[\"]\n        self.right_brackets = [\")\", \"}\", \"]\"]\n        \n        # Store the input expression\n        self.expr = expr\n\n    def clear_expr(self):\n        \"\"\"\n        Clears the expression of all characters that are not brackets.\n        >>> b = BalancedBrackets(\"a(b)c\")\n        >>> b.clear_expr()\n        >>> b.expr\n        '()'\n\n        \"\"\"\n        # Use a list comprehension to filter out non-bracket characters from the expression\n        # Join the result back into a string and store it in self.expr\n        self.expr = ''.join(c for c in self.expr if (c in self.left_brackets or c in self.right_brackets))\n\n    def check_balanced_brackets(self):\n        \"\"\"\n        Checks if the expression has balanced brackets.\n        :return: True if the expression has balanced brackets, False otherwise.\n        >>> b = BalancedBrackets(\"a(b)c\")\n        >>> b.check_balanced_brackets()\n        True\n\n        \"\"\"\n        # First, clear the expression of non-bracket characters\n        self.clear_expr()\n        \n        # Iterate over each character in the expression\n        for Brkt in self.expr:\n            # If the character is a left bracket, push it onto the stack\n            if Brkt in self.left_brackets:\n                self.stack.append(Brkt)\n            else:\n                # If the character is a right bracket, pop the last left bracket from the stack\n                # If the stack is empty, continue to the next character\n                if self.stack:\n                    Current_Brkt = self.stack.pop()\n                else:\n                    continue\n                \n                # Check if the popped left bracket matches with the current right bracket\n                # If not, return False\n                if Current_Brkt == \"(\":\n                    if Brkt != \")\":\n                        return False\n                if Current_Brkt == \"{\":\n                    if Brkt != \"}\":\n                        return False\n                if Current_Brkt == \"[\":\n                    if Brkt != \"]\":\n                        return False\n        \n        # After checking all characters, if the stack is not empty, return False\n        # Otherwise, return True\n        if self.stack:\n            return False\n        return True"}, {"id": "8", "llm_annotated_code": "class BankAccount:\n    \"\"\"\n    This is a class as a bank account system, which supports deposit money, withdraw money, view balance, and transfer money.\n    \"\"\"\n\n    def __init__(self, balance=0):\n        \"\"\"\n        Initializes a bank account object with an attribute balance, default value is 0.\n        \"\"\"\n        # Initialize the balance attribute of the BankAccount instance\n        self.balance = balance\n\n    def deposit(self, amount):\n        \"\"\"\n        Deposits a certain amount into the account, increasing the account balance, return the current account balance.\n        If amount is negative, raise a ValueError(\"Invalid amount\").\n        :param amount: int\n        \"\"\"\n\n        # Check if the amount is negative, if so, raise a ValueError\n        if amount < 0:\n            raise ValueError(\"Invalid amount\")\n        \n        # Add the amount to the balance attribute of the BankAccount instance\n        self.balance += amount\n        \n        # Return the updated balance\n        return self.balance\n\n    def withdraw(self, amount):\n        \"\"\"\n        Withdraws a certain amount from the account, decreasing the account balance, return the current account balance.\n        If amount is negative, raise a ValueError(\"Invalid amount\").\n        If the withdrawal amount is greater than the account balance, raise a ValueError(\"Insufficient balance.\").\n        :param amount: int\n        \"\"\"\n\n        # Check if the amount is negative, if so, raise a ValueError\n        if amount < 0:\n            raise ValueError(\"Invalid amount\")\n        \n        # Check if the amount is greater than the balance, if so, raise a ValueError\n        if amount > self.balance:\n            raise ValueError(\"Insufficient balance.\")\n        \n        # Subtract the amount from the balance attribute of the BankAccount instance\n        self.balance -= amount\n        \n        # Return the updated balance\n        return self.balance\n\n    def view_balance(self):\n        \"\"\"\n        Return the account balance.\n        \"\"\"\n        # Return the balance attribute of the BankAccount instance\n        return self.balance\n\n    def transfer(self, other_account, amount):\n        \"\"\"\n        Transfers a certain amount from the current account to another account.\n        :param other_account: BankAccount\n        :param amount: int\n        >>> account1 = BankAccount()\n        >>> account2 = BankAccount()\n        >>> account1.deposit(1000)\n        >>> account1.transfer(account2, 300)\n        account1.balance = 700 account2.balance = 300\n        \"\"\"\n\n        # Use the withdraw method of the current BankAccount instance to withdraw the amount\n        self.withdraw(amount)\n        \n        # Use the deposit method of the other BankAccount instance to deposit the amount\n        other_account.deposit(amount)"}, {"id": "10", "llm_annotated_code": "class BinaryDataProcessor:\n    \"\"\"\n    This is a class used to process binary data, which includes functions such as clearing non 0 or 1 characters, counting binary string information, and converting to corresponding strings based on different encoding methods.\n    \"\"\"\n\n    def __init__(self, binary_string):\n        \"\"\"\n        Initialize the class with a binary string and clean it by removing all non 0 or 1 characters.\n        \"\"\"\n        self.binary_string = binary_string\n        # Call the clean_non_binary_chars method to clean the binary string\n        self.clean_non_binary_chars()\n\n    def clean_non_binary_chars(self):\n        \"\"\"\n        Clean the binary string by removing all non 0 or 1 characters.\n        >>> bdp = BinaryDataProcessor(\"01101000daf3e4r01100101011011000110110001101111\")\n        >>> bdp.clean_non_binary_chars()\n        >>> bdp.binary_string\n        '0110100001100101011011000110110001101111'\n\n        \"\"\"\n        # Use the filter function to remove all non 0 or 1 characters from the binary string\n        self.binary_string = ''.join(filter(lambda x: x in '01', self.binary_string))\n\n    def calculate_binary_info(self):\n        \"\"\"\n        Calculate the binary string information, including the percentage of 0 and 1, and the total length of the binary string.\n        >>> bdp = BinaryDataProcessor(\"0110100001100101011011000110110001101111\")\n        >>> bdp.calculate_binary_info()\n        {'Zeroes': 0.475, 'Ones': 0.525, 'Bit length': 40}\n\n        \"\"\"\n        # Count the number of 0s and 1s in the binary string\n        zeroes_count = self.binary_string.count('0')\n        ones_count = self.binary_string.count('1')\n        # Calculate the total length of the binary string\n        total_length = len(self.binary_string)\n        # Calculate the percentage of 0s and 1s in the binary string\n        zeroes_percentage = (zeroes_count / total_length)\n        ones_percentage = (ones_count / total_length)\n\n        # Return a dictionary with the calculated information\n        return {\n            'Zeroes': zeroes_percentage,\n            'Ones': ones_percentage,\n            'Bit length': total_length\n        }\n\n    def convert_to_ascii(self):\n        \"\"\"\n        Convert the binary string to ascii string.\n        >>> bdp = BinaryDataProcessor(\"0110100001100101011011000110110001101111\")\n        >>> bdp.convert_to_ascii()\n        'hello'\n\n        \"\"\"\n\n        # Initialize an empty bytearray\n        byte_array = bytearray()\n        # Iterate over the binary string in steps of 8 (since ASCII characters are represented by 8 bits)\n        for i in range(0, len(self.binary_string), 8):\n            # Extract the current byte from the binary string\n            byte = self.binary_string[i:i+8]\n            # Convert the byte to decimal\n            decimal = int(byte, 2)\n            # Append the decimal value to the bytearray\n            byte_array.append(decimal)\n        # Convert the bytearray to an ASCII string and return it\n        return byte_array.decode('ascii')\n\n    def convert_to_utf8(self):\n        \"\"\"\n        Convert the binary string to utf-8 string.\n        >>> bdp = BinaryDataProcessor(\"0110100001100101011011000110110001101111\")\n        >>> bdp.convert_to_utf8()\n        'hello'\n\n        \"\"\"\n\n        # Initialize an empty bytearray\n        byte_array = bytearray()\n        # Iterate over the binary string in steps of 8 (since UTF-8 characters can be represented by 8 bits)\n        for i in range(0, len(self.binary_string), 8):\n            # Extract the current byte from the binary string\n            byte = self.binary_string[i:i+8]\n            # Convert the byte to decimal\n            decimal = int(byte, 2)\n            # Append the decimal value to the bytearray\n            byte_array.append(decimal)\n        # Convert the bytearray to a UTF-8 string and return it\n        return byte_array.decode('utf-8')"}, {"id": "11", "llm_annotated_code": "class BitStatusUtil:\n    \"\"\"\n    This is a utility class that provides methods for manipulating and checking status using bitwise operations.\n    \"\"\"\n\n    @staticmethod\n    def add(states, stat):\n        \"\"\"\n        Add a status to the current status,and check the parameters wheather they are legal.\n        :param states: Current status,int.\n        :param stat: Status to be added,int.\n        :return: The status after adding the status,int.\n        >>> bit_status_util = BitStatusUtil()\n        >>> bit_status_util.add(2,4)\n        6\n\n        \"\"\"\n\n        # Check if the input parameters are valid\n        BitStatusUtil.check([states, stat])\n\n        # Use bitwise OR operation to add the status\n        # Return the updated status\n        return states | stat\n\n    @staticmethod\n    def has(states, stat):\n        \"\"\"\n        Check if the current status contains the specified status,and check the parameters wheather they are legal.\n        :param states: Current status,int.\n        :param stat: Specified status,int.\n        :return: True if the current status contains the specified status,otherwise False,bool.\n        >>> bit_status_util = BitStatusUtil()\n        >>> bit_status_util.has(6,2)\n        True\n\n        \"\"\"\n\n        # Check if the input parameters are valid\n        BitStatusUtil.check([states, stat])\n\n        # Use bitwise AND operation to check if the current status contains the specified status\n        # Return True if it does, otherwise return False\n        return (states & stat) == stat\n\n    @staticmethod\n    def remove(states, stat):\n        \"\"\"\n        Remove the specified status from the current status,and check the parameters wheather they are legal.\n        :param states: Current status,int.\n        :param stat: Specified status,int.\n        :return: The status after removing the specified status,int.\n        >>> bit_status_util = BitStatusUtil()\n        >>> bit_status_util.remove(6,2)\n        4\n\n        \"\"\"\n\n        # Check if the input parameters are valid\n        BitStatusUtil.check([states, stat])\n\n        # Check if the current status contains the specified status\n        if BitStatusUtil.has(states, stat):\n            # If it does, use bitwise XOR operation to remove the specified status\n            # Return the updated status\n            return states ^ stat\n\n        # If the current status does not contain the specified status, return the current status\n        return states\n\n    @staticmethod\n    def check(args):\n        \"\"\"\n        Check if the parameters are legal, args must be greater than or equal to 0 and must be even,if not,raise ValueError.\n        :param args: Parameters to be checked,list.\n        :return: None.\n        >>> bit_status_util = BitStatusUtil()\n        >>> bit_status_util.check([2,3,4])\n        Traceback (most recent call last):\n        ...\n        ValueError: 3 not even\n        \"\"\"\n\n        # Iterate through each argument in the input list\n        for arg in args:\n            # If the argument is less than 0, raise a ValueError\n            if arg < 0:\n                raise ValueError(f\"{arg} must be greater than or equal to 0\")\n            # If the argument is not even, raise a ValueError\n            if arg % 2 != 0:\n                raise ValueError(f\"{arg} not even\")"}, {"id": "12", "llm_annotated_code": "class BlackjackGame:\n    \"\"\"\n    This is a class representing a game of blackjack, which includes creating a deck, calculating the value of a hand, and determine the winner based on the hand values of the player and dealer.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the Blackjack Game with the attribute deck, player_hand and dealer_hand.\n        While initializing deck attribute, call the create_deck method to generate.\n        The deck stores 52 random order poker with the Jokers removed, format is ['AS', '2S', ...].\n        player_hand is a list which stores player's hand cards.\n        dealer_hand is is a list which stores dealer's hand cards.\n        \"\"\"\n        # Call the create_deck method to generate a deck of cards\n        self.deck = self.create_deck()\n        # Initialize player_hand and dealer_hand as empty lists\n        self.player_hand = []\n        self.dealer_hand = []\n\n    def create_deck(self):\n        \"\"\"\n        Create a deck of 52 cards, which stores 52 random order poker with the Jokers removed.\n        :return: a list of 52 random order poker with the Jokers removed, format is ['AS', '2S', ...].\n        \"\"\"\n\n        # Initialize an empty list to store the deck of cards\n        deck = []\n        # Define the suits and ranks of the cards\n        suits = ['S', 'C', 'D', 'H']\n        ranks = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K']\n        # Generate the deck by combining each rank with each suit\n        for suit in suits:\n            for rank in ranks:\n                deck.append(rank + suit)\n        # Shuffle the deck to ensure randomness\n        random.shuffle(deck)\n        # Return the shuffled deck\n        return deck\n\n    def calculate_hand_value(self, hand):\n        \"\"\"\n        Calculate the value of the poker cards stored in hand list according to the rules of the Blackjack Game.\n        If the card is a digit, its value is added to the total hand value.\n        Value of J, Q, or K is 10, while Aces are worth 11.\n        If the total hand value exceeds 21 and there are Aces present, one Ace is treated as having a value of 1 instead of 11,\n        until the hand value is less than or equal to 21, or all Aces have been counted as value of 1.\n        :param hand: list\n        :return: the value of the poker cards stored in hand list, a number.\n        \"\"\"\n\n        # Initialize the total value and the number of Aces\n        value = 0\n        num_aces = 0\n        # Iterate through each card in the hand\n        for card in hand:\n            # Extract the rank of the card\n            rank = card[:-1]\n            # If the rank is a digit, add its value to the total value\n            if rank.isdigit():\n                value += int(rank)\n            # If the rank is J, Q, or K, add 10 to the total value\n            elif rank in ['J', 'Q', 'K']:\n                value += 10\n            # If the rank is A, add 11 to the total value and increment the number of Aces\n            elif rank == 'A':\n                value += 11\n                num_aces += 1\n        # If the total value exceeds 21 and there are Aces in the hand, treat each Ace as having a value of 1 until the total value is less than or equal to 21\n        while value > 21 and num_aces > 0:\n            value -= 10\n            num_aces -= 1\n        # Return the total value\n        return value\n\n    def check_winner(self, player_hand, dealer_hand):\n        \"\"\"\n        Determines the winner of a game by comparing the hand values of the player and dealer.\n        rule:\n        If both players have hand values that are equal to or less than 21, the winner is the one whose hand value is closer to 21.\n        Otherwise, the winner is the one with the lower hand value.\n        :param player_hand: list\n        :param dealer_hand: list\n        :return: the result of the game, only two certain str: 'Dealer wins' or 'Player wins'\n        \"\"\"\n\n        # Calculate the hand values of the player and the dealer\n        player_value = self.calculate_hand_value(player_hand)\n        dealer_value = self.calculate_hand_value(dealer_hand)\n        # If both hand values are greater than 21, the player with the lower hand value wins\n        if player_value > 21 and dealer_value > 21:\n            if player_value < dealer_value:\n                return 'Player wins'\n            elif player_value > dealer_value:\n                return 'Dealer wins'\n        # If the player's hand value is greater than 21, the dealer wins\n        elif player_value > 21:\n            return 'Dealer wins'\n        # If the dealer's hand value is greater than 21, the player wins\n        elif dealer_value > 21:\n            return 'Player wins'\n        # If both hand values are less than or equal to 21, the player with the hand value closer to 21 wins\n        else:\n            if player_value < dealer_value:\n                return 'Dealer wins'\n            elif player_value > dealer_value:\n                return 'Player wins'"}, {"id": "13", "llm_annotated_code": "class BookManagement:\n    \"\"\"\n    This is a class as managing books system, which supports to add and remove books from the inventory dict, view the inventory, and check the quantity of a specific book.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the inventory of Book Manager.\n        \"\"\"\n        # Initialize an empty dictionary to store the inventory of books\n        self.inventory = {}\n\n    def add_book(self, title, quantity=1):\n        \"\"\"\n        Add one or several books to inventory which is sorted by book title.\n        :param title: str, the book title\n        :param quantity: int, default value is 1.\n        \"\"\"\n\n        # Check if the book title already exists in the inventory\n        if title in self.inventory:\n            # If it exists, increment the quantity of the book in the inventory\n            self.inventory[title] += quantity\n        else:\n            # If it does not exist, add the book title to the inventory with the specified quantity\n            self.inventory[title] = quantity\n\n    def remove_book(self, title, quantity):\n        \"\"\"\n        Remove one or several books from inventory which is sorted by book title.\n        Raise false while get invalid input.\n        :param title: str, the book title\n        :param quantity: int\n        \"\"\"\n\n        # Check if the book title exists in the inventory and if the quantity to be removed is less than or equal to the current quantity in the inventory\n        if title not in self.inventory or self.inventory[title] < quantity:\n            # If either condition is not met, raise an exception\n            raise False\n        # Subtract the specified quantity from the current quantity of the book in the inventory\n        self.inventory[title] -= quantity\n        # If the quantity of the book in the inventory becomes 0, remove the book title from the inventory\n        if self.inventory[title] == 0:\n            del (self.inventory[title])\n\n    def view_inventory(self):\n        \"\"\"\n        Get the inventory of the Book Management.\n        :return self.inventory: dictionary, {title(str): quantity(int), ...}\n        >>> bookManagement = BookManagement()\n        >>> bookManagement.add_book(\"book1\", 1)\n        >>> bookManagement.add_book(\"book2\", 1)\n        >>> bookManagement.view_inventory()\n        {'book1': 1, 'book2': 1}\n        \"\"\"\n\n        # Return the current inventory of books\n        return self.inventory\n\n    def view_book_quantity(self, title):\n        \"\"\"\n        Get the quantity of a book.\n        :param title: str, the title of the book.\n        :return quantity: the quantity of this book title. return 0 when the title does not exist in self.invenroty\n        >>> bookManagement = BookManagement()\n        >>> bookManagement.add_book(\"book1\", 1)\n        >>> bookManagement.view_book_quantity(\"book3\")\n        0\n        \"\"\"\n\n        # Check if the book title exists in the inventory\n        if title not in self.inventory:\n            # If it does not exist, return 0\n            return 0\n        # If it exists, return the quantity of the book in the inventory\n        return self.inventory[title]"}, {"id": "14", "llm_annotated_code": "import sqlite3\n\nclass BookManagementDB:\n    '''\n    This is a database class as a book management system, used to handle the operations of adding, removing, updating, and searching books.\n    '''\n\n    def __init__(self, db_name):\n        '''\n        Initializes the class by creating a database connection and cursor, \n        and creates the book table if it does not already exist\n        :param db_name: str, the name of db file\n        '''\n        # Connect to the SQLite database with the provided db_name\n        self.connection = sqlite3.connect(db_name)\n        # Create a cursor object using the connection object\n        self.cursor = self.connection.cursor()\n        # Call the create_table method to create the books table if it doesn't exist\n        self.create_table()\n\n    def create_table(self):\n        '''\n        Creates the book table in the database if it does not already exist.\n        '''\n\n        # Execute SQL command to create a new table named 'books' with columns 'id', 'title', 'author', and 'available'\n        # 'id' is the primary key, 'title' and 'author' are text, and 'available' is an integer\n        # If the table already exists, this command does nothing\n        self.cursor.execute('''\n            CREATE TABLE IF NOT EXISTS books (\n                id INTEGER PRIMARY KEY,\n                title TEXT,\n                author TEXT,\n                available INTEGER\n            )\n        ''')\n        # Commit the changes to the database\n        self.connection.commit()\n\n    def add_book(self, title, author):\n        '''\n        Adds a book to the database with the specified title and author, \n        setting its availability to 1 as free to borrow.\n        :param title: str, book title\n        :param author: str, author name\n        '''\n\n        # Execute SQL command to insert a new row into the 'books' table with the provided 'title' and 'author'\n        # The 'available' column is set to 1, indicating that the book is available to borrow\n        self.cursor.execute('''\n            INSERT INTO books (title, author, available)\n            VALUES (?, ?, 1)\n        ''', (title, author))\n        # Commit the changes to the database\n        self.connection.commit()\n\n    def remove_book(self, book_id):\n        '''\n        Removes a book from the database based on the given book ID.\n        :param book_id: int\n        '''\n\n        # Execute SQL command to delete the row from the 'books' table where the 'id' matches the provided 'book_id'\n        self.cursor.execute('''\n            DELETE FROM books WHERE id = ?\n        ''', (book_id,))\n        # Commit the changes to the database\n        self.connection.commit()\n\n    def borrow_book(self, book_id):\n        '''\n        Marks a book as borrowed in the database based on the given book ID.\n        :param book_id: int\n        '''\n\n        # Execute SQL command to update the 'available' column to 0 (indicating the book is borrowed) in the 'books' table where the 'id' matches the provided 'book_id'\n        self.cursor.execute('''\n            UPDATE books SET available = 0 WHERE id = ?\n        ''', (book_id,))\n        # Commit the changes to the database\n        self.connection.commit()\n\n    def return_book(self, book_id):\n        '''\n        Marks a book as returned in the database based on the given book ID.\n        :param book_id: int\n        '''\n\n        # Execute SQL command to update the 'available' column to 1 (indicating the book is available) in the 'books' table where the 'id' matches the provided 'book_id'\n        self.cursor.execute('''\n            UPDATE books SET available = 1 WHERE id = ?\n        ''', (book_id,))\n        # Commit the changes to the database\n        self.connection.commit()\n\n    def search_books(self):\n        '''\n        Retrieves all books from the database and returns their information.\n        :return books: list[tuple], the information of all books in database\n        '''\n\n        # Execute SQL command to select all rows from the 'books' table\n        self.cursor.execute('''\n            SELECT * FROM books\n        ''')\n        # Fetch all rows from the last executed SQL command and store them in the 'books' variable\n        books = self.cursor.fetchall()\n        # Return the 'books' variable, which is a list of tuples where each tuple represents a row from the 'books' table\n        return books"}, {"id": "15", "llm_annotated_code": "class BoyerMooreSearch:\n    \"\"\"\n    This is a class that implements the Boyer-Moore algorithm for string searching, which is used to find occurrences of a pattern within a given text.\n    \"\"\"\n\n    def __init__(self, text, pattern):\n        \"\"\"\n        Initializes the BoyerMooreSearch class with the given text and pattern.\n        :param text: The text to be searched, str.\n        :param pattern: The pattern to be searched for, str.\n        \"\"\"\n        # Store the input text and pattern as class attributes\n        self.text, self.pattern = text, pattern\n        # Calculate and store the lengths of the text and pattern as class attributes\n        self.textLen, self.patLen = len(text), len(pattern)\n\n    def match_in_pattern(self, char):\n        \"\"\"\n        Finds the rightmost occurrence of a character in the pattern.\n        :param char: The character to be searched for, str.\n        :return: The index of the rightmost occurrence of the character in the pattern, int.\n        \"\"\"\n\n        # Iterate over the pattern in reverse order\n        for i in range(self.patLen - 1, -1, -1):\n            # If the current character matches the input character, return its index\n            if char == self.pattern[i]:\n                return i\n        # If the character is not found in the pattern, return -1\n        return -1\n\n    def mismatch_in_text(self, currentPos):\n        \"\"\"\n        Determines the position of the first mismatch between the pattern and the text.\n        :param currentPos: The current position in the text, int.\n        :return: The position of the first mismatch between the pattern and the text, int,otherwise -1.\n        \"\"\"\n\n        # Iterate over the pattern in reverse order\n        for i in range(self.patLen - 1, -1, -1):\n            # If the current character in the pattern does not match the corresponding character in the text, return its index in the text\n            if self.pattern[i] != self.text[currentPos + i]:\n                return currentPos + i\n        # If no mismatch is found, return -1\n        return -1\n\n    def bad_character_heuristic(self):\n        \"\"\"\n        Finds all occurrences of the pattern in the text.\n        :return: A list of all positions of the pattern in the text, list.\n        \"\"\"\n\n        # Initialize an empty list to store the positions of the pattern in the text\n        positions = []\n        # Initialize a variable to keep track of the current position in the text\n        i = 0\n        # Iterate over the text until the end of the pattern reaches the end of the text\n        while i <= self.textLen - self.patLen:\n            # Find the position of the first mismatch between the pattern and the text at the current position\n            mismatch_index = self.mismatch_in_text(i)\n            # If no mismatch is found, add the current position to the list of positions and move to the next position in the text\n            if mismatch_index == -1:\n                positions.append(i)\n                i += 1\n            else:\n                # If a mismatch is found, find the rightmost occurrence of the mismatched character in the pattern\n                match_index = self.match_in_pattern(self.text[mismatch_index])\n                # Move the current position in the text by the difference between the mismatch and match indices, or by 1 if the difference is 0\n                i += max(1, mismatch_index - match_index)\n        # Return the list of positions\n        return positions"}, {"id": "16", "llm_annotated_code": "class Calculator:\n    \"\"\"\n    This is a class for a calculator, capable of performing basic arithmetic calculations on numerical expressions using the operators +, -, *, /, and ^ (exponentiation).\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the operations performed by the five operators'+','-','*','/','^'\n        \"\"\"\n        # Define a dictionary of lambda functions for each operator\n        # Each lambda function takes two arguments and performs the corresponding operation\n        self.operators = {\n            '+': lambda x, y: x + y,\n            '-': lambda x, y: x - y,\n            '*': lambda x, y: x * y,\n            '/': lambda x, y: x / y,\n            '^': lambda x, y: x ** y\n        }\n\n    def calculate(self, expression):\n        \"\"\"\n        Calculate the value of a given expression\n        :param expression: string, given expression\n        :return:If successful, returns the value of the expression; otherwise, returns None\n        >>> calculator = Calculator()\n        >>> calculator.calculate('1+2-3')\n        0.0\n        \"\"\"\n\n        # Initialize two empty lists to store operands and operators\n        operand_stack = []\n        operator_stack = []\n        num_buffer = ''\n\n        # Iterate over each character in the expression\n        for char in expression:\n            # If the character is a digit or a decimal point, add it to the num_buffer\n            if char.isdigit() or char == '.':\n                num_buffer += char\n            else:\n                # If num_buffer is not empty, convert it to a float and add it to the operand stack\n                if num_buffer:\n                    operand_stack.append(float(num_buffer))\n                    num_buffer = ''\n                # If the character is an operator, apply the operator and update the stacks\n                if char in '+-*/^':\n                    while (\n                            operator_stack and\n                            operator_stack[-1] != '(' and\n                            self.precedence(operator_stack[-1]) >= self.precedence(char)\n                    ):\n                        operand_stack, operator_stack = self.apply_operator(operand_stack, operator_stack)\n                    operator_stack.append(char)\n                # If the character is an opening parenthesis, add it to the operator stack\n                elif char == '(':\n                    operator_stack.append(char)\n                # If the character is a closing parenthesis, apply the operator until an opening parenthesis is found\n                elif char == ')':\n                    while operator_stack and operator_stack[-1] != '(':\n                        operand_stack, operator_stack = self.apply_operator(operand_stack, operator_stack)\n                    operator_stack.pop()\n        # If num_buffer is not empty after the loop, convert it to a float and add it to the operand stack\n        if num_buffer:\n            operand_stack.append(float(num_buffer))\n        # Apply the remaining operators in the operator stack\n        while operator_stack:\n            operand_stack, operator_stack = self.apply_operator(operand_stack, operator_stack)\n        # Return the last element in the operand stack, which is the result of the calculation\n        return operand_stack[-1] if operand_stack else None\n\n    def precedence(self, operator):\n        \"\"\"\n        Returns the priority of the specified operator, where the higher the priority, the greater the assignment. The priority of '^' is greater than '/' and '*', and the priority of '/' and '*' is greater than '+' and '-'\n        :param operator: string, given operator\n        :return: int, the priority of the given operator, otherwise return 0\n        >>> calculator = Calculator()\n        >>> calculator.precedence('+')\n        1\n        >>> calculator.precedence('^')\n        3\n        \"\"\"\n\n        # Define a dictionary of precedences for each operator\n        precedences = {\n            '+': 1,\n            '-': 1,\n            '*': 2,\n            '/': 2,\n            '^': 3\n        }\n        # Return the precedence of the given operator, or 0 if the operator is not in the dictionary\n        return precedences.get(operator, 0)\n\n    def apply_operator(self, operand_stack, operator_stack):\n        \"\"\"\n        Use the operator at the top of the operator stack to perform the operation on the two numbers at the top of the operator stack, and store the results at the top of the operator stack\n        :param operand_stack:list\n        :param operator_stack:list\n        :return: the updated operand_stack and operator_stack\n        >>> calculator = Calculator()\n        >>> calculator.apply_operator([1, 2, 3], ['+', '-'])\n        ([1, -1], ['-'])\n        \"\"\"\n\n        # Pop the operator from the top of the operator stack\n        operator = operator_stack.pop()\n        # Pop the two operands from the top of the operand stack\n        operand2 = operand_stack.pop()\n        operand1 = operand_stack.pop()\n        # Calculate the result of applying the operator to the operands\n        result = self.operators[operator](operand1, operand2)\n        # Push the result back to the operand stack\n        operand_stack.append(result)\n        # Return the updated operand and operator stacks\n        return operand_stack, operator_stack"}, {"id": "17", "llm_annotated_code": "class CalendarUtil:\n    \"\"\"\n    This is a class as CalendarUtil that provides functionalities to manage calendar events, schedule appointments, and perform conflict checks.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the calendar with an empty list of events.\n        \"\"\"\n        # Initialize an empty list to store events\n        self.events = []\n\n    def add_event(self, event):\n        \"\"\"\n        Add an event to the calendar.\n        :param event: The event to be added to the calendar,dict.\n        \"\"\"\n        # Append the new event to the events list\n        self.events.append(event)\n\n    def remove_event(self, event):\n        \"\"\"\n        Remove an event from the calendar.\n        :param event: The event to be removed from the calendar,dict.\n        \"\"\"\n        # Check if the event is in the events list\n        # If it is, remove it\n        if event in self.events:\n            self.events.remove(event)\n\n    def get_events(self, date):\n        \"\"\"\n        Get all events on a given date.\n        :param date: The date to get events for,datetime.\n        :return: A list of events on the given date,list.\n        \"\"\"\n        events_on_date = []\n        # Iterate over all events\n        for event in self.events:\n            # If the date of the event matches the given date, add it to the events_on_date list\n            if event['date'].date() == date.date():\n                events_on_date.append(event)\n        # Return the list of events on the given date\n        return events_on_date\n\n    def is_available(self, start_time, end_time):\n        \"\"\"\n        Check if the calendar is available for a given time slot.\n        :param start_time: The start time of the time slot,datetime.\n        :param end_time: The end time of the time slot,datetime.\n        :return: True if the calendar is available for the given time slot, False otherwise,bool.\n        \"\"\"\n        # Iterate over all events\n        for event in self.events:\n            # If the given time slot overlaps with any event, return False\n            if start_time < event['end_time'] and end_time > event['start_time']:\n                return False\n        # If no overlapping event is found, return True\n        return True\n\n    def get_available_slots(self, date):\n        \"\"\"\n        Get all available time slots on a given date.\n        :param date: The date to get available time slots for,datetime.\n        :return: A list of available time slots on the given date,list.\n        \"\"\"\n        available_slots = []\n        # Define the start and end times for the day\n        start_time = datetime(date.year, date.month, date.day, 0, 0)\n        end_time = datetime(date.year, date.month, date.day, 23, 59)\n\n        # Iterate over each hour of the day\n        while start_time < end_time:\n            # Define the end of the time slot as one hour after the start\n            slot_end_time = start_time + timedelta(minutes=60)\n            # If the time slot is available, add it to the list of available slots\n            if self.is_available(start_time, slot_end_time):\n                available_slots.append((start_time, slot_end_time))\n            # Move to the next hour\n            start_time += timedelta(minutes=60)\n        # Return the list of available time slots\n        return available_slots\n\n    def get_upcoming_events(self, num_events):\n        \"\"\"\n        Get the next n upcoming events from a given date.\n        :param date: The date to get upcoming events from,datetime.\n        :param n: The number of upcoming events to get,int.\n        :return: A list of the next n upcoming events from the given date,list.\n        \"\"\"\n        # Get the current date and time\n        now = datetime.now()\n        upcoming_events = []\n\n        # Iterate over all events\n        for event in self.events:\n            # If the event starts in the future, add it to the list of upcoming events\n            if event['start_time'] >= now:\n                upcoming_events.append(event)\n            # If the number of upcoming events reaches the requested number, stop adding events\n            if len(upcoming_events) == num_events:\n                break\n        \n        # Return the list of upcoming events\n        return upcoming_events"}, {"id": "18", "llm_annotated_code": "class CamelCaseMap:\n    \"\"\"\n    This is a custom class that allows keys to be in camel case style by converting them from underscore style, which provides dictionary-like functionality.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize data to an empty dictionary\n        \"\"\"\n        # Initialize an empty dictionary to store the data\n        self._data = {}\n\n    def __getitem__(self, key):\n        \"\"\"\n        Return the value corresponding to the key\n        :param key:str\n        :return:str,the value corresponding to the key\n        >>> camelize_map = CamelCaseMap()\n        >>> camelize_map['first_name'] = 'John'\n        >>> camelize_map.__getitem__('first_name')\n        'John'\n        \"\"\"\n\n        # Convert the key to camel case and return the corresponding value from the data dictionary\n        return self._data[self._convert_key(key)]\n\n    def __setitem__(self, key, value):\n        \"\"\"\n        Set the value corresponding to the key to the specified value\n        :param key:str\n        :param value:str, the specified value\n        :return:None\n        >>> camelize_map = CamelCaseMap()\n        >>> camelize_map['first_name'] = 'John'\n        >>> camelize_map.__setitem__('first_name', 'new name')\n        camelize_map['first_name'] = 'new name'\n        \"\"\"\n\n        # Convert the key to camel case and set the corresponding value in the data dictionary\n        self._data[self._convert_key(key)] = value\n\n    def __delitem__(self, key):\n        \"\"\"\n        Delete the value corresponding to the key\n        :param key:str\n        :return:None\n        >>> camelize_map = CamelCaseMap()\n        >>> camelize_map['first_name'] = 'John'\n        >>> camelize_map.__delitem__('first_name')\n        >>> flag = 'first_name' in camelize_map\n        flag = False\n        \"\"\"\n\n        # Convert the key to camel case and delete the corresponding entry from the data dictionary\n        del self._data[self._convert_key(key)]\n\n    def __iter__(self):\n        \"\"\"\n        Returning Iterateable Objects with Own Data\n        :return:Iterator\n        >>> camelize_map = CamelCaseMap()\n        >>> camelize_map['first_name'] = 'John'\n        >>> camelize_map['last_name'] = 'Doe'\n        >>> camelize_map['age'] = 30\n        >>> camelize_map.__iter__()\n        <dict_keyiterator object at 0x0000026739977C20>\n        \"\"\"\n\n        # Return an iterator over the keys of the data dictionary\n        return iter(self._data)\n\n    def __len__(self):\n        \"\"\"\n        Returns the length of the own data\n        :return:int, length of data\n        >>> camelize_map = CamelCaseMap()\n        >>> camelize_map['first_name'] = 'John'\n        >>> camelize_map['last_name'] = 'Doe'\n        >>> camelize_map['age'] = 30\n        >>> camelize_map.__len__()\n        3\n        \"\"\"\n\n        # Return the number of entries in the data dictionary\n        return len(self._data)\n\n    def _convert_key(self, key):\n        \"\"\"\n        convert key string into camel case\n        :param key:str\n        :return:str, converted key string\n        >>> camelize_map = CamelCaseMap()\n        >>> camelize_map._convert_key('first_name')\n        'firstName'\n        \"\"\"\n\n        # If the key is a string, convert it to camel case using the _to_camel_case method\n        # Otherwise, return the key as is\n        if isinstance(key, str):\n            return self._to_camel_case(key)\n        return key\n\n    @staticmethod\n    def _to_camel_case(key):\n        \"\"\"\n        convert key string into camel case\n        :param key:str\n        :return:str, converted key string\n        >>> camelize_map = CamelCaseMap()\n        >>> camelize_map._to_camel_case('first_name')\n        'firstName'\n        \"\"\"\n\n        # Split the key into parts at underscores\n        parts = key.split('_')\n        # Return the first part of the key followed by each of the remaining parts capitalized\n        return parts[0] + ''.join(part.title() for part in parts[1:])"}, {"id": "19", "llm_annotated_code": "class ChandrasekharSieve:\n    \"\"\"\n    This is a class that uses the Chandrasekhar's Sieve method to find all prime numbers within the range\n    \"\"\"\n\n    def __init__(self, n):\n        \"\"\"\n        Initialize the ChandrasekharSieve class with the given limit.\n        :param n: int, the upper limit for generating prime numbers\n        \"\"\"\n        # Store the upper limit for generating prime numbers\n        self.n = n\n        # Generate the prime numbers up to the upper limit and store them\n        self.primes = self.generate_primes()\n\n    def generate_primes(self):\n        \"\"\"\n        Generate prime numbers up to the specified limit using the Chandrasekhar sieve algorithm.\n        :return: list, a list of prime numbers\n        >>> cs = ChandrasekharSieve(20)\n        >>> cs.generate_primes()\n        [2, 3, 5, 7, 11, 13, 17, 19]\n\n        \"\"\"\n        # If the upper limit is less than 2, return an empty list as there are no prime numbers\n        if self.n < 2:\n            return []\n        \n        # Initialize a list of boolean values representing whether each index is prime\n        sieve = [True] * (self.n + 1)\n        # 0 and 1 are not prime numbers\n        sieve[0] = sieve[1] = False\n\n        # Start from 2, the first prime number\n        p = 2\n        # For each number up to the square root of the upper limit\n        while p * p <= self.n:\n            # If the number is prime\n            if sieve[p]:\n                # Mark its multiples as not prime\n                for i in range(p * p, self.n + 1, p):\n                    sieve[i] = False\n            # Move to the next number\n            p += 1\n\n        # Initialize a list to store the prime numbers\n        primes = []\n        # For each number up to the upper limit\n        for i in range(2, self.n + 1):\n            # If the number is prime, add it to the list of prime numbers\n            if sieve[i]:\n                primes.append(i)\n\n        # Return the list of prime numbers\n        return primes\n\n    def get_primes(self):\n        \"\"\"\n        Get the list of generated prime numbers.\n        :return: list, a list of prime numbers\n        >>> cs = ChandrasekharSieve(20)\n        >>> cs.get_primes()\n        [2, 3, 5, 7, 11, 13, 17, 19]\n\n        \"\"\"\n        # Return the list of prime numbers generated by the Chandrasekhar sieve algorithm\n        return self.primes"}, {"id": "20", "llm_annotated_code": "class Chat:\n    \"\"\"\n    This is a chat class with the functions of adding users, removing users, sending messages, and obtaining messages.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the Chat with an attribute users, which is an empty dictionary.\n        \"\"\"\n        # Initialize an empty dictionary to store users and their messages\n        self.users = {}\n\n    def add_user(self, username):\n        \"\"\"\n        Add a new user to the Chat.\n        :param username: The user's name, str.\n        :return: If the user is already in the Chat, returns False, otherwise, returns True.\n        \"\"\"\n\n        # Check if the user already exists in the chat\n        if username in self.users:\n            return False\n        else:\n            # If not, add the user to the chat with an empty list for storing messages\n            self.users[username] = []\n            return True\n\n    def remove_user(self, username):\n        \"\"\"\n        Remove a user from the Chat.\n        :param username: The user's name, str.\n        :return: If the user is already in the Chat, returns True, otherwise, returns False.\n        \"\"\"\n\n        # Check if the user exists in the chat\n        if username in self.users:\n            # If yes, remove the user from the chat\n            del self.users[username]\n            return True\n        else:\n            return False\n\n    def send_message(self, sender, receiver, message):\n        \"\"\"\n        Send a message from a user to another user.\n        :param sender: The sender's name, str.\n        :param receiver: The receiver's name, str.\n        :param message: The message, str.\n        :return: If the sender or the receiver is not in the Chat, returns False, otherwise, returns True.\n        \"\"\"\n\n        # Check if both sender and receiver exist in the chat\n        if sender not in self.users or receiver not in self.users:\n            return False\n\n        # Create a timestamp for the message\n        timestamp = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n        # Create a dictionary to store the message information\n        message_info = {\n            'sender': sender,\n            'receiver': receiver,\n            'message': message,\n            'timestamp': timestamp\n        }\n\n        # Add the message to both sender's and receiver's message list\n        self.users[sender].append(message_info)\n        self.users[receiver].append(message_info)\n        return True\n\n    def get_messages(self, username):\n        \"\"\"\n        Get all the messages of a user from the Chat.\n        :param username: The user's name, str.\n        :return: A list of messages, each message is a dictionary with keys 'sender', 'receiver', 'message', 'timestamp'.\n        \"\"\"\n\n        # Check if the user exists in the chat\n        if username not in self.users:\n            return []\n        \n        # If yes, return the user's message list\n        return self.users[username]"}, {"id": "21", "llm_annotated_code": "class Classroom:\n    \"\"\"\n    This is a class representing a classroom, capable of adding and removing courses, checking availability at a given time, and detecting conflicts when scheduling new courses.\n    \"\"\"\n\n    def __init__(self, id):\n        \"\"\"\n        Initialize the classroom management system.\n        :param id: int, the id of classroom\n        \"\"\"\n        # Store the classroom id\n        self.id = id\n        # Initialize an empty list to store the courses\n        self.courses = []\n\n    def add_course(self, course):\n        \"\"\"\n        Add course to self.courses list if the course wasn't in it.\n        :param course: dict, information of the course, including 'start_time', 'end_time' and 'name'\n        >>> classroom = Classroom(1)\n        >>> classroom.add_course({'name': 'math', 'start_time': '8:00', 'end_time': '9:40'})\n        \"\"\"\n        # Check if the course is not already in the list of courses\n        if course not in self.courses:\n            # If not, append it to the list\n            self.courses.append(course)\n\n    def remove_course(self, course):\n        \"\"\"\n        Remove course from self.courses list if the course was in it.\n        :param course: dict, information of the course, including 'start_time', 'end_time' and 'name'\n        >>> classroom = Classroom(1)\n        >>> classroom.add_course({'name': 'math', 'start_time': '8:00', 'end_time': '9:40'})\n        >>> classroom.remove_course({'name': 'math', 'start_time': '8:00', 'end_time': '9:40'})\n        \"\"\"\n        # Check if the course is in the list of courses\n        if course in self.courses:\n            # If it is, remove it from the list\n            self.courses.remove(course)\n\n    def is_free_at(self, check_time):\n        \"\"\"\n        change the time format as '%H:%M' and check the time is free or not in the classroom.\n        :param check_time: str, the time need to be checked\n        :return: True if the check_time does not conflict with every course time, or False otherwise.\n        >>> classroom = Classroom(1)\n        >>> classroom.add_course({'name': 'math', 'start_time': '8:00', 'end_time': '9:40'})\n        >>> classroom.is_free_at('10:00')\n        True\n        >>> classroom.is_free_at('9:00')\n        False\n        \"\"\"\n        # Convert the check_time from string to datetime object\n        check_time = datetime.strptime(check_time, '%H:%M')\n\n        # Iterate over each course in the list of courses\n        for course in self.courses:\n            # If the check_time falls within the start and end time of any course, return False\n            if datetime.strptime(course['start_time'], '%H:%M') <= check_time <= datetime.strptime(course['end_time'],\n                                                                                                   '%H:%M'):\n                return False\n        \n        # If the check_time does not conflict with any course, return True\n        return True\n\n    def check_course_conflict(self, new_course):\n        \"\"\"\n        Before adding a new course, check if the new course time conflicts with any other course.\n        :param new_course: dict, information of the course, including 'start_time', 'end_time' and 'name'\n        :return: False if the new course time conflicts(including two courses have the same boundary time) with other courses, or True otherwise.\n        >>> classroom = Classroom(1)\n        >>> classroom.add_course({'name': 'math', 'start_time': '8:00', 'end_time': '9:40'})\n        >>> classroom.check_course_conflict({'name': 'SE', 'start_time': '9:40', 'end_time': '10:40'})\n        False\n        \"\"\"\n        # Convert the start and end time of the new course from string to datetime object\n        new_start_time = datetime.strptime(new_course['start_time'], '%H:%M')\n        new_end_time = datetime.strptime(new_course['end_time'], '%H:%M')\n\n        # Initialize a flag as True\n        flag = True\n        # Iterate over each course in the list of courses\n        for course in self.courses:\n            # Convert the start and end time of the current course from string to datetime object\n            start_time = datetime.strptime(course['start_time'], '%H:%M')\n            end_time = datetime.strptime(course['end_time'], '%H:%M')\n\n            # If the start or end time of the new course falls within the start and end time of any existing course, set the flag as False\n            if start_time <= new_start_time and end_time >= new_start_time:\n                flag = False\n            if start_time <= new_end_time and end_time >= new_end_time:\n                flag = False\n\n        # Return the flag\n        return flag"}, {"id": "22", "llm_annotated_code": "class ClassRegistrationSystem:\n\n    \"\"\"\n    This is a class as a class registration system, allowing to register students, register them for classes, retrieve students by major, get a list of all majors, and determine the most popular class within a specific major.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the registration system with the attribute students and students_registration_class.\n        students is a list of student dictionaries, each student dictionary has the key of name and major.\n        students_registration_classes is a dictionary, key is the student name, value is a list of class names\n        \"\"\"\n        # Initialize an empty list to store student dictionaries\n        self.students = []\n        # Initialize an empty dictionary to store student class registrations\n        self.students_registration_classes = {}\n\n    def register_student(self, student):\n        \"\"\"\n        register a student to the system, add the student to the students list, if the student is already registered, return 0, else return 1\n        :param student: dict\n        :return 0 if the student is already registered, else return 1\n        >>> registration_system = ClassRegistrationSystem()\n        >>> student1 = {\"name\": \"John\", \"major\": \"Computer Science\"}\n        >>> registration_system.register_student(student1)\n        1\n        \"\"\"\n\n        # Check if the student is already in the students list\n        if student in self.students:\n            # If the student is already registered, return 0\n            return 0\n        else:\n            # If the student is not registered, add the student to the students list and return 1\n            self.students.append(student)\n            return 1\n\n    def register_class(self, student_name, class_name):\n        \"\"\"\n        register a class to the student.\n        :param student_name: str\n        :param class_name: str\n        :return a list of class names that the student has registered\n        >>> registration_system = ClassRegistrationSystem()\n        >>> registration_system.register_class(student_name=\"John\", class_name=\"CS101\")\n        >>> registration_system.register_class(student_name=\"John\", class_name=\"CS102\")\n        [\"CS101\", \"CS102\"]\n        \"\"\"\n\n        # Check if the student is already in the students_registration_classes dictionary\n        if student_name in self.students_registration_classes:\n            # If the student is already registered, add the class to the student's list of classes\n            self.students_registration_classes[student_name].append(class_name)\n        else:\n            # If the student is not registered, add the student to the students_registration_classes dictionary with the class as the value\n            self.students_registration_classes[student_name] = [class_name]\n        # Return the list of classes that the student is registered for\n        return self.students_registration_classes[student_name]\n\n    def get_students_by_major(self, major):\n        \"\"\"\n        get all students in the major\n        :param major: str\n        :return a list of student name\n        >>> registration_system = ClassRegistrationSystem()\n        >>> student1 = {\"name\": \"John\", \"major\": \"Computer Science\"}\n        >>> registration_system.register_student(student1)\n        >>> registration_system.get_students_by_major(\"Computer Science\")\n        [\"John\"]\n        \"\"\"\n\n        # Initialize an empty list to store the names of students in the specified major\n        student_list = []\n        # Iterate over the students list\n        for student in self.students:\n            # If the student's major matches the specified major, add the student's name to the student_list\n            if student[\"major\"] == major:\n                student_list.append(student[\"name\"])\n        \n        # Return the list of students in the specified major\n        return student_list\n\n    def get_all_major(self):\n        \"\"\"\n        get all majors in the system\n        :return a list of majors\n        >>> registration_system = ClassRegistrationSystem()\n        >>> registration_system.students = [{\"name\": \"John\", \"major\": \"Computer Science\"}],\n        >>> registration_system.get_all_major(student1)\n        [\"Computer Science\"]\n        \"\"\"\n\n        # Initialize an empty list to store the names of all majors\n        major_list = []\n        # Iterate over the students list\n        for student in self.students:\n            # If the student's major is not already in the major_list, add it\n            if student[\"major\"] not in major_list:\n                major_list.append(student[\"major\"])\n            \n        # Return the list of all majors\n        return major_list\n\n    def get_most_popular_class_in_major(self, major):\n        \"\"\"\n        get the class with the highest enrollment in the major.\n        :return  a string of the most popular class in this major\n        >>> registration_system = ClassRegistrationSystem()\n        >>> registration_system.students = [{\"name\": \"John\", \"major\": \"Computer Science\"},\n                                             {\"name\": \"Bob\", \"major\": \"Computer Science\"},\n                                             {\"name\": \"Alice\", \"major\": \"Computer Science\"}]\n        >>> registration_system.students_registration_classes = {\"John\": [\"Algorithms\", \"Data Structures\"],\n                                            \"Bob\": [\"Operating Systems\", \"Data Structures\", \"Algorithms\"]}\n        >>> registration_system.get_most_popular_class_in_major(\"Computer Science\")\n        \"Data Structures\"\n        \"\"\"\n\n        # Initialize an empty list to store the names of all classes in the specified major\n        class_list = []\n        # Iterate over the students list\n        for student in self.students:\n            # If the student's major matches the specified major, add the student's classes to the class_list\n            if student[\"major\"] == major:\n                class_list += self.students_registration_classes[student[\"name\"]]\n        \n        # Find the class that appears most frequently in the class_list\n        most_popular_class = max(set(class_list), key=class_list.count)\n        # Return the most popular class in the specified major\n        return most_popular_class"}, {"id": "23", "llm_annotated_code": "class CombinationCalculator:\n    \"\"\"\n    This is a class that provides methods to calculate the number of combinations for a specific count, calculate all possible combinations, and generate combinations with a specified number of elements.\n    \"\"\"\n\n    def __init__(self, datas: List[str]):\n        \"\"\"\n        Initialize the calculator with a list of data.\n        \"\"\"\n        # Store the input data list in the instance variable self.datas\n        self.datas = datas\n\n    @staticmethod\n    def count(n: int, m: int) -> int:\n        \"\"\"\n        Calculate the number of combinations for a specific count.\n        :param n: The total number of elements,int.\n        :param m: The number of elements in each combination,int.\n        :return: The number of combinations,int.\n        >>> CombinationCalculator.count(4, 2)\n        6\n        \"\"\"\n\n        # If m is 0 or equal to n, return 1 as there is only one combination possible\n        if m == 0 or n == m:\n            return 1\n        # Calculate the number of combinations using the formula n! / ((n - m)! * m!)\n        # Use the math.factorial function to calculate the factorial of a number\n        return math.factorial(n) // (math.factorial(n - m) * math.factorial(m))\n\n    @staticmethod\n    def count_all(n: int) -> int:\n        \"\"\"\n        Calculate the number of all possible combinations.\n        :param n: The total number of elements,int.\n        :return: The number of all possible combinations,int,if the number of combinations is greater than 2^63-1,return float(\"inf\").\n        >>> CombinationCalculator.count_all(4)\n        15\n        \"\"\"\n\n        # If n is less than 0 or greater than 63, return False as the number of combinations is not valid\n        if n < 0 or n > 63:\n            return False\n        # Calculate the number of all possible combinations using the formula 2^n - 1\n        # If n is 63, return infinity as the number of combinations is greater than 2^63 - 1\n        return (2 ** n) - 1 if n != 63 else float(\"inf\")\n\n    def select(self, m: int) -> List[List[str]]:\n        \"\"\"\n        Generate combinations with a specified number of elements.\n        :param m: The number of elements in each combination,int.\n        :return: A list of combinations,List[List[str]].\n        >>> calc = CombinationCalculator([\"A\", \"B\", \"C\", \"D\"])\n        >>> calc.select(2)\n        [['A', 'B'], ['A', 'C'], ['A', 'D'], ['B', 'C'], ['B', 'D'], ['C', 'D']]\n\n        \"\"\"\n\n        # Initialize an empty list to store the combinations\n        result = []\n        # Call the private method _select to generate the combinations\n        self._select(0, [None] * m, 0, result)\n        # Return the list of combinations\n        return result\n\n    def select_all(self) -> List[List[str]]:\n        \"\"\"\n        Generate all possible combinations of  selecting elements from the given data list,and it uses the select method.\n        :return: A list of combinations,List[List[str]].\n        >>> calc = CombinationCalculator([\"A\", \"B\", \"C\", \"D\"])\n        >>> calc.select_all()\n        [['A'], ['B'], ['C'], ['D'], ['A', 'B'], ['A', 'C'], ['A', 'D'], ['B', 'C'], ['B', 'D'], ['C', 'D'], ['A', 'B', 'C'], ['A', 'B', 'D'], ['A', 'C', 'D'], ['B', 'C', 'D'], ['A', 'B', 'C', 'D']]\n\n        \"\"\"\n\n        # Initialize an empty list to store the combinations\n        result = []\n        # Generate all possible combinations by calling the select method for each number from 1 to the length of the data list\n        for i in range(1, len(self.datas) + 1):\n            result.extend(self.select(i))\n        # Return the list of all possible combinations\n        return result\n\n    def _select(self, dataIndex: int, resultList: List[str], resultIndex: int, result: List[List[str]]):\n        \"\"\"\n        Generate combinations with a specified number of elements by recursion.\n        :param dataIndex: The index of the data to be selected,int.\n        :param resultList: The list of elements in the combination,List[str].\n        :param resultIndex: The index of the element in the combination,int.\n        :param result: The list of combinations,List[List[str]].\n        :return: None.\n        >>> calc = CombinationCalculator([\"A\", \"B\", \"C\", \"D\"])\n        >>> result = []\n        >>> calc._select(0, [None] * 2, 0, result)\n        >>> result\n        [['A', 'B'], ['A', 'C'], ['A', 'D'], ['B', 'C'], ['B', 'D'], ['C', 'D']]\n\n        \"\"\"\n\n        # Get the length of the resultList\n        resultLen = len(resultList)\n        # Calculate the count of the result\n        resultCount = resultIndex + 1\n        # If the count of the result is greater than the length of the resultList, add a copy of the resultList to the result and return\n        if resultCount > resultLen:\n            result.append(resultList.copy())\n            return\n\n        # Generate combinations by iterating over the data from the dataIndex to the end of the data\n        for i in range(dataIndex, len(self.datas) + resultCount - resultLen):\n            # Add the current data to the resultList at the current resultIndex\n            resultList[resultIndex] = self.datas[i]\n            # Recursively call the _select method with the next dataIndex and resultIndex\n            self._select(i + 1, resultList, resultIndex + 1, result)"}, {"id": "24", "llm_annotated_code": "class ComplexCalculator:\n\n    \"\"\"\n    This is a class that implements addition, subtraction, multiplication, and division operations for complex numbers.\n    \"\"\"\n\n    def __init__(self):\n        pass\n\n    @staticmethod\n    def add(c1, c2):\n        \"\"\"\n        Adds two complex numbers.\n        :param c1: The first complex number,complex.\n        :param c2: The second complex number,complex.\n        :return: The sum of the two complex numbers,complex.\n        >>> complexCalculator = ComplexCalculator()\n        >>> complexCalculator.add(1+2j, 3+4j)\n        (4+6j)\n\n        \"\"\"\n\n        # Extract the real and imaginary parts from the complex numbers\n        real = c1.real + c2.real\n        imaginary = c1.imag + c2.imag\n\n        # Create a new complex number from the sum of the real and imaginary parts\n        answer = complex(real, imaginary)\n\n        # Return the sum of the complex numbers\n        return answer\n\n    @staticmethod\n    def subtract(c1, c2):\n        \"\"\"\n        Subtracts two complex numbers.\n        :param c1: The first complex number,complex.\n        :param c2: The second complex number,complex.\n        :return: The difference of the two complex numbers,complex.\n        >>> complexCalculator = ComplexCalculator()\n        >>> complexCalculator.subtract(1+2j, 3+4j)\n        (-2-2j)\n\n        \"\"\"\n\n        # Extract the real and imaginary parts from the complex numbers\n        real = c1.real - c2.real\n        imaginary = c1.imag - c2.imag\n\n        # Return the difference of the complex numbers\n        return complex(real, imaginary)\n\n    @staticmethod\n    def multiply(c1, c2):\n        \"\"\"\n        Multiplies two complex numbers.\n        :param c1: The first complex number,complex.\n        :param c2: The second complex number,complex.\n        :return: The product of the two complex numbers,complex.\n        >>> complexCalculator = ComplexCalculator()\n        >>> complexCalculator.multiply(1+2j, 3+4j)\n        (-5+10j)\n\n        \"\"\"\n\n        # Calculate the real part of the product using the formula (a*c - b*d)\n        real = c1.real * c2.real - c1.imag * c2.imag\n\n        # Calculate the imaginary part of the product using the formula (a*d + b*c)\n        imaginary = c1.real * c2.imag + c1.imag * c2.real\n\n        # Return the product of the complex numbers\n        return complex(real, imaginary)\n\n    @staticmethod\n    def divide(c1, c2):\n        \"\"\"\n        Divides two complex numbers.\n        :param c1: The first complex number,complex.\n        :param c2: The second complex number,complex.\n        :return: The quotient of the two complex numbers,complex.\n        >>> complexCalculator = ComplexCalculator()\n        >>> complexCalculator.divide(1+2j, 3+4j)\n        (0.44+0.08j)\n\n        \"\"\"\n\n        # Calculate the denominator using the formula (c^2 + d^2)\n        denominator = c2.real**2 + c2.imag**2\n\n        # Calculate the real part of the quotient using the formula ((a*c + b*d) / (c^2 + d^2))\n        real = (c1.real * c2.real + c1.imag * c2.imag) / denominator\n\n        # Calculate the imaginary part of the quotient using the formula ((b*c - a*d) / (c^2 + d^2))\n        imaginary = (c1.imag * c2.real - c1.real * c2.imag) / denominator\n\n        # Return the quotient of the complex numbers\n        return complex(real, imaginary)"}, {"id": "25", "llm_annotated_code": "class CookiesUtil:\n    \"\"\"\n    This is a class as utility for managing and manipulating Cookies, including methods for retrieving, saving, and setting Cookies data.\n    \"\"\"\n\n    def __init__(self, cookies_file):\n        \"\"\"\n        Initializes the CookiesUtil with the specified cookies file.\n        :param cookies_file: The cookies file to use, str.\n        \"\"\"\n        # Store the cookies file path\n        self.cookies_file = cookies_file\n        # Initialize cookies as None\n        self.cookies = None\n\n    def get_cookies(self, reponse):\n        \"\"\"\n        Gets the cookies from the specified response,and save it to cookies_file.\n        :param reponse: The response to get cookies from, dict.\n        >>> cookies_util = CookiesUtil('cookies.json')\n        >>> cookies_util.get_cookies({'cookies': {'key1': 'value1', 'key2': 'value2'}})\n        >>> cookies_util.cookies\n        {'key1': 'value1', 'key2': 'value2'}\n\n        \"\"\"\n        # Extract cookies from the response\n        self.cookies = reponse['cookies']\n        # Save the cookies to the file\n        self._save_cookies()\n\n    def load_cookies(self):\n        \"\"\"\n        Loads the cookies from the cookies_file to the cookies data.\n        :return: The cookies data, dict.\n        >>> cookies_util = CookiesUtil('cookies.json')\n        >>> cookies_util.load_cookies()\n        {'key1': 'value1', 'key2': 'value2'}\n\n        \"\"\"\n        try:\n            # Open the cookies file and load the cookies data\n            with open(self.cookies_file, 'r') as file:\n                cookies_data = json.load(file)\n                # Return the loaded cookies data\n                return cookies_data\n        except FileNotFoundError:\n            # If the file does not exist, return an empty dictionary\n            return {}\n\n    def _save_cookies(self):\n        \"\"\"\n        Saves the cookies to the cookies_file, and returns True if successful, False otherwise.\n        :return: True if successful, False otherwise.\n        >>> cookies_util = CookiesUtil('cookies.json')\n        >>> cookies_util.cookies = {'key1': 'value1', 'key2': 'value2'}\n        >>> cookies_util._save_cookies()\n        True\n\n        \"\"\"\n        try:\n            # Open the cookies file and dump the cookies data\n            with open(self.cookies_file, 'w') as file:\n                json.dump(self.cookies, file)\n            # Return True if the operation is successful\n            return True\n        except:\n            # Return False if any error occurs\n            return False"}, {"id": "26", "llm_annotated_code": "class CSVProcessor:\n\n    \"\"\"\n    This is a class for processing CSV files, including reading and writing CSV data, as well as processing specific operations and saving as a new CSV file.\n    \"\"\"\n\n    def __init__(self):\n        pass\n\n    def read_csv(self, file_name):\n        \"\"\"\n        Read the csv file by file_name, get the title and data from it\n        :param file_name: str, name of the csv file\n        :return title, data: (list, list), first row is title, the rest is data\n        >>> csvProcessor = CSVProcessor()\n        >>> csvProcessor.read_csv('read_test.csv')\n        (['a', 'b', 'c', 'd'], [['hElLo', 'YoU', 'ME', 'LoW']])\n        \"\"\"\n\n        data = []\n        # Open the CSV file in read mode\n        with open(file_name, 'r') as file:\n            # Use the csv.reader function to read the file\n            reader = csv.reader(file)\n            # The first row of the CSV file is the title\n            title = next(reader)\n            # The rest of the rows are the data\n            for row in reader:\n                data.append(row)\n        # Return the title and data\n        return title, data\n\n    def write_csv(self, data, file_name):\n        \"\"\"\n        Write data into a csv file.\n        :param file_name: str, name of the csv file\n        :return:int, if success return 1, or 0 otherwise\n        >>> csvProcessor = CSVProcessor()\n        >>> csvProcessor.write_csv([['a', 'b', 'c', 'd'], ['1', '2', '3', '4']], 'write_test.csv')\n        1\n        \"\"\"\n\n        try:\n            # Open the CSV file in write mode\n            with open(file_name, 'w', newline='') as file:\n                # Use the csv.writer function to write to the file\n                writer = csv.writer(file)\n                # Write the data to the file\n                writer.writerows(data)\n            # If the write operation is successful, return 1\n            return 1\n        except:\n            # If the write operation fails, return 0\n            return 0\n\n    def process_csv_data(self, N, save_file_name):\n        \"\"\"\n        Read a csv file into variable title and data.\n        Only remain the N th (from 0) column data and Capitalize them, store the title and new data into a new csv file.\n        Add '_process' suffix after old file name, as a new file name.\n        :param N: int, the N th column(from 0)\n        :param save_file_name, the name of file that needs to be processed.\n        :return:int, if success return 1, or 0 otherwise\n        >>> csvProcessor = CSVProcessor()\n        >>> csvProcessor.read_csv('read_test.csv')\n        (['a', 'b', 'c', 'd'], [['hElLo', 'YoU', 'ME', 'LoW']])\n        >>> csvProcessor.process_csv_data(0, 'read_test.csv')\n        1\n        >>> csvProcessor.read_csv('read_test_process.csv')\n        (['a', 'b', 'c', 'd'], [['HELLO']])\n        \"\"\"\n\n        # Use the read_csv method to read the CSV file\n        title, data = self.read_csv(save_file_name)\n        # Extract the Nth column from the data\n        column_data = [row[N] for row in data]\n        # Capitalize the data in the Nth column\n        column_data = [row.upper() for row in column_data]\n        # Combine the title and the processed column data\n        new_data = [title, column_data]\n        # Use the write_csv method to write the new data to a new CSV file\n        # The new file name is the old file name with '_process' appended before the file extension\n        return self.write_csv(new_data, save_file_name.split('.')[0] + '_process.csv')"}, {"id": "27", "llm_annotated_code": "class CurrencyConverter:\n\n    \"\"\"\n    This is a class for currency conversion, which supports to convert amounts between different currencies, retrieve supported currencies, add new currency rates, and update existing currency rates.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the exchange rate of the US dollar against various currencies\n        \"\"\"\n        # Initialize a dictionary to store the exchange rates of various currencies against the US dollar\n        self.rates = {\n            'USD': 1.0,\n            'EUR': 0.85,\n            'GBP': 0.72,\n            'JPY': 110.15,\n            'CAD': 1.23,\n            'AUD': 1.34,\n            'CNY': 6.40,\n        }\n\n    def convert(self, amount, from_currency, to_currency):\n        \"\"\"\n        Convert the value of a given currency to another currency type\n        :param amount: float, The value of a given currency\n        :param from_currency: string, source currency type\n        :param to_currency: string, target currency type\n        :return: float, value converted to another currency type\n        >>> cc = CurrencyConverter()\n        >>> cc.convert(64, 'CNY','USD')\n        10.0\n        \"\"\"\n\n        # If the source and target currencies are the same, return the original amount\n        if from_currency == to_currency:\n            return amount\n\n        # If either the source or target currency is not supported, return False\n        if from_currency not in self.rates or to_currency not in self.rates:\n            return False\n\n        # Retrieve the exchange rates of the source and target currencies\n        from_rate = self.rates[from_currency]\n        to_rate = self.rates[to_currency]\n\n        # Convert the amount from the source currency to the target currency\n        converted_amount = (amount / from_rate) * to_rate\n\n        # Return the converted amount\n        return converted_amount\n\n\n    def get_supported_currencies(self):\n        \"\"\"\n        Returns a list of supported currency types\n        :return:list, All supported currency types\n        >>> cc = CurrencyConverter()\n        >>> cc.get_supported_currencies()\n        ['USD','EUR','GBP','JPY','CAD','AUD','CNY']\n        \"\"\"\n\n        # Return a list of the keys in the rates dictionary, which represent the supported currencies\n        return list(self.rates.keys())\n\n\n    def add_currency_rate(self, currency, rate):\n        \"\"\"\n        Add a new supported currency type, return False if the currency type is already in the support list\n        :param currency:string, currency type to be added\n        :param rate:float, exchange rate for this type of currency\n        :return:If successful, returns None; if unsuccessful, returns False\n        >>> cc = CurrencyConverter()\n        >>> cc.add_currency_rate('KRW', 1308.84)\n        self.rates['KRW'] = 1308.84\n        \"\"\"\n\n        # If the currency is already supported, return False\n        if currency in self.rates:\n            return False\n\n        # Add the new currency and its exchange rate to the rates dictionary\n        self.rates[currency] = rate\n\n\n    def update_currency_rate(self, currency, new_rate):\n        \"\"\"\n        Update the exchange rate for a certain currency\n        :param currency:string\n        :param new_rate:float\n        :return:If successful, returns None; if unsuccessful, returns False\n        >>> cc = CurrencyConverter()\n        >>> cc.update_currency_rate('CNY', 7.18)\n        self.rates['CNY'] = 7.18\n        \"\"\"\n\n        # If the currency is not supported, return False\n        if currency not in self.rates:\n            return False\n\n        # Update the exchange rate of the currency in the rates dictionary\n        self.rates[currency] = new_rate"}, {"id": "28", "llm_annotated_code": "import sqlite3\n\nclass DatabaseProcessor:\n\n    \"\"\"\n    This is a class for processing a database, supporting to create tables, insert data into the database, search for data based on name, and delete data from the database.\n    \"\"\"\n\n    def __init__(self, database_name):\n        \"\"\"\n        Initialize database name of database processor\n        \"\"\"\n        # Store the database name to be used in other methods\n        self.database_name = database_name\n\n\n    def create_table(self, table_name, key1, key2):\n        \"\"\"\n        Create a new table in the database if it doesn't exist.\n        And make id (INTEGER) as PRIMARY KEY, make key1 as TEXT, key2 as INTEGER\n        :param table_name: str, the name of the table to create.\n        :param key1: str, the name of the first column in the table.\n        :param key2: str, the name of the second column in the table.\n        >>> db.create_table('user', 'name', 'age')\n        \"\"\"\n\n        # Connect to the SQLite database using the sqlite3.connect method\n        conn = sqlite3.connect(self.database_name)\n        # Create a cursor object using the connection's cursor method\n        cursor = conn.cursor()\n        # Define the SQL query to create a new table with the specified name and columns\n        create_table_query = f\"CREATE TABLE IF NOT EXISTS {table_name} (id INTEGER PRIMARY KEY, {key1} TEXT, {key2} INTEGER)\"\n        # Execute the SQL query using the cursor's execute method\n        cursor.execute(create_table_query)\n        # Commit the transaction using the connection's commit method\n        conn.commit()\n        # Close the connection using the connection's close method\n        conn.close()\n\n\n    def insert_into_database(self, table_name, data):\n        \"\"\"\n        Insert data into the specified table in the database.\n        :param table_name: str, the name of the table to insert data into.\n        :param data: list, a list of dictionaries where each dictionary represents a row of data.\n        >>> db.insert_into_database('user', [\n                {'name': 'John', 'age': 25},\n                {'name': 'Alice', 'age': 30}\n            ])\n        \"\"\"\n\n        # Connect to the SQLite database using the sqlite3.connect method\n        conn = sqlite3.connect(self.database_name)\n        # Create a cursor object using the connection's cursor method\n        cursor = conn.cursor()\n        # Iterate over the data list\n        for item in data:\n            # Define the SQL query to insert a new row into the specified table\n            insert_query = f\"INSERT INTO {table_name} (name, age) VALUES (?, ?)\"\n            # Execute the SQL query using the cursor's execute method, passing the values to be inserted as a tuple\n            cursor.execute(insert_query, (item['name'], item['age']))\n        # Commit the transaction using the connection's commit method\n        conn.commit()\n        # Close the connection using the connection's close method\n        conn.close()\n\n    def search_database(self, table_name, name):\n        \"\"\"\n        Search the specified table in the database for rows with a matching name.\n        :param table_name: str, the name of the table to search.\n        :param name: str, the name to search for.\n        :return: list, a list of tuples representing the rows with matching name, if any;\n                    otherwise, returns None.\n        >>> db.search_database('user', 'John')\n        [(1, 'John', 25)]\n        \"\"\"\n\n        # Connect to the SQLite database using the sqlite3.connect method\n        conn = sqlite3.connect(self.database_name)\n        # Create a cursor object using the connection's cursor method\n        cursor = conn.cursor()\n        # Define the SQL query to select rows from the specified table where the name matches the specified name\n        select_query = f\"SELECT * FROM {table_name} WHERE name = ?\"\n        # Execute the SQL query using the cursor's execute method, passing the name to be searched for as a tuple\n        cursor.execute(select_query, (name,))\n        # Fetch all the rows returned by the query using the cursor's fetchall method\n        result = cursor.fetchall()\n        # If the result is not empty, return it; otherwise, return None\n        if result:\n            return result\n        else:\n            return None\n\n\n    def delete_from_database(self, table_name, name):\n        \"\"\"\n        Delete rows from the specified table in the database with a matching name.\n        :param table_name: str, the name of the table to delete rows from.\n        :param name: str, the name to match for deletion.\n        >>> db.delete_from_database('user', 'John')\n        \"\"\"\n\n        # Connect to the SQLite database using the sqlite3.connect method\n        conn = sqlite3.connect(self.database_name)\n        # Create a cursor object using the connection's cursor method\n        cursor = conn.cursor()\n        # Define the SQL query to delete rows from the specified table where the name matches the specified name\n        delete_query = f\"DELETE FROM {table_name} WHERE name = ?\"\n        # Execute the SQL query using the cursor's execute method, passing the name to be deleted as a tuple\n        cursor.execute(delete_query, (name,))\n        # Commit the transaction using the connection's commit method\n        conn.commit()\n        # Close the connection using the connection's close method\n        conn.close()"}, {"id": "29", "llm_annotated_code": "class DataStatistics:\n    \n    \"\"\"\n    This is a class for performing data statistics, supporting to calculate the mean, median, and mode of a given data set.\n    \"\"\"\n\n    def mean(self, data):\n        \"\"\"\n        Calculate the average value of a group of data, accurate to two digits after the Decimal separator\n        :param data:list, data list\n        :return:float, the mean value\n        >>> ds = DataStatistics()\n        >>> ds.mean([1, 2, 3, 4, 5])\n        3.00\n        \"\"\"\n\n        # Calculate the sum of the data and divide by the length of the data to get the mean\n        # Round the result to 2 decimal places\n        return round(sum(data) / len(data), 2)\n\n    def median(self, data):\n        \"\"\"\n        Calculate the median of a group of data, accurate to two digits after the Decimal separator\n        :param data:list, data list\n        :return:float, the median value\n        >>> ds = DataStatistics()\n        >>> ds.median([2, 5, 1, 3, 4])\n        3.00\n        \"\"\"\n\n        # Sort the data in ascending order\n        sorted_data = sorted(data)\n\n        # Calculate the index of the middle element\n        n = len(sorted_data)\n        if n % 2 == 0:\n            # If the length of the data is even, the median is the average of the two middle elements\n            middle = n // 2\n            return round((sorted_data[middle - 1] + sorted_data[middle]) / 2, 2)\n        else:\n            # If the length of the data is odd, the median is the middle element\n            middle = n // 2\n            return sorted_data[middle]\n\n    def mode(self, data):\n        \"\"\"\n        Calculate the mode of a set of data\n        :param data:list, data list\n        :return:float, the mode\n        >>> ds = DataStatistics()\n        >>> ds.mode([2, 2, 3, 3, 4])\n        [2, 3]\n        \"\"\"\n\n        # Use the Counter class from the collections module to count the frequency of each element in the data\n        counter = Counter(data)\n\n        # Find the maximum count (i.e., the most frequent element(s))\n        mode_count = max(counter.values())\n\n        # Find all elements that have the maximum count and return them as the mode(s)\n        mode = [x for x, count in counter.items() if count == mode_count]\n        return mode"}, {"id": "30", "llm_annotated_code": "import numpy as np\n\nclass DataStatistics2:\n\n    \"\"\"\n    This is a class for performing data statistics, supporting to get the sum, minimum, maximum, variance, standard deviation, and correlation of a given dataset.\n    \"\"\"\n\n    def __init__(self, data):\n        \"\"\"\n        Initialize Data List\n        :param data:list\n        \"\"\"\n\n        # Convert the input data list to a numpy array and store it in self.data\n        self.data = np.array(data)\n\n    def get_sum(self):\n        \"\"\"\n        Calculate the sum of data\n        :return:float\n        >>> ds2 = DataStatistics2([1, 2, 3, 4])\n        >>> ds2.get_sum()\n        10\n        \"\"\"\n\n        # Use numpy's sum function to calculate the sum of self.data and return the result\n        return np.sum(self.data)\n\n    def get_min(self):\n        \"\"\"\n        Calculate the minimum value in the data\n        :return:float\n        >>> ds2 = DataStatistics2([1, 2, 3, 4])\n        >>> ds2.get_min()\n        1\n        \"\"\"\n\n        # Use numpy's min function to find the minimum value in self.data and return the result\n        return np.min(self.data)\n\n    def get_max(self):\n        \"\"\"\n        Calculate the maximum value in the data\n        :return:float\n        >>> ds2 = DataStatistics2([1, 2, 3, 4])\n        >>> ds2.get_max()\n        4\n        \"\"\"\n\n        # Use numpy's max function to find the maximum value in self.data and return the result\n        return np.max(self.data)\n\n    def get_variance(self):\n        \"\"\"\n        Calculate variance, accurate to two digits after the Decimal separator\n        :return:float\n        >>> ds2 = DataStatistics2([1, 2, 3, 4])\n        >>> ds2.get_variance()\n        1.25\n        \"\"\"\n\n        # Use numpy's var function to calculate the variance of self.data\n        # Use the round function to round the result to 2 decimal places\n        # Return the result\n        return round(np.var(self.data), 2)\n\n    def get_std_deviation(self):\n        \"\"\"\n        Calculate standard deviation, accurate to two digits after the Decimal separator\n        :return:float\n        >>> ds2 = DataStatistics2([1, 2, 3, 4])\n        >>> ds2.get_std_deviation()\n        1.12\n        \"\"\"\n\n        # Use numpy's std function to calculate the standard deviation of self.data\n        # Use the round function to round the result to 2 decimal places\n        # Return the result\n        return round(np.std(self.data), 2)\n\n    def get_correlation(self):\n        \"\"\"\n        Calculate correlation\n        :return:float\n        >>> ds2 = DataStatistics2([1, 2, 3, 4])\n        >>> ds2.get_correlation()\n        1.0\n        \"\"\"\n\n        # Use numpy's corrcoef function to calculate the correlation coefficient matrix of self.data\n        # Set rowvar to False to compute the correlation between columns (variables) instead of rows (observations)\n        # Return the result\n        return np.corrcoef(self.data, rowvar=False)"}, {"id": "31", "llm_annotated_code": "import math\n\nclass DataStatistics4:\n\n    \"\"\"\n    This is a class that performs advanced mathematical calculations and statistics, including correlation coefficient, skewness, kurtosis, and probability density function (PDF) for a normal distribution.\n    \"\"\"\n\n    @staticmethod\n    def correlation_coefficient(data1, data2):\n        \"\"\"\n        Calculate the correlation coefficient of two sets of data.\n        :param data1: The first set of data,list.\n        :param data2: The second set of data,list.\n        :return: The correlation coefficient, float.\n        >>> DataStatistics4.correlation_coefficient([1, 2, 3], [4, 5, 6])\n        0.9999999999999998\n\n        \"\"\"\n\n        # Calculate the length of the data\n        n = len(data1)\n\n        # Calculate the mean of both data sets\n        mean1 = sum(data1) / n\n        mean2 = sum(data2) / n\n\n        # Calculate the numerator of the correlation coefficient formula\n        numerator = sum((data1[i] - mean1) * (data2[i] - mean2) for i in range(n))\n\n        # Calculate the denominator of the correlation coefficient formula\n        denominator = math.sqrt(sum((data1[i] - mean1) ** 2 for i in range(n))) * math.sqrt(sum((data2[i] - mean2) ** 2 for i in range(n)))\n\n        # Return the correlation coefficient if the denominator is not zero, otherwise return 0\n        return numerator / denominator if denominator != 0 else 0\n\n    @staticmethod\n    def skewness(data):\n        \"\"\"\n        Calculate the skewness of a set of data.\n        :param data: The input data list, list.\n        :return: The skewness, float.\n        >>> DataStatistics4.skewness([1, 2, 5])\n        2.3760224064818463\n\n        \"\"\"\n\n        # Calculate the length of the data\n        n = len(data)\n\n        # Calculate the mean of the data\n        mean = sum(data) / n\n\n        # Calculate the variance of the data\n        variance = sum((x - mean) ** 2 for x in data) / n\n\n        # Calculate the standard deviation of the data\n        std_deviation = math.sqrt(variance)\n\n        # Calculate the skewness of the data if the standard deviation is not zero, otherwise return 0\n        skewness = sum((x - mean) ** 3 for x in data) * n / ((n - 1) * (n - 2) * std_deviation ** 3) if std_deviation != 0 else 0\n\n        return skewness\n\n    @staticmethod\n    def kurtosis(data):\n        \"\"\"\n        Calculate the kurtosis of a set of data.\n        :param data: The input data list, list.\n        :return: The kurtosis, float.\n        >>> DataStatistics4.kurtosis([1, 20,100])\n        -1.5000000000000007\n\n        \"\"\"\n\n        # Calculate the length of the data\n        n = len(data)\n\n        # Calculate the mean of the data\n        mean = sum(data) / n\n\n        # Calculate the standard deviation of the data\n        std_dev = math.sqrt(sum((x - mean) ** 2 for x in data) / n)\n\n        # If the standard deviation is zero, return NaN\n        if std_dev == 0:\n            return math.nan\n\n        # Calculate the centered data by subtracting the mean from each data point\n        centered_data = [(x - mean) for x in data]\n\n        # Calculate the fourth moment of the data\n        fourth_moment = sum(x ** 4 for x in centered_data) / n\n\n        # Calculate the kurtosis of the data\n        kurtosis_value = (fourth_moment / std_dev ** 4) - 3\n\n        return kurtosis_value\n\n    @staticmethod\n    def pdf(data, mu, sigma):\n        \"\"\"\n        Calculate the probability density function (PDF) of a set of data under a normal distribution.\n        :param data: The input data list, list.\n        :param mu: The mean of the normal distribution, float.\n        :param sigma: The standard deviation of the normal distribution, float.\n        :return: The probability density function (PDF), list.\n        >>> DataStatistics4.pdf([1, 2, 3], 1, 1)\n        [0.3989422804014327, 0.24197072451914337, 0.05399096651318806]\n\n        \"\"\"\n\n        # Calculate the PDF for each data point in the data set using the formula for the PDF of a normal distribution\n        pdf_values = [1 / (sigma * math.sqrt(2 * math.pi)) * math.exp(-0.5 * ((x - mu) / sigma) ** 2) for x in data]\n\n        return pdf_values"}, {"id": "32", "llm_annotated_code": "class DecryptionUtils:\n\n    \"\"\"\n    This is a class that provides methods for decryption, including the Caesar cipher, Vigenere cipher, and Rail Fence cipher.\n    \"\"\"\n\n    def __init__(self, key):\n        \"\"\"\n        Initializes the decryption utility with a key.\n        :param key: The key to use for decryption,str.\n        \"\"\"\n        # Store the key for decryption\n        self.key = key\n\n    def caesar_decipher(self, ciphertext, shift):\n        \"\"\"\n        Deciphers the given ciphertext using the Caesar cipher\n        :param ciphertext: The ciphertext to decipher,str.\n        :param shift: The shift to use for decryption,int.\n        :return: The deciphered plaintext,str.\n        >>> d = DecryptionUtils('key')\n        >>> d.caesar_decipher('ifmmp', 1)\n        'hello'\n\n        \"\"\"\n\n        plaintext = \"\"\n\n        # Loop through each character in the ciphertext\n        for char in ciphertext:\n\n            if char.isalpha():\n                # If the character is an uppercase letter set the ascii offset to 65\n                # If the character is a lowercase letter set the ascii offset to 97\n                if char.isupper():\n                    ascii_offset = 65\n                else:\n                    ascii_offset = 97\n                # Calculate the shifted character\n                shifted_char = chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n\n                # Add the shifted character to the plaintext\n                plaintext += shifted_char\n            else:\n                # If the character is not a letter, add it to the plaintext as is\n                plaintext += char\n\n        # Return the deciphered plaintext\n        return plaintext\n\n    def vigenere_decipher(self, ciphertext):\n        \"\"\"\n        Deciphers the given ciphertext using the Vigenere cipher\n        :param ciphertext: The ciphertext to decipher,str.\n        :return: The deciphered plaintext,str.\n        >>> d = DecryptionUtils('key')\n        >>> d.vigenere_decipher('ifmmp')\n        'ybocl'\n\n        \"\"\"\n\n        decrypted_text = \"\"\n        key_index = 0\n\n        # Loop through each character in the ciphertext\n        for char in ciphertext:\n\n            if char.isalpha():\n\n                # Calculate the shift based on the character at key_index in the key\n                shift = ord(self.key[key_index % len(self.key)].lower()) - ord('a')\n\n                # Calculate the decrypted character\n                decrypted_char = chr((ord(char.lower()) - ord('a') - shift) % 26 + ord('a'))\n\n                # If the character was uppercase, convert the decrypted character to uppercase\n                # Add the decrypted character to the deciphered text\n                decrypted_text += decrypted_char.upper() if char.isupper() else decrypted_char\n\n                # Move to the next character in the key\n                key_index += 1\n            else:\n                # If the character is not a letter, add it to the decrypted text as is\n                decrypted_text += char\n\n        # Return the deciphered text\n        return decrypted_text\n\n    def rail_fence_decipher(self, encrypted_text, rails):\n        \"\"\"\n        Deciphers the given ciphertext using the Rail Fence cipher\n        :param encrypted_text: The ciphertext to decipher,str.\n        :param rails: The number of rails to use for decryption,int.\n        :return: The deciphered plaintext,str.\n        >>> d = DecryptionUtils('key')\n        >>> d.rail_fence_decipher('Hoo!el,Wrdl l', 3)\n        'Hello, World!'\n\n        \"\"\"\n\n        # Create a fence with new line characters that has dimensions rails x len(encrypted_text)\n        fence = [['\n' for _ in range(len(encrypted_text))] for _ in range(rails)]\n        direction = -1\n        row, col = 0, 0\n\n        # Loop through each character in the encrypted text\n        for _ in range(len(encrypted_text)):\n\n            # Change direction when reaching the top or bottom rail\n            if row == 0 or row == rails - 1:\n                direction = -direction\n\n            # Mark the position in the fence with an empty string\n            fence[row][col] = ''\n\n            # Move to the next column and row\n            col += 1\n            row += direction\n\n        index = 0\n        for i in range(rails):\n            for j in range(len(encrypted_text)):\n                if fence[i][j] == '':\n                    fence[i][j] = encrypted_text[index]\n                    index += 1\n\n        plain_text = ''\n        direction = -1\n        row, col = 0, 0\n        for _ in range(len(encrypted_text)):\n            if row == 0 or row == rails - 1:\n                direction = -direction\n            plain_text += fence[row][col]\n            col += 1\n            row += direction\n        return plain_text"}, {"id": "34", "llm_annotated_code": "class DocFileHandler:\n\n    \"\"\"\n    This is a class that handles Word documents and provides functionalities for reading, writing, and modifying the content of Word documents.\n    \"\"\"\n\n    def __init__(self, file_path):\n        \"\"\"\n        Initializes the DocFileHandler object with the specified file path.\n        :param file_path: str, the path to the Word document file.\n        \"\"\"\n        # Store the file path to the Word document\n        self.file_path = file_path\n\n    def read_text(self):\n        \"\"\"\n        Reads the content of a Word document and returns it as a string.\n        :return: str, the content of the Word document.\n        \"\"\"\n        # Create a Document object from the Word document file\n        doc = Document(self.file_path)\n        text = []\n        # Iterate over the paragraphs in the document, appending each paragraph's text to the text list\n        for paragraph in doc.paragraphs:\n            text.append(paragraph.text)\n        # Join the list of paragraph texts into a single string with line breaks between paragraphs and return it\n        return \"\\n\".join(text)\n\n    def write_text(self, content, font_size=12, alignment='left'):\n        \"\"\"\n        Writes the specified content to a Word document.\n        :param content: str, the text content to write.\n        :param font_size: int, optional, the font size of the text (default is 12).\n        :param alignment: str, optional, the alignment of the text ('left', 'center', or 'right'; default is 'left').\n        :return: bool, True if the write operation is successful, False otherwise.\n        \"\"\"\n        try:\n            # Create a new Document object\n            doc = Document()\n            # Add a paragraph to the document and add a run of text to the paragraph\n            paragraph = doc.add_paragraph()\n            run = paragraph.add_run(content)\n            # Set the font size of the run of text\n            font = run.font\n            font.size = Pt(font_size)\n            # Set the alignment of the paragraph\n            alignment_value = self._get_alignment_value(alignment)\n            paragraph.alignment = alignment_value\n            # Save the document to the file path\n            doc.save(self.file_path)\n            return True\n        except:\n            # If any error occurs during the write operation, return False\n            return False\n\n    def add_heading(self, heading, level=1):\n        \"\"\"\n        Adds a heading to the Word document.\n        :param heading: str, the text of the heading.\n        :param level: int, optional, the level of the heading (1, 2, 3, etc.; default is 1).\n        :return: bool, True if the heading is successfully added, False otherwise.\n        \"\"\"\n        try:\n            # Open the existing Word document\n            doc = Document(self.file_path)\n            # Add a heading to the document with the specified text and level\n            doc.add_heading(heading, level)\n            # Save the document to the file path\n            doc.save(self.file_path)\n            return True\n        except:\n            # If any error occurs during the operation, return False\n            return False\n\n    def add_table(self, data):\n        \"\"\"\n        Adds a table to the Word document with the specified data.\n        :param data: list of lists, the data to populate the table.\n        :return: bool, True if the table is successfully added, False otherwise.\n        \"\"\"\n        try:\n            # Open the existing Word document\n            doc = Document(self.file_path)\n            # Add a table to the document with the specified number of rows and columns\n            table = doc.add_table(rows=len(data), cols=len(data[0]))\n            # Populate the table with the data\n            for i, row in enumerate(data):\n                for j, cell_value in enumerate(row):\n                    table.cell(i, j).text = str(cell_value)\n            # Save the document to the file path\n            doc.save(self.file_path)\n            return True\n        except:\n            # If any error occurs during the operation, return False\n            return False\n\n    def _get_alignment_value(self, alignment):\n        \"\"\"\n        Returns the alignment value corresponding to the given alignment string.\n        :param alignment: str, the alignment string ('left', 'center', or 'right').\n        :return: int, the alignment value.\n        \"\"\"\n        # Define a dictionary mapping alignment strings to their corresponding alignment values\n        alignment_options = {\n            'left': WD_PARAGRAPH_ALIGNMENT.LEFT,\n            'center': WD_PARAGRAPH_ALIGNMENT.CENTER,\n            'right': WD_PARAGRAPH_ALIGNMENT.RIGHT\n        }\n        # Return the alignment value corresponding to the given alignment string, defaulting to left alignment if the string is not recognized\n        return alignment_options.get(alignment.lower(), WD_PARAGRAPH_ALIGNMENT.LEFT)"}, {"id": "35", "llm_annotated_code": "class EightPuzzle:\n\n    \"\"\"\n    This class is an implementation of the classic 8-puzzle game, including methods for finding the blank tile, making moves, getting possible moves, and solving the puzzle using a breadth-first search algorithm.\n    \"\"\"\n\n    def __init__(self, initial_state):\n        \"\"\"\n        Initializing the initial state of Eight Puzzle Game, stores in attribute self.initial_state.\n        And set the goal state of this game, stores in self.goal_state. In this case, set the size as 3*3\n        :param initial_state: a 3*3 size list of Integer, stores the initial state\n        \"\"\"\n        # Store the initial state of the puzzle\n        self.initial_state = initial_state\n        # Define the goal state of the puzzle\n        self.goal_state = [[1, 2, 3], [4, 5, 6], [7, 8, 0]]\n\n    def find_blank(self, state):\n        \"\"\"\n        Find the blank position of current state, which is the 0 element.\n        :param state: a 3*3 size list of Integer, stores the current state.\n        :return i, j: two Integers, represent the coordinate of the blank block.\n        \"\"\"\n\n        # Iterate over the rows and columns of the state to find the blank tile (0)\n        for i in range(3):\n            for j in range(3):\n                if state[i][j] == 0:\n                    # Return the coordinates of the blank tile\n                    return i, j\n\n    def move(self, state, direction):\n        \"\"\"\n        Find the blank block, then makes the board moves forward the given direction.\n        :param state: a 3*3 size list of Integer, stores the state before moving.\n        :param direction: str, only has 4 direction 'up', 'down', 'left', 'right'\n        :return new_state: a 3*3 size list of Integer, stores the state after moving.\n        \"\"\"\n\n        # Find the blank tile in the current state\n        i, j = self.find_blank(state)\n        # Create a copy of the current state to generate the new state\n        new_state = [row[:] for row in state]\n        # Swap the blank tile with the tile in the specified direction\n        if direction == 'up':\n            new_state[i][j], new_state[i - 1][j] = new_state[i - 1][j], new_state[i][j]\n        elif direction == 'down':\n            new_state[i][j], new_state[i + 1][j] = new_state[i + 1][j], new_state[i][j]\n        elif direction == 'left':\n            new_state[i][j], new_state[i][j - 1] = new_state[i][j - 1], new_state[i][j]\n        elif direction == 'right':\n            new_state[i][j], new_state[i][j + 1] = new_state[i][j + 1], new_state[i][j]\n\n        # Return the new state after the move\n        return new_state\n\n    def get_possible_moves(self, state):\n        \"\"\"\n        According the current state, find all the possible moving directions. Only has 4 direction 'up', 'down', 'left', 'right'.\n        :param state: a 3*3 size list of Integer, stores the current state.\n        :return moves: a list of str, store all the possible moving directions according to the current state.\n        \"\"\"\n\n        # Initialize an empty list to store the possible moves\n        moves = []\n        # Find the blank tile in the current state\n        i, j = self.find_blank(state)\n        # Add the possible moves to the list based on the position of the blank tile\n        if i > 0:\n            moves.append('up')\n        if i < 2:\n            moves.append('down')\n        if j > 0:\n            moves.append('left')\n        if j < 2:\n            moves.append('right')\n        # Return the list of possible moves\n        return moves\n\n    def solve(self):\n        \"\"\"\n        Use BFS algorithm to find the path solution which makes the initial state to the goal method.\n        Maintain a list as a queue, named as open_list, append the initial state.\n        Always visit and pop the 0 index element, invoke get_possible_moves method find all the possible directions.\n        Traversal the possible_moves list and invoke move method to get several new states.Then append them.\n        redo the above steps until the open_list is empty or the state has changed to the goal state.\n        :return path: list of str, the solution to the goal state.\n        \"\"\"\n\n        # Initialize the open list with the initial state and an empty path\n        open_list = [(self.initial_state, [])]\n        # Initialize the closed list to keep track of the visited states\n        closed_list = []\n        # Loop until the open list is empty or the goal state is reached\n        while open_list:\n            # Pop the first state and path from the open list\n            current_state, path = open_list.pop(0)\n            # Add the current state to the closed list\n            closed_list.append(current_state)\n            # If the current state is the goal state, return the path\n            if current_state == self.goal_state:\n                return path\n            # For each possible move from the current state\n            for move in self.get_possible_moves(current_state):\n                # Generate a new state by making the move\n                new_state = self.move(current_state, move)\n                # If the new state has not been visited, add it to the open list with the updated path\n                if new_state not in closed_list:\n                    open_list.append((new_state, path + [move]))\n\n        # If no solution is found, return None\n        return None"}, {"id": "36", "llm_annotated_code": "class EmailClient:\n\n    \"\"\"\n    This is a class that serves as an email client, implementing functions such as checking emails, determining whether there is sufficient space, and cleaning up space\n    \"\"\"\n\n    def __init__(self, addr, capacity) -> None:\n        \"\"\"\n        Initializes the EmailClient class with the email address and the capacity of the email box.\n        :param addr: The email address, str.\n        :param capacity: The capacity of the email box, float.\n        \"\"\"\n        # Store the email address and capacity as instance variables\n        self.addr = addr\n        self.capacity = capacity\n        # Initialize an empty list to store the emails in the inbox\n        self.inbox = []\n\n    def send_to(self, recv, content, size):\n        \"\"\"\n        Sends an email to the given email address.\n        :param recv: The email address of the receiver, str.\n        :param content: The content of the email, str.\n        :param size: The size of the email, float.\n        :return: True if the email is sent successfully, False if the receiver's email box is full.\n        \"\"\"\n\n        # Check if the receiver's email box has enough space for the new email\n        if not recv.is_full_with_one_more_email(size):\n            # If there is enough space, create a new email with the sender's address, receiver's address, content, size, current time, and state\n            timestamp = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n            email = {\n                \"sender\": self.addr,\n                \"receiver\": recv.addr,\n                \"content\": content,\n                \"size\": size,\n                \"time\": timestamp,\n                \"state\": \"unread\"\n            }\n            # Add the new email to the receiver's inbox\n            recv.inbox.append(email)\n            return True\n        else:\n            # If there is not enough space, clear the sender's inbox to make space and return False\n            self.clear_inbox(size)\n            return False\n\n    def fetch(self):\n        \"\"\"\n        Retrieves the first unread email in the email box and marks it as read.\n        :return: The first unread email in the email box, dict.\n        \"\"\"\n\n        # If the inbox is empty, return None\n        if len(self.inbox) == 0:\n            return None\n        # Iterate over the emails in the inbox\n        for i in range(len(self.inbox)):\n            # If an email is unread, mark it as read and return it\n            if self.inbox[i]['state'] == \"unread\":\n                self.inbox[i]['state'] = \"read\"\n                return self.inbox[i]\n        # If all emails are read, return None\n        return None\n\n    def is_full_with_one_more_email(self, size):\n        \"\"\"\n        Determines whether the email box is full after adding an email of the given size.\n        :param size: The size of the email, float.\n        :return: True if the email box is full, False otherwise.\n        \"\"\"\n\n        # Calculate the total size of the emails in the inbox\n        occupied_size = self.get_occupied_size()\n        # If the total size plus the size of the new email is greater than the capacity, return True\n        return True if occupied_size + size > self.capacity else False\n\n    def get_occupied_size(self):\n        \"\"\"\n        Gets the total size of the emails in the email box.\n        :return: The total size of the emails in the email box, float.\n        \"\"\"\n\n        # Initialize a variable to store the total size\n        occupied_size = 0\n        # Iterate over the emails in the inbox and add their sizes to the total size\n        for email in self.inbox:\n            occupied_size += email[\"size\"]\n        # Return the total size\n        return occupied_size\n\n    def clear_inbox(self, size):\n        \"\"\"\n        Clears the email box by deleting the oldest emails until the email box has enough space to accommodate the given size.\n        :param size: The size of the email, float.\n        \"\"\"\n\n        # If the inbox is empty, return\n        if len(self.addr) == 0:\n            return\n        # Initialize a variable to store the total size of the deleted emails\n        freed_space = 0\n        # While the total size of the deleted emails is less than the size of the new email and there are still emails in the inbox\n        while freed_space < size and self.inbox:\n            # Get the oldest email in the inbox\n            email = self.inbox[0]\n            # Add its size to the total size of the deleted emails\n            freed_space += email['size']\n            # Delete the oldest email from the inbox\n            del self.inbox[0]"}, {"id": "37", "llm_annotated_code": "class EncryptionUtils:\n\n    \"\"\"\n    This is a class that provides methods for encryption, including the Caesar cipher, Vigenere cipher, and Rail Fence cipher.\n    \"\"\"\n\n    def __init__(self, key):\n        \"\"\"\n        Initializes the class with a key.\n        :param key: The key to use for encryption, str.\n        \"\"\"\n        # Store the key as a class attribute\n        self.key = key\n\n    def caesar_cipher(self, plaintext, shift):\n        \"\"\"\n        Encrypts the plaintext using the Caesar cipher.\n        :param plaintext: The plaintext to encrypt, str.\n        :param shift: The number of characters to shift each character in the plaintext, int.\n        :return: The ciphertext, str.\n        >>> e = EncryptionUtils(\"key\")\n        >>> e.caesar_cipher(\"abc\", 1)\n        'bcd'\n\n        \"\"\"\n\n        # Initialize an empty string for the ciphertext\n        ciphertext = \"\"\n\n        # Iterate over each character in the plaintext\n        for char in plaintext:\n            # Check if the character is a letter\n            if char.isalpha():\n                # Determine the ASCII offset based on whether the character is uppercase or lowercase\n                if char.isupper():\n                    ascii_offset = 65\n                else:\n                    ascii_offset = 97\n\n                # Calculate the shifted character and add it to the ciphertext\n                shifted_char = chr((ord(char) - ascii_offset + shift) % 26 + ascii_offset)\n                ciphertext += shifted_char\n            else:\n                # If the character is not a letter, add it to the ciphertext as is\n                ciphertext += char\n\n        # Return the ciphertext\n        return ciphertext\n\n    def vigenere_cipher(self, plaintext):\n        \"\"\"\n        Encrypts the plaintext using the Vigenere cipher.\n        :param plaintext: The plaintext to encrypt, str.\n        :return: The ciphertext, str.\n        >>> e = EncryptionUtils(\"key\")\n        >>> e.vigenere_cipher(\"abc\")\n        'kfa'\n\n        \"\"\"\n\n        # Initialize an empty string for the encrypted text and a counter for the key index\n        encrypted_text = \"\"\n        key_index = 0\n\n        # Iterate over each character in the plaintext\n        for char in plaintext:\n            # Check if the character is a letter\n            if char.isalpha():\n                # Calculate the shift value based on the current character in the key\n                shift = ord(self.key[key_index % len(self.key)].lower()) - ord('a')\n\n                # Calculate the encrypted character and add it to the encrypted text\n                encrypted_char = chr((ord(char.lower()) - ord('a') + shift) % 26 + ord('a'))\n                encrypted_text += encrypted_char.upper() if char.isupper() else encrypted_char\n\n                # Increment the key index\n                key_index += 1\n            else:\n                # If the character is not a letter, add it to the encrypted text as is\n                encrypted_text += char\n\n        # Return the encrypted text\n        return encrypted_text\n\n    def rail_fence_cipher(self,plain_text, rails):\n        \"\"\"\n        Encrypts the plaintext using the Rail Fence cipher.\n        :param plaintext: The plaintext to encrypt, str.\n        :return: The ciphertext, str.\n        >>> e = EncryptionUtils(\"key\")\n        >>> e.rail_fence_cipher(\"abc\", 2)\n        'acb'\n\n        \"\"\"\n\n        # Initialize a 2D list (fence) with the same number of rows as rails and the same number of columns as the length of the plaintext\n        fence = [['\\n' for _ in range(len(plain_text))] for _ in range(rails)]\n\n        # Initialize variables for the direction of movement, and the current row and column\n        direction = -1\n        row, col = 0, 0\n\n        # Iterate over each character in the plaintext\n        for char in plain_text:\n            # Change the direction of movement when the top or bottom of the fence is reached\n            if row == 0 or row == rails-1:\n                direction = -direction\n\n            # Place the character in the current position of the fence\n            fence[row][col] = char\n\n            # Move to the next column and adjust the row based on the direction\n            col += 1\n            row += direction\n\n        # Initialize an empty string for the encrypted text\n        encrypted_text = ''\n\n        # Iterate over each row in the fence\n        for i in range(rails):\n            # Iterate over each column in the row\n            for j in range(len(plain_text)):\n                # If the position in the fence is not a newline character, add it to the encrypted text\n                if fence[i][j] != '\\n':\n                    encrypted_text += fence[i][j]\n\n        # Return the encrypted text\n        return encrypted_text"}, {"id": "38", "llm_annotated_code": "class ExcelProcessor:\n\n    \"\"\"\n    This is a class for processing excel files, including reading and writing excel data, as well as processing specific operations and saving as a new excel file.\n    \"\"\"\n\n    def __init__(self):\n        pass\n\n    def read_excel(self, file_name):\n        \"\"\"\n        Reading data from Excel files\n        :param file_name:str, Excel file name to read\n        :return:list of data, Data in Excel\n        \"\"\"\n\n        data = []\n        try:\n            # Load the workbook using openpyxl\n            workbook = openpyxl.load_workbook(file_name)\n            # Get the active sheet in the workbook\n            sheet = workbook.active\n            # Iterate over each row in the sheet and append it to the data list\n            for row in sheet.iter_rows(values_only=True):\n                data.append(row)\n            # Close the workbook\n            workbook.close()\n            # Return the data list\n            return data\n        except:\n            # If an error occurs, return None\n            return None\n\n\n    def write_excel(self, data, file_name):\n        \"\"\"\n        Write data to the specified Excel file\n        :param data: list, Data to be written\n        :param file_name: str, Excel file name to write to\n        :return: 0 or 1, 1 represents successful writing, 0 represents failed writing\n        \"\"\"\n\n        try:\n            # Create a new workbook using openpyxl\n            workbook = openpyxl.Workbook()\n            # Get the active sheet in the workbook\n            sheet = workbook.active\n            # Iterate over each row in the data list and append it to the sheet\n            for row in data:\n                sheet.append(row)\n            # Save the workbook with the specified file name\n            workbook.save(file_name)\n            # Close the workbook\n            workbook.close()\n            # Return 1 to indicate successful writing\n            return 1\n        except:\n            # If an error occurs, return 0 to indicate failed writing\n            return 0\n\n\n    def process_excel_data(self, N, save_file_name):\n        \"\"\"\n        Change the specified column in the Excel file to uppercase\n        :param N: int, The serial number of the column that want to change\n        :param save_file_name: str, source file name\n        :return:(int, str), The former is the return value of write_excel, while the latter is the saved file name of the processed data\n        \"\"\"\n\n        # Read the data from the specified Excel file\n        data = self.read_excel(save_file_name)\n        # If the data is None or N is greater than or equal to the number of columns in the data, return 0\n        if data is None or N >= len(data[0]):\n            return 0\n        \n        new_data = []\n        # Iterate over each row in the data\n        for row in data:\n            # Create a copy of the row\n            new_row = list(row[:])\n            # If the Nth element in the row is not a digit, convert it to uppercase and append it to the new row\n            if not str(row[N]).isdigit():\n                new_row.append(str(row[N]).upper())\n            # If the Nth element in the row is a digit, append it to the new row as is\n            else:\n                new_row.append(row[N])\n            # Append the new row to the new data list\n            new_data.append(new_row)\n        # Create a new file name by appending '_process.xlsx' to the original file name without the extension\n        new_file_name = save_file_name.split('.')[0] + '_process.xlsx'\n        # Write the new data to the new file and get the success status\n        success = self.write_excel(new_data, new_file_name)\n        # Return the success status and the new file name\n        return success, new_file_name"}, {"id": "39", "llm_annotated_code": "class ExpressionCalculator:\n\n    \"\"\"\n    This is a class in Python that can perform calculations with basic arithmetic operations, including addition, subtraction, multiplication, division, and modulo.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the expression calculator\n        \"\"\"\n        # Initialize a deque to hold the postfix expression\n        self.postfix_stack = deque()\n        # Define the priority of the operators\n        self.operat_priority = [0, 3, 2, 1, -1, 1, 0, 2]\n\n    def calculate(self, expression):\n        \"\"\"\n        Calculate the result of the given postfix expression\n        :param expression: string, the postfix expression to be calculated\n        :return: float, the calculated result\n        \"\"\"\n        # Prepare the postfix expression\n        self.prepare(self.transform(expression))\n        # Initialize a deque to hold the intermediate results\n        result_stack = deque()\n        # Reverse the postfix stack to make it easier to pop the elements\n        self.postfix_stack.reverse()\n\n        # Process each element in the postfix stack\n        while self.postfix_stack:\n            current_op = self.postfix_stack.pop()\n\n            # If the current element is not an operator, it's an operand\n            if not self.is_operator(current_op):\n                # Replace the unary minus sign with a negative sign\n                current_op = current_op.replace(\"~\", \"-\")\n                # Push the operand to the result stack\n                result_stack.append(current_op)\n            else:\n                # Pop two operands from the result stack\n                second_value = result_stack.pop()\n                first_value = result_stack.pop()\n\n                # Replace the unary minus sign with a negative sign\n                first_value = first_value.replace(\"~\", \"-\")\n                second_value = second_value.replace(\"~\", \"-\")\n\n                # Calculate the result of the operation and push it back to the result stack\n                temp_result = self._calculate(first_value, second_value, current_op)\n                result_stack.append(str(temp_result))\n\n        # The final result is the only element left in the result stack\n        return float(eval(\"*\".join(result_stack)))\n\n\n    def prepare(self, expression):\n        \"\"\"\n        Prepare the infix expression for conversion to postfix notation\n        :param expression: string, the infix expression to be prepared\n        \"\"\"\n\n        # Initialize a deque to hold the operators\n        op_stack = deque([','])\n        # Convert the expression to a list of characters\n        arr = list(expression)\n\n        # Initialize the current index and the count of consecutive operands\n        current_index = 0\n        count = 0\n\n        # Process each character in the expression\n        for i, current_op in enumerate(arr):\n\n            # If the current character is an operator\n            if self.is_operator(current_op):\n                # If there are consecutive operands before the operator, they form a number\n                if count > 0:\n                    # Push the number to the postfix stack\n                    self.postfix_stack.append(\"\".join(arr[current_index: current_index + count]))\n                \n                # Peek the operator at the top of the operator stack\n                peek_op = op_stack[-1]\n                # If the current operator is a right parenthesis\n                if current_op == ')':\n                    # Pop the operators from the operator stack and push them to the postfix stack until a left parenthesis is encountered\n                    while op_stack[-1] != '(':\n                        self.postfix_stack.append(str(op_stack.pop()))\n                    # Pop the left parenthesis from the operator stack\n                    op_stack.pop()\n                else:\n                    # While the current operator has lower precedence than the operator at the top of the operator stack\n                    while current_op != '(' and peek_op != ',' and self.compare(current_op, peek_op):\n                        # Pop the operator from the operator stack and push it to the postfix stack\n                        self.postfix_stack.append(str(op_stack.pop()))\n\n                        # Peek the operator at the top of the operator stack\n                        peek_op = op_stack[-1]\n                    \n                    # Push the current operator to the operator stack\n\n                    op_stack.append(current_op)\n\n                # Reset the count of consecutive operands and update the current index\n                count = 0\n                current_index = i + 1\n            else:\n                # If the current character is an operand, increment the count\n                count += 1\n\n        # If there are consecutive operands at the end of the expression, they form a number\n        if count > 1 or (count == 1 and not self.is_operator(arr[current_index])):\n            # Push the number to the postfix stack\n            self.postfix_stack.append(\"\".join(arr[current_index: current_index + count]))\n\n        # Pop the remaining operators from the operator stack and push them to the postfix stack\n        while op_stack[-1] != ',':\n            self.postfix_stack.append(str(op_stack.pop()))\n\n\n    @staticmethod\n    def is_operator(c):\n        \"\"\"\n        Check if a character is an operator in {'+', '-', '*', '/', '(', ')', '%'}\n        :param c: string, the character to be checked\n        :return: bool, True if the character is an operator, False otherwise\n        \"\"\"\n\n        # Return True if the character is in the set of operators, False otherwise\n        return c in {'+', '-', '*', '/', '(', ')', '%'}\n\n\n    def compare(self, cur, peek):\n        \"\"\"\n        Compare the precedence of two operators\n        :param cur: string, the current operator\n        :param peek: string, the operator at the top of the operator stack\n        :return: bool, True if the current operator has higher or equal precedence, False otherwise\n        \"\"\"\n\n        # Convert the modulo operator to the division operator for comparison\n        if cur == '%':\n            cur = '/'\n        if peek == '%':\n            peek = '/'\n        \n        # Return True if the current operator has lower or equal precedence than the operator at the top of the operator stack, False otherwise\n        return self.operat_priority[ord(peek) - 40] >= self.operat_priority[ord(cur) - 40]\n\n\n    @staticmethod\n    def _calculate(first_value, second_value, current_op):\n        \"\"\"\n        Perform the mathematical calculation based on the given operands and operator\n        :param first_value: string, the first operand\n        :param second_value: string, the second operand\n        :param current_op: string, the operator\n        :return: decimal.Decimal, the calculated result\n        \"\"\"\n\n        # Perform the operation based on the operator and return the result\n        if current_op == '+':\n            return Decimal(first_value) + Decimal(second_value)\n        elif current_op == '-':\n            return Decimal(first_value) - Decimal(second_value)\n        elif current_op == '*':\n            return Decimal(first_value) * Decimal(second_value)\n        elif current_op == '/':\n            return Decimal(first_value) / Decimal(second_value)\n        elif current_op == '%':\n            return Decimal(first_value) % Decimal(second_value)\n        else:\n            # Raise a ValueError if the operator is not recognized\n            raise ValueError(\"Unexpected operator: {}\".format(current_op))\n\n\n    @staticmethod\n    def transform(expression):\n        \"\"\"\n        Transform the infix expression to a format suitable for conversion\n        :param expression: string, the infix expression to be transformed\n        :return: string, the transformed expression\n        \"\"\"\n\n        # Remove all spaces from the expression\n        expression = re.sub(r\"\\s+\", \"\", expression)\n        # Remove the equal sign at the end of the expression if it exists\n        expression = re.sub(r\"=$\", \"\", expression)\n        # Convert the expression to a list of characters\n        arr = list(expression)\n\n        # Replace the unary minus sign with a tilde\n        for i, c in enumerate(arr):\n            if c == '-':\n                if i == 0:\n                    arr[i] = '~'\n                else:\n                    prev_c = arr[i - 1]\n                    if prev_c in {'+', '-', '*', '/', '(', 'E', 'e'}:\n                        arr[i] = '~'\n\n        # If the expression starts with a tilde followed by a left parenthesis, replace the tilde with a negative sign and prepend a zero to the expression\n        if arr[0] == '~' and (len(arr) > 1 and arr[1] == '('):\n            arr[0] = '-'\n            return \"0\" + \"\".join(arr)\n        else:\n            # Return the transformed expression as a string\n            return \"\".join(arr)"}, {"id": "40", "llm_annotated_code": "class FitnessTracker:\n\n    \"\"\"\n    This is a class as fitness tracker that implements to calculate BMI (Body Mass Index) and calorie intake based on the user's height, weight, age, and sex.\n    \"\"\"\n\n    def __init__(self, height, weight, age, sex) -> None:\n        \"\"\"\n        Initialize the class with height, weight, age, and sex, and calculate the BMI standard based on sex, and male is 20-25, female is 19-24.\n        \"\"\"\n        self.height = height  # User's height in meters\n        self.weight = weight  # User's weight in kilograms\n        self.age = age  # User's age in years\n        self.sex = sex  # User's sex, either \"male\" or \"female\"\n        \n        # BMI standards for males and females\n        self.BMI_std = [\n            {\"male\": [20, 25]},\n            {\"female\": [19, 24]}\n        ]\n\n    def get_BMI(self):\n        \"\"\"\n        Calculate the BMI based on the height and weight.\n        :return: BMI,which is the weight divide by the square of height, float.\n        \"\"\"\n\n        # Calculate BMI using the formula weight / (height^2)\n        return self.weight / self.height ** 2\n\n    def condition_judge(self):\n        \"\"\"\n        Judge the condition of the user based on the BMI standard.\n        :return: 1 if the user is too fat, -1 if the user is too thin, 0 if the user is normal, int.\n        \"\"\"\n\n        # Get the user's BMI\n        BMI = self.get_BMI()\n        \n        # Get the BMI range for the user's sex\n        if self.sex == \"male\":\n            BMI_range = self.BMI_std[0][\"male\"]\n        else:\n            BMI_range = self.BMI_std[1][\"female\"]\n        \n        # Return 1 if the user's BMI is above the range (too fat), -1 if it's below the range (too thin), or 0 if it's within the range (normal)\n        if BMI > BMI_range[1]:\n            return 1\n        elif BMI < BMI_range[0]:\n            return -1\n        else:\n            return 0\n\n    def calculate_calorie_intake(self):\n        \"\"\"\n        Calculate the calorie intake based on the user's condition and BMR (Basal Metabolic Rate),BMR is calculated based on the user's height, weight, age, and sex,male is10 * self.weight + 6.25 * self.height - 5 * self.age + 5,female is 10 * self.weight + 6.25 * self.height - 5 * self.age - 161, and the calorie intake is calculated based on the BMR and the user's condition,if the user is too fat, the calorie intake is BMR * 1.2, if the user is too thin, the calorie intake is BMR * 1.6, if the user is normal, the calorie intake is BMR * 1.4.\n        :return: calorie intake, float.\n        \"\"\"\n\n        # Calculate the user's Basal Metabolic Rate (BMR) based on their sex, height, weight, and age\n        if self.sex == \"male\":\n            BMR = 10 * self.weight + 6.25 * self.height - 5 * self.age + 5\n        else:\n            BMR = 10 * self.weight + 6.25 * self.height - 5 * self.age - 161\n\n        # Calculate the user's recommended calorie intake based on their BMR and condition\n        # If the user is too fat, they should have a sedentary lifestyle (BMR * 1.2)\n        # If the user is too thin, they should have an active lifestyle (BMR * 1.6)\n        # If the user is normal, they should have a moderate lifestyle (BMR * 1.4)\n        if self.condition_judge() == 1:\n            calorie_intake = BMR * 1.2\n        elif self.condition_judge() == -1:\n            calorie_intake = BMR * 1.6\n        else:\n            calorie_intake = BMR * 1.4\n            \n        return calorie_intake"}, {"id": "41", "llm_annotated_code": "class GomokuGame:\n\n    \"\"\"\n    This class is an implementation of a Gomoku game, supporting for making moves, checking for a winner, and checking if there are five consecutive symbols on the game board.\n    \"\"\"\n\n    def __init__(self, board_size):\n        \"\"\"\n        Initializes the game with a given board size.\n        It initializes the board with empty spaces and sets the current player symble as 'X'.\n        \"\"\"\n        # Set the board size\n        self.board_size = board_size\n        # Initialize the game board with empty spaces\n        self.board = [[' ' for _ in range(board_size)] for _ in range(board_size)]\n        # Set the current player to 'X'\n        self.current_player = 'X'\n\n    def make_move(self, row, col):\n        \"\"\"\n        Makes a move at the given row and column.\n        If the move is valid, it places the current player's symbol on the board\n        and changes the current player to the other player (if the current player is 'X', then it becomes 'O' and vice versa).\n        :param row: int, the row index of this move\n        :param col: int, the column index\n        return: True if the move is valid, or False otherwise.\n        \"\"\"\n\n        # Check if the cell at the given row and column is empty\n        if self.board[row][col] == ' ':\n            # If it is, place the current player's symbol on the board\n            self.board[row][col] = self.current_player\n            # Switch the current player to the other player\n            self.current_player = 'O' if self.current_player == 'X' else 'X'\n            # Return True to indicate that the move was valid\n            return True\n        # If the cell is not empty, return False to indicate that the move was invalid\n        return False\n\n    def check_winner(self):\n        \"\"\"\n        Checks if there is a winner by looking for five in a row in all directions (horizontal, vertical, diagonal).\n        return: the symbol of the winning player (either 'X' or 'O') if there is a winner, or None otherwise.\n        \"\"\"\n\n        # Define the four possible directions to check for five in a row\n        directions = [(0, 1), (1, 0), (1, 1), (1, -1)]\n        # Iterate over each cell in the board\n        for row in range(self.board_size):\n            for col in range(self.board_size):\n                # If the cell is not empty\n                if self.board[row][col] != ' ':\n                    # Check each direction for five in a row\n                    for direction in directions:\n                        # If five in a row is found, return the symbol of the winning player\n                        if self._check_five_in_a_row(row, col, direction):\n                            return self.board[row][col]\n        # If no winner is found, return None\n        return None\n\n    def _check_five_in_a_row(self, row, col, direction):\n        \"\"\"\n        checks if there are five consecutive symbols of the same player in a row starting from a given cell in a given direction (horizontal, vertical, diagonal).\n        Counts the number of consecutive symbols in that direction starting from the given cell,\n        :param row: int, row of the given cell\n        :param col: int, column of the given cell\n        :param direction: tuple, (int, int), named as (dx, dy). Row and col will plus several dx and dy repectively.\n        :return: True if there are five consecutive symbols of the same player, and False otherwise.\n        \"\"\"\n\n        # Extract the row and column increments from the direction tuple\n        dx, dy = direction\n        # Initialize the count of consecutive symbols to 1\n        count = 1\n        # Get the symbol at the given cell\n        symbol = self.board[row][col]\n        # Check the next four cells in the given direction\n        for i in range(1, 5):\n            # Calculate the row and column of the next cell\n            new_row = row + dx * i\n            new_col = col + dy * i\n            # If the next cell is outside the board, return False\n            if not (0 <= new_row < self.board_size and 0 <= new_col < self.board_size):\n                return False\n            # If the symbol in the next cell is not the same as the original symbol, return False\n            if self.board[new_row][new_col] != symbol:\n                return False\n            # Otherwise, increment the count of consecutive symbols\n            count += 1\n        # If there are five consecutive symbols, return True\n        return count == 5"}, {"id": "42", "llm_annotated_code": "class Hotel:\n\n    \"\"\"\n    This is a class as hotel management system, managing the booking, check-in, check-out, and availability of rooms in a hotel with different room types.\n    \"\"\"\n\n    def __init__(self, name, rooms):\n        \"\"\"\n        Initialize the three fields in Hotel System.\n        name is the hotel name.\n        available_rooms stores the remaining rooms in the hotel\n        booked_rooms stores the rooms that have been booked and the person's name who booked rooms.\n        >>> hotel.name\n        'peace hotel'\n        >>> hotel.available_rooms\n        available_rooms = {'single': 5, 'double': 3}\n        >>> hotel.booked_rooms\n        {'single': {'guest 1': 2, 'guest 2':1}, 'double': {'guest1': 1}}\n        \"\"\"\n\n        # Initialize the hotel name, available rooms, and booked rooms\n        self.name = name\n        self.available_rooms = rooms\n        self.booked_rooms = {}\n\n    def book_room(self, room_type, room_number, name):\n        \"\"\"\n        Check if there are any rooms of the specified type available.\n        if rooms are adequate, modify available_rooms and booked_rooms and finish booking, or fail to book otherwise.\n        :param room_type: str\n        :param room_number: int, the expected number of specified type rooms to be booked\n        :param name: str, guest name\n        :return: if number of rooms about to be booked doesn't exceed the remaining rooms, return str 'Success!'\n                if exceeds but quantity of available rooms is not equal to zero, return int(the remaining quantity of this room type).\n                if exceeds and quantity is zero or the room_type isn't in available_room, return False.\n        >>> hotel = Hotel('peace hotel', {'single': 5, 'double': 3})\n        >>> hotel.book_room('single', 1, 'guest 1')\n        'Success!'\n        >>> hotel.book_room('single', 5, 'guest 1')\n        4\n        >>> hotel.book_room('single', 4, 'guest 1')\n        'Success!'\n        >>> hotel.book_room('single', 1, 'guest 1')\n        False\n        >>> hotel.book_room('triple', 1, 'guest 1')\n        False\n        \"\"\"\n\n        # Check if the room type is available\n        if room_type not in self.available_rooms.keys():\n            return False\n\n        # Check if the number of rooms to be booked is less than or equal to the number of available rooms of that type\n        if room_number <= self.available_rooms[room_type]:\n\n            # If the room type is not already in the booked rooms, add it\n            if room_type not in self.booked_rooms.keys():\n                self.booked_rooms[room_type] = {}\n\n            # Add the booking to the booked rooms and update the number of available rooms\n            self.booked_rooms[room_type][name] = room_number\n            self.available_rooms[room_type] -= room_number\n            return \"Success!\"\n\n        # If the number of rooms to be booked is more than the number of available rooms but there are still some rooms available, return the number of available rooms\n        elif self.available_rooms[room_type] != 0:\n            return self.available_rooms[room_type]\n\n        # If the number of rooms to be booked is more than the number of available rooms and there are no rooms available, return False\n        else:\n            return False\n    \n    def check_in(self, room_type, room_number, name):\n        \"\"\"\n        Check if the room of the specified type and number is booked by the person named name.\n        Remove this name when check in successfuly(room_number is equal to specific person's booked_rooms. When the actual check in quantity (room_number) is less than the booked quantity, number in booked_rooms will be booked quantity minus actual quantity\n        :param room_type: str, check in room type\n        :param room_number: int, check in room number\n        :param name: str, person name\n        :return False: only if the room_type is not in the booked_rooms or room_number is higher than quantity in booked rooms.\n        >>> hotel = Hotel('peace hotel', {'single': 5, 'double': 3})\n        >>> hotel.book_room('single', 1, 'guest 1')\n        'Success!'\n        >>> hotel.check_in('single', 2, 'guest 1')\n        False\n        >>> hotel.check_in('single', 1, 'guest 1')\n        >>> hotel.booked_rooms\n        {'single': {}}\n        \"\"\"\n\n        # Check if the room type is in the booked rooms\n        if room_type not in self.booked_rooms.keys():\n            return False\n\n        # Check if the name is in the booked rooms of the room type\n        if name in self.booked_rooms[room_type]:\n\n            # If the number of rooms to check in is more than the number of booked rooms, return False\n            if room_number > self.booked_rooms[room_type][name]:\n                return False\n\n            # If the number of rooms to check in is equal to the number of booked rooms, remove the name from the booked rooms\n            elif room_number == self.booked_rooms[room_type][name]:\n                self.booked_rooms[room_type].pop(name)\n\n            # If the number of rooms to check in is less than the number of booked rooms, update the number of booked rooms\n            else:\n                self.booked_rooms[room_type][name] -= room_number\n\n    def check_out(self, room_type, room_number):\n        \"\"\"\n        Check out rooms, add number for specific type in available_rooms.\n        If room_type is new, add new type in available_rooms.\n        :param room_type: str, check out room type\n        :param room_number: int, check out room number\n        >>> hotel = Hotel('peace hotel', {'single': 5, 'double': 3})\n        >>> hotel.check_out('single', 2)\n        >>> hotel.available_rooms\n        {'single': 7, 'double': 3}\n        >>> hotel.check_out('triple', 2)\n        >>> hotel.available_rooms\n        {'single': 7, 'double': 3, 'triple': 2}\n        \"\"\"\n\n        # If the room type is in the available rooms, add the number of rooms to check out to the number of available rooms\n        if room_type in self.available_rooms:\n            self.available_rooms[room_type] += room_number\n\n        # If the room type is not in the available rooms, add it to the available rooms with the number of rooms to check out\n        else:\n            self.available_rooms[room_type] = room_number\n\n    def get_available_rooms(self, room_type):\n        \"\"\"\n        Get the number of specific type of available rooms.\n        :param room_type: str, the room type that want to know\n        :return: int, the remaining number of this type rooms.\n        >>> hotel = Hotel('peace hotel', {'single': 5, 'double': 3})\n        >>> hotel.get_available_rooms('single')\n        5\n        \"\"\"\n\n        # Return the number of available rooms of the room type\n        return self.available_rooms[room_type]"}, {"id": "43", "llm_annotated_code": "class HRManagementSystem:\n\n    \"\"\"\n    This is a class as personnel management system that implements functions such as adding, deleting, querying, and updating employees\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the HRManagementSystem with an attribute employees, which is an empty dictionary.\n        \"\"\"\n        # Initialize an empty dictionary to store employee data\n        self.employees = {}\n\n    def add_employee(self, employee_id, name, position, department, salary):\n        \"\"\"\n        Add a new employee to the HRManagementSystem.\n        :param employee_id: The employee's id, int.\n        :param name: The employee's name, str.\n        :param position: The employee's position, str.\n        :param department: The employee's department, str.\n        :param salary: The employee's salary, int.\n        :return: If the employee is already in the HRManagementSystem, returns False, otherwise, returns True.\n        \"\"\"\n\n        # Check if the employee_id already exists in the employees dictionary\n        if employee_id in self.employees:\n            return False\n        else:\n            # If not, add a new entry to the employees dictionary with the employee_id as the key and the rest of the parameters as the value\n            self.employees[employee_id] = {\n                'name': name,\n                'position': position,\n                'department': department,\n                'salary': salary\n            }\n            return True\n\n    def remove_employee(self, employee_id):\n        \"\"\"\n        Remove an employee from the HRManagementSystem.\n        :param employee_id: The employee's id, int.\n        :return: If the employee is already in the HRManagementSystem, returns True, otherwise, returns False.\n        \"\"\"\n\n        # Check if the employee_id exists in the employees dictionary\n        if employee_id in self.employees:\n            # If it does, remove the entry from the employees dictionary and return True\n            del self.employees[employee_id]\n            return True\n        else:\n            # If it doesn't, return False\n            return False\n\n    def update_employee(self, employee_id: int, employee_info: dict):\n        \"\"\"\n        Update an employee's information in the HRManagementSystem.\n        :param employee_id: The employee's id, int.\n        :param employee_info: The employee's information, dict.\n        :return: If the employee is already in the HRManagementSystem, returns True, otherwise, returns False.\n        \"\"\"\n\n        # Use the get_employee method to get the employee's current information\n        employee = self.get_employee(employee_id)\n        if employee == False:\n            # If the employee does not exist, return False\n            return False\n        else:\n            # If the employee exists, update the employee's information with the new information provided in employee_info\n            for key, value in employee_info.items():\n                if key not in employee:\n                    return False\n            for key, value in employee_info.items():\n                employee[key] = value\n            return True\n\n    def get_employee(self, employee_id):\n        \"\"\"\n        Get an employee's information from the HRManagementSystem.\n        :param employee_id: The employee's id, int.\n        :return: If the employee is already in the HRManagementSystem, returns the employee's information, otherwise, returns False.\n        \"\"\"\n\n        # Check if the employee_id exists in the employees dictionary\n        if employee_id in self.employees:\n            # If it does, return the employee's information\n            return self.employees[employee_id]\n        else:\n            # If it doesn't, return False\n            return False\n\n    def list_employees(self):\n        \"\"\"\n        List all employees' information in the HRManagementSystem.\n        :return: A list of all employees' information,dict.\n        \"\"\"\n\n        # Initialize an empty dictionary to store the employee data\n        employee_data = {}\n        if self.employees:\n            # If there are employees in the employees dictionary, iterate over each employee\n            for employee_id, employee_info in self.employees.items():\n                # For each employee, create a new dictionary to store their information\n                employee_details = {}\n                # Add the employee's ID to their information\n                employee_details[\"employee_ID\"] = employee_id\n                # Add the rest of the employee's information to their information\n                for key, value in employee_info.items():\n                    employee_details[key] = value\n                # Add the employee's information to the employee_data dictionary with their ID as the key\n                employee_data[employee_id] = employee_details\n        # Return the employee_data dictionary\n        return employee_data"}, {"id": "44", "llm_annotated_code": "class HtmlUtil:\n\n    \"\"\"\n    This is a class as util for HTML, supporting for formatting and extracting code from HTML text, including cleaning up the text and converting certain elements into specific marks.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize a series of labels\n        \"\"\"\n        # Define a series of labels to mark different types of text in the HTML\n        self.SPACE_MARK = '-SPACE-'\n        self.JSON_MARK = '-JSON-'\n        self.MARKUP_LANGUAGE_MARK = '-MARKUP_LANGUAGE-'\n        self.URL_MARK = '-URL-'\n        self.NUMBER_MARK = '-NUMBER-'\n        self.TRACE_MARK = '-TRACE-'\n        self.COMMAND_MARK = '-COMMAND-'\n        self.COMMENT_MARK = '-COMMENT-'\n        self.CODE_MARK = '-CODE-'\n\n    @staticmethod\n    def __format_line_feed(text):\n        \"\"\"\n        Replace consecutive line breaks with a single line break\n        :param text: string with consecutive line breaks\n        :return:string, replaced text with single line break\n        \"\"\"\n        # Use the re.sub function to replace consecutive line breaks with a single line break\n        return re.sub(re.compile(r'\\n+'), '\\n', text)\n\n    def format_line_html_text(self, html_text):\n        \"\"\"\n        get the html text without the code, and add the code tag -CODE- where the code is\n        :param html_text:string\n        :return:string\n        \"\"\"\n        # Check if the html_text is None or empty, if so, return an empty string\n        if html_text is None or len(html_text) == 0:\n            return ''\n        \n        # Use BeautifulSoup to parse the HTML text\n        soup = BeautifulSoup(html_text, 'lxml')\n        \n        # Find all the 'pre' and 'blockquote' tags which usually contain code\n        code_tag = soup.find_all(name=['pre', 'blockquote'])\n        \n        # Replace the text in these tags with the code mark\n        for tag in code_tag:\n            tag.string = self.CODE_MARK\n        \n        # Find all the 'ul' and 'ol' tags which usually contain lists\n        ul_ol_group = soup.find_all(name=['ul', 'ol'])\n        \n        # Format the text in these tags\n        for ul_ol_item in ul_ol_group:\n            li_group = ul_ol_item.find_all('li')\n            for li_item in li_group:\n                li_item_text = li_item.get_text().strip()\n                if len(li_item_text) == 0:\n                    continue\n                if li_item_text[-1] in string.punctuation:\n                    li_item.string = '[{0}]{1}'.format('-', li_item_text)\n                    continue\n                li_item.string = '[{0}]{1}.'.format('-', li_item_text)\n\n        # Find all the 'p' tags which usually contain paragraphs\n        p_group = soup.find_all(name=['p'])\n        \n        # Format the text in these tags\n        for p_item in p_group:\n            p_item_text = p_item.get_text().strip()\n            if p_item_text:\n                if p_item_text[-1] in string.punctuation:\n                    p_item.string = p_item_text\n                    continue\n                next_sibling = p_item.find_next_sibling()\n                if next_sibling and self.CODE_MARK in next_sibling.get_text():\n                    p_item.string = p_item_text + ':'\n                    continue\n                p_item.string = p_item_text + '.'\n\n        # Use gensim's decode_htmlentities function to convert HTML entities to their corresponding characters\n        clean_text = gensim.utils.decode_htmlentities(soup.get_text())\n        \n        # Return the formatted text\n        return self.__format_line_feed(clean_text)\n\n    def extract_code_from_html_text(self, html_text):\n        \"\"\"\n        extract codes from the html body\n        :param html_text: string, html text\n        :return: the list of code\n        \"\"\"\n        # Format the HTML text and get the text with code tags\n        text_with_code_tag = self.format_line_html_text(html_text)\n        \n        # If there are no code tags in the text, return an empty list\n        if self.CODE_MARK not in text_with_code_tag:\n            return []\n\n        # Use BeautifulSoup to parse the HTML text\n        soup = BeautifulSoup(html_text, 'lxml')\n        \n        # Find all the 'pre' and 'blockquote' tags which usually contain code\n        code_tag = soup.find_all(name=['pre', 'blockquote'])\n        \n        # Count the number of code tags in the text\n        code_count = text_with_code_tag.count(self.CODE_MARK)\n        \n        # Initialize an empty list to store the code\n        code_list = []\n\n        # Extract the code from each code tag and add it to the code list\n        for code_index in range(code_count):\n            code = code_tag[code_index].get_text()\n            if code:\n                code_list.append(code)\n        \n        # Return the list of code\n        return code_list"}, {"id": "45", "llm_annotated_code": "class ImageProcessor:\n\n    \"\"\"\n    This is a class to process image, including loading, saving, resizing, rotating, and adjusting the brightness of images.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize self.image\n        \"\"\"\n        # Initialize the image attribute to None\n        self.image = None\n\n    def load_image(self, image_path):\n        \"\"\"\n        Use Image util in PIL to open a image\n        :param image_path: str, path of image that is to be\n        >>> processor.load_image('test.jpg')\n        >>> processor.image\n        <PIL.JpegImagePlugin.JpegImageFile image mode=RGB size=3072x4096 at 0x194F2412A48>\n        \"\"\"\n\n        # Use the open method from the Image class in PIL to load the image from the provided path\n        # Store the loaded image in the image attribute\n        self.image = Image.open(image_path)\n\n    def save_image(self, save_path):\n        \"\"\"\n        Save image to a path if image has opened\n        :param save_path: str, the path that the image will be saved\n        >>> processor.load_image('test.jpg')\n        >>> processor.save_image('test2.jpg')\n        \"\"\"\n\n        # Check if an image has been loaded\n        if self.image:\n            # Use the save method of the Image class in PIL to save the image to the provided path\n            self.image.save(save_path)\n\n    def resize_image(self, width, height):\n        \"\"\"\n        Risize the image if image has opened.\n        :param width: int, the target width of image\n        :param height: int, the target height of image\n        >>> processor.load_image('test.jpg')\n        >>> processor.resize_image(300, 300)\n        >>> processor.image.width\n        300\n        >>> processor.image.height\n        300\n        \"\"\"\n\n        # Check if an image has been loaded\n        if self.image:\n            # Use the resize method of the Image class in PIL to resize the image to the provided dimensions\n            # Store the resized image in the image attribute\n            self.image = self.image.resize((width, height))\n\n    def rotate_image(self, degrees):\n        \"\"\"\n        rotate image if image has opened\n        :param degrees: float, the degrees that the image will be rotated\n        >>> processor.load_image('test.jpg')\n        >>> processor.resize_image(90)\n        \"\"\"\n\n        # Check if an image has been loaded\n        if self.image:\n            # Use the rotate method of the Image class in PIL to rotate the image by the provided degrees\n            # Store the rotated image in the image attribute\n            self.image = self.image.rotate(degrees)\n\n    def adjust_brightness(self, factor):\n        \"\"\"\n        Adjust the brightness of image if image has opened.\n        :param factor: float, brightness of an image. A factor of 0.0 gives a black image. A factor of 1.0 gives the original image.\n        >>> processor.load_image('test.jpg')\n        >>> processor.adjust_brightness(0.5)\n        \"\"\"\n\n        # Check if an image has been loaded\n        if self.image:\n            # Use the Brightness class from the ImageEnhance module in PIL to create a brightness enhancer for the image\n            enhancer = ImageEnhance.Brightness(self.image)\n            # Use the enhance method of the enhancer to adjust the brightness of the image by the provided factor\n            # Store the adjusted image in the image attribute\n            self.image = enhancer.enhance(factor)"}, {"id": "46", "llm_annotated_code": "class Interpolation:\n\n    \"\"\"\n    This is a class that implements the Linear interpolation operation of one-dimensional and two-dimensional data\n    \"\"\"\n\n    def __init__(self):\n        pass\n\n    @staticmethod\n    def interpolate_1d(x, y, x_interp):\n        \"\"\"\n        Linear interpolation of one-dimensional data\n        :param x: The x-coordinate of the data point, list.\n        :param y: The y-coordinate of the data point, list.\n        :param x_interp: The x-coordinate of the interpolation point, list.\n        :return: The y-coordinate of the interpolation point, list.\n        >>> interpolation = Interpolation()\n        >>> interpolation.interpolate_1d([1, 2, 3], [1, 2, 3], [1.5, 2.5])\n        [1.5, 2.5]\n\n        \"\"\"\n\n        # Initialize an empty list to store the interpolated y values\n        y_interp = []\n\n        # Iterate over each x value to be interpolated\n        for xi in x_interp:\n            # Iterate over each pair of x values in the original data\n            for i in range(len(x) - 1):\n                # If the x value to be interpolated is within the current pair of x values\n                if x[i] <= xi <= x[i+1]:\n                    # Calculate the corresponding y value using linear interpolation\n                    yi = y[i] + (y[i+1] - y[i]) * (xi - x[i]) / (x[i+1] - x[i])\n                    # Append the interpolated y value to the list\n                    y_interp.append(yi)\n                    # Break the loop as the interpolation for the current xi is done\n                    break\n        # Return the list of interpolated y values\n        return y_interp\n\n    @staticmethod\n    def interpolate_2d(x, y, z, x_interp, y_interp):\n        \"\"\"\n        Linear interpolation of two-dimensional data\n        :param x: The x-coordinate of the data point, list.\n        :param y: The y-coordinate of the data point, list.\n        :param z: The z-coordinate of the data point, list.\n        :param x_interp: The x-coordinate of the interpolation point, list.\n        :param y_interp: The y-coordinate of the interpolation point, list.\n        :return: The z-coordinate of the interpolation point, list.\n        >>> interpolation = Interpolation()\n        >>> interpolation.interpolate_2d([1, 2, 3], [1, 2, 3], [[1, 2, 3], [4, 5, 6], [7, 8, 9]], [1.5, 2.5], [1.5, 2.5])\n        [3.0, 7.0]\n\n        \"\"\"\n\n        # Initialize an empty list to store the interpolated z values\n        z_interp = []\n\n        # Iterate over each pair of x and y values to be interpolated\n        for xi, yi in zip(x_interp, y_interp):\n            # Iterate over each pair of x values in the original data\n            for i in range(len(x) - 1):\n                # If the x value to be interpolated is within the current pair of x values\n                if x[i] <= xi <= x[i+1]:\n                    # Iterate over each pair of y values in the original data\n                    for j in range(len(y) - 1):\n                        # If the y value to be interpolated is within the current pair of y values\n                        if y[j] <= yi <= y[j+1]:\n                            # Get the z values at the four corners of the current grid cell\n                            z00 = z[i][j]\n                            z01 = z[i][j+1]\n                            z10 = z[i+1][j]\n                            z11 = z[i+1][j+1]\n\n                            # Calculate the interpolated z value using bilinear interpolation\n                            zi = (z00 * (x[i+1] - xi) * (y[j+1] - yi) +\n                                  z10 * (xi - x[i]) * (y[j+1] - yi) +\n                                  z01 * (x[i+1] - xi) * (yi - y[j]) +\n                                  z11 * (xi - x[i]) * (yi - y[j])) / ((x[i+1] - x[i]) * (y[j+1] - y[j]))\n                            \n                            # Append the interpolated z value to the list\n                            z_interp.append(zi)\n                            # Break the loop as the interpolation for the current xi, yi is done\n                            break\n                    # Break the loop as the interpolation for the current xi is done\n                    break\n        # Return the list of interpolated z values\n        return z_interp"}, {"id": "47", "llm_annotated_code": "class IPAddress:\n\n    \"\"\"\n    This is a class to process IP Address, including validating, getting the octets and obtaining the binary representation of a valid IP address.\n    \"\"\"\n\n    def __init__(self, ip_address):\n        \"\"\"\n        Initialize the IP address to the specified address\n        :param ip_address:string\n        \"\"\"\n        # Store the provided IP address in the instance variable ip_address\n        self.ip_address = ip_address\n\n\n    def is_valid(self):\n        \"\"\"\n        Judge whether the IP address is valid, that is, whether the IP address is composed of four Decimal digits separated by '.'. Each digit is greater than or equal to 0 and less than or equal to 255\n        :return: bool\n        >>> ipaddress = IPAddress(\"10.10.10.10\")\n        >>> ipaddress.is_valid()\n        True\n        \"\"\"\n\n        # Split the IP address into octets using the '.' delimiter\n        octets = self.ip_address.split('.')\n        \n        # Check if the IP address has exactly 4 octets\n        if len(octets) != 4:\n            return False\n            \n        # Iterate over each octet\n        for octet in octets:\n            # Check if the octet is a digit and within the valid range of 0-255\n            if not octet.isdigit() or int(octet) < 0 or int(octet) > 255:\n                return False    \n                \n        # If all checks pass, return True indicating a valid IP address\n        return True\n\n\n    def get_octets(self):\n        \"\"\"\n        If the IP address is valid, the list of four decimal numbers separated by \".\" constituting the IP address is returned; otherwise, an empty list is returned\n        :return: list\n        >>> ipaddress = IPAddress(\"10.10.10.10\")\n        >>> ipaddress.get_octets()\n        [\"10\", \"10\", \"10\", \"10\"]\n        \"\"\"\n\n        # Check if the IP address is valid using the is_valid method\n        if self.is_valid():\n            # If valid, split the IP address into octets and return the list of octets\n            return self.ip_address.split('.')\n        else:\n            # If not valid, return an empty list\n            return []\n\n\n    def get_binary(self):\n        \"\"\"\n        If the IP address is valid, return the binary form of the IP address; otherwise, return ''\n        :return: string\n        >>> ipaddress = IPAddress(\"10.10.10.10\")\n        >>> ipaddress.get_binary()\n        \"00001010.00001010.00001010.00001010\"\n        \"\"\"\n\n        # Check if the IP address is valid using the is_valid method\n        if self.is_valid():\n            # If valid, convert each octet to binary and join them with '.' delimiter\n            binary_octets = []\n            for octet in self.get_octets():\n                binary_octets.append(format(int(octet), '08b'))\n            return '.'.join(binary_octets)\n        else:\n            # If not valid, return an empty string\n            return \"\""}, {"id": "48", "llm_annotated_code": "class IpUtil:\n\n    \"\"\"\n    This is a class as tool for ip that can be used to obtain the local IP address, validate its validity, and also provides the functionality to retrieve the corresponding hostname.\n    \"\"\"\n\n    @staticmethod\n    def is_valid_ipv4(ip_address):\n        \"\"\"\n        Check if the given IP address is a valid IPv4 address.\n        :param ip_address: string, the IP address to check\n        :return: bool, True if the IP address is valid, False otherwise\n        >>> IpUtil.is_valid_ipv4('192.168.0.123')\n        True\n        >>> IpUtil.is_valid_ipv4('256.0.0.0')\n        False\n\n        \"\"\"\n\n        try:\n            # Use the socket.inet_pton function to try to convert the IP address to a packed binary format\n            # If the conversion is successful, the IP address is valid and the function returns True\n            socket.inet_pton(socket.AF_INET, ip_address)\n            return True\n        except socket.error:\n            # If the conversion fails (a socket.error is raised), the IP address is not valid and the function returns False\n            return False\n\n    @staticmethod\n    def is_valid_ipv6(ip_address):\n        \"\"\"\n        Check if the given IP address is a valid IPv6 address.\n        :param ip_address:string, the IP address to check\n        :return:bool, True if the IP address is valid, False otherwise\n        >>> IpUtil.is_valid_ipv6('2001:0db8:85a3:0000:0000:8a2e:0370:7334')\n        True\n        >>> IpUtil.is_valid_ipv6('2001:0db8:85a3:::8a2e:0370:7334')\n        False\n\n        \"\"\"\n\n        try:\n            # Use the socket.inet_pton function to try to convert the IP address to a packed binary format\n            # If the conversion is successful, the IP address is valid and the function returns True\n            socket.inet_pton(socket.AF_INET6, ip_address)\n            return True\n        except socket.error:\n            # If the conversion fails (a socket.error is raised), the IP address is not valid and the function returns False\n            return False\n\n\n    @staticmethod\n    def get_hostname(ip_address):\n        \"\"\"\n        Get the hostname associated with the given IP address.\n        :param ip_address:string, the IP address to get the hostname for\n        :return: string, the hostname associated with the IP address\n        >>> IpUtil.get_hostname('110.242.68.3')\n        'www.baidu.com'\n        >>> IpUtil.get_hostname('10.0.0.1')\n\n        \"\"\"\n\n        try:\n            # Use the socket.gethostbyaddr function to try to get the hostname associated with the IP address\n            # If the lookup is successful, the function returns the hostname\n            hostname = socket.gethostbyaddr(ip_address)[0]\n            return hostname\n        except socket.herror:\n            # If the lookup fails (a socket.herror is raised), the function returns None\n            return None"}, {"id": "49", "llm_annotated_code": "class JobMarketplace:\n\n    \"\"\"\n    This is a class that provides functionalities to publish positions, remove positions, submit resumes, withdraw resumes, search for positions, and obtain candidate information.\n    \"\"\"\n\n    def __init__(self):\n        # Initialize two empty lists to store job listings and resumes\n        self.job_listings = []\n        self.resumes = []\n\n    def post_job(self, job_title, company, requirements):\n        \"\"\"\n        This function is used to publish positions,and add the position information to the job_listings list.\n        :param job_title: The title of the position,str.\n        :param company: The company of the position,str.\n        :param requirements: The requirements of the position,list.\n        :return: None\n        \"\"\"\n\n        # Create a dictionary to store the job details\n        job = {\"job_title\": job_title, \"company\": company, \"requirements\": requirements}\n        # Append the job dictionary to the job_listings list\n        self.job_listings.append(job)\n\n    def remove_job(self, job):\n        \"\"\"\n        This function is used to remove positions,and remove the position information from the job_listings list.\n        :param job: The position information to be removed,dict.\n        :return: None\n        \"\"\"\n\n        # Remove the job dictionary from the job_listings list\n        self.job_listings.remove(job)\n\n    def submit_resume(self, name, skills, experience):\n        \"\"\"\n        This function is used to submit resumes,and add the resume information to the resumes list.\n        :param name: The name of the resume,str.\n        :param skills: The skills of the resume,list.\n        :param experience: The experience of the resume,str.\n        :return: None\n        \"\"\"\n\n        # Create a dictionary to store the resume details\n        resume = {\"name\": name, \"skills\": skills, \"experience\": experience}\n        # Append the resume dictionary to the resumes list\n        self.resumes.append(resume)\n\n    def withdraw_resume(self, resume):\n        \"\"\"\n        This function is used to withdraw resumes,and remove the resume information from the resumes list.\n        :param resume: The resume information to be removed,dict.\n        :return: None\n        \"\"\"\n\n        # Remove the resume dictionary from the resumes list\n        self.resumes.remove(resume)\n\n    def search_jobs(self, criteria):\n        \"\"\"\n        This function is used to search for positions,and return the position information that meets the requirements.\n        :param criteria: The requirements of the position,str.\n        :return: The position information that meets the requirements,list.\n        \"\"\"\n\n        matching_jobs = []\n        # Iterate over each job in the job_listings list\n        for job_listing in self.job_listings:\n            # Check if the criteria is in the job title or requirements\n            if criteria.lower() in job_listing[\"job_title\"].lower() or criteria.lower() in [r.lower() for r in job_listing[\"requirements\"]]:\n                # If the criteria is found, append the job to the matching_jobs list\n                matching_jobs.append(job_listing)\n        # Return the list of matching jobs\n        return matching_jobs\n\n    @staticmethod\n    def matches_requirements(resume, requirements):\n        \"\"\"\n        This function is used to check whether all the skills in the provided resume exist in the provided requirements for a job.\n        :param resume: The resume information,dict.\n        :param requirements: The requirements of some position,str.\n        :return: Whether all the skills in the resume exists in the requirements,boolean.\n\n        \"\"\"\n\n        # Iterate over each skill in the resume\n        for skill in resume[\"skills\"]:\n            # If the skill is not in the job requirements, return False\n            if skill not in requirements:\n                return False\n        # If all skills are in the job requirements, return True\n        return True\n\n    def get_job_applicants(self, job):\n        \"\"\"\n        This function is used to obtain candidate information,and return the candidate information that meets the requirements by calling the matches_requirements function.\n        :param job: The position information,dict.\n        :return: The candidate information that meets the requirements,list.\n        \"\"\"\n\n        applicants = []\n        # Iterate over each resume in the resumes list\n        for resume in self.resumes:\n            # If the resume matches the job requirements, append the resume to the applicants list\n            if self.matches_requirements(resume, job[\"requirements\"]):\n                applicants.append(resume)\n        # Return the list of matching applicants\n        return applicants"}, {"id": "50", "llm_annotated_code": "class JSONProcessor:\n    \"\"\"\n    This is a class to process JSON file, including reading and writing JSON files, as well as processing JSON data by removing a specified key from the JSON object.\n    \"\"\"\n\n    def read_json(self, file_path):\n        \"\"\"\n        Read a JSON file and return the data.\n        :param file_path: str, the path of the JSON file.\n        :return: dict, the data from the JSON file if read successfully, or return -1 if an error occurs during the reading process.\n                    return 0 if the file does not exist.\n        >>> json.read_json('test.json')\n        {'name': 'test', 'age': 14}\n        \"\"\"\n\n        # Check if the file exists\n        if not os.path.exists(file_path):\n            return 0\n        try:\n            # Open the file in read mode\n            with open(file_path, 'r') as file:\n                # Load the JSON data from the file\n                data = json.load(file)\n            # Return the loaded data\n            return data\n        except:\n            # Return -1 if an error occurs\n            return -1\n\n    def write_json(self, data, file_path):\n        \"\"\"\n        Write data to a JSON file and save it to the given path.\n\n        :param data: dict, the data to be written to the JSON file.\n        :param file_path: str, the path of the JSON file.\n        :return: 1 if the writing process is successful, or -1, if an error occurs during the writing process.\n        >>> json.write_json({'key1': 'value1', 'key2': 'value2'}, 'test.json')\n        1\n        >>> json.read_json('test.json')\n        {'key1': 'value1', 'key2': 'value2'}\n        \"\"\"\n        try:\n            # Open the file in write mode\n            with open(file_path, 'w') as file:\n                # Dump the data to the file in JSON format\n                json.dump(data, file)\n            # Return 1 if the writing process is successful\n            return 1\n        except:\n            # Return -1 if an error occurs\n            return -1\n\n    def process_json(self, file_path, remove_key):\n        \"\"\"\n        read a JSON file and process the data by removing a specified key and rewrite the modified data back to the file.\n\n        :param file_path: str, the path of the JSON file.\n        :param remove_key: str, the key to be removed.\n        :return: 1, if the specified key is successfully removed and the data is written back.\n                    0, if the file does not exist or the specified key does not exist in the data.\n        >>> json.read_json('test.json')\n        {'key1': 'value1', 'key2': 'value2'}\n        >>> json.process_json('test.json', 'key1')\n        1\n        >>> json.read_json('test.json')\n        {'key2': 'value2'}\n        \"\"\"\n\n        # Read the JSON file\n        data = self.read_json(file_path)\n        # If the file does not exist or an error occurs during reading, return 0\n        if data == 0 or data == -1:\n            return 0\n        # If the specified key exists in the data\n        if remove_key in data:\n            # Remove the key from the data\n            del data[remove_key]\n            # Write the modified data back to the file\n            self.write_json(data, file_path)\n            # Return 1 if the process is successful\n            return 1\n        else:\n            # Return 0 if the specified key does not exist in the data\n            return 0"}, {"id": "51", "llm_annotated_code": "import numpy as np\n\nclass KappaCalculator:\n    \"\"\"\n    This is a class as KappaCalculator, supporting to calculate Cohen's and Fleiss' kappa coefficient.\n    \"\"\"\n\n    @staticmethod\n    def kappa(testData, k):\n        \"\"\"\n        Calculate the cohens kappa value of a k-dimensional matrix\n        :param testData: The k-dimensional matrix that needs to calculate the cohens kappa value\n        :param k: int, Matrix dimension\n        :return:float, the cohens kappa value of the matrix\n        >>> KappaCalculator.kappa([[2, 1, 1], [1, 2, 1], [1, 1, 2]], 3)\n        0.25\n        \"\"\"\n        # Convert the input testData to a numpy matrix\n        dataMat = np.mat(testData)\n        \n        # Initialize P0 as 0.0\n        P0 = 0.0\n        \n        # Calculate the sum of the diagonal elements of the matrix\n        for i in range(k):\n            P0 += dataMat[i, i] * 1.0\n        \n        # Calculate the sum of each row and each column of the matrix\n        xsum = np.sum(dataMat, axis=1)\n        ysum = np.sum(dataMat, axis=0)\n        \n        # Calculate the total sum of the matrix\n        sum = np.sum(dataMat)\n        \n        # Calculate the expected agreement Pe\n        Pe = float(ysum * xsum) / sum / sum\n        \n        # Calculate the observed agreement P0\n        P0 = float(P0 / sum * 1.0)\n        \n        # Calculate Cohen's kappa coefficient\n        cohens_coefficient = float((P0 - Pe) / (1 - Pe))\n        \n        # Return Cohen's kappa coefficient\n        return cohens_coefficient\n\n    @staticmethod\n    def fleiss_kappa(testData, N, k, n):\n        \"\"\"\n        Calculate the fliss kappa value of an N * k matrix\n        :param testData: Input data matrix, N * k\n        :param N: int, Number of samples\n        :param k: int, Number of categories\n        :param n: int, Number of raters\n        :return: float, fleiss kappa value\n        >>> KappaCalculator.fleiss_kappa([[0, 0, 0, 0, 14],\n        >>>                              [0, 2, 6, 4, 2],\n        >>>                              [0, 0, 3, 5, 6],\n        >>>                              [0, 3, 9, 2, 0],\n        >>>            [2, 2, 8, 1, 1],\n        >>>                              [7, 7, 0, 0, 0],\n        >>>                              [3, 2, 6, 3, 0],\n        >>>                              [2, 5, 3, 2, 2],\n        >>>                              [6, 5, 2, 1, 0],\n        >>>                 [0, 2, 2, 3, 7]], 10, 5, 14)\n        0.20993070442195522\n        \"\"\"\n        # Convert the input testData to a numpy matrix\n        dataMat = np.mat(testData, float)\n        \n        # Create a k-dimensional column vector of ones\n        oneMat = np.ones((k, 1))\n        \n        # Initialize sum and P0 as 0.0\n        sum = 0.0\n        P0 = 0.0\n        \n        # Calculate the sum of the squares of each element in the matrix, subtract n, divide by (n - 1) * n, and add to P0\n        for i in range(N):\n            temp = 0.0\n            for j in range(k):\n                sum += dataMat[i, j]\n                temp += 1.0 * dataMat[i, j] ** 2\n            temp -= n\n            temp /= (n - 1) * n\n            P0 += temp\n        \n        # Divide P0 by N\n        P0 = 1.0 * P0 / N\n        \n        # Calculate the sum of each column of the matrix\n        ysum = np.sum(dataMat, axis=0)\n        \n        # Square each element in ysum and divide by the total sum\n        for i in range(k):\n            ysum[0, i] = (ysum[0, i] / sum) ** 2\n        \n        # Calculate the expected agreement Pe\n        Pe = ysum * oneMat * 1.0\n        \n        # Calculate Fleiss' kappa coefficient\n        ans = (P0 - Pe) / (1 - Pe)\n        \n        # Return Fleiss' kappa coefficient\n        return ans[0, 0]"}, {"id": "52", "llm_annotated_code": "class Lemmatization:\n    \"\"\"\n    This is a class about Lemmatization, which utilizes the nltk library to perform lemmatization and part-of-speech tagging on sentences, as well as remove punctuation.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        creates a WordNetLemmatizer object and stores it in the self.lemmatizer member variable.\n        \"\"\"\n        # Instantiate a WordNetLemmatizer object and assign it to the instance variable self.lemmatizer\n        self.lemmatizer = WordNetLemmatizer()\n\n    def lemmatize_sentence(self, sentence):\n        \"\"\"\n        Remove punctuations of the sentence and tokenizes the input sentence, mark the part of speech tag of each word,\n        lemmatizes the words with different parameters based on their parts of speech, and stores in a list.\n        :param sentence: a sentence str\n        :return: a list of words which have been lemmatized.\n        >>> lemmatization = Lemmatization()\n        >>> lemmatization.lemmatize_sentence(\"I am running in a race.\")\n        ['I', 'be', 'run', 'in', 'a', 'race']\n\n        \"\"\"\n        # Initialize an empty list to store the lemmatized words\n        lemmatized_words = []\n\n        # Remove punctuation from the sentence using the remove_punctuation method\n        sentence = self.remove_punctuation(sentence)\n\n        # Tokenize the sentence into words using the word_tokenize function from nltk\n        words = word_tokenize(sentence)\n\n        # Get the part of speech tag for each word in the sentence using the pos_tag function from nltk\n        tagged_words = pos_tag(words)\n\n        # Iterate over each word and its corresponding part of speech tag\n        for word, tag in tagged_words:\n            # If the part of speech tag starts with 'V', lemmatize the word as a verb\n            if tag.startswith('V'):\n                lemmatized_word = self.lemmatizer.lemmatize(word, pos='v')\n            # If the part of speech tag starts with 'J', lemmatize the word as an adjective\n            elif tag.startswith('J'):\n                lemmatized_word = self.lemmatizer.lemmatize(word, pos='a')\n            # If the part of speech tag starts with 'R', lemmatize the word as an adverb\n            elif tag.startswith('R'):\n                lemmatized_word = self.lemmatizer.lemmatize(word, pos='r')\n            # Otherwise, lemmatize the word without specifying a part of speech\n            else:\n                lemmatized_word = self.lemmatizer.lemmatize(word)\n            # Append the lemmatized word to the list of lemmatized words\n            lemmatized_words.append(lemmatized_word)\n\n        # Return the list of lemmatized words\n        return lemmatized_words\n\n    def get_pos_tag(self, sentence):\n        \"\"\"\n        Remove punctuations of the sentence and tokenizes the input sentence, mark the part of speech tag of each word.\n        :param sentence: a sentence str\n        :return: list, part of speech tag of each word in the sentence.\n        >>> lemmatization = Lemmatization()\n        >>> lemmatization.get_pos_tag(\"I am running in a race.\")\n        ['PRP', 'VBP', 'VBG', 'IN', 'DT', 'NN']\n\n        \"\"\"\n        # Initialize an empty list to store the part of speech tags\n        pos_tags = []\n\n        # Remove punctuation from the sentence using the remove_punctuation method\n        sentence = self.remove_punctuation(sentence)\n\n        # Tokenize the sentence into words using the word_tokenize function from nltk\n        words = word_tokenize(sentence)\n\n        # Get the part of speech tag for each word in the sentence using the pos_tag function from nltk\n        tagged_words = pos_tag(words)\n\n        # Iterate over each word and its corresponding part of speech tag\n        for tagged_word in tagged_words:\n            # Append the part of speech tag to the list of part of speech tags\n            pos_tags.append(tagged_word[1])\n\n        # Return the list of part of speech tags\n        return pos_tags\n\n    def remove_punctuation(self, sentence):\n        \"\"\"\n        Removes punctuation from the input text.\n        :param sentence: a sentence str\n        :return: str, sentence without any punctuation\n        >>> lemmatization = Lemmatization()\n        >>> lemmatization.remove_punctuation(\"I am running in a race.\")\n        'I am running in a race'\n\n        \"\"\"\n        # Use the translate and maketrans methods from the string class to remove punctuation from the sentence\n        # The maketrans method creates a translation table that maps every character in the third argument (string.punctuation) to None\n        # The translate method then applies this table to the sentence\n        return sentence.translate(str.maketrans('', '', string.punctuation))"}, {"id": "53", "llm_annotated_code": "class LongestWord:\n    \"\"\"\n    This is a class allows to add words to a list and find the longest word in a given sentence by comparing the words with the ones in the word list.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize a list of word.\n        \"\"\"\n        # Initialize an empty list to store the words\n        self.word_list = []\n\n    def add_word(self, word):\n        \"\"\"\n        append the input word into self.word_list\n        :param word: str, input word\n        \"\"\"\n        # Append the input word to the word list\n        self.word_list.append(word)\n\n    def find_longest_word(self, sentence):\n        \"\"\"\n        Remove punctuation marks and split a sentence into a list of word. Find the longest splited word that is in the self.word_list.\n        Words are strictly case sensitive.\n        :param sentence: a sentence str\n        :return str: longest splited word that is in the self.word_list. return '' if self.word_list is empty.\n        >>> longestWord = LongestWord()\n        >>> longestWord.add_word('A')\n        >>> longestWord.add_word('aM')\n        >>> longestWord.find_longest_word('I am a student.')\n        'a'\n        \"\"\"\n        # Initialize an empty string to store the longest word\n        longest_word = \"\"\n\n        # Convert the sentence to lowercase\n        sentence = sentence.lower()\n\n        # Use the re.sub function to remove punctuation from the sentence\n        sentence = re.sub('[%s]' % re.escape(string.punctuation), '', sentence)\n\n        # Use the re.split function to split the sentence into a list of words\n        sentence = re.split(' ', sentence)\n\n        # Iterate through each word in the sentence\n        for word in sentence:\n            # If the word is in the word list and its length is greater than the length of the current longest word, update the longest word\n            if word in self.word_list and len(word) > len(longest_word):\n                longest_word = word\n\n        # Return the longest word\n        return longest_word"}, {"id": "54", "llm_annotated_code": "class MahjongConnect:\n    \"\"\"\n    MahjongConnect is a class representing a game board for Mahjong Connect with features like creating the board, checking valid moves, finding paths, removing icons, and checking if the game \nis over.\n    \"\"\"\n\n    def __init__(self, BOARD_SIZE, ICONS):\n        \"\"\"\n        Initialize the board size and the icon list, create the game board\n        :param BOARD_SIZE: list of two integer numbers, representing the number of rows and columns of the game board\n        :param ICONS: list of string, representing the icons\n        \"\"\"\n        # Store the board size and icons as class attributes\n        self.BOARD_SIZE = BOARD_SIZE\n        self.ICONS = ICONS\n\n        # Create the game board by calling the create_board method\n        self.board = self.create_board()\n\n    def create_board(self):\n        \"\"\"\n        Create the game board with the given board size and icons\n        :return: 2-dimensional list, the game board\n        \"\"\"\n        # Use list comprehension and the random.choice function to create a 2D list (game board) with random icons\n        board = [[random.choice(self.ICONS) for _ in range(self.BOARD_SIZE[1])] for _ in range(self.BOARD_SIZE[0])]\n        return board\n\n    def is_valid_move(self, pos1, pos2):\n        \"\"\"\n        Check if the move of two icons is valid (i.e. positions are within the game board range, the two positions are not the same, the two positions have the same icon, and there is a valid path between the two positions)\n        :param pos1: position tuple(x, y) of the first icon\n        :param pos2: position tuple(x, y) of the second icon\n        :return:True or False ,representing whether the move of two icons is valid\n        \"\"\"\n        x1, y1 = pos1\n        x2, y2 = pos2\n\n        # Check if positions are within the game board range\n        if not (0 <= x1 < self.BOARD_SIZE[0] and 0 <= y1 < self.BOARD_SIZE[1] and 0 <= x2 < self.BOARD_SIZE[\n            0] and 0 <= y2 < self.BOARD_SIZE[1]):\n            return False\n\n        # Check if the two positions are the same\n        if pos1 == pos2:\n            return False\n\n        # Check if the two positions have the same icon\n        if self.board[x1][y1] != self.board[x2][y2]:\n            return False\n\n        # Check if there is a valid path between the two positions by calling the has_path method\n        if not self.has_path(pos1, pos2):\n            return False\n\n        return True\n\n    def has_path(self, pos1, pos2):\n        \"\"\"\n        Check if there is a path between two icons\n        :param pos1: position tuple(x, y) of the first icon\n        :param pos2: position tuple(x, y) of the second icon\n        :return: True or False ,representing whether there is a path between two icons\n        \"\"\"\n        # Initialize a set to store visited positions and a list to store positions to visit (stack)\n        visited = set()\n        stack = [pos1]\n\n        # Use a while loop to visit all positions until the stack is empty\n        while stack:\n            current_pos = stack.pop()\n\n            # If the current position is the target position (pos2), return True\n            if current_pos == pos2:\n                return True\n\n            # If the current position has been visited, skip it\n            if current_pos in visited:\n                continue\n\n            # Mark the current position as visited\n            visited.add(current_pos)\n            x, y = current_pos\n\n            # Check adjacent positions (up, down, left, right)\n            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                new_x, new_y = x + dx, y + dy\n\n                # If the new position is within the game board and has the same icon as the current position, add it to the stack\n                if 0 <= new_x < self.BOARD_SIZE[0] and 0 <= new_y < self.BOARD_SIZE[1]:\n                    if (new_x, new_y) not in visited and self.board[new_x][new_y] == self.board[x][y]:\n                        stack.append((new_x, new_y))\n\n        # If no path is found, return False\n        return False\n\n    def remove_icons(self, pos1, pos2):\n        \"\"\"\n        Remove the connected icons on the game board\n        :param pos1: position tuple(x, y) of the first icon to be removed\n        :param pos2: position tuple(x, y) of the second icon to be removed\n        :return: None\n        \"\"\"\n        # Extract the x and y coordinates from pos1 and pos2\n        x1, y1 = pos1\n        x2, y2 = pos2\n\n        # Set the icons at pos1 and pos2 on the game board to ' ' (empty)\n        self.board[x1][y1] = ' '\n        self.board[x2][y2] = ' '\n\n    def is_game_over(self):\n        \"\"\"\n        Check if the game is over (i.e., if there are no more icons on the game board)\n        :return: True or False ,representing whether the game is over\n        \"\"\"\n        # Iterate through each row in the game board\n        for row in self.board:\n            # If any icon in the row is not empty, return False\n            if any(icon != ' ' for icon in row):\n                return False\n\n        # If all icons on the game board are empty, return True\n        return True"}, {"id": "55", "llm_annotated_code": "class Manacher:\n    \"\"\"\n    This is a class that implements a manacher algorithm to find the Longest palindromic substring in a given string.\n    \"\"\"\n\n    def __init__(self, input_string) -> None:\n        \"\"\"\n        Initializes the Manacher class with the given input_string.\n        :param input_string: The input_string to be searched, str.\n        \"\"\"\n        # Store the input string to be searched for palindromic substrings\n        self.input_string = input_string\n\n    def palindromic_length(self, center, diff, string):\n        \"\"\"\n        Recursively calculates the length of the palindromic substring based on a given center, difference value, and input string.\n        :param center: The center of the palindromic substring, int.\n        :param diff: The difference between the center and the current position, int.\n        :param string: The string to be searched, str.\n        :return: The length of the palindromic substring, int.\n        >>> manacher = Manacher('ababa')\n        >>> manacher.palindromic_length(2, 1, 'a|b|a|b|a')\n        2\n\n        \"\"\"\n        # Base case: if the center - diff is -1 or center + diff is the length of the string\n        # or the characters at the positions center - diff and center + diff are not the same, return 0\n        if (center - diff == -1 or center + diff == len(string)\n                or string[center - diff] != string[center + diff]):\n            return 0\n\n        # Recursive case: return 1 plus the result of the function called with center and diff incremented by 1\n        return 1 + self.palindromic_length(center, diff + 1, string)\n\n    def palindromic_string(self):\n        \"\"\"\n        Finds the longest palindromic substring in the given string.\n        :return: The longest palindromic substring, str.\n        >>> manacher = Manacher('ababaxse')\n        >>> manacher.palindromic_string()\n        'ababa'\n\n        \"\"\"\n        # Initialize max_length to 0\n        max_length = 0\n\n        # Initialize new_input_string and output_string to empty strings\n        new_input_string = \"\"\n        output_string = \"\"\n\n        # Add each character in the input string followed by a \"|\" to new_input_string\n        for i in self.input_string[:len(self.input_string) - 1]:\n            new_input_string += i + \"|\"\n        new_input_string += self.input_string[-1]\n\n        # Iterate through each character in new_input_string\n        for i in range(len(new_input_string)):\n\n            # Call the palindromic_length method with i as the center and 1 as the diff\n            length =self.palindromic_length(i, 1, new_input_string)\n\n            # If the returned length is greater than max_length, update max_length and start\n            if max_length < length:\n                max_length = length\n                start = i\n\n        # Iterate through the substring of new_input_string from start - max_length to start + max_length + 1\n        for i in new_input_string[start - max_length:start + max_length + 1]:\n            # If the character is not \"|\", add it to output_string\n            if i != \"|\":\n                output_string += i\n\n        # Return the longest palindromic substring\n        return output_string"}, {"id": "56", "llm_annotated_code": "class MetricsCalculator:\n    \"\"\"\n    The class calculates precision, recall, F1 score, and accuracy based on predicted and true labels.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the number of all four samples to 0\n        \"\"\"\n        # Initialize the counts of true positives, false positives, false negatives, and true negatives to 0\n        self.true_positives = 0\n        self.false_positives = 0\n        self.false_negatives = 0\n        self.true_negatives = 0\n\n\n    def update(self, predicted_labels, true_labels):\n        \"\"\"\n        Update the number of all four samples(true_positives, false_positives, false_negatives, true_negatives)\n        :param predicted_labels: list, predicted results\n        :param true_labels: list, true labels\n        :return: None, change the number of corresponding samples\n        \"\"\"\n        # Iterate over the predicted and true labels\n        for predicted, true in zip(predicted_labels, true_labels):\n            # Update the counts based on the comparison of predicted and true labels\n            if predicted == 1 and true == 1:\n                self.true_positives += 1\n            elif predicted == 1 and true == 0:\n                self.false_positives += 1\n            elif predicted == 0 and true == 1:\n                self.false_negatives += 1\n            elif predicted == 0 and true == 0:\n                self.true_negatives += 1\n\n\n    def precision(self, predicted_labels, true_labels):\n        \"\"\"\n        Calculate precision\n        :param predicted_labels: list, predicted results\n        :param true_labels: list, true labels\n        :return: float\n        \"\"\"\n        # Update the counts with the new predicted and true labels\n        self.update(predicted_labels, true_labels)\n        # If there are no true positives or false positives, return 0.0 to avoid division by zero\n        if self.true_positives + self.false_positives == 0:\n            return 0.0\n        # Calculate and return the precision\n        return self.true_positives / (self.true_positives + self.false_positives)\n\n\n    def recall(self, predicted_labels, true_labels):\n        \"\"\"\n        Calculate recall\n        :param predicted_labels: list, predicted results\n        :param true_labels: list, true labels\n        :return: float\n        \"\"\"\n        # Update the counts with the new predicted and true labels\n        self.update(predicted_labels, true_labels)\n        # If there are no true positives or false negatives, return 0.0 to avoid division by zero\n        if self.true_positives + self.false_negatives == 0:\n            return 0.0\n        # Calculate and return the recall\n        return self.true_positives / (self.true_positives + self.false_negatives)\n\n\n    def f1_score(self, predicted_labels, true_labels):\n        \"\"\"\n        Calculate f1 score, which is the harmonic mean of precision and recall\n        :param predicted_labels: list, predicted results\n        :param true_labels: list, true labels\n        :return: float\n        \"\"\"\n        # Update the counts with the new predicted and true labels\n        self.update(predicted_labels, true_labels)\n        # Calculate the precision and recall\n        precision = self.precision(predicted_labels, true_labels)\n        recall = self.recall(predicted_labels, true_labels)\n        # If both precision and recall are 0.0, return 0.0 to avoid division by zero\n        if precision + recall == 0.0:\n            return 0.0\n        # Calculate and return the F1 score\n        return (2 * precision * recall) / (precision + recall)\n\n\n    def accuracy(self, predicted_labels, true_labels):\n        \"\"\"\n        Calculate accuracy\n        :param predicted_labels: list, predicted results\n        :param true_labels: list, true labels\n        :return: float\n        \"\"\"\n        # Update the counts with the new predicted and true labels\n        self.update(predicted_labels, true_labels)\n        # Calculate the total number of samples\n        total = self.true_positives + self.true_negatives + self.false_positives + self.false_negatives\n        # If the total is 0, return 0.0 to avoid division by zero\n        if total == 0:\n            return 0.0\n        # Calculate and return the accuracy\n        return (self.true_positives + self.true_negatives) / total"}, {"id": "57", "llm_annotated_code": "import numpy as np\n\nclass MetricsCalculator2:\n    \"\"\"\n    The class provides to calculate Mean Reciprocal Rank (MRR) and Mean Average Precision (MAP) based on input data, where MRR measures the ranking quality and MAP measures the average precision.\n    \"\"\"\n\n    def __init__(self):\n        pass\n\n    @staticmethod\n    def mrr(data):\n        \"\"\"\n        Compute the MRR of the input data. MRR is a widely used evaluation index. It is the mean of reciprocal rank.\n        :param data: the data must be a tuple, list 0,1,eg.([1,0,...],5).  In each tuple (actual result,ground truth num),ground truth num is the total ground num.\n         ([1,0,...],5),\n        or list of tuple eg. [([1,0,1,...],5),([1,0,...],6),([0,0,...],5)].\n        1 stands for a correct answer, 0 stands for a wrong answer.\n        :return: if input data is list, return the recall of this list. if the input data is list of list, return the\n        average recall on all list. The second return value is a list of precision for each input.\n        >>> MetricsCalculator2.mrr(([1, 0, 1, 0], 4))\n        >>> MetricsCalculator2.mrr([([1, 0, 1, 0], 4), ([0, 1, 0, 1], 4)])\n        1.0, [1.0]\n        0.75, [1.0, 0.5]\n        \"\"\"\n        # Check if the input data is a list or a tuple, if not raise an exception\n        if type(data) != list and type(data) != tuple:\n            raise Exception(\"the input must be a tuple([0,...,1,...],int) or a iteration of list of tuple\")\n\n        # If the input data is empty, return 0.0 and a list containing 0.0\n        if len(data) == 0:\n            return 0.0, [0.0]\n\n        # If the input data is a tuple, calculate the MRR for the tuple\n        if type(data) == tuple:\n            # Unpack the tuple into a list of results and the total number of results\n            (sub_list, total_num) = data\n            # Convert the list of results to a numpy array\n            sub_list = np.array(sub_list)\n            # If the total number of results is 0, return 0.0 and a list containing 0.0\n            if total_num == 0:\n                return 0.0, [0.0]\n            else:\n                # Create a ranking array by dividing 1.0 by the index of each result plus 1\n                ranking_array = 1.0 / (np.array(list(range(len(sub_list)))) + 1)\n                # Multiply the list of results by the ranking array\n                mr_np = sub_list * ranking_array\n\n                # Initialize the mean reciprocal rank to 0.0\n                mr = 0.0\n                # Iterate over the multiplied results\n                for team in mr_np:\n                    # If the result is greater than 0, set the mean reciprocal rank to the result and break the loop\n                    if team > 0:\n                        mr = team\n                        break\n                # Return the mean reciprocal rank and a list containing the mean reciprocal rank\n                return mr, [mr]\n\n        # If the input data is a list, calculate the MRR for each tuple in the list\n        if type(data) == list:\n            # Initialize a list to store the MRR for each tuple\n            separate_result = []\n            # Iterate over the tuples in the list\n            for (sub_list, total_num) in data:\n                # Convert the list of results to a numpy array\n                sub_list = np.array(sub_list)\n\n                # If the total number of results is 0, set the mean reciprocal rank to 0.0\n                if total_num == 0:\n                    mr = 0.0\n                else:\n                    # Create a ranking array by dividing 1.0 by the index of each result plus 1\n                    ranking_array = 1.0 / (np.array(list(range(len(sub_list)))) + 1)\n                    # Multiply the list of results by the ranking array\n                    mr_np = sub_list * ranking_array\n\n                    # Initialize the mean reciprocal rank to 0.0\n                    mr = 0.0\n                    # Iterate over the multiplied results\n                    for team in mr_np:\n                        # If the result is greater than 0, set the mean reciprocal rank to the result and break the loop\n                        if team > 0:\n                            mr = team\n                            break\n\n                # Append the mean reciprocal rank to the list of results\n                separate_result.append(mr)\n            # Return the mean of the list of results and the list of results\n            return np.mean(separate_result), separate_result\n\n\n    @staticmethod\n    def map(data):\n        \"\"\"\n        Compute the MAP of the input data. MAP is a widely used evaluation index. It is the mean of AP (average precision).\n        :param data: the data must be a tuple, list 0,1,eg.([1,0,...],5).  In each tuple (actual result,ground truth num),ground truth num is the total ground num.\n         ([1,0,...],5),\n        or list of tuple eg. [([1,0,1,...],5),([1,0,...],6),([0,0,...],5)].\n        1 stands for a correct answer, 0 stands for a wrong answer.\n        :return: if input data is list, return the recall of this list. if the input data is list of list, return the\n        average recall on all list. The second return value is a list of precision for each input.\n        >>> MetricsCalculator2.map(([1, 0, 1, 0], 4))\n        >>> MetricsCalculator2.map([([1, 0, 1, 0], 4), ([0, 1, 0, 1], 4)])\n        0.41666666666666663, [0.41666666666666663]\n        0.3333333333333333, [0.41666666666666663, 0.25]\n        \"\"\"\n        # Check if the input data is a list or a tuple, if not raise an exception\n        if type(data) != list and type(data) != tuple:\n            raise Exception(\"the input must be a tuple([0,...,1,...],int) or a iteration of list of tuple\")\n\n        # If the input data is empty, return 0.0 and a list containing 0.0\n        if len(data) == 0:\n            return 0.0, [0.0]\n\n        # If the input data is a tuple, calculate the MAP for the tuple\n        if type(data) == tuple:\n            # Unpack the tuple into a list of results and the total number of results\n            (sub_list, total_num) = data\n            # Convert the list of results to a numpy array\n            sub_list = np.array(sub_list)\n            # If the total number of results is 0, return 0.0 and a list containing 0.0\n            if total_num == 0:\n                return 0.0, [0.0]\n            else:\n                # Create a ranking array by dividing 1.0 by the index of each result plus 1\n                ranking_array = 1.0 / (np.array(list(range(len(sub_list)))) + 1)\n\n                # Initialize a list to store the ranks of the correct answers\n                right_ranking_list = []\n                count = 1\n                # Iterate over the results\n                for t in sub_list:\n                    # If the result is 0, append 0 to the list of ranks\n                    if t == 0:\n                        right_ranking_list.append(0)\n                    # If the result is 1, append the current count to the list of ranks and increment the count\n                    else:\n                        right_ranking_list.append(count)\n                        count += 1\n\n                # Calculate the average precision by dividing the sum of the product of the list of ranks and the ranking array by the total number of results\n                ap = np.sum(np.array(right_ranking_list) * ranking_array) / total_num\n                # Return the average precision and a list containing the average precision\n                return ap, [ap]\n\n        # If the input data is a list, calculate the MAP for each tuple in the list\n        if type(data) == list:\n            # Initialize"}, {"id": "58", "llm_annotated_code": "class MinesweeperGame:\n    \"\"\"\n    This is a class that implements mine sweeping games including minesweeping and winning judgment.\n    \"\"\"\n\n    def __init__(self, n, k) -> None:\n        \"\"\"\n        Initializes the MinesweeperGame class with the size of the board and the number of mines.\n        :param n: The size of the board, int.\n        :param k: The number of mines, int.\n        \"\"\"\n\n        # Store the size of the board and the number of mines\n        self.n = n\n        self.k = k\n\n        # Generate the minesweeper map and the player map\n        self.minesweeper_map = self.generate_mine_sweeper_map()\n        self.player_map = self.generate_playerMap()\n\n        # Initialize the score to 0\n        self.score = 0\n\n    def generate_mine_sweeper_map(self):\n        \"\"\"\n        Generates a minesweeper map with the given size of the board and the number of mines,the given parameter n is the size of the board,the size of the board is n*n,the parameter k is the number of mines,'X' represents the mine,other numbers represent the number of mines around the position.\n        :return: The minesweeper map, list.\n        \"\"\"\n\n        # Initialize a 2D array with size n*n filled with 0s\n        arr = [[0 for row in range(self.n)] for column in range(self.n)]\n\n        # Place k mines randomly on the map\n        for num in range(self.k):\n            x = random.randint(0, self.n-1)\n            y = random.randint(0, self.n-1)\n            arr[y][x] = 'X'\n\n            # Update the numbers around the mine to represent the number of mines in the neighboring cells\n            # The numbers are updated for the eight cells surrounding the mine (top, bottom, left, right, and the four diagonals)\n            # The numbers are only updated if the cell is not a mine itself\n            if (x >=0 and x <= self.n-2) and (y >= 0 and y <= self.n-1):\n                if arr[y][x+1] != 'X':\n                    arr[y][x+1] += 1\n            if (x >=1 and x <= self.n-1) and (y >= 0 and y <= self.n-1):\n                if arr[y][x-1] != 'X':\n                    arr[y][x-1] += 1\n            if (x >= 1 and x <= self.n-1) and (y >= 1 and y <= self.n-1):\n                if arr[y-1][x-1] != 'X':\n                    arr[y-1][x-1] += 1\n            if (x >= 0 and x <= self.n-2) and (y >= 1 and y <= self.n-1):\n                if arr[y-1][x+1] != 'X':\n                    arr[y-1][x+1] += 1\n            if (x >= 0 and x <= self.n-1) and (y >= 1 and y <= self.n-1):\n                if arr[y-1][x] != 'X':\n                    arr[y-1][x] += 1\n            if (x >=0 and x <= self.n-2) and (y >= 0 and y <= self.n-2):\n                if arr[y+1][x+1] != 'X':\n                    arr[y+1][x+1] += 1\n            if (x >= 1 and x <= self.n-1) and (y >= 0 and y <= self.n-2):\n                if arr[y+1][x-1] != 'X':\n                    arr[y+1][x-1] += 1\n            if (x >= 0 and x <= self.n-1) and (y >= 0 and y <= self.n-2):\n                if arr[y+1][x] != 'X':\n                    arr[y+1][x] += 1\n\n        # Return the generated minesweeper map\n        return arr\n\n    def generate_playerMap(self):\n        \"\"\"\n        Generates a player map with the given size of the board, the given parameter n is the size of the board,the size of the board is n*n,the parameter k is the number of mines,'-' represents the unknown position.\n        :return: The player map, list.\n        \"\"\"\n\n        # Initialize a 2D array with size n*n filled with '-'\n        arr = [['-' for row in range(self.n)] for column in range(self.n)]\n\n        # Return the generated player map\n        return arr\n\n    def check_won(self,map):\n        \"\"\"\n        Checks whether the player has won the game,if there are just mines in the player map,return True,otherwise return False.\n        :return: True if the player has won the game, False otherwise.\n        \"\"\"\n\n        # Iterate through each cell in the player map\n        for i in range(self.n):\n            for j in range(self.n):\n                # If a cell in the player map is unknown ('-') and the corresponding cell in the minesweeper map is not a mine ('X'), return False\n                if map[i][j] == '-' and self.minesweeper_map[i][j] != 'X':\n                    return False\n\n        # If all cells in the player map are either known or mines, return True\n        return True\n\n    def sweep(self, x, y):\n        \"\"\"\n        Sweeps the given position.\n        :param x: The x coordinate of the position, int.\n        :param y: The y coordinate of the position, int.\n        :return: True if the player has won the game, False otherwise,if the game still continues, return the player map, list.\n        \"\"\"\n\n        # If the cell in the minesweeper map at the given position is a mine ('X'), return False\n        if (self.minesweeper_map[x][y] == 'X'):\n            return False\n        else:\n            # If the cell is not a mine, update the corresponding cell in the player map with the value from the minesweeper map\n            self.player_map[x][y] = self.minesweeper_map[x][y]\n\n            # Increase the score by 1\n            self.score += 1\n\n            # If the player has won the game (all non-mine cells are known), return True\n            if self.check_won(self.player_map) == True:\n                return True\n\n            # If the game is still ongoing, return the player map\n            return self.player_map"}, {"id": "59", "llm_annotated_code": "from datetime import datetime\nimport numpy as np\n\nclass MovieBookingSystem:\n    \"\"\"\n    This is a class for a movie booking system, which allows to add movies, book tickets and check the available movies within a given time range.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the movies attribute as an empty list. This list will store the information about movies.\n        \"\"\"\n        self.movies = []\n\n    def add_movie(self, name, price, start_time, end_time, n):\n        \"\"\"\n        Add a new movie into self.movies\n        :param name: str, movie name\n        :param price: float, price for one ticket\n        :param start_time: str, start time of the movie in HH:MM format\n        :param end_time: str, end time of the movie in HH:MM format\n        :param n: int, the size of seats(n*n)\n        \"\"\"\n        # Create a dictionary with movie details\n        # Convert start_time and end_time from string to datetime object\n        # Initialize seats as a 2D numpy array of zeros with shape (n, n)\n        movie = {\n            'name': name,\n            'price': price,\n            'start_time': datetime.strptime(start_time, '%H:%M'),\n            'end_time': datetime.strptime(end_time, '%H:%M'),\n            'seats': np.zeros((n, n))\n        }\n        # Append the movie dictionary to the movies list\n        self.movies.append(movie)\n\n    def book_ticket(self, name, seats_to_book):\n        \"\"\"\n        Book tickets for a movie. Change the seats value in self.movies if book successfully.\n        :param name: str, movie name\n        :param seats_to_book: list of tuples, representing seats to book [(row1, col1), (row2, col2), ...]\n        :return: str, booking status message. \"Movie not found.\" for no such movie.\n                \"Booking success.\" for successfully booking, or \"Booking failed.\" otherwise\n        \"\"\"\n        # Iterate over the movies list\n        for movie in self.movies:\n            # If the movie name matches the input name\n            if movie['name'] == name:\n                # Iterate over the seats to book\n                for seat in seats_to_book:\n                    # If the seat is available (value is 0), book it (change value to 1)\n                    if movie['seats'][seat[0]][seat[1]] == 0:\n                        movie['seats'][seat[0]][seat[1]] = 1\n                    else:\n                        # If the seat is not available, return \"Booking failed.\"\n                        return \"Booking failed.\"\n                # If all seats are successfully booked, return \"Booking success.\"\n                return \"Booking success.\"\n        # If no movie matches the input name, return \"Movie not found.\"\n        return \"Movie not found.\"\n\n    def available_movies(self, start_time, end_time):\n        \"\"\"\n        Get a list of available movies within the specified time range\n        :param start_time: str, start time in HH:MM format\n        :param end_time: str, end time in HH:MM format\n        :return: list of str, names of available movies\n        \"\"\"\n        # Convert start_time and end_time from string to datetime object\n        start_time = datetime.strptime(start_time, '%H:%M')\n        end_time = datetime.strptime(end_time, '%H:%M')\n\n        # Initialize an empty list to store the names of available movies\n        available_movies = []\n        # Iterate over the movies list\n        for movie in self.movies:\n            # If the movie start time is later than or equal to the input start time and the movie end time is earlier than or equal to the input end time\n            if start_time <= movie['start_time'] and movie['end_time'] <= end_time:\n                # Append the movie name to the available_movies list\n                available_movies.append(movie['name'])\n\n        # Return the list of available movies\n        return available_movies"}, {"id": "60", "llm_annotated_code": "import sqlite3\n\nclass MovieTicketDB:\n    \"\"\"\n    This is a class for movie database operations, which allows for inserting movie information, searching for movie information by name, and deleting movie information by name.\n    \"\"\"\n\n    def __init__(self, db_name):\n        \"\"\"\n        Initializes the MovieTicketDB object with the specified database name.\n        :param db_name: str, the name of the SQLite database.\n        \"\"\"\n        # Connect to the SQLite database with the provided database name\n        self.connection = sqlite3.connect(db_name)\n        \n        # Create a cursor object using the connection object\n        self.cursor = self.connection.cursor()\n        \n        # Call the create_table method to create the \"tickets\" table if it doesn't exist\n        self.create_table()\n\n\n    def create_table(self):\n        \"\"\"\n        Creates a \"tickets\" table in the database if it does not exist already.Fields include ID of type int, movie name of type str, theater name of type str, seat number of type str, and customer name of type str\n        :return: None\n        \"\"\"\n        # Execute a SQL command to create a table named \"tickets\" with the specified columns if it doesn't exist\n        self.cursor.execute(\"\"\"\n            CREATE TABLE IF NOT EXISTS tickets (\n                id INTEGER PRIMARY KEY,\n                movie_name TEXT,\n                theater_name TEXT,\n                seat_number TEXT,\n                customer_name TEXT\n            )\n        \"\"\")\n        \n        # Commit the changes to the database\n        self.connection.commit()\n\n    def insert_ticket(self, movie_name, theater_name, seat_number, customer_name):\n        \"\"\"\n        Inserts a new ticket into the \"tickets\" table.\n        :param movie_name: str, the name of the movie.\n        :param theater_name: str, the name of the theater.\n        :param seat_number: str, the seat number.\n        :param customer_name: str, the name of the customer.\n        :return: None\n        \"\"\"\n        # Execute a SQL command to insert a new row into the \"tickets\" table with the provided values\n        self.cursor.execute(\"\"\"\n            INSERT INTO tickets (movie_name, theater_name, seat_number, customer_name)\n            VALUES (?, ?, ?, ?)\n        \"\"\", (movie_name, theater_name, seat_number, customer_name))\n        \n        # Commit the changes to the database\n        self.connection.commit()\n\n    def search_tickets_by_customer(self, customer_name):\n        \"\"\"\n        Searches for tickets in the \"tickets\" table by customer name.\n        :param customer_name: str, the name of the customer to search for.\n        :return: list of tuples, the rows from the \"tickets\" table that match the search criteria.\n        >>> ticket_db = MovieTicketDB(\"ticket_database.db\")\n        >>> ticket_db.create_table()\n        >>> ticket_db.insert_ticket(\"Movie A\", \"Theater 1\", \"A1\", \"John Doe\")\n        >>> result = ticket_db.search_tickets_by_customer(\"John Doe\")\n        len(result) = 1\n        \"\"\"\n        # Execute a SQL command to select all rows from the \"tickets\" table where the customer_name matches the provided value\n        self.cursor.execute(\"\"\"\n            SELECT * FROM tickets WHERE customer_name = ?\n        \"\"\", (customer_name,))\n        \n        # Fetch all the rows from the result of the SQL command\n        tickets = self.cursor.fetchall()\n        \n        # Return the fetched rows\n        return tickets\n\n    def delete_ticket(self, ticket_id):\n        \"\"\"\n        Deletes a ticket from the \"tickets\" table by ticket ID.\n        :param ticket_id: int, the ID of the ticket to delete.\n        :return: None\n        \"\"\"\n        # Execute a SQL command to delete the row from the \"tickets\" table where the id matches the provided value\n        self.cursor.execute(\"\"\"\n            DELETE FROM tickets WHERE id = ?\n        \"\"\", (ticket_id,))\n        \n        # Commit the changes to the database\n        self.connection.commit()"}, {"id": "61", "llm_annotated_code": "class MusicPlayer:\n    \"\"\"\n    This is a class as a music player that provides to play, stop, add songs, remove songs, set volume, shuffle, and switch to the next or previous song.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initializes the music player with an empty playlist, no current song, and a default volume of 50.\n        \"\"\"\n        # Initialize an empty playlist\n        self.playlist = []\n        # Initialize no current song\n        self.current_song = None\n        # Initialize a default volume of 50\n        self.volume = 50\n\n    def add_song(self, song):\n        \"\"\"\n        Adds a song to the playlist.\n        :param song: The song to add to the playlist, str.\n        \"\"\"\n        # Append the song to the playlist\n        self.playlist.append(song)\n\n    def remove_song(self, song):\n        \"\"\"\n        Removes a song from the playlist.\n        :param song: The song to remove from the playlist, str.\n        \"\"\"\n        # Check if the song is in the playlist\n        if song in self.playlist:\n            # Remove the song from the playlist\n            self.playlist.remove(song)\n            # If the current song is the song to be removed, stop the song\n            if self.current_song == song:\n                self.stop()\n\n    def play(self):\n        \"\"\"\n        Plays the current song in the playlist.\n        :return: The current song in the playlist, or False if there is no current song.\n        \"\"\"\n        # If there is a playlist and a current song, return the first song in the playlist\n        if self.playlist and self.current_song:\n            return self.playlist[0]\n        # If there is no current song but there is a playlist, return False\n        elif len(self.playlist):\n            return False\n\n    def stop(self):\n        \"\"\"\n        Stops the current song in the playlist.\n        :return: True if the current song was stopped, False if there was no current song.\n        \"\"\"\n        # If there is a current song, stop the song and return True\n        if self.current_song:\n            self.current_song = None\n            return True\n        # If there is no current song, return False\n        else:\n            return False\n\n    def switch_song(self):\n        \"\"\"\n        Switches to the next song in the playlist.\n        :return: True if the next song was switched to, False if there was no next song.\n        \"\"\"\n        # If there is a current song, switch to the next song\n        if self.current_song:\n            # Get the index of the current song in the playlist\n            current_index = self.playlist.index(self.current_song)\n            # If the current song is not the last song in the playlist, switch to the next song and return True\n            if current_index < len(self.playlist) - 1:\n                self.current_song = self.playlist[current_index + 1]\n                return True\n            # If the current song is the last song in the playlist, return False\n            else:\n                return False\n        # If there is no current song, return False\n        else:\n            return False\n\n    def previous_song(self):\n        \"\"\"\n        Switches to the previous song in the playlist.\n        :return: True if the previous song was switched to, False if there was no previous song.\n        \"\"\"\n        # If there is a current song, switch to the previous song\n        if self.current_song:\n            # Get the index of the current song in the playlist\n            current_index = self.playlist.index(self.current_song)\n            # If the current song is not the first song in the playlist, switch to the previous song and return True\n            if current_index > 0:\n                self.current_song = self.playlist[current_index - 1]\n                return True\n            # If the current song is the first song in the playlist, return False\n            else:\n                return False\n        # If there is no current song, return False\n        else:\n            return False\n\n    def set_volume(self, volume):\n        \"\"\"\n        Sets the volume of the music player,ifthe volume is between 0 and 100 is valid.\n        :param volume: The volume to set the music player to,int.\n        :return: True if the volume was set, False if the volume was invalid.\n        \"\"\"\n        # If the volume is between 0 and 100, set the volume and return True\n        if 0 <= volume <= 100:\n            self.volume = volume\n        # If the volume is not between 0 and 100, return False\n        else:\n            return False\n\n    def shuffle(self):\n        \"\"\"\n        Shuffles the playlist.\n        :return: True if the playlist was shuffled, False if the playlist was empty.\n        \"\"\"\n        # If there is a playlist, shuffle the playlist and return True\n        if self.playlist:\n            import random\n            random.shuffle(self.playlist)\n            return True\n        # If the playlist is empty, return False\n        else:\n            return False"}, {"id": "62", "llm_annotated_code": "class NLPDataProcessor:\n    \"\"\"\n    The class processes NLP data by removing stop words from a list of strings using a pre-defined stop word list.\n    \"\"\"\n\n    def construct_stop_word_list(self):\n        \"\"\"\n        Construct a stop word list including 'a', 'an', 'the'.\n        :return: a list of stop words\n        >>> NLPDataProcessor.construct_stop_word_list()\n        ['a', 'an', 'the']\n        \"\"\"\n\n        # Define a list of stop words\n        stop_word_list = ['a', 'an', 'the']\n\n        # Return the list of stop words\n        return stop_word_list\n\n    def remove_stop_words(self, string_list, stop_word_list):\n        \"\"\"\n        Remove all the stop words from the list of strings.\n        :param string_list: a list of strings\n        :param stop_word_list: a list of stop words\n        :return: a list of words without stop words\n        >>> NLPDataProcessor.process(['This is a test.'])\n        [['This', 'is', 'test.']]\n        \"\"\"\n\n        # Initialize an empty list to store the processed strings\n        answer = []\n\n        # Iterate over each string in the input list\n        for string in string_list:\n\n            # Split the string into words\n            string_split = string.split()\n\n            # Iterate over each word in the split string\n            for word in string_split:\n\n                # If the word is in the stop word list, remove it from the split string\n                if word in stop_word_list:\n                    string_split.remove(word)\n\n            # Append the processed string to the answer list\n            answer.append(string_split)\n\n        # Return the list of processed strings\n        return answer\n\n    def process(self, string_list):\n        \"\"\"\n        Construct a stop word list including 'a', 'an', 'the', and remove all the stop words from the list of strings.\n        :param string_list: a list of strings\n        :return: a list of words without stop words\n        >>> NLPDataProcessor.process(['This is a test.'])\n        [['This', 'is', 'test.']]\n        \"\"\"\n\n        # Call the construct_stop_word_list method to get the list of stop words\n        stop_word_list = self.construct_stop_word_list()\n\n        # Call the remove_stop_words method to remove the stop words from the input list of strings\n        words_list = self.remove_stop_words(string_list, stop_word_list)\n\n        # Return the processed list of strings\n        return words_list"}, {"id": "63", "llm_annotated_code": "class NLPDataProcessor2:\n    \"\"\"\n    The class processes NLP data by extracting words from a list of strings, calculating the frequency of each word, and returning the top 5 most frequent words.\n    \"\"\"\n\n    def process_data(self, string_list):\n        \"\"\"\n        Keep only English letters and spaces in the string, then convert the string to lower case, and then split the string into a list of words.\n        :param string_list: a list of strings\n        :return: words_list: a list of words lists\n        >>> NLPDataProcessor.process_data(['This is a test.'])\n        [['this', 'is', 'a', 'test']]\n        \"\"\"\n        words_list = []\n        for string in string_list:\n            # Use the re.sub function to remove non-English letters and convert to lowercase\n            # The regular expression pattern r'[^a-zA-Z\\s]' matches any character that is not an English letter or a space\n            processed_string = re.sub(r'[^a-zA-Z\\s]', '', string.lower())\n            \n            # Split the processed string into words using the split method and append the list of words to words_list\n            words = processed_string.split()\n            words_list.append(words)\n        \n        # Return the list of words lists\n        return words_list\n\n    def calculate_word_frequency(self, words_list):\n        \"\"\"\n        Calculate the word frequency of each word in the list of words list, and sort the word frequency dictionary by value in descending order.\n        :param words_list: a list of words lists\n        :return: top 5 word frequency dictionary, a dictionary of word frequency, key is word, value is frequency\n        >>> NLPDataProcessor.calculate_word_frequency([['this', 'is', 'a', 'test'], ['this', 'is', 'another', 'test']])\n        {'this': 2, 'is': 2, 'test': 2, 'a': 1, 'another': 1}\n        \"\"\"\n        # Initialize a Counter object to count the frequency of each word\n        word_frequency = Counter()\n        \n        for words in words_list:\n            # Use the update method of the Counter object to count the frequency of each word in the list of words\n            word_frequency.update(words)\n        \n        # Sort the word frequency dictionary by value in descending order using the sorted function and a lambda function as the key argument\n        sorted_word_frequency = dict(sorted(word_frequency.items(), key=lambda x: x[1], reverse=True))\n        \n        # Get the top 5 most frequent words by slicing the sorted word frequency dictionary\n        top_5_word_frequency = dict(list(sorted_word_frequency.items())[:5])\n        \n        # Return the top 5 word frequency dictionary\n        return top_5_word_frequency\n\n    def process(self, string_list):\n        \"\"\"\n        Keep only English letters and spaces in the string, then convert the string to lower case, and then split the string into a list of words. Calculate the word frequency of each word in the list of words list, and sort the word frequency dictionary by value in descending order.\n        :param string_list: a list of strings\n        :return: top 5 word frequency dictionary, a dictionary of word frequency, key is word, value is frequency\n        >>> NLPDataProcessor.process(['This is a test.', 'This is another test.'])\n        {'this': 2, 'is': 2, 'test': 2, 'a': 1, 'another': 1}\n        \"\"\"\n        # Use the process_data method to process the string list into a list of words lists\n        words_list = self.process_data(string_list)\n        \n        # Use the calculate_word_frequency method to calculate the word frequency of each word in the list of words lists\n        word_frequency_dict = self.calculate_word_frequency(words_list)\n        \n        # Return the top 5 word frequency dictionary\n        return word_frequency_dict"}, {"id": "64", "llm_annotated_code": "class NumberConverter:\n    \"\"\"\n    The class allows to convert  decimal to binary, octal and hexadecimal repectively and contrarily\n    \"\"\"\n\n    @staticmethod\n    def decimal_to_binary(decimal_num):\n        \"\"\"\n        Convert a number from decimal format to binary format.\n        :param decimal_num: int, decimal number\n        :return: str, the binary representation of an integer.\n        >>> NumberConverter.decimal_to_binary(42423)\n        '1010010110110111'\n        \"\"\"\n\n        # Use the built-in bin function to convert the decimal number to binary\n        # The bin function returns a string in the format '0b...', so we slice it from the 3rd character to get the binary number\n        binary_num = bin(decimal_num)[2:]\n        return binary_num\n\n    @staticmethod\n    def binary_to_decimal(binary_num):\n        \"\"\"\n        Convert a number from binary format to decimal format.\n        :param binary_num: str, binary number\n        :return: int, the decimal representation of binary number str.\n        >>> NumberConverter.binary_to_decimal('1010010110110111')\n        42423\n        \"\"\"\n\n        # Use the built-in int function with base 2 to convert the binary number to decimal\n        decimal_num = int(binary_num, 2)\n        return decimal_num\n\n\n    @staticmethod\n    def decimal_to_octal(decimal_num):\n        \"\"\"\n        Convert a number from decimal format to octal format.\n        :param decimal_num: int, decimal number\n        :return: str, the octal representation of an integer.\n        >>> NumberConverter.decimal_to_octal(42423)\n        '122667'\n        \"\"\"\n\n        # Use the built-in oct function to convert the decimal number to octal\n        # The oct function returns a string in the format '0o...', so we slice it from the 3rd character to get the octal number\n        octal_num = oct(decimal_num)[2:]\n        return octal_num\n\n    @staticmethod\n    def octal_to_decimal(octal_num):\n        \"\"\"\n        Convert a number from octal format to decimal format.\n        :param octal_num: str, octal num\n        :return: int, the decimal representation of octal number str.\n        >>> NumberConverter.octal_to_decimal('122667')\n        42423\n        \"\"\"\n\n        # Use the built-in int function with base 8 to convert the octal number to decimal\n        decimal_num = int(octal_num, 8)\n        return decimal_num\n\n    @staticmethod\n    def decimal_to_hex(decimal_num):\n        \"\"\"\n        Convert a number from decimal format to hex format.\n        :param decimal_num: int, decimal number\n        :return hex_num: str, the hex representation of an integer.\n        >>> NumberConverter.decimal_to_hex(42423)\n        'a5b7'\n        \"\"\"\n\n        # Use the built-in hex function to convert the decimal number to hexadecimal\n        # The hex function returns a string in the format '0x...', so we slice it from the 3rd character to get the hexadecimal number\n        hex_num = hex(decimal_num)[2:]\n        return hex_num\n\n    @staticmethod\n    def hex_to_decimal(hex_num):\n        \"\"\"\n        Convert a number from hex format to decimal format.\n        :param hex_num: str, hex num\n        :return: int, the decimal representation of hex number str.\n        >>> NumberConverter.hex_to_decimal('a5b7')\n        42423\n        \"\"\"\n\n        # Use the built-in int function with base 16 to convert the hexadecimal number to decimal\n        decimal_num = int(hex_num, 16)\n        return decimal_num"}, {"id": "65", "llm_annotated_code": "class NumberWordFormatter:\n    \"\"\"\n    This is a class that provides to convert numbers into their corresponding English word representation, including handling the conversion of both the integer and decimal parts, and incorporating appropriate connectors and units.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize NumberWordFormatter object.\n        \"\"\"\n        # Define the string representation for numbers 1-9\n        self.NUMBER = [\"\", \"ONE\", \"TWO\", \"THREE\", \"FOUR\", \"FIVE\", \"SIX\", \"SEVEN\", \"EIGHT\", \"NINE\"]\n        \n        # Define the string representation for numbers 10-19\n        self.NUMBER_TEEN = [\"TEN\", \"ELEVEN\", \"TWELVE\", \"THIRTEEN\", \"FOURTEEN\", \"FIFTEEN\", \"SIXTEEN\", \"SEVENTEEN\",\n                            \"EIGHTEEN\", \"NINETEEN\"]\n        \n        # Define the string representation for multiples of 10 from 10 to 90\n        self.NUMBER_TEN = [\"TEN\", \"TWENTY\", \"THIRTY\", \"FORTY\", \"FIFTY\", \"SIXTY\", \"SEVENTY\", \"EIGHTY\", \"NINETY\"]\n        \n        # Define the string representation for thousands, millions, and billions\n        self.NUMBER_MORE = [\"\", \"THOUSAND\", \"MILLION\", \"BILLION\"]\n        \n        # Define the string representation for suffixes of large numbers\n        self.NUMBER_SUFFIX = [\"k\", \"w\", \"\", \"m\", \"\", \"\", \"b\", \"\", \"\", \"t\", \"\", \"\", \"p\", \"\", \"\", \"e\"]\n\n    def format(self, x):\n        \"\"\"\n        Converts a number into words format\n        :param x: int or float, the number to be converted into words format\n        :return: str, the number in words format\n        \"\"\"\n        # If x is not None, convert x to string and pass it to the format_string method\n        # If x is None, return an empty string\n        if x is not None:\n            return self.format_string(str(x))\n        else:\n            return \"\"\n\n\n    def format_string(self, x):\n        \"\"\"\n        Converts a string representation of a number into words format\n        :param x: str, the string representation of a number\n        :return: str, the number in words format\n        \"\"\"\n        # Split the string x into integer part and decimal part\n        # If there is no decimal part, set rstr to an empty string\n        lstr, rstr = (x.split('.') + [''])[:2]\n        \n        # Reverse the string of the integer part\n        lstrrev = lstr[::-1]\n        \n        # Initialize an empty list a with 5 elements\n        a = [''] * 5\n\n        # If the length of the reversed integer part is not a multiple of 3, append zeros to make it a multiple of 3\n        if len(lstrrev) % 3 == 1:\n            lstrrev += \"00\"\n        elif len(lstrrev) % 3 == 2:\n            lstrrev += \"0\"\n\n        # Initialize an empty string lm\n        lm = \"\"\n        \n        # For each group of 3 digits in the reversed integer part\n        for i in range(len(lstrrev) // 3):\n            # Reverse the group of 3 digits and store it in a\n            a[i] = lstrrev[3 * i:3 * i + 3][::-1]\n            \n            # If the group of 3 digits is not \"000\"\n            if a[i] != \"000\":\n                # Convert the group of 3 digits to words, append the corresponding suffix, and append it to lm\n                lm = self.trans_three(a[i]) + \" \" + self.parse_more(i) + \" \" + lm\n            else:\n                # If the group of 3 digits is \"000\", append it to lm\n                lm += self.trans_three(a[i])\n\n        # If there is a decimal part, convert it to words and append it to xs\n        # If there is no decimal part, set xs to an empty string\n        xs = f\"AND CENTS {self.trans_two(rstr)} \" if rstr else \"\"\n        \n        # If lm is an empty string, return \"ZERO ONLY\"\n        # Otherwise, return the words representation of the number\n        if not lm.strip():\n            return \"ZERO ONLY\"\n        else:\n            return f\"{lm.strip()} {xs}ONLY\"\n\n\n    def trans_two(self, s):\n        \"\"\"\n        Converts a two-digit number into words format\n        :param s: str, the two-digit number\n        :return: str, the number in words format\n        \"\"\"\n        # Pad s with a leading zero to make it a two-digit number\n        s = s.zfill(2)\n        \n        # If the first digit is 0, return the words representation of the second digit\n        if s[0] == \"0\":\n            return self.NUMBER[int(s[-1])]\n        \n        # If the first digit is 1, return the words representation of the number from 10 to 19\n        elif s[0] == \"1\":\n            return self.NUMBER_TEEN[int(s) - 10]\n        \n        # If the second digit is 0, return the words representation of the multiple of 10\n        elif s[1] == \"0\":\n            return self.NUMBER_TEN[int(s[0]) - 1]\n        \n        # Otherwise, return the words representation of the multiple of 10 and the second digit\n        else:\n            return self.NUMBER_TEN[int(s[0]) - 1] + \" \" + self.NUMBER[int(s[-1])]\n\n\n    def trans_three(self, s):\n        \"\"\"\n        Converts a three-digit number into words format\n        :param s: str, the three-digit number\n        :return: str, the number in words format\n        \"\"\"\n        # If the first digit is 0, return the words representation of the last two digits\n        if s[0] == \"0\":\n            return self.trans_two(s[1:])\n        \n        # If the last two digits are \"00\", return the words representation of the first digit followed by \"HUNDRED\"\n        elif s[1:] == \"00\":\n            return f\"{self.NUMBER[int(s[0])]} HUNDRED\"\n        \n        # Otherwise, return the words representation of the first digit followed by \"HUNDRED AND\" and the words representation of the last two digits\n        else:\n            return f\"{self.NUMBER[int(s[0])]} HUNDRED AND {self.trans_two(s[1:])}\"\n\n    def parse_more(self, i):\n        \"\"\"\n        Parses the thousand/million/billion suffix based on the index\n        :param i: int, the index representing the magnitude (thousand, million, billion)\n        :return: str, the corresponding suffix for the magnitude\n        \"\"\"\n        # Return the words representation of the thousand/million/billion suffix based on the index i\n        return self.NUMBER_MORE[i]"}, {"id": "66", "llm_annotated_code": "class NumericEntityUnescaper:\n    \"\"\"\n    This is a class that provides functionality to replace numeric entities with their corresponding characters in a given string.\n    \"\"\"\n\n    def __init__(self):\n        pass\n\n    def replace(self, string):\n        \"\"\"\n        Replaces numeric character references (HTML entities) in the input string with their corresponding Unicode characters.\n        :param string: str, the input string containing numeric character references.\n        :return: str, the input string with numeric character references replaced with their corresponding Unicode characters.\n        >>> unescaper = NumericEntityUnescaper()\n        >>> unescaper.replace(\"&#65;&#66;&#67;\")\n        'ABC'\n\n        \"\"\"\n        # Initialize an empty list to store the output characters\n        out = []\n        # Initialize the position to start from\n        pos = 0\n        # Get the length of the input string\n        length = len(string)\n\n        # Loop through the string until the second last character\n        while pos < length - 2:\n            # If the current character and the next one form the start of a numeric entity\n            if string[pos] == '&' and string[pos + 1] == '#':\n                # The start of the numeric entity (excluding the '&' and '#')\n                start = pos + 2\n                # Flag to indicate if the numeric entity is in hexadecimal form\n                is_hex = False\n                # The first character of the numeric entity\n                first_char = string[start]\n\n                # If the numeric entity is in hexadecimal form\n                if first_char == 'x' or first_char == 'X':\n                    # Skip the 'x' or 'X'\n                    start += 1\n                    # Set the flag to True\n                    is_hex = True\n\n                # If we've reached the end of the string, return the output so far\n                if start == length:\n                    return ''.join(out)\n\n                # Find the end of the numeric entity\n                end = start\n                while end < length and self.is_hex_char(string[end]):\n                    end += 1\n\n                # If the numeric entity is properly terminated with a semicolon\n                if end < length and string[end] == ';':\n                    try:\n                        # Convert the numeric entity to an integer\n                        entity_value = int(string[start:end], 16 if is_hex else 10)\n                    except:\n                        # If the conversion fails, return the output so far\n                        return ''.join(out)\n\n                    # Append the corresponding Unicode character to the output\n                    out.append(chr(entity_value))\n                    # Move the position to the character after the semicolon\n                    pos = end + 1\n                    # Skip the rest of the loop\n                    continue\n\n            # If the current character is not part of a numeric entity, append it to the output\n            out.append(string[pos])\n            # Move to the next character\n            pos += 1\n\n        # Return the output as a string\n        return ''.join(out)\n\n\n    @staticmethod\n    def is_hex_char(char):\n        \"\"\"\n        Determines whether a given character is a hexadecimal digit.\n        :param char: str, the character to check.\n        :return: bool, True if the character is a hexadecimal digit, False otherwise.\n        >>> NumericEntityUnescaper.is_hex_char('a')\n        True\n\n        \"\"\"\n        # Return True if the character is a digit or a lowercase or uppercase letter from 'a' to 'f'\n        # Return False otherwise\n        return char.isdigit() or ('a' <= char.lower() <= 'f')"}, {"id": "67", "llm_annotated_code": "class Order:\n    \"\"\"\n    The class manages restaurant orders by allowing the addition of dishes, calculation of the total cost, and checkout.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the order management system\n        self.menu stores the dishes of restaurant inventory\n        menu = [{\"dish\": dish name, \"price\": price, \"count\": count}, ...]\n        self.selected_dishes stores the dishes selected by customer\n        selected_dish = {\"dish\": dish name, \"count\": count, price: price}\n        self.sales stores the sales of each dish\n        sales = {dish name: sales}\n        \"\"\"\n        self.menu = []  # List to store the menu items\n        self.selected_dishes = []  # List to store the selected dishes\n        self.sales = {}  # Dictionary to store the sales of each dish\n\n    def add_dish(self, dish):\n        \"\"\"\n        Check the self.menu and add into self.selected_dish if the dish count is valid.\n        And if the dish has successfully been added, change the count in self.menu.\n        :param dish: dict, the information of dish. dish = {\"dish\": dish name, \"count\": count, price: price}\n        :return: True if successfully added, or False otherwise.\n        \"\"\"\n        # Iterate over the menu items\n        for menu_dish in self.menu:\n            # If the dish is in the menu\n            if dish[\"dish\"] == menu_dish[\"dish\"]:\n                # If the count of the dish in the menu is less than the count of the dish to be added, return False\n                if menu_dish[\"count\"] < dish[\"count\"]:\n                    return False\n                else:\n                    # Otherwise, subtract the count of the dish to be added from the count of the dish in the menu\n                    menu_dish[\"count\"] -= dish[\"count\"]\n                    break\n        # Add the dish to the selected dishes\n        self.selected_dishes.append(dish)\n        return True\n\n    def calculate_total(self):\n        \"\"\"\n        Calculate the total price of dishes that have been ordered. Multiply the count, price and sales.\n        :return total: float, the final total price.\n        \"\"\"\n        total = 0  # Initialize the total price\n        # Iterate over the selected dishes\n        for dish in self.selected_dishes:\n            # Add the product of the price, count, and sales of the dish to the total price\n            total += dish[\"price\"] * dish[\"count\"] * self.sales[dish[\"dish\"]]\n        return total  # Return the total price\n\n    def checkout(self):\n        \"\"\"\n        Check out the dishes ordered. If the self.selected_dishes is not empty, invoke the calculate_total\n        method to check out.\n        :return False if the self.selected_dishes is empty, or total(return value of calculate_total) otherwise.\n        \"\"\"\n        # If there are no selected dishes, return False\n        if len(self.selected_dishes) == 0:\n            return False\n        # Otherwise, calculate the total price\n        total = self.calculate_total()\n        # Clear the selected dishes\n        self.selected_dishes = []\n        # Return the total price\n        return total"}, {"id": "68", "llm_annotated_code": "class PageUtil:\n    \"\"\"\n    PageUtil class is a versatile utility for handling pagination and search functionalities in an efficient and convenient manner.\n    \"\"\"\n\n    def __init__(self, data, page_size):\n        \"\"\"\n        Initialize the PageUtil object with the given data and page size.\n        :param data: list, the data to be paginated\n        :param page_size: int, the number of items per page\n        \"\"\"\n        # Store the input data and page size as instance variables\n        self.data = data\n        self.page_size = page_size\n\n        # Calculate the total number of items and pages based on the input data and page size\n        self.total_items = len(data)\n        self.total_pages = (self.total_items + page_size - 1) // page_size\n\n    def get_page(self, page_number):\n        \"\"\"\n        Retrieve a specific page of data.\n        :param page_number: int, the page number to fetch\n        :return: list, the data on the specified page\n        \"\"\"\n        # If the page number is out of range, return an empty list\n        if page_number < 1 or page_number > self.total_pages:\n            return []\n\n        # Calculate the start and end indices of the data for the specified page\n        start_index = (page_number - 1) * self.page_size\n        end_index = start_index + self.page_size\n\n        # Return the data for the specified page\n        return self.data[start_index:end_index]\n\n    def get_page_info(self, page_number):\n        \"\"\"\n        Retrieve information about a specific page.\n        :param page_number: int, the page number to fetch information about\n        :return: dict, containing page information such as current page number, total pages, etc.\n        \"\"\"\n        # If the page number is out of range, return an empty dictionary\n        if page_number < 1 or page_number > self.total_pages:\n            return {}\n\n        # Calculate the start and end indices of the data for the specified page\n        start_index = (page_number - 1) * self.page_size\n        end_index = min(start_index + self.page_size, self.total_items)\n\n        # Retrieve the data for the specified page\n        page_data = self.data[start_index:end_index]\n\n        # Construct a dictionary containing information about the specified page\n        page_info = {\n            \"current_page\": page_number,\n            \"per_page\": self.page_size,\n            \"total_pages\": self.total_pages,\n            \"total_items\": self.total_items,\n            \"has_previous\": page_number > 1,\n            \"has_next\": page_number < self.total_pages,\n            \"data\": page_data\n        }\n\n        # Return the page information\n        return page_info\n\n    def search(self, keyword):\n        \"\"\"\n        Search for items in the data that contain the given keyword.\n        :param keyword: str, the keyword to search for\n        :return: dict, containing search information such as total results and matching items\n        \"\"\"\n        # Use a list comprehension to find all items in the data that contain the keyword\n        results = [item for item in self.data if keyword in str(item)]\n\n        # Calculate the number of results and pages based on the search results and page size\n        num_results = len(results)\n        num_pages = (num_results + self.page_size - 1) // self.page_size\n\n        # Construct a dictionary containing information about the search results\n        search_info = {\n            \"keyword\": keyword,\n            \"total_results\": num_results,\n            \"total_pages\": num_pages,\n            \"results\": results\n        }\n\n        # Return the search information\n        return search_info"}, {"id": "69", "llm_annotated_code": "import PyPDF2\n\nclass PDFHandler:\n    \"\"\"\n    The class allows merging multiple PDF files into one and extracting text from PDFs using PyPDF2 library.\n    \"\"\"\n\n    def __init__(self, filepaths):\n        \"\"\"\n        takes a list of file paths filepaths as a parameter.\n        It creates a list named readers using PyPDF2, where each reader opens a file from the given paths.\n        \"\"\"\n        # Store the filepaths as a class attribute\n        self.filepaths = filepaths\n\n        # Create a list of PdfFileReader objects, one for each file in filepaths\n        self.readers = [PyPDF2.PdfFileReader(fp) for fp in filepaths]\n\n    def merge_pdfs(self, output_filepath):\n        \"\"\"\n        Read files in self.readers which stores handles to multiple PDF files.\n        Merge them to one pdf and update the page number, then save in disk.\n        :param output_filepath: str, ouput file path to save to\n        :return: str, \"Merged PDFs saved at {output_filepath}\" if successfully merged\n        >>> handler = PDFHandler(['a.pdf', 'b.pdf'])\n        >>> handler.merge_pdfs('out.pdf')\n        Merged PDFs saved at out.pdf\n        \"\"\"\n        # Create a PdfWriter object\n        pdf_writer = PyPDF2.PdfWriter()\n\n        # Iterate over each PdfFileReader object in self.readers\n        for reader in self.readers:\n            # Iterate over each page in the current PdfFileReader object\n            for page_num in range(len(reader.pages)):\n                # Get the current page\n                page = reader.pages[page_num]\n                # Add the current page to the PdfWriter object\n                pdf_writer.add_page(page)\n\n        # Open the output file in write-binary mode\n        with open(output_filepath, 'wb') as out:\n            # Write the content of the PdfWriter object to the output file\n            pdf_writer.write(out)\n\n        # Return a success message\n        return f\"Merged PDFs saved at {output_filepath}\"\n\n    def extract_text_from_pdfs(self):\n        \"\"\"\n        Extract text from pdf files in self.readers\n        :return pdf_texts: list of str, each element is the text of one pdf file\n        >>> handler = PDFHandler(['a.pdf', 'b.pdf'])\n        >>> handler.extract_text_from_pdfs()\n        ['Test a.pdf', 'Test b.pdf']\n        \"\"\"\n        # Initialize an empty list to store the extracted text\n        pdf_texts = []\n\n        # Iterate over each PdfFileReader object in self.readers\n        for reader in self.readers:\n            # Iterate over each page in the current PdfFileReader object\n            for page_num in range(len(reader.pages)):\n                # Get the current page\n                page = reader.pages[page_num]\n                # Extract the text from the current page and append it to pdf_texts\n                pdf_texts.append(page.extract_text())\n\n        # Return the list of extracted text\n        return pdf_texts"}, {"id": "70", "llm_annotated_code": "class PersonRequest:\n    \"\"\"\n    This class validates input personal information data and sets invalid fields to None based to specific rules.\n    \"\"\"\n\n    def __init__(self, name: str, sex: str, phoneNumber: str):\n        \"\"\"\n        Initialize PersonRequest object with the provided information.\n        :param name: str, the name of the person\n        :param sex: str, the sex of the person\n        :param phoneNumber: str, the phone number of the person\n        \"\"\"\n\n        # Validate the input name, sex, and phoneNumber using the corresponding validation methods\n        # Store the validated values in the instance variables\n        self.name = self._validate_name(name)\n        self.sex = self._validate_sex(sex)\n        self.phoneNumber = self._validate_phoneNumber(phoneNumber)\n\n\n    def _validate_name(self, name: str) -> str:\n        \"\"\"\n        Validate the name and return it. If name is empty or exceeds 33 characters in length, set to None.\n        :param name: str, the name to validate\n        :return: str, the validated name or None if invalid\n        \"\"\"\n\n        # If the name is empty or its length exceeds 33 characters, return None\n        # Otherwise, return the name as it is\n        if not name or len(name) > 33:\n            return None\n        return name\n\n\n    def _validate_sex(self, sex: str) -> str:\n        \"\"\"\n        Validate the sex and return it. If sex is not Man, Woman, or UGM, set to None.\n        :param sex: str, the sex to validate\n        :return: str, the validated sex or None if invalid\n        \"\"\"\n\n        # If the sex is not one of the valid options (\"Man\", \"Woman\", \"UGM\"), return None\n        # Otherwise, return the sex as it is\n        if sex not in [\"Man\", \"Woman\", \"UGM\"]:\n            return None\n        return sex\n\n    def _validate_phoneNumber(self, phoneNumber: str) -> str:\n        \"\"\"\n        Validate the phone number and return it. If phoneNumber is empty or not an 11 digit number, set to None.\n        :param phoneNumber: str, the phone number to validate\n        :return: str, the validated phone number or None if invalid\n        \"\"\"\n\n        # If the phoneNumber is empty or it's not an 11-digit number, return None\n        # Otherwise, return the phoneNumber as it is\n        if not phoneNumber or len(phoneNumber) != 11 or not phoneNumber.isdigit():\n            return None\n        return phoneNumber"}, {"id": "71", "llm_annotated_code": "class PushBoxGame:\n    \"\"\"\n    This class implements a functionality of a sokoban game, where the player needs to move boxes to designated targets in order to win.\n    \"\"\"\n\n    def __init__(self, map):\n        \"\"\"\n        Initialize the push box game with the map and various attributes.\n        :param map: list[str], the map of the push box game, represented as a list of strings.\n            Each character on the map represents a different element, including the following:\n            - '#' represents a wall that neither the player nor the box can pass through;\n            - 'O' represents the initial position of the player;\n            - 'G' represents the target position;\n            - 'X' represents the initial position of the box.\n        >>> map = [\"#####\", \"#O  #\", \"# X #\", \"#  G#\", \"#####\"]\n        >>> game = PushBoxGame(map)\n        \"\"\"\n\n        # Store the map of the game\n        self.map = map\n\n        # Initialize the player's position\n        self.player_row = 0\n        self.player_col = 0\n\n        # Initialize the list of target positions and boxes\n        self.targets = []\n        self.boxes = []\n\n        # Initialize the count of targets\n        self.target_count = 0\n\n        # Initialize the game over status\n        self.is_game_over = False\n\n        # Call the init_game method to set up the game\n        self.init_game()\n\n    def init_game(self):\n        \"\"\"\n        Initialize the game by setting the positions of the player, targets, and boxes based on the map.\n        >>> game = PushBoxGame([\"#####\", \"#O  #\", \"# X #\", \"#  G#\", \"#####\"])\n        >>> game.targets\n        [(3, 3)]\n        >>> game.boxes\n        [(2, 2)]\n        >>> game.player_row\n        1\n        >>> game.player_col\n        1\n        \"\"\"\n\n        # Iterate over the rows and columns of the map\n        for row in range(len(self.map)):\n            for col in range(len(self.map[row])):\n\n                # If the character at the current position is 'O', set the player's position\n                if self.map[row][col] == \"O\":\n                    self.player_row = row\n                    self.player_col = col\n\n                # If the character at the current position is 'G', add the position to the list of targets and increment the target count\n                elif self.map[row][col] == \"G\":\n                    self.targets.append((row, col))\n                    self.target_count += 1\n\n                # If the character at the current position is 'X', add the position to the list of boxes\n                elif self.map[row][col] == \"X\":\n                    self.boxes.append((row, col))\n\n    def check_win(self):\n        \"\"\"\n        Check if the game is won. The game is won when all the boxes are placed on target positions.\n        And update the value of self.is_game_over.\n        :return self.is_game_over: True if all the boxes are placed on target positions, or False otherwise.\n        >>> game = PushBoxGame([\"#####\", \"#O  #\", \"# X #\", \"#  G#\", \"#####\"])\n        >>> game.check_win()\n        \"\"\"\n\n        # Initialize the count of boxes on target positions\n        box_on_target_count = 0\n\n        # Iterate over the boxes\n        for box in self.boxes:\n\n            # If the box is on a target position, increment the count\n            if box in self.targets:\n                box_on_target_count += 1\n\n        # If all boxes are on target positions, set the game over status to True\n        if box_on_target_count == self.target_count:\n            self.is_game_over = True\n\n        # Return the game over status\n        return self.is_game_over\n\n\n    def move(self, direction):\n        \"\"\"\n        Move the player based on the specified direction and check if the game is won.\n        :param direction: str, the direction of the player's movement.\n            It can be 'w', 's', 'a', or 'd' representing up, down, left, or right respectively.\n\n        :return: True if the game is won, False otherwise.\n        >>> game = PushBoxGame([\"#####\", \"#O  #\", \"# X #\", \"#  G#\", \"#####\"])\n        >>> game.print_map()\n        # # # # #\n        # O     #\n        #   X   #\n        #     G #\n        # # # # #\n        >>> game.move('d')\n        False\n        >>> game.move('s')\n        False\n        >>> game.move('a')\n        False\n        >>> game.move('s')\n        False\n        >>> game.move('d')\n        True\n        \"\"\"\n\n        # Initialize the new player's position to the current position\n        new_player_row = self.player_row\n        new_player_col = self.player_col\n\n        # Update the new player's position based on the direction\n        if direction == \"w\":\n            new_player_row -= 1\n        elif direction == \"s\":\n            new_player_row += 1\n        elif direction == \"a\":\n            new_player_col -= 1\n        elif direction == \"d\":\n            new_player_col += 1\n\n        # If the new position is not a wall\n        if self.map[new_player_row][new_player_col] != \"#\":\n\n            # If the new position is a box\n            if (new_player_row, new_player_col) in self.boxes:\n\n                # Calculate the new box's position\n                new_box_row = new_player_row + (new_player_row - self.player_row)\n                new_box_col = new_player_col + (new_player_col - self.player_col)\n\n                # If the new box's position is not a wall\n                if self.map[new_box_row][new_box_col] != \"#\":\n\n                    # Move the box to the new position and update the player's position\n                    self.boxes.remove((new_player_row, new_player_col))\n                    self.boxes.append((new_box_row, new_box_col))\n                    self.player_row = new_player_row\n                    self.player_col = new_player_col\n\n            # If the new position is not a box, update the player's position\n            else:\n                self.player_row = new_player_row\n                self.player_col = new_player_col\n\n        # Check if the game is won and return the result\n        return self.check_win()"}, {"id": "72", "llm_annotated_code": "import re\n\nclass RegexUtils:\n    \"\"\"\n    The class provides to match, find all occurrences, split, and substitute text using regular expressions. It also includes predefined patterns, validating phone numbers and extracting email \naddresses.\n    \"\"\"\n\n    def match(self, pattern, text):\n        \"\"\"\n        Check if the text matches the regular expression\n        :param pattern: string, Regular expression pattern\n        :param text: string, Text to match\n        :return: True or False, representing whether the text matches the regular expression or not\n\n        This method uses the re.match function from the re module to check if the start of the text matches the regular expression pattern.\n        \"\"\"\n        ans = re.match(pattern, text)\n        if ans:\n            return True\n        else:\n            return False\n\n    def findall(self, pattern, text):\n        \"\"\"\n        Find all matching substrings and return a list of all matching substrings\n        :param pattern: string, Regular expression pattern\n        :param text: string, Text to match\n        :return: list of string, List of all matching substrings\n\n        This method uses the re.findall function from the re module to find all non-overlapping matches of the regular expression pattern in the text as a list of strings.\n        \"\"\"\n        return re.findall(pattern, text)\n\n    def split(self, pattern, text):\n        \"\"\"\n        Split text based on regular expression patterns and return a list of substrings\n        :param pattern: string, Regular expression pattern\n        :param text: string, Text to be split\n        :return: list of string, List of substrings after splitting\n\n        This method uses the re.split function from the re module to split the text by the occurrences of the regular expression pattern.\n        \"\"\"\n        return re.split(pattern, text)\n\n    def sub(self, pattern, replacement, text):\n        \"\"\"\n        Replace the substring matched by a regular expression with the specified string\n        :param pattern: string, Regular expression pattern\n        :param replacement: Text to replace with\n        :param text: string, Text to be replaced\n        :return: string, Text after replacement\n\n        This method uses the re.sub function from the re module to replace the leftmost non-overlapping occurrences of the regular expression pattern in the text by the replacement string.\n        \"\"\"\n        return re.sub(pattern, replacement, text)\n\n    def generate_email_pattern(self):\n        \"\"\"\n        Generate regular expression patterns that match email addresses\n        :return: string, regular expression patterns that match email addresses\n\n        This method returns a regular expression pattern that matches email addresses.\n        \"\"\"\n        pattern = r'[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Z|a-z]{2,}'\n        return pattern\n\n    def generate_phone_number_pattern(self):\n        \"\"\"\n        Generate regular expression patterns that match phone numbers\n        :return: string, regular expression patterns that match phone numbers\n\n        This method returns a regular expression pattern that matches phone numbers.\n        \"\"\"\n        pattern = r'\\d{3}-\\d{3}-\\d{4}'\n        return pattern\n\n    def generate_split_sentences_pattern(self):\n        \"\"\"\n        Generate regular expression patterns that match the middle characters of two sentences\n        :return: string, regular expression patterns that match the middle characters of two sentences\n\n        This method returns a regular expression pattern that matches the middle characters of two sentences.\n        \"\"\"\n        pattern = r'[.!?][\\s]{1,2}(?=[A-Z])'\n        return pattern\n\n    def split_sentences(self, text):\n        \"\"\"\n        Split the text into a list of sentences without Punctuation except the last sentence\n        :param text: Text to be split\n        :return: Split Text List\n\n        This method uses the generate_split_sentences_pattern method to generate a regular expression pattern and the split method to split the text into a list of sentences.\n        \"\"\"\n        pattern = self.generate_split_sentences_pattern()\n        return self.split(pattern, text)\n\n    def validate_phone_number(self, phone_number):\n        \"\"\"\n        Verify if the phone number is valid\n        :param phone_number: Phone number to be verified\n        :return: True or False, indicating whether the phone number is valid\n\n        This method uses the generate_phone_number_pattern method to generate a regular expression pattern and the match method to check if the phone number matches the pattern.\n        \"\"\"\n        pattern = self.generate_phone_number_pattern()\n        return self.match(pattern, phone_number)\n\n    def extract_email(self, text):\n        \"\"\"\n        Extract all email addresses from the text\n        :param text: string, input text\n        :return: list of string, All extracted email addresses\n\n        This method uses the generate_email_pattern method to generate a regular expression pattern and the findall method to find all email addresses in the text.\n        \"\"\"\n        pattern = self.generate_email_pattern()\n        return self.findall(pattern, text)"}, {"id": "73", "llm_annotated_code": "class RPGCharacter:\n    \"\"\"\n    The class represents a role-playing game character, which allows to attack other characters, heal, gain experience, level up, and check if the character is alive.\n    \"\"\"\n\n    def __init__(self, name, hp, attack_power, defense, level=1):\n        \"\"\"\n        Initialize an RPG character object.\n        :param name: strm, the name of the character.\n        :param hp: int, The health points of the character.\n        :param attack_power: int, the attack power of the character.\n        :param defense: int, the defense points of the character.\n        :param level: int, the level of the character. Default is 1.\n        \"\"\"\n\n        # Initialize the character's name, health points, attack power, defense points, level, and experience points\n        self.name = name\n        self.hp = hp\n        self.attack_power = attack_power\n        self.defense = defense\n        self.level = level\n        self.exp = 0\n\n    def attack(self, other_character):\n        \"\"\"\n        Attack another character. The damage caused needs to offset the defense value.\n        :param other_character: str, The character being attacked.\n        \"\"\"\n\n        # Calculate the damage by subtracting the defense of the other character from the attack power of the current character\n        # The minimum damage is 1\n        damage = max(self.attack_power - other_character.defense, 1)\n\n        # Subtract the damage from the health points of the other character\n        other_character.hp -= damage\n\n    def heal(self):\n        \"\"\"\n        Heal the character with 10 hp and the max hp is 100.\n        :return: int, the current health points after healing.\n        \"\"\"\n\n        # Increase the health points of the character by 10\n        self.hp += 10\n\n        # If the health points exceed 100, set them to 100\n        if self.hp > 100:\n            self.hp = 100\n\n        # Return the current health points\n        return self.hp\n\n    def gain_exp(self, amount):\n        \"\"\"\n        Gain experience points for the character and level_up when the exp has reached the values that is 100 times the current level\n        The experience that overflows should be used to calculate the next leve up untill exhausts\n        :param amount: int, the amount of experience points to gain.\n        \"\"\"\n\n        # While there is still experience to gain\n        while amount != 0:\n\n            # If the current experience plus the amount to gain is greater than or equal to the level times 100\n            if self.exp + amount >= self.level * 100:\n\n                # Subtract the amount needed to level up from the amount to gain\n                amount -= (self.level * 100 - self.exp)\n\n                # Level up the character\n                self.level_up()\n\n            # If the current experience plus the amount to gain is less than the level times 100\n            else:\n\n                # Add the remaining amount to the current experience\n                self.exp += amount\n\n                # Set the amount to gain to 0\n                amount = 0\n\n    def level_up(self):\n        \"\"\"\n        Level up the character and return to zero experience points, increase hp by 20 points, attack power and defense points by 5 points.\n        max level is 100\n        :return: tuple[int, int, int, int], the new level, health points, attack power, and defense points after leveling up.\n        \"\"\"\n\n        # If the character's level is less than 100\n        if self.level < 100:\n\n            # Increase the level by 1\n            self.level += 1\n\n            # Reset the experience points to 0\n            self.exp = 0\n\n            # Increase the health points by 20\n            self.hp += 20\n\n            # Increase the attack power by 5\n            self.attack_power += 5\n\n            # Increase the defense points by 5\n            self.defense += 5\n\n        # Return the new level, health points, attack power, and defense points\n        return self.level, self.hp, self.attack_power, self.defense\n\n    def is_alive(self):\n        \"\"\"\n        Check if player is alive.\n        :return: True if the hp is larger than 0, or False otherwise.\n        \"\"\"\n\n        # Return True if the character's health points are greater than 0, otherwise return False\n        return self.hp > 0"}, {"id": "74", "llm_annotated_code": "class Server:\n    \"\"\"\n    This is a class as a server, which handles a white list, message sending and receiving, and information display.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the whitelist as an empty list, and initialize the sending and receiving information as an empty dictionary\n        \"\"\"\n        # Initialize an empty list for the whitelist\n        self.white_list = []\n        # Initialize an empty dictionary for the sending structure\n        self.send_struct = {}\n        # Initialize an empty dictionary for the receiving structure\n        self.receive_struct = {}\n\n    def add_white_list(self, addr):\n        \"\"\"\n        Add an address to the whitelist and do nothing if it already exists\n        :param addr: int, address to be added\n        :return: new whitelist, return False if the address already exists\n        >>> server = Server()\n        >>> server.add_white_list(88)\n        [88]\n        \"\"\"\n        # Check if the address is already in the whitelist\n        if addr in self.white_list:\n            # If it is, return False\n            return False\n        else:\n            # If it's not, add it to the whitelist and return the updated whitelist\n            self.white_list.append(addr)\n            return self.white_list\n\n    def del_white_list(self, addr):\n        \"\"\"\n        Remove an address from the whitelist and do nothing if it does not exist\n        :param addr: int, address to be deleted\n        :return: new whitelist, return False if the address does not exist\n        >>> server.add_white_list(88)\n        >>> server.del_white_list(88)\n        []\n        \"\"\"\n        # Check if the address is in the whitelist\n        if addr not in self.white_list:\n            # If it's not, return False\n            return False\n        else:\n            # If it is, remove it from the whitelist and return the updated whitelist\n            self.white_list.remove(addr)\n            return self.white_list\n\n    def recv(self, info):\n        \"\"\"\n        Receive information containing address and content. If the address is on the whitelist, receive the content; otherwise, do not receive it\n        :param info: dict, information dictionary containing address and content\n        :return: if successfully received, return the content of the infomation; otherwise, return False\n        >>> server.recv({\"addr\":88,\"content\":\"abc\"})\n        abc\n        \"\"\"\n        # Check if the info is a dictionary and contains the keys \"addr\" and \"content\"\n        if not isinstance(info, dict) or \"addr\" not in info or \"content\" not in info:\n            # If not, return -1\n            return -1\n        # Extract the address and content from the info\n        addr = info[\"addr\"]\n        content = info[\"content\"]\n        # Check if the address is in the whitelist\n        if addr not in self.white_list:\n            # If it's not, return False\n            return False\n        else:\n            # If it is, update the receiving structure with the address and content and return the content\n            self.receive_struct = {\"addr\": addr, \"content\": content}\n            return self.receive_struct[\"content\"]\n\n    def send(self, info):\n        \"\"\"\n        Send information containing address and content\n        :param info: dict, information dictionary containing address and content\n        :return: if successfully sent, return nothing; otherwise, return a string indicating an error message\n        >>> server.send({\"addr\":66,\"content\":\"ABC\"})\n        self.send_struct = {\"addr\":66,\"content\":\"ABC\"}\n        \"\"\"\n        # Check if the info is a dictionary and contains the keys \"addr\" and \"content\"\n        if not isinstance(info, dict) or \"addr\" not in info or \"content\" not in info:\n            # If not, return an error message\n            return \"info structure is not correct\"\n        # If it is, update the sending structure with the address and content\n        self.send_struct = {\"addr\": info[\"addr\"], \"content\": info[\"content\"]}\n\n    def show(self, type):\n        \"\"\"\n        Returns struct of the specified type\n        :param type: string, the type of struct to be returned, which can be 'send' or 'receive'\n        :return: if type is equal to 'send' or 'receive', return the corresponding struct; otherwise, return False\n        >>> server.recv({\"addr\":88,\"content\":\"abc\"})\n        >>> server.send({\"addr\":66,\"content\":\"ABC\"})\n        >>> server.show(\"send\")\n        {\"addr\":66,\"content\":\"ABC\"}\n        \"\"\"\n        # Check if the type is \"send\"\n        if type == \"send\":\n            # If it is, return the sending structure\n            return self.send_struct\n        # Check if the type is \"receive\"\n        elif type == \"receive\":\n            # If it is, return the receiving structure\n            return self.receive_struct\n        else:\n            # If it's neither, return False\n            return False"}, {"id": "75", "llm_annotated_code": "class ShoppingCart:\n    \"\"\"\n    The class manages items, their prices, quantities, and allows to for add, removie, view items, and calculate the total price.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the items representing the shopping list as an empty dictionary\n        \"\"\"\n        # Initialize an empty dictionary to store items in the shopping cart\n        self.items = {}\n\n\n    def add_item(self, item, price, quantity=1):\n        \"\"\"\n        Add item information to the shopping list items, including price and quantity. The default quantity is 1\n        :param item: string, Item to be added\n        :param price: float, The price of the item\n        :param quantity:int, The number of items, defaults to 1\n        :return:None\n        >>> shoppingcart = ShoppingCart()\n        >>> shoppingcart.add_item(\"apple\", 1, 5)\n        self.items = {\"apple\":{\"price\":1, \"quantity\":5}}\n        \"\"\"\n        # Check if the item already exists in the shopping cart\n        # If it does, update the price and quantity of the item\n        # If it doesn't, add the item to the shopping cart with the given price and quantity\n        if item in self.items:\n            self.items[item] = {'price': price, 'quantity': quantity}\n        else:\n            self.items[item] = {'price': price, 'quantity': quantity}\n\n\n    def remove_item(self, item, quantity=1):\n        \"\"\"\n        Subtract the specified quantity of item from the shopping list items\n        :param item:string, Item to be subtracted in quantity\n        :param quantity:int, Quantity to be subtracted\n        :return:None\n        >>> shoppingcart.add_item(\"apple\", 1, 5)\n        >>> shoppingcart.remove_item(\"apple\", 3)\n        self.items = {\"apple\":{\"price\":1, \"quantity\":2}}\n        \"\"\"\n        # Check if the item exists in the shopping cart\n        # If it does, subtract the specified quantity from the item's quantity\n        # If it doesn't, do nothing\n        if item in self.items:\n            self.items[item]['quantity'] -= quantity\n        else:\n            pass\n\n\n    def view_items(self) -> dict:\n        \"\"\"\n        Return the current shopping list items\n        :return:dict, the current shopping list items\n        >>> shoppingcart.add_item(\"apple\", 1, 5)\n        >>> shoppingcart.remove_item(\"apple\", 3)\n        >>> shoppingcart.view_items()\n        {\"apple\":{\"price\":1, \"quantity\":2}}\n        \"\"\"\n        # Return the current items in the shopping cart\n        return self.items\n\n\n    def total_price(self) -> float:\n        \"\"\"\n        Calculate the total price of all items in the shopping list, which is the quantity of each item multiplied by the price\n        :return:float, the total price of all items in the shopping list\n        >>> shoppingcart = ShoppingCart()\n        >>> shoppingcart.add_item(\"apple\", 1, 5)\n        >>> shoppingcart.add_item(\"banana\", 2, 3)\n        >>> shoppingcart.total_price()\n        11.0\n        \"\"\"\n        # Calculate the total price of all items in the shopping cart\n        # The total price is the sum of the price of each item multiplied by its quantity\n        return sum([item['quantity'] * item['price'] for item in self.items.values()])"}, {"id": "76", "llm_annotated_code": "class SignInSystem:\n    \"\"\"\n    This is a class as sign-in system, including adding users, signing in/out, checking sign-in status, and retrieving signed-in/not signed-in users.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the sign-in system.\n        \"\"\"\n        # Initialize an empty dictionary to store users and their sign-in status\n        self.users = {}\n\n    def add_user(self, username):\n        \"\"\"\n        Add a user to the sign-in system if the user wasn't in the self.users.\n        And the initial state is False.\n        :param username: str, the username to be added.\n        :return: bool, True if the user is added successfully, False if the user already exists.\n        >>> signInSystem.add_user(\"mike\")\n        True\n        >>> signInSystem.add_user(\"mike\")\n        False\n        \"\"\"\n        # Check if the user already exists in the system\n        if username in self.users:\n            return False\n        else:\n            # Add the user to the system with a sign-in status of False\n            self.users[username] = False\n            return True\n\n    def sign_in(self, username):\n        \"\"\"\n        Sign in a user if the user was in the self.users and change the state to True.\n        :param username: str, the username to be signed in.\n        :return: bool, True if the user is signed in successfully, False if the user does not exist.\n        >>> signInSystem.sign_in(\"mike\")\n        True\n        >>> signInSystem.sign_in(\"mik\")\n        False\n        \"\"\"\n        # Check if the user exists in the system\n        if username not in self.users:\n            return False\n        else:\n            # Change the user's sign-in status to True\n            self.users[username] = True\n            return True\n\n    def check_sign_in(self, username):\n        \"\"\"\n        Check if a user is signed in.\n        :param username: str, the username to be checked.\n        :return: bool, True if the user is signed in, False if the user does not exist or is not signed in.\n        >>> signInSystem.check_sign_in(\"jack\")\n        False\n        >>> signInSystem.add_user(\"jack\")\n        >>> signInSystem.check_sign_in(\"jack\")\n        >>> signInSystem.sign_in(\"jack\")\n        >>> signInSystem.check_sign_in(\"jack\")\n        True\n        \"\"\"\n        # Check if the user exists in the system\n        if username not in self.users:\n            return False\n        else:\n            # Return the user's sign-in status\n            if self.users[username]:\n                return True\n            else:\n                return False\n\n    def all_signed_in(self):\n        \"\"\"\n        Check if all users are signed in.\n        :return: bool, True if all users are signed in, False otherwise.\n        >>> signInSystem.add_user(\"jack\")\n        True\n        >>> signInSystem.sign_in(\"jack\")\n        >>> signInSystem.all_signed_in()\n        True\n        \"\"\"\n        # Check if all users in the system are signed in\n        if all(self.users.values()):\n            return True\n        else:\n            return False\n\n    def all_not_signed_in(self):\n        \"\"\"\n        Get a list of usernames that are not signed in.\n        :return: list[str], a list of usernames that are not signed in.\n        >>> signInSystem = SignInSystem()\n        >>> signInSystem.add_user(\"a\")\n        True\n        >>> signInSystem.add_user(\"b\")\n        True\n        >>> signInSystem.all_not_signed_in()\n        ['a', 'b']\n        \"\"\"\n        not_signed_in_users = []\n        # Iterate over all users in the system\n        for username, signed_in in self.users.items():\n            # If a user is not signed in, add their username to the list\n            if not signed_in:\n                not_signed_in_users.append(username)\n        # Return the list of users who are not signed in\n        return not_signed_in_users"}, {"id": "77", "llm_annotated_code": "class Snake:\n    \"\"\"\n    The class is a snake game, with allows snake to move and eat food, and also enables to reset, and generat a random food position.\n    \"\"\"\n\n    def __init__(self, SCREEN_WIDTH, SCREEN_HEIGHT, BLOCK_SIZE, food_position):\n        \"\"\"\n        Initialize the length of the snake, screen width, screen height, block size, snake head position, score, and food position.\n        :param SCREEN_WIDTH: int\n        :param SCREEN_HEIGHT: int\n        :param BLOCK_SIZE: int, Size of moving units\n        :param food_position: tuple, representing the position(x, y) of food.\n        \"\"\"\n        # Initialize the length of the snake to 1\n        self.length = 1\n        # Initialize the screen width and height\n        self.SCREEN_WIDTH = SCREEN_WIDTH\n        self.SCREEN_HEIGHT = SCREEN_HEIGHT\n        # Initialize the block size\n        self.BLOCK_SIZE = BLOCK_SIZE\n        # Initialize the snake's head position to the center of the screen\n        self.positions = [((SCREEN_WIDTH / 2), (SCREEN_HEIGHT / 2))]\n        # Initialize the score to 0\n        self.score = 0\n        # Initialize the food position\n        self.food_position = food_position\n\n\n    def move(self, direction):\n        \"\"\"\n        Move the snake in the specified direction. If the new position of the snake's head is equal to the position of the food, then eat the food; If the position of the snake's head is equal \nto the position of its body, then start over, otherwise its own length plus one.\n        :param direction: tuple, representing the direction of movement (x, y).\n        :return: None\n        \"\"\"\n        # Get the current position of the snake's head\n        cur = self.positions[0]\n        x, y = direction\n\n        # Calculate the new position of the snake's head based on the direction and the block size\n        new = (\n            ((cur[0] + (x * self.BLOCK_SIZE)) % self.SCREEN_WIDTH),\n            (cur[1] + (y * self.BLOCK_SIZE)) % self.SCREEN_HEIGHT,\n        )\n\n        # If the new position is the same as the food position, eat the food\n        if new == self.food_position:\n            self.eat_food()\n\n        # If the new position is the same as any position in the snake's body, reset the game\n        if len(self.positions) > 2 and new in self.positions[2:]:\n            self.reset()\n        else:\n            # Otherwise, add the new position to the front of the positions list\n            self.positions.insert(0, new)\n            # If the length of the positions list is greater than the length of the snake, remove the last position\n            if len(self.positions) > self.length:\n                self.positions.pop()\n\n\n    def random_food_position(self):\n        \"\"\"\n        Randomly generate a new food position, but don't place it on the snake.\n        :return: None, Change the food position\n        \"\"\"\n        # Generate a new food position that is not in the snake's positions\n        while self.food_position in self.positions:\n            self.food_position = (random.randint(0, self.SCREEN_WIDTH // self.BLOCK_SIZE - 1) * self.BLOCK_SIZE,\n                                  random.randint(0, self.SCREEN_HEIGHT // self.BLOCK_SIZE - 1) * self.BLOCK_SIZE)\n\n\n    def reset(self):\n        \"\"\"\n        Reset the snake to its initial state. Set the length to 1, the snake head position to ((SCREEN_WIDTH/2), (SCREEN_HEIGHT/2)), the score to 0, and randomly generate new food position.    \n        :return: None\n        \"\"\"\n        # Reset the length of the snake to 1\n        self.length = 1\n        # Reset the snake's head position to the center of the screen\n        self.positions = [((self.SCREEN_WIDTH / 2), (self.SCREEN_HEIGHT / 2))]\n        # Reset the score to 0\n        self.score = 0\n        # Generate a new food position\n        self.random_food_position()\n\n\n    def eat_food(self):\n        \"\"\"\n        Increase the length of the snake by 1 and increase the score by 100. Randomly generate a new food position, but\n        don't place it on the snake.\n        :return: None\n        \"\"\"\n        # Increase the length of the snake by 1\n        self.length += 1\n        # Increase the score by 100\n        self.score += 100\n        # Generate a new food position\n        self.random_food_position()"}, {"id": "78", "llm_annotated_code": "class SplitSentence:\n    \"\"\"\n    The class allows to split sentences, count words in a sentence, and process a text file to find the maximum word count.\n    \"\"\"\n\n    def split_sentences(self, sentences_string):\n        \"\"\"\n        Split a string into a list of sentences. Sentences end with . or ? and with a space after that. Please note that Mr. also end with . but are not sentences.\n        :param sentences_string: string, string to split\n        :return:list, split sentence list\n        >>> ss = SplitSentence()\n        >>> ss.split_sentences(\"aaa aaaa. bb bbbb bbb? cccc cccc. dd ddd?\")\n        ['aaa aaaa.', 'bb bbbb bbb?', 'cccc cccc.', 'dd ddd?']\n        \"\"\"\n\n        # Use the re.split function to split the sentences_string into sentences.\n        # The regular expression pattern r'(?<!\\w\\.\\w.)(?<![A-Z][a-z]\\.)(?<=\\.|\\?)\\s' is used to split the string at every . or ? followed by a space, but not when the . is part of an abbreviation like Mr.\n        sentences = re.split(r'(?<!\\w\\.\\w.)(?<![A-Z][a-z]\\.)(?<=\\.|\\?)\\s', sentences_string)\n\n        # Return the list of sentences\n        return sentences\n\n    def count_words(self, sentence):\n        \"\"\"\n        Count the number of words in a sentence. Note that words are separated by spaces and that punctuation marks and numbers are not counted as words.\n        :param sentence:string, sentence to be counted, where words are separated by spaces\n        :return:int, number of words in the sentence\n        >>> ss.count_words(\"abc def\")\n        2\n        \"\"\"\n\n        # Use the re.sub function to remove all non-alphabetic characters from the sentence\n        sentence = re.sub(r'[^a-zA-Z\\s]', '', sentence)\n\n        # Use the split method to split the sentence into words at every space\n        words = sentence.split()\n\n        # Return the number of words in the sentence\n        return len(words)\n\n    def process_text_file(self, sentences_string):\n        \"\"\"\n        Given a text, return the number of words in the longest sentence\n        :param sentences_string: string, undivided long sentence\n        :return:int, the number of words in the longest sentence\n        >>> ss.process_text_file(\"aaa aaaa. bb bbbb bbb? cccc ccccccc cc ccc. dd ddd?\")\n        4\n        \"\"\"\n\n        # Use the split_sentences method to split the sentences_string into sentences\n        sentences = self.split_sentences(sentences_string)\n\n        # Initialize max_count to 0\n        max_count = 0\n\n        # Iterate over each sentence in sentences\n        for sentence in sentences:\n\n            # Use the count_words method to count the number of words in the sentence\n            count = self.count_words(sentence)\n\n            # If the count is greater than max_count, update max_count\n            if count > max_count:\n                max_count = count\n\n        # Return the maximum word count\n        return max_count"}, {"id": "79", "llm_annotated_code": "class SQLGenerator:\n    \"\"\"\n    This class generates SQL statements for common operations on a table, such as SELECT, INSERT, UPDATE, and DELETE.\n    \"\"\"\n\n    def __init__(self, table_name):\n        \"\"\"\n        Initialize the table name.\n        :param table_name: str\n        \"\"\"\n        # Store the table name to be used in SQL queries\n        self.table_name = table_name\n\n    def select(self, fields=None, condition=None):\n        \"\"\"\n        Generates a SELECT SQL statement based on the specified fields and conditions.\n        :param fields: list, optional. Default is None. The list of fields to be queried.\n        :param condition: str, optional. Default is None. The condition expression for the query.\n        :return: str. The generated SQL statement.\n        \"\"\"\n        # If no fields are specified, select all fields\n        if fields is None:\n            fields = \"*\"\n        else:\n            # Join the list of fields into a string separated by commas\n            fields = \", \".join(fields)\n        \n        # Start building the SQL query\n        sql = f\"SELECT {fields} FROM {self.table_name}\"\n        \n        # If a condition is specified, add it to the query\n        if condition is not None:\n            sql += f\" WHERE {condition}\"\n        \n        # Return the final SQL query\n        return sql + \";\"\n\n    def insert(self, data):\n        \"\"\"\n        Generates an INSERT SQL statement based on the given data.\n        :param data: dict. The data to be inserted, in dictionary form where keys are field names and values are field values.\n        :return: str. The generated SQL statement.\n        \"\"\"\n        # Extract the field names and values from the data dictionary\n        fields = \", \".join(data.keys())\n        values = \", \".join([f\"'{value}'\" for value in data.values()])\n        \n        # Build the SQL query\n        sql = f\"INSERT INTO {self.table_name} ({fields}) VALUES ({values})\"\n        \n        # Return the final SQL query\n        return sql + \";\"\n\n    def update(self, data, condition):\n        \"\"\"\n        Generates an UPDATE SQL statement based on the given data and condition.\n        :param data: dict. The data to be updated, in dictionary form where keys are field names and values are new field values.\n        :param condition: str. The condition expression for the update.\n        :return: str. The generated SQL statement.\n        \"\"\"\n        # Build the SET clause of the SQL query from the data dictionary\n        set_clause = \", \".join([f\"{field} = '{value}'\" for field, value in data.items()])\n        \n        # Build the SQL query\n        sql = f\"UPDATE {self.table_name} SET {set_clause} WHERE {condition}\"\n        \n        # Return the final SQL query\n        return sql + \";\"\n\n    def delete(self, condition):\n        \"\"\"\n        Generates a DELETE SQL statement based on the given condition.\n        :param condition: str. The condition expression for the delete.\n        :return: str. The generated SQL statement.\n        \"\"\"\n        # Build the SQL query\n        sql = f\"DELETE FROM {self.table_name} WHERE {condition}\"\n        \n        # Return the final SQL query\n        return sql + \";\"\n\n    def select_female_under_age(self, age):\n        \"\"\"\n        Generates a SQL statement to select females under a specified age.\n        :param age: int. The specified age.\n        :return: str. The generated SQL statement.\n        \"\"\"\n        # Build the condition for the SQL query\n        condition = f\"age < {age} AND gender = 'female'\"\n        \n        # Use the select method to generate the SQL query\n        return self.select(condition=condition)\n\n    def select_by_age_range(self, min_age, max_age):\n        \"\"\"\n        Generates a SQL statement to select records within a specified age range.\n        :param min_age: int. The minimum age.\n        :param max_age: int. The maximum age.\n        :return: str. The generated SQL statement.\n        \"\"\"\n        # Build the condition for the SQL query\n        condition = f\"age BETWEEN {min_age} AND {max_age}\"\n        \n        # Use the select method to generate the SQL query\n        return self.select(condition=condition)"}, {"id": "80", "llm_annotated_code": "class SQLQueryBuilder:\n    \"\"\"\n    This class provides to build SQL queries, including SELECT, INSERT, UPDATE, and DELETE statements.\n    \"\"\"\n\n    @staticmethod\n    def select(table, columns='*', where=None):\n        \"\"\"\n        Generate the SELECT SQL statement from the given parameters.\n        :param table: str, the query table in database.\n        :param columns: list of str, ['col1', 'col2'].\n        :param where: dict, {key1: value1, key2: value2 ...}. The query condition.\n        return query: str, the SQL query statement.\n        >>> SQLQueryBuilder.select('table1', columns = [\"col1\",\"col2\"], where = {\"age\": 15})\n        \"SELECT col1, col2 FROM table1 WHERE age='15'\"\n        \"\"\"\n\n        # If columns is not '*', join the columns with ', '\n        if columns != '*':\n            columns = ', '.join(columns)\n        \n        # Start building the query with SELECT statement\n        query = f\"SELECT {columns} FROM {table}\"\n        \n        # If where condition is provided, append it to the query\n        if where:\n            query += \" WHERE \" + ' AND '.join(f\"{k}='{v}'\" for k, v in where.items())\n        \n        # Return the final query\n        return query\n\n    @staticmethod\n    def insert(table, data):\n        \"\"\"\n        Generate the INSERT SQL statement from the given parameters.\n        :param table: str, the table to be inserted in database.\n        :param data: dict, the key and value in SQL insert statement\n        :return query: str, the SQL insert statement.\n        >>> SQLQueryBuilder.insert('table1', {'name': 'Test', 'age': 14})\n        \"INSERT INTO table1 (name, age) VALUES ('Test', '14')\"\n        \"\"\"\n\n        # Extract keys and values from data\n        keys = ', '.join(data.keys())\n        values = ', '.join(f\"'{v}'\" for v in data.values())\n        \n        # Build and return the INSERT query\n        return f\"INSERT INTO {table} ({keys}) VALUES ({values})\"\n\n    @staticmethod\n    def delete(table, where=None):\n        \"\"\"\n        Generate the DELETE SQL statement from the given parameters.\n        :param table: str, the table that will be excuted with DELETE operation in database\n        :param where: dict, {key1: value1, key2: value2 ...}. The query condition.\n        :return query: str, the SQL delete statement.\n        >>> SQLQueryBuilder.delete('table1', {'name': 'Test', 'age': 14})\n        \"DELETE FROM table1 WHERE name='Test' AND age='14'\"\n        \"\"\"\n\n        # Start building the query with DELETE statement\n        query = f\"DELETE FROM {table}\"\n        \n        # If where condition is provided, append it to the query\n        if where:\n            query += \" WHERE \" + ' AND '.join(f\"{k}='{v}'\" for k, v in where.items())\n        \n        # Return the final query\n        return query\n\n    @staticmethod\n    def update(table, data, where=None):\n        \"\"\"\n        Generate the UPDATE SQL statement from the given parameters.\n        :param table: str, the table that will be excuted with UPDATE operation in database\n        :param data: dict, the key and value in SQL update statement\n        :param where: dict, {key1: value1, key2: value2 ...}. The query condition.\n        >>> SQLQueryBuilder.update('table1', {'name': 'Test2', 'age': 15}, where = {'name':'Test'})\n        \"UPDATE table1 SET name='Test2', age='15' WHERE name='Test'\"\n        \"\"\"\n\n        # Extract keys and values from data and join them with ', '\n        update_str = ', '.join(f\"{k}='{v}'\" for k, v in data.items())\n        \n        # Start building the query with UPDATE statement\n        query = f\"UPDATE {table} SET {update_str}\"\n        \n        # If where condition is provided, append it to the query\n        if where:\n            query += \" WHERE \" + ' AND '.join(f\"{k}='{v}'\" for k, v in where.items())\n        \n        # Return the final query\n        return query"}, {"id": "81", "llm_annotated_code": "import math\n\nclass Statistics3:\n    \"\"\"\n    This is a class that implements methods for calculating indicators such as median, mode, correlation matrix, and Z-score in statistics.\n    \"\"\"\n\n    @staticmethod\n    def median(data):\n        \"\"\"\n        calculates the median of the given list.\n        :param data: the given list, list.\n        :return: the median of the given list, float.\n        >>> statistics3 = Statistics3()\n        >>> statistics3.median([1, 2, 3, 4])\n        2.5\n\n        \"\"\"\n        # Sort the data\n        sorted_data = sorted(data)\n        # Calculate the length of the data\n        n = len(sorted_data)\n        # If the length of the data is odd, return the middle value\n        if n % 2 == 1:\n            return sorted_data[n // 2]\n        # If the length of the data is even, return the average of the two middle values\n        else:\n            return (sorted_data[n // 2 - 1] + sorted_data[n // 2]) / 2\n\n    @staticmethod\n    def mode(data):\n        \"\"\"\n        calculates the mode of the given list.\n        :param data: the given list, list.\n        :return: the mode of the given list, list.\n        >>> statistics3 = Statistics3()\n        >>> statistics3.mode([1, 2, 3, 3])\n        [3]\n\n        \"\"\"\n        # Initialize a dictionary to store the counts of each value in the data\n        counts = {}\n        # Count the occurrences of each value in the data\n        for value in data:\n            counts[value] = counts.get(value, 0) + 1\n        # Find the maximum count\n        max_count = max(counts.values())\n        # Find all values that have the maximum count\n        mode_values = [value for value, count in counts.items() if count == max_count]\n        # Return the mode values\n        return mode_values\n\n    @staticmethod\n    def correlation(x, y):\n        \"\"\"\n        calculates the correlation of the given list.\n        :param x: the given list, list.\n        :param y: the given list, list.\n        :return: the correlation of the given list, float.\n        >>> statistics3 = Statistics3()\n        >>> statistics3.correlation([1, 2, 3], [4, 5, 6])\n        1.0\n\n        \"\"\"\n        # Calculate the length of the lists\n        n = len(x)\n        # Calculate the mean of each list\n        mean_x = sum(x) / n\n        mean_y = sum(y) / n\n        # Calculate the numerator of the correlation formula\n        numerator = sum((xi - mean_x) * (yi - mean_y) for xi, yi in zip(x, y))\n        # Calculate the denominator of the correlation formula\n        denominator = math.sqrt(sum((xi - mean_x) ** 2 for xi in x) * sum((yi - mean_y) ** 2 for yi in y))\n        # If the denominator is 0, return None\n        if denominator == 0:\n            return None\n        # Return the correlation\n        return numerator / denominator\n\n    @staticmethod\n    def mean(data):\n        \"\"\"\n        calculates the mean of the given list.\n        :param data: the given list, list.\n        :return: the mean of the given list, float.\n        >>> statistics3 = Statistics3()\n        >>> statistics3.mean([1, 2, 3])\n        2.0\n\n        \"\"\"\n        # If the data is empty, return None\n        if len(data) == 0:\n            return None\n        # Calculate and return the mean of the data\n        return sum(data) / len(data)\n\n    @staticmethod\n    def correlation_matrix(data):\n        \"\"\"\n        calculates the correlation matrix of the given list.\n        :param data: the given list, list.\n        :return: the correlation matrix of the given list, list.\n        >>> statistics3 = Statistics3()\n        >>> statistics3.correlation_matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n        [[1.0, 1.0, 1.0], [1.0, 1.0, 1.0], [1.0, 1.0, 1.0]]\n\n        \"\"\"\n        # Initialize an empty list to store the correlation matrix\n        matrix = []\n        # Iterate over the columns of the data\n        for i in range(len(data[0])):\n            # Initialize an empty list to store the current row of the correlation matrix\n            row = []\n            # Iterate over the columns of the data\n            for j in range(len(data[0])):\n                # Extract the i-th and j-th columns of the data\n                column1 = [row[i] for row in data]\n                column2 = [row[j] for row in data]\n                # Calculate the correlation between the two columns\n                correlation = Statistics3.correlation(column1, column2)\n                # Append the correlation to the current row of the correlation matrix\n                row.append(correlation)\n            # Append the current row to the correlation matrix\n            matrix.append(row)\n        # Return the correlation matrix\n        return matrix\n\n    @staticmethod\n    def standard_deviation(data):\n        \"\"\"\n        calculates the standard deviation of the given list.\n        :param data: the given list, list.\n        :return: the standard deviation of the given list, float.\n        >>> statistics3 = Statistics3()\n        >>> statistics3.standard_deviation([1, 2, 3])\n        1.0\n\n        \"\"\"\n        # Calculate the length of the data\n        n = len(data)\n        # If the length of the data is less than 2, return None\n        if n < 2:\n            return None\n        # Calculate the mean of the data\n        mean_value = Statistics3.mean(data)\n        # Calculate the variance of the data\n        variance = sum((x - mean_value) ** 2 for x in data) / (n - 1)\n        # Return the square root of the variance (i.e., the standard deviation)\n        return math.sqrt(variance)\n\n    @staticmethod\n    def z_score(data):\n        \"\"\"\n        calculates the z-score of the given list.\n        :param data: the given list, list.\n        :return: the z-score of the given list, list.\n        >>> statistics3 = Statistics3()\n        >>> statistics3.z_score([1, 2, 3, 4])\n        [-1.161895003862225, -0.3872983346207417, 0.3872983346207417, 1.161895003862225]\n\n        \"\"\"\n        # Calculate the mean of the data\n        mean = Statistics3.mean(data)\n        # Calculate the standard deviation of the data\n        std_deviation = Statistics3.standard_deviation(data)\n        # If the standard deviation is None or 0, return None\n        if std_deviation is None or std_deviation == 0:\n            return None\n        # Calculate and return the z-scores of the data\n        return [(x - mean) / std_deviation for x in data]"}, {"id": "82", "llm_annotated_code": "class StockPortfolioTracker:\n    \"\"\"\n    This is a class as StockPortfolioTracker that allows to add stocks, remove stocks, buy stocks, sell stocks, calculate the total value of the portfolio, and obtain a summary of the portfolio.\n    \"\"\"\n\n    def __init__(self, cash_balance):\n        \"\"\"\n        Initialize the StockPortfolioTracker class with a cash balance and an empty portfolio.\n        \"\"\"\n        # Initialize an empty portfolio as a list\n        self.portfolio = []\n        # Initialize the cash balance with the provided cash_balance\n        self.cash_balance = cash_balance\n\n    def add_stock(self, stock):\n        \"\"\"\n        Add a stock to the portfolio.\n        :param stock: a dictionary with keys \"name\", \"price\", and \"quantity\"\n        \"\"\"\n        # Iterate over the portfolio\n        for pf in self.portfolio:\n            # If the stock is already in the portfolio, increase its quantity\n            if pf['name'] == stock['name']:\n                pf['quantity'] += stock['quantity']\n                return\n\n        # If the stock is not in the portfolio, add it\n        self.portfolio.append(stock)\n\n    def remove_stock(self, stock):\n        \"\"\"\n        Remove a stock from the portfolio.\n        :param stock: a dictionary with keys \"name\", \"price\", and \"quantity\"\n        \"\"\"\n        # Iterate over the portfolio\n        for pf in self.portfolio:\n            # If the stock is in the portfolio and its quantity is greater than or equal to the quantity to be removed\n            if pf['name'] == stock['name'] and pf['quantity'] >= stock['quantity']:\n                # Decrease the quantity of the stock in the portfolio\n                pf['quantity'] -= stock['quantity']\n                # If the quantity of the stock in the portfolio is 0, remove the stock from the portfolio\n                if pf['quantity'] == 0:\n                    self.portfolio.remove(pf)\n                return True\n        # If the stock is not in the portfolio or its quantity is less than the quantity to be removed, return False\n        return False\n\n    def buy_stock(self, stock):\n        \"\"\"\n        Buy a stock and add it to the portfolio.\n        :param stock: a dictionary with keys \"name\", \"price\", and \"quantity\"\n        \"\"\"\n        # If the cost of the stock is greater than the cash balance, return False\n        if stock['price'] * stock['quantity'] > self.cash_balance:\n            return False\n        else:\n            # Otherwise, add the stock to the portfolio and decrease the cash balance\n            self.add_stock(stock)\n            self.cash_balance -= stock['price'] * stock['quantity']\n            return True\n\n    def sell_stock(self, stock):\n        \"\"\"\n        Sell a stock and remove it from the portfolio and add the cash to the cash balance.\n        :param stock: a dictionary with keys \"name\", \"price\", and \"quantity\"\n        \"\"\"\n        # If the stock is not in the portfolio or its quantity is less than the quantity to be sold, return False\n        if self.remove_stock(stock) == False:\n            return False\n        # Otherwise, increase the cash balance and return True\n        self.cash_balance += stock['price'] * stock['quantity']\n        return True\n\n    def calculate_portfolio_value(self):\n        \"\"\"\n        Calculate the total value of the portfolio.\n        \"\"\"\n        # Initialize the total value with the cash balance\n        total_value = self.cash_balance\n        # Add the value of each stock in the portfolio to the total value\n        for stock in self.portfolio:\n            total_value += stock['price'] * stock['quantity']\n        # Return the total value\n        return total_value\n\n    def get_portfolio_summary(self):\n        \"\"\"\n        Get a summary of the portfolio.\n        \"\"\"\n        # Initialize an empty summary list\n        summary = []\n        # For each stock in the portfolio, calculate its value and add it to the summary\n        for stock in self.portfolio:\n            value = self.get_stock_value(stock)\n            summary.append({\"name\": stock[\"name\"], \"value\": value})\n        # Calculate the total value of the portfolio\n        portfolio_value = self.calculate_portfolio_value()\n        # Return the total value and the summary\n        return portfolio_value, summary\n\n    def get_stock_value(self, stock):\n        \"\"\"\n        Get the value of a stock.\n        :param stock: a dictionary with keys \"name\", \"price\", and \"quantity\"\n        \"\"\"\n        # Calculate and return the value of the stock\n        return stock['price'] * stock['quantity']"}, {"id": "83", "llm_annotated_code": "import sqlite3\n\nclass StudentDatabaseProcessor:\n    \"\"\"\n    This is a class with database operation, including inserting student information, searching for student information by name, and deleting student information by name.\n    \"\"\"\n\n    def __init__(self, database_name):\n        \"\"\"\n        Initializes the StudentDatabaseProcessor object with the specified database name.\n        :param database_name: str, the name of the SQLite database.\n        \"\"\"\n        # Store the database name for future use\n        self.database_name = database_name\n\n    def create_student_table(self):\n        \"\"\"\n        Creates a \"students\" table in the database if it does not exist already.Fields include ID of type int, name of type str, age of type int, gender of type str, and grade of type int      \n        :return: None\n        >>> processor = StudentDatabaseProcessor(\"students.db\")\n        >>> processor.create_student_table()\n        \"\"\"\n        # Connect to the SQLite database\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n\n        # SQL query to create a new table if it doesn't exist\n        create_table_query = \"\"\"\n        CREATE TABLE IF NOT EXISTS students (\n            id INTEGER PRIMARY KEY,\n            name TEXT,\n            age INTEGER,\n            gender TEXT,\n            grade INTEGER\n        )\n        \"\"\"\n        # Execute the SQL query\n        cursor.execute(create_table_query)\n\n        # Commit the changes and close the connection\n        conn.commit()\n        conn.close()\n\n    def insert_student(self, student_data):\n        \"\"\"\n        Inserts a new student into the \"students\" table.\n        :param student_data: dict, a dictionary containing the student's information (name, age, gender, grade).\n        :return: None\n        >>> processor = StudentDatabaseProcessor(\"students.db\")\n        >>> processor.create_student_table()\n        >>> student_data = {'name': 'John', 'age': 15, 'gender': 'Male', 'grade': 9}\n        >>> processor.insert_student(student_data)\n        \"\"\"\n        # Connect to the SQLite database\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n\n        # SQL query to insert a new row into the table\n        insert_query = \"\"\"\n        INSERT INTO students (name, age, gender, grade)\n        VALUES (?, ?, ?, ?)\n        \"\"\"\n        # Execute the SQL query with the student data\n        cursor.execute(insert_query,\n                       (student_data['name'], student_data['age'], student_data['gender'], student_data['grade']))\n\n        # Commit the changes and close the connection\n        conn.commit()\n        conn.close()\n\n    def search_student_by_name(self, name):\n        \"\"\"\n        Searches for a student in the \"students\" table by their name.\n        :param name: str, the name of the student to search for.\n        :return: list of tuples, the rows from the \"students\" table that match the search criteria.\n        >>> processor = StudentDatabaseProcessor(\"students.db\")\n        >>> processor.create_student_table()\n        >>> result = processor.search_student_by_name(\"John\")\n        \"\"\"\n        # Connect to the SQLite database\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n\n        # SQL query to select rows from the table where the name matches the input\n        select_query = \"SELECT * FROM students WHERE name = ?\"\n        cursor.execute(select_query, (name,))\n        # Fetch all the matching rows\n        result = cursor.fetchall()\n\n        # Close the connection\n        conn.close()\n\n        # Return the result\n        return result\n\n    def delete_student_by_name(self, name):\n        \"\"\"\n        Deletes a student from the \"students\" table by their name.\n        :param name: str, the name of the student to delete.\n        :return: None\n        >>> processor = StudentDatabaseProcessor(\"students.db\")\n        >>> processor.create_student_table()\n        >>> student_data = {'name': 'John', 'age': 15, 'gender': 'Male', 'grade': 9}\n        >>> processor.insert_student(student_data)\n        >>> processor.delete_student_by_name(\"John\")\n        \"\"\"\n        # Connect to the SQLite database\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n\n        # SQL query to delete rows from the table where the name matches the input\n        delete_query = \"DELETE FROM students WHERE name = ?\"\n        cursor.execute(delete_query, (name,))\n\n        # Commit the changes and close the connection\n        conn.commit()\n        conn.close()"}, {"id": "84", "llm_annotated_code": "import json\n\nclass TextFileProcessor:\n    \"\"\"\n    The class handles reading, writing, and processing text files. It can read the file as JSON, read the raw text, write content to the file, and process the file by removing non-alphabetic characters.\n    \"\"\"\n\n    def __init__(self, file_path):\n        \"\"\"\n        Initialize the file path.\n        :param file_path: str\n        \"\"\"\n        # Store the file path\n        self.file_path = file_path\n\n    def read_file_as_json(self):\n        \"\"\"\n        Read the self.file_path file as json format.\n        if the file content doesn't obey json format, the code will raise error.\n        :return data: dict if the file is stored as json format, or str/int/float.. according to the file content otherwise.\n        >>> textFileProcessor = TextFileProcessor('test.json')\n        >>> textFileProcessor.read_file_as_json()\n        {'name': 'test', 'age': 12}\n        >>> type(textFileProcessor.read_file_as_json())\n        <class 'dict'>\n        \"\"\"\n        # Open the file in read mode\n        with open(self.file_path, 'r') as file:\n            # Use the json.load method to parse the file content as JSON\n            data = json.load(file)\n\n        # Return the parsed data\n        return data\n\n    def read_file(self):\n        \"\"\"\n        Read the return the content of self.file_path file.\n        :return: the same return as the read() method\n        >>> textFileProcessor = TextFileProcessor('test.json')\n        >>> textFileProcessor.read_file()\n        '{\n    \"name\": \"test\",\n    \"age\": 12\n}'\n        \"\"\"\n        # Open the file in read mode\n        with open(self.file_path, 'r') as file:\n            # Use the read method to get the file content\n            return file.read()\n\n    def write_file(self, content):\n        \"\"\"\n        Write content into the self.file_path file, and overwrite if the file has already existed.\n        :param content: any content\n        >>> textFileProcessor = TextFileProcessor('test.json')\n        >>> textFileProcessor.write_file('Hello world!')\n        >>> textFileProcessor.read_file()\n        'Hello world!'\n        \"\"\"\n        # Open the file in write mode\n        with open(self.file_path, 'w') as file:\n            # Use the write method to write the content to the file\n            file.write(content)\n\n    def process_file(self):\n        \"\"\"\n        Read the self.file_path file and filter out non-alphabetic characters from the content string.\n        Overwrite the after-processed data into the same self.file_path file.\n        >>> textFileProcessor = TextFileProcessor('test.json')\n        >>> textFileProcessor.read_file()\n        '{\n    \"name\": \"test\",\n    \"age\": 12\n}'\n        >>> textFileProcessor.process_file()\n        'nametestage'\n        \"\"\"\n        # Use the read_file method to get the file content\n        content = self.read_file()\n        # Use a list comprehension to filter out non-alphabetic characters\n        content = ''.join([char for char in content if char.isalpha()])\n        # Use the write_file method to overwrite the processed content to the file\n        self.write_file(content)\n        # Return the processed content\n        return content"}, {"id": "85", "llm_annotated_code": "class Thermostat:\n    \"\"\"\n    The class manages temperature control, including setting and retrieving the target temperature, adjusting the mode, and simulating temperature operation.\n    \"\"\"\n\n    def __init__(self, current_temperature, target_temperature, mode):\n        \"\"\"\n        initialize instances of the Thermostat class, including the current temperature, target temperature, and operating mode.\n        :param current_temperature: float\n        :param target_temperature: float\n        :param mode: str, the work mode\n        \"\"\"\n\n        # Initialize instance variables for current temperature, target temperature and mode\n        self.current_temperature = current_temperature\n        self.target_temperature = target_temperature\n        self.mode = mode\n\n    def get_target_temperature(self):\n        \"\"\"\n        Get the target temperature of an instance of the Thermostat class.\n        :return self.current_temperature: int\n        \"\"\"\n\n        # Return the target temperature of the thermostat\n        return self.target_temperature\n\n    def set_target_temperature(self, temperature):\n        \"\"\"\n        Set the target temperature\n        :param temperature: float, the target temperature\n        \"\"\"\n\n        # Set the target temperature of the thermostat\n        self.target_temperature = temperature\n\n    def get_mode(self):\n        \"\"\"\n        Get the current work mode\n        :return mode: str, working mode. only ['heat', 'cool']\n        \"\"\"\n\n        # Return the current mode of the thermostat\n        return self.mode\n\n    def set_mode(self, mode):\n        \"\"\"\n        Get the current work mode\n        :param mode: str, working mode. only ['heat', 'cool']\n        \"\"\"\n\n        # Check if the provided mode is either 'heat' or 'cool'\n        # If so, set the mode of the thermostat\n        # Otherwise, return False\n        if mode in ['heat', 'cool']:\n            self.mode = mode\n        else:\n            return False\n\n    def auto_set_mode(self):\n        \"\"\"\n        Automatically set the operating mode by comparing with the current temperature and target temperature. If the current temperature is lower than the target temperature, the operating mode is set to 'heat', otherwise it is set to 'cool'.\n        \"\"\"\n\n        # Check if the current temperature is less than the target temperature\n        # If so, set the mode of the thermostat to 'heat'\n        # Otherwise, set the mode to 'cool'\n        if self.current_temperature < self.target_temperature:\n            self.mode = 'heat'\n        else:\n            self.mode = 'cool'\n\n    def auto_check_conflict(self):\n        \"\"\"\n        Check if there is a conflict between the operating mode and the relationship between the current temperature and the target temperature.\n        If there is a conflict, the operating mode will be adjusted automatically.\n        :return: True if mode isn't conflict with the relationship between the current temperature and the target temperature, or False otherwise.\n        \"\"\"\n\n        # Check if the current temperature is greater than the target temperature\n        # If so, check if the mode of the thermostat is 'cool'\n        # If so, return True\n        # Otherwise, call the auto_set_mode method to automatically set the mode and return False\n        # If the current temperature is not greater than the target temperature, check if the mode of the thermostat is 'heat'\n        # If so, return True\n        # Otherwise, call the auto_set_mode method to automatically set the mode and return False\n        if self.current_temperature > self.target_temperature:\n            if self.mode == 'cool':\n                return True\n            else:\n                self.auto_set_mode()\n                return False\n        else:\n            if self.mode == 'heat':\n                return True\n            else:\n                self.auto_set_mode()\n                return False\n\n    def simulate_operation(self):\n        \"\"\"\n        simulate the operation of Thermostat. It will automatically start the auto_set_mode method to set the operating mode,\n        and then automatically adjust the current temperature according to the operating mode until the target temperature is reached.\n        :return time: int, the time it took to complete the simulation.\n        \"\"\"\n\n        # Call the auto_set_mode method to automatically set the mode of the thermostat\n        self.auto_set_mode()\n\n        # Initialize a variable to keep track of the time it takes to reach the target temperature\n        use_time = 0\n\n        # Check if the mode of the thermostat is 'heat'\n        # If so, increment the current temperature and the time until the current temperature is equal to the target temperature\n        # If the mode is not 'heat', decrement the current temperature and the time until the current temperature is equal to the target temperature\n        if self.mode == 'heat':\n            while(self.current_temperature < self.target_temperature):\n                self.current_temperature += 1\n                use_time += 1\n        else:\n            while(self.current_temperature > self.target_temperature):\n                self.current_temperature -= 1\n                use_time += 1\n\n        # Return the time it took to reach the target temperature\n        return use_time"}, {"id": "86", "llm_annotated_code": "class TicTacToe:\n    \"\"\"\n    The class represents a game of Tic-Tac-Toe and its functions include making a move on the board, checking for a winner, and determining if the board is full.\n    \"\"\"\n\n    def __init__(self, N=3):\n        \"\"\"\n        Initialize a 3x3 game board with all empty spaces and current symble player, default is 'X'.\n        \"\"\"\n        # Initialize a 3x3 game board with all empty spaces\n        self.board = [[' ' for _ in range(N)] for _ in range(3)]\n        # Initialize the current player as 'X'\n        self.current_player = 'X'\n\n    def make_move(self, row, col):\n        \"\"\"\n        Place the current player's mark at the specified position on the board and switch the mark.\n        :param row: int, the row index of the position\n        :param col: int, the column index of the position\n        :return: bool, indicating whether the move was successful or not\n        \"\"\"\n        # Check if the specified position on the board is empty\n        if self.board[row][col] == ' ':\n            # If it is, place the current player's mark at the position\n            self.board[row][col] = self.current_player\n            # Switch the current player's mark\n            self.current_player = 'O' if self.current_player == 'X' else 'X'\n            # Return True to indicate that the move was successful\n            return True\n        else:\n            # If the specified position on the board is not empty, return False to indicate that the move was not successful\n            return False\n\n    def check_winner(self):\n        \"\"\"\n        Check if there is a winner on the board in rows, columns and diagonals three directions\n        :return: str or None, the mark of the winner ('X' or 'O'), or None if there is no winner yet\n        \"\"\"\n        # Check each row for a winner\n        for row in self.board:\n            if row[0] == row[1] == row[2] != ' ':\n                return row[0]\n        # Check each column for a winner\n        for col in range(3):\n            if self.board[0][col] == self.board[1][col] == self.board[2][col] != ' ':\n                return self.board[0][col]\n        # Check the two diagonals for a winner\n        if self.board[0][0] == self.board[1][1] == self.board[2][2] != ' ':\n            return self.board[0][0]\n        if self.board[0][2] == self.board[1][1] == self.board[2][0] != ' ':\n            return self.board[0][2]\n        # If no winner is found, return None\n        return None\n\n    def is_board_full(self):\n        \"\"\"\n        Check if the game board is completely filled.\n        :return: bool, indicating whether the game board is full or not\n        \"\"\"\n        # Check each row for an empty space\n        for row in self.board:\n            if ' ' in row:\n                # If an empty space is found, return False to indicate that the board is not full\n                return False\n        # If no empty space is found, return True to indicate that the board is full\n        return True"}, {"id": "87", "llm_annotated_code": "import datetime\nimport time\n\nclass TimeUtils:\n    \"\"\"\n    This is a time util class, including getting the current time and date, adding seconds to a datetime, converting between strings and datetime objects, calculating the time difference in minutes, and formatting a datetime object.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Get the current datetime\n        \"\"\"\n        # Use the datetime.datetime.now() method to get the current datetime and store it in self.datetime\n        self.datetime = datetime.datetime.now()\n\n    def get_current_time(self):\n        \"\"\"\n        Return the current time in the format of '%H:%M:%S'\n        :return: string\n        >>> timeutils = TimeUtils()\n        >>> timeutils.get_current_time()\n        \"19:19:22\"\n        \"\"\"\n        # Define the time format\n        format = \"%H:%M:%S\"\n        # Use the strftime method to format the current datetime as a string in the specified format and return it\n        return self.datetime.strftime(format)\n\n    def get_current_date(self):\n        \"\"\"\n        Return the current date in the format of \"%Y-%m-%d\"\n        :return: string\n        >>> timeutils.get_current_date()\n        \"2023-06-14\"\n        \"\"\"\n        # Define the date format\n        format = \"%Y-%m-%d\"\n        # Use the strftime method to format the current datetime as a string in the specified format and return it\n        return self.datetime.strftime(format)\n\n    def add_seconds(self, seconds):\n        \"\"\"\n        Add the specified number of seconds to the current time\n        :param seconds: int, number of seconds to add\n        :return: string, time after adding the specified number of seconds in the format '%H:%M:%S'\n        >>> timeutils.add_seconds(600)\n        \"19:29:22\"\n        \"\"\"\n        # Use the datetime.timedelta method to create a timedelta object representing the specified number of seconds\n        # Add this timedelta to the current datetime to get a new datetime\n        new_datetime = self.datetime + datetime.timedelta(seconds=seconds)\n        # Define the time format\n        format = \"%H:%M:%S\"\n        # Use the strftime method to format the new datetime as a string in the specified format and return it\n        return new_datetime.strftime(format)\n\n    def string_to_datetime(self, string):\n        \"\"\"\n        Convert the time string to a datetime instance\n        :param string: string, string before converting format\n        :return: datetime instance\n        >>> timeutils.string_to_datetime(\"2001-7-18 1:1:1\")\n        2001-07-18 01:01:01\n        \"\"\"\n        # Use the datetime.datetime.strptime method to convert the string to a datetime object in the specified format and return it\n        return datetime.datetime.strptime(string, \"%Y-%m-%d %H:%M:%S\")\n\n    def datetime_to_string(self, datetime):\n        \"\"\"\n        Convert a datetime instance to a string\n        :param datetime: the datetime instance to convert\n        :return: string, converted time string\n        >>> timeutils.datetime_to_string(timeutils.datetime)\n        \"2023-06-14 19:30:03\"\n        \"\"\"\n        # Use the strftime method to format the datetime as a string in the specified format and return it\n        return datetime.strftime(\"%Y-%m-%d %H:%M:%S\")\n\n    def get_minutes(self, string_time1, string_time2):\n        \"\"\"\n        Calculate how many minutes have passed between two times, and round the results to the nearest\n        :return: int, the number of minutes between two times, rounded off\n        >>> timeutils.get_minutes(\"2001-7-18 1:1:1\", \"2001-7-18 2:1:1\")\n        60\n        \"\"\"\n        # Use the string_to_datetime method to convert the time strings to datetime objects\n        time1 = self.string_to_datetime(string_time1)\n        time2 = self.string_to_datetime(string_time2)\n        # Subtract the two datetime objects to get a timedelta object\n        # Use the seconds attribute of the timedelta object to get the number of seconds\n        # Divide by 60 to get the number of minutes and round the result to the nearest integer\n        return round((time2 - time1).seconds / 60)\n\n    def get_format_time(self, year, month, day, hour, minute, second):\n        \"\"\"\n        get format time\n        :param year: int\n        :param month: int\n        :param day: int\n        :param hour: int\n        :param minute: int\n        :param second: int\n        :return: formatted time string\n        >>> timeutils.get_format_time(2001, 7, 18, 1, 1, 1)\n        \"2001-07-18 01:01:01\"\n        \"\"\"\n        # Define the time format\n        format = \"%Y-%m-%d %H:%M:%S\"\n        # Use the datetime.datetime method to create a datetime object with the specified year, month, day, hour, minute, and second\n        time_item = datetime.datetime(year, month, day, hour, minute, second)\n        # Use the strftime method to format the datetime object as a string in the specified format and return it\n        return time_item.strftime(format)"}, {"id": "88", "llm_annotated_code": "class TriCalculator:\n    \"\"\"\n    The class allows to calculate trigonometric values, including cosine, sine, and tangent, using Taylor series approximations.\n    \"\"\"\n\n    def __init__(self):\n        pass\n\n    def cos(self, x):\n        \"\"\"\n        Calculate the cos value of the x-degree angle\n        :param x:float\n        :return:float\n        >>> tricalculator = TriCalculator()\n        >>> tricalculator.cos(60)\n        0.5\n        \"\"\"\n        # Use the taylor method to calculate the cosine value of the x-degree angle\n        # Round the result to 10 decimal places\n        return round(self.taylor(x, 50), 10)\n\n    def factorial(self, a):\n        \"\"\"\n        Calculate the factorial of a\n        :param a: int\n        :return: int\n        >>> tricalculator.factorial(5)\n        120\n        \"\"\"\n        b = 1\n        # Calculate the factorial of a using a while loop\n        while a != 1:\n            b *= a\n            a -= 1\n        return b\n\n    def taylor(self, x, n):\n        \"\"\"\n        Finding the n-order Taylor expansion value of cos (x/180 * pi)\n        :param x: int\n        :param n: int\n        :return: float\n        >>> tricalculator.taylor(60, 50)\n        0.5000000000000001\n        \"\"\"\n        a = 1\n        # Convert the degree to radian\n        x = x / 180 * pi\n        count = 1\n        # Calculate the n-order Taylor expansion value of cos (x/180 * pi)\n        for k in range(1, n):\n            if count % 2 != 0:\n                a -= (x ** (2 * k)) / self.factorial(2 * k)\n            else:\n                a += (x ** (2 * k)) / self.factorial(2 * k)\n            count += 1\n        return a\n\n    def sin(self, x):\n        \"\"\"\n        Calculate the sin value of the x-degree angle\n        :param x: float\n        :return: float\n        >>> tricalculator.sin(30)\n        0.5\n        \"\"\"\n        # Convert the degree to radian\n        x = x / 180 * pi\n        g = 0\n        t = x\n        n = 1\n        # Calculate the sin value of the x-degree angle using Taylor series approximation\n        while fabs(t) >= 1e-15:\n            g += t\n            n += 1\n            t = -t * x * x / (2 * n - 1) / (2 * n - 2)\n        # Round the result to 10 decimal places\n        return round(g, 10)\n\n    def tan(self, x):\n        \"\"\"\n        Calculate the tan value of the x-degree angle\n        :param x: float\n        :return: float\n        >>> tricalculator.tan(45)\n        1.0\n        \"\"\"\n        # Check if the cosine of the angle is not zero to avoid division by zero\n        if self.cos(x) != 0:\n            # Calculate the tangent of the angle as the ratio of the sine to the cosine\n            result = self.sin(x) / self.cos(x)\n            # Round the result to 10 decimal places\n            return round(result, 10)\n        else:\n            # Return False if the cosine of the angle is zero\n            return False"}, {"id": "89", "llm_annotated_code": "class TwentyFourPointGame:\n    \"\"\"\n    This ia a game of twenty-four points, which provides to generate four numbers and check whether player's expression is equal to 24.\n    \"\"\"\n\n    def __init__(self) -> None:\n        # Initialize an empty list to store the numbers for the game\n        self.nums = []\n\n    def _generate_cards(self):\n        \"\"\"\n        Generate random numbers between 1 and 9 for the cards.\n        \"\"\"\n        # Use a for loop to generate 4 random numbers between 1 and 9\n        # Use the random.randint function to generate the random numbers\n        # Append each generated number to the self.nums list\n        for i in range(4):\n            self.nums.append(random.randint(1, 9))\n        # Assert that the length of self.nums is 4\n        assert len(self.nums) == 4\n\n    def get_my_cards(self):\n        \"\"\"\n        Get a list of four random numbers between 1 and 9 representing the player's cards.\n        :return: list of integers, representing the player's cards\n        \"\"\"\n        # Clear the self.nums list\n        self.nums = []\n        # Call the _generate_cards method to generate 4 random numbers and store them in self.nums\n        self._generate_cards()\n        # Return the self.nums list\n        return self.nums\n\n    def answer(self, expression):\n        \"\"\"\n        Check if a given mathematical expression using the cards can evaluate to 24.\n        :param expression: string, mathematical expression using the cards\n        :return: bool, True if the expression evaluates to 24, False otherwise\n        \"\"\"\n        # If the expression is 'pass', call the get_my_cards method and return the result\n        if expression == 'pass':\n            return self.get_my_cards()\n        \n        # Initialize an empty dictionary to store the count of each number in the expression\n        statistic = {}\n        # Iterate through each character in the expression\n        for c in expression:\n            # If the character is a digit and it is in self.nums, increment its count in the statistic dictionary\n            if c.isdigit() and int(c) in self.nums:\n                statistic[c] = statistic.get(c, 0) + 1\n\n        # Copy the statistic dictionary to nums_used\n        nums_used = statistic.copy()\n\n        # Iterate through each number in self.nums\n        for num in self.nums:\n            # If the number is in nums_used and its count is greater than 0, decrement its count in nums_used\n            # Otherwise, return False\n            if nums_used.get(str(num), -100) != -100 and nums_used[str(num)] > 0:\n                nums_used[str(num)] -= 1\n            else:\n                return False\n\n        # If all counts in nums_used are 0, call the evaluate_expression method with the expression and return the result\n        # Otherwise, return False\n        if all(count == 0 for count in nums_used.values()) == True:\n            return self.evaluate_expression(expression)\n        else:\n            return False\n\n    def evaluate_expression(self, expression):\n        \"\"\"\n        Evaluate a mathematical expression and check if the result is 24.\n        :param expression: string, mathematical expression\n        :return: bool, True if the expression evaluates to 24, False otherwise\n        \"\"\"\n        try:\n            # Use the eval function to evaluate the expression\n            # If the result is 24, return True\n            # Otherwise, return False\n            if eval(expression) == 24:\n                return True\n            else:\n                return False\n        except Exception as e:\n            # If an exception occurs during the evaluation, return False\n            return False"}, {"id": "90", "llm_annotated_code": "class URLHandler:\n    \"\"\"\n    The class supports to handle URLs, including extracting the scheme, host, path, query parameters, and fragment.\n    \"\"\"\n\n    def __init__(self, url):\n        \"\"\"\n        Initialize URLHandler's URL\n        \"\"\"\n        # Store the provided URL in the instance variable self.url\n        self.url = url\n\n    def get_scheme(self):\n        \"\"\"\n        get the scheme of the URL\n        :return: string, If successful, return the scheme of the URL\n        >>> urlhandler = URLHandler(\"https://www.baidu.com/s?wd=aaa&rsv_spt=1#page\")\n        >>> urlhandler.get_scheme()\n        \"https\"\n        \"\"\"\n        # Find the end of the scheme in the URL (denoted by \"://\")\n        scheme_end = self.url.find(\"://\")\n        if scheme_end != -1:\n            # If a scheme is found, return it\n            return self.url[:scheme_end]\n        # If no scheme is found, return None\n        return None\n\n\n    def get_host(self):\n        \"\"\"\n        Get the second part of the URL, which is the host domain name\n        :return: string, If successful, return the host domain name of the URL\n        >>> urlhandler = URLHandler(\"https://www.baidu.com/s?wd=aaa&rsv_spt=1#page\")\n        >>> urlhandler.get_host()\n        \"www.baidu.com\"\n        \"\"\"\n        # Find the end of the scheme in the URL (denoted by \"://\")\n        scheme_end = self.url.find(\"://\")\n        if scheme_end != -1:\n            # Remove the scheme from the URL\n            url_without_scheme = self.url[scheme_end + 3:]\n            # Find the end of the host in the URL (denoted by \"/\")\n            host_end = url_without_scheme.find(\"/\")\n            if host_end != -1:\n                # If a host is found, return it\n                return url_without_scheme[:host_end]\n            # If no \"/\" is found, the entire string is the host\n            return url_without_scheme\n        # If no scheme is found, return None\n        return None\n\n\n    def get_path(self):\n        \"\"\"\n        Get the third part of the URL, which is the address of the resource\n        :return: string, If successful, return the address of the resource of the URL\n        >>> urlhandler = URLHandler(\"https://www.baidu.com/s?wd=aaa&rsv_spt=1#page\")\n        >>> urlhandler.get_path()\n        \"/s?wd=aaa&rsv_spt=1#page\"\n        \"\"\"\n        # Find the end of the scheme in the URL (denoted by \"://\")\n        scheme_end = self.url.find(\"://\")\n        if scheme_end != -1:\n            # Remove the scheme from the URL\n            url_without_scheme = self.url[scheme_end + 3:]\n            # Find the end of the host in the URL (denoted by \"/\")\n            host_end = url_without_scheme.find(\"/\")\n            if host_end != -1:\n                # If a path is found, return it\n                return url_without_scheme[host_end:]\n        # If no scheme is found, return None\n        return None\n\n\n    def get_query_params(self):\n        \"\"\"\n        Get the request parameters for the URL\n        :return: dict, If successful, return the request parameters of the URL\n        >>> urlhandler = URLHandler(\"https://www.baidu.com/s?wd=aaa&rsv_spt=1#page\")\n        >>> urlhandler.get_query_params()\n        {\"wd\": \"aaa\", \"rsv_spt\": \"1\"}\n        \"\"\"\n        # Find the start of the query parameters in the URL (denoted by \"?\")\n        query_start = self.url.find(\"?\")\n        # Find the start of the fragment in the URL (denoted by \"#\")\n        fragment_start = self.url.find(\"#\")\n        if query_start != -1:\n            # Extract the query string from the URL\n            query_string = self.url[query_start + 1:fragment_start]\n            params = {}\n            if len(query_string) > 0:\n                # Split the query string into key-value pairs\n                param_pairs = query_string.split(\"&\")\n                for pair in param_pairs:\n                    # Split each pair into a key and a value\n                    key_value = pair.split(\"=\")\n                    if len(key_value) == 2:\n                        key, value = key_value\n                        # Store the key-value pair in the params dictionary\n                        params[key] = value\n            # Return the params dictionary\n            return params\n        # If no query parameters are found, return None\n        return None\n\n\n    def get_fragment(self):\n        \"\"\"\n        Get the fragment after '#' in the URL\n        :return: string, If successful, return the fragment after '#' of the URL\n        >>> urlhandler = URLHandler(\"https://www.baidu.com/s?wd=aaa&rsv_spt=1#page\")\n        >>> urlhandler.get_fragment()\n        \"page\"\n        \"\"\"\n        # Find the start of the fragment in the URL (denoted by \"#\")\n        fragment_start = self.url.find(\"#\")\n        if fragment_start != -1:\n            # If a fragment is found, return it\n            return self.url[fragment_start + 1:]\n        # If no fragment is found, return None\n        return None"}, {"id": "91", "llm_annotated_code": "class UrlPath:\n    \"\"\"\n    The  class is a utility for encapsulating and manipulating the path component of a URL, including adding nodes, parsing path strings, and building path strings with optional encoding.      \n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initializes the UrlPath object with an empty list of segments and a flag indicating the presence of an end tag.\n        \"\"\"\n        # Initialize an empty list to store the segments of the URL path\n        self.segments = []\n        \n        # Initialize a flag to indicate whether the URL path ends with a slash\n        self.with_end_tag = False\n\n    def add(self, segment):\n        \"\"\"\n        Adds a segment to the list of segments in the UrlPath.\n        :param segment: str, the segment to add.\n        >>> url_path = UrlPath()\n        >>> url_path.add('foo')\n        >>> url_path.add('bar')\n\n        url_path.segments = ['foo', 'bar']\n        \"\"\"\n        # Add the segment to the list of segments after removing leading and trailing slashes\n        self.segments.append(self.fix_path(segment))\n\n\n    def parse(self, path, charset):\n        \"\"\"\n        Parses a given path string and populates the list of segments in the UrlPath.\n        :param path: str, the path string to parse.\n        :param charset: str, the character encoding of the path string.\n        >>> url_path = UrlPath()\n        >>> url_path.parse('/foo/bar/', 'utf-8')\n\n        url_path.segments = ['foo', 'bar']\n        \"\"\"\n        # If the path is not empty\n        if path:\n            # If the path ends with a slash, set the with_end_tag flag to True\n            if path.endswith('/'):\n                self.with_end_tag = True\n\n            # Remove leading and trailing slashes from the path\n            path = self.fix_path(path)\n            \n            # If the path is not empty after removing slashes\n            if path:\n                # Split the path into segments using the slash as a delimiter\n                split = path.split('/')\n                \n                # For each segment in the split path\n                for seg in split:\n                    # Decode the segment using the provided charset and add it to the list of segments\n                    decoded_seg = urllib.parse.unquote(seg, encoding=charset)\n                    self.segments.append(decoded_seg)\n\n\n    @staticmethod\n    def fix_path(path):\n        \"\"\"\n        Fixes the given path string by removing leading and trailing slashes.\n        :param path: str, the path string to fix.\n        :return: str, the fixed path string.\n        >>> url_path = UrlPath()\n        >>> url_path.fix_path('/foo/bar/')\n        'foo/bar'\n\n        \"\"\"\n        # If the path is empty, return an empty string\n        if not path:\n            return ''\n\n        # Remove leading and trailing slashes from the path and return the result\n        segment_str = path.strip('/')\n        return segment_str"}, {"id": "92", "llm_annotated_code": "class UserLoginDB:\n    \"\"\"\n    This is a database management class for user login verification, providing functions for inserting user information, searching user information, deleting user information, and validating user login.\n    \"\"\"\n\n    def __init__(self, db_name):\n        \"\"\"\n        Initializes the UserLoginDB object with the specified database name.\n        :param db_name: str, the name of the SQLite database.\n        \"\"\"\n        # Connect to the SQLite database with the given name and create a cursor object for executing SQL commands\n        self.connection = sqlite3.connect(db_name)\n        self.cursor = self.connection.cursor()\n\n    def insert_user(self, username, password):\n        \"\"\"\n        Inserts a new user into the \"users\" table.\n        :param username: str, the username of the user.\n        :param password: str, the password of the user.\n        :return: None\n        >>> user_db = UserLoginDB(\"user_database.db\")\n        >>> user_db.create_table()\n        >>> user_db.insert_user('user1', 'pass1')\n        \"\"\"\n        # Execute an SQL command to insert a new row into the \"users\" table with the given username and password\n        self.cursor.execute(\"\"\"\n            INSERT INTO users (username, password)\n            VALUES (?, ?)\n        \"\"\", (username, password))\n        # Commit the changes to the database\n        self.connection.commit()\n\n\n    def search_user_by_username(self, username):\n        \"\"\"\n        Searches for users in the \"users\" table by username.\n        :param username: str, the username of the user to search for.\n        :return:list of tuples, the rows from the \"users\" table that match the search criteria.\n        >>> user_db = UserLoginDB(\"user_database.db\")\n        >>> user_db.create_table()\n        >>> user_db.insert_user('user1', 'pass1')\n        >>> result = user_db.search_user_by_username('user1')\n        len(result) = 1\n        \"\"\"\n        # Execute an SQL command to select the row from the \"users\" table where the username matches the given username\n        self.cursor.execute(\"\"\"\n            SELECT * FROM users WHERE username = ?\n        \"\"\", (username,))\n        # Fetch the first row from the results of the SQL command\n        user = self.cursor.fetchone()\n        # Return the fetched row\n        return user\n\n\n    def delete_user_by_username(self, username):\n        \"\"\"\n        Deletes a user from the \"users\" table by username.\n        :param username: str, the username of the user to delete.\n        :return: None\n        >>> user_db = UserLoginDB(\"user_database.db\")\n        >>> user_db.create_table()\n        >>> user_db.insert_user('user1', 'pass1')\n        >>> user_db.delete_user_by_username('user1')\n        \"\"\"\n        # Execute an SQL command to delete the row from the \"users\" table where the username matches the given username\n        self.cursor.execute(\"\"\"\n            DELETE FROM users WHERE username = ?\n        \"\"\", (username,))\n        # Commit the changes to the database\n        self.connection.commit()\n\n\n    def validate_user_login(self, username, password):\n        \"\"\"\n        Determine whether the user can log in, that is, the user is in the database and the password is correct\n        :param username:str, the username of the user to validate.\n        :param password:str, the password of the user to validate.\n        :return:bool, representing whether the user can log in correctly\n        >>> user_db = UserLoginDB(\"user_database.db\")\n        >>> user_db.create_table()\n        >>> user_db.insert_user('user1', 'pass1')\n        >>> user_db.validate_user_login('user1', 'pass1')\n        True\n        \"\"\"\n        # Use the search_user_by_username method to get the user with the given username\n        user = self.search_user_by_username(username)\n        # If the user exists and the password matches the given password, return True\n        # Otherwise, return False\n        if user is not None and user[1] == password:\n            return True\n        return False"}, {"id": "94", "llm_annotated_code": "class VendingMachine:\n    \"\"\"\n    This is a class to simulate a vending machine, including adding products, inserting coins, purchasing products, viewing balance, replenishing product inventory, and displaying product information.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initializes the vending machine's inventory and balance.\n        \"\"\"\n        # Initialize an empty dictionary to store the inventory of the vending machine\n        self.inventory = {}\n        # Initialize the balance of the vending machine to 0\n        self.balance = 0\n\n    def add_item(self, item_name, price, quantity):\n        \"\"\"\n        Adds a product to the vending machine's inventory.\n        :param item_name: The name of the product to be added, str.\n        :param price: The price of the product to be added, float.\n        :param quantity: The quantity of the product to be added, int.\n        :return: None\n        \"\"\"\n        # Check if the item is already in the inventory using the restock_item method\n        # If not, add the item to the inventory with its price and quantity\n        if not self.restock_item(item_name, quantity):\n            self.inventory[item_name] = {'price': price, 'quantity': quantity}\n\n    def insert_coin(self, amount):\n        \"\"\"\n        Inserts coins into the vending machine.\n        :param amount: The amount of coins to be inserted, float.\n        :return: The balance of the vending machine after the coins are inserted, float.\n        \"\"\"\n        # Add the inserted amount to the balance\n        self.balance += amount\n        # Return the updated balance\n        return self.balance\n\n    def purchase_item(self, item_name):\n        \"\"\"\n        Purchases a product from the vending machine and returns the balance after the purchase and display purchase unsuccessful if the product is out of stock.\n        :param item_name: The name of the product to be purchased, str.\n        :return: If successful, returns the balance of the vending machine after the product is purchased, float,otherwise,returns False.\n        \"\"\"\n        # Check if the item is in the inventory\n        if item_name in self.inventory:\n            item = self.inventory[item_name]\n            # Check if the item is in stock and if the balance is sufficient to purchase the item\n            if item['quantity'] > 0 and self.balance >= item['price']:\n                # Deduct the price of the item from the balance\n                self.balance -= item['price']\n                # Decrease the quantity of the item in the inventory\n                item['quantity'] -= 1\n                # Return the updated balance\n                return self.balance\n            else:\n                # Return False if the item is out of stock or the balance is insufficient\n                return False\n        else:\n            # Return False if the item is not in the inventory\n            return False\n\n    def restock_item(self, item_name, quantity):\n        \"\"\"\n        Replenishes the inventory of a product already in the vending machine.\n        :param item_name: The name of the product to be replenished, str.\n        :param quantity: The quantity of the product to be replenished, int.\n        :return: If the product is already in the vending machine, returns True, otherwise, returns False.\n        \"\"\"\n        # Check if the item is in the inventory\n        if item_name in self.inventory:\n            # Increase the quantity of the item in the inventory\n            self.inventory[item_name]['quantity'] += quantity\n            # Return True if the item is in the inventory\n            return True\n        else:\n            # Return False if the item is not in the inventory\n            return False\n\n    def display_items(self):\n        \"\"\"\n        Displays the products in the vending machine.\n        :return: If the vending machine is empty, returns False, otherwise, returns a list of the products in the vending machine, str.\n        \"\"\"\n        # Check if the inventory is empty\n        if not self.inventory:\n            # Return False if the inventory is empty\n            return False\n        else:\n            # Initialize an empty list to store the items in the inventory\n            items = []\n            # Iterate through the items in the inventory\n            for item_name, item_info in self.inventory.items():\n                # Append each item to the items list in the format \"item_name - $price [quantity]\"\n                items.append(f\"{item_name} - ${item_info['price']} [{item_info['quantity']}]\")\n            # Return the items list as a string, with each item on a new line\n            return \"\\n\".join(items)"}, {"id": "95", "llm_annotated_code": "class Warehouse:\n    \"\"\"\n    The class manages inventory and orders, including adding products, updating product quantities, retrieving product quantities, creating orders, changing order statuses, and tracking orders.    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize two fields.\n        self.inventory is a dict that stores the products.\n        self.inventory = {Product ID: Product}\n        self.orders is a dict that stores the products in a order.\n        self.orders = {Order ID: Order}\n        \"\"\"\n        # Initialize inventory and orders as empty dictionaries\n        self.inventory = {}  # Product ID: Product\n        self.orders = {}  # Order ID: Order\n\n    def add_product(self, product_id, name, quantity):\n        \"\"\"\n        Add product to inventory and plus the quantity if it has existed in inventory.\n        Or just add new product to dict otherwise.\n        :param product_id: int\n        :param name: str, product name\n        :param quantity: int, product quantity\n        \"\"\"\n        # Check if product_id is already in inventory\n        if product_id not in self.inventory:\n            # If not, add new product to inventory with given name and quantity\n            self.inventory[product_id] = {'name': name, 'quantity': quantity}\n        else:\n            # If yes, increase the quantity of the product in inventory\n            self.inventory[product_id]['quantity'] += quantity\n\n    def update_product_quantity(self, product_id, quantity):\n        \"\"\"\n        According to product_id, add the quantity to the corresponding product in inventory.\n        \"\"\"\n        # Check if product_id is in inventory\n        if product_id in self.inventory:\n            # If yes, increase or decrease the quantity of the product in inventory\n            self.inventory[product_id]['quantity'] += quantity\n\n    def get_product_quantity(self, product_id):\n        \"\"\"\n        Get the quantity of specific product by product_id.\n        :param product_id, int\n        :return: if the product_id is in inventory then return the corresponding quantity,\n                or False otherwise.\n        \"\"\"\n        # Check if product_id is in inventory\n        if product_id in self.inventory:\n            # If yes, return the quantity of the product\n            return self.inventory[product_id]['quantity']\n        else:\n            # If no, return False\n            return False\n\n    def create_order(self, order_id, product_id, quantity):\n        \"\"\"\n        Create a order which includes the infomation of product, like id and quantity.\n        And put the new order into self.orders.\n        The default value of status is 'Shipped'.\n        :param order_id: int\n        :param product_id: int\n        :param quantity: the quantity of product that be selected.\n        :return False: only if product_id is not in inventory or the quantity is not adequate\n        \"\"\"\n        # Check if the quantity of the product in inventory is enough for the order\n        if self.get_product_quantity(product_id) >= quantity:\n            # If yes, decrease the quantity of the product in inventory and create a new order with given order_id, product_id, quantity, and status 'Shipped'\n            self.update_product_quantity(product_id, -quantity)\n            self.orders[order_id] = {'product_id': product_id, 'quantity': quantity, 'status': 'Shipped'}\n        else:\n            # If no, return False\n            return False\n\n    def change_order_status(self, order_id, status):\n        \"\"\"\n        Change the status of order if the input order_id is in self.orders.\n        :param order_id: int\n        :param status: str, the state that is going to change to\n        :return False: only if the order_id is not in self.orders\n        \"\"\"\n        # Check if order_id is in orders\n        if order_id in self.orders:\n            # If yes, change the status of the order to the given status\n            self.orders[order_id]['status'] = status\n        else:\n            # If no, return False\n            return False\n\n    def track_order(self, order_id):\n        \"\"\"\n        Get the status of specific order.\n        :param order_id: int\n        :return False: only if the order_id is not in self.orders.\n        \"\"\"\n        # Check if order_id is in orders\n        if order_id in self.orders:\n            # If yes, return the status of the order\n            return self.orders[order_id]['status']\n        else:\n            # If no, return False\n            return False"}, {"id": "96", "llm_annotated_code": "class WeatherSystem:\n    \"\"\"\n    This is a class representing a weather system that provides functionality to query weather information for a specific city and convert temperature units between Celsius and Fahrenheit.     \n    \"\"\"\n\n    def __init__(self, city) -> None:\n        \"\"\"\n        Initialize the weather system with a city name.\n        \"\"\"\n        # Initialize class attributes: temperature, weather, city, and weather_list\n        self.temperature = None\n        self.weather = None\n        self.city = city\n        self.weather_list = {}\n\n    def query(self, weather_list, tmp_units = 'celsius'):\n        \"\"\"\n        Query the weather system for the weather and temperature of the city,and convert the temperature units based on the input parameter.\n        :param weather_list: a dictionary of weather information for different cities,dict.\n        :param tmp_units: the temperature units to convert to, str.\n        :return: the temperature and weather of the city, tuple.\n        >>> weatherSystem = WeatherSystem('New York')\n        >>> weather_list = {'New York': {'weather': 'sunny','temperature': 27,'temperature units': 'celsius'},'Beijing': {'weather': 'cloudy','temperature': 23,'temperature units': 'celsius'}} \n        >>> weatherSystem.query(weather_list)\n        (27, 'sunny')\n\n        \"\"\"\n        # Store the weather_list in the class attribute\n        self.weather_list = weather_list\n\n        # Check if the city is in the weather_list\n        if self.city not in weather_list:\n            return False\n        else:\n            # If the city is in the weather_list, store the temperature and weather in the class attributes\n            self.temperature = self.weather_list[self.city]['temperature']\n            self.weather = self.weather_list[self.city]['weather']\n\n        # Check if the temperature units in the weather_list match the desired units\n        if self.weather_list[self.city]['temperature units'] != tmp_units:\n            # If the units don't match, convert the temperature to the desired units\n            if tmp_units == 'celsius':\n                return self.fahrenheit_to_celsius(), self.weather\n            elif tmp_units == 'fahrenheit':\n                return self.celsius_to_fahrenheit(), self.weather\n        else:\n            # If the units match, return the temperature and weather\n            return self.temperature, self.weather\n\n    def set_city(self, city):\n        \"\"\"\n        Set the city of the weather system.\n        :param city: the city to set, str.\n        :return: None\n        >>> weatherSystem = WeatherSystem('New York')\n        >>> weatherSystem.set_city('Beijing')\n        >>> weatherSystem.city\n        'Beijing'\n\n        \"\"\"\n        # Update the city attribute with the new city\n        self.city = city\n\n    def celsius_to_fahrenheit(self):\n        \"\"\"\n        Convert the temperature from Celsius to Fahrenheit.\n        :return: the temperature in Fahrenheit, float.\n        >>> weatherSystem = WeatherSystem('New York')\n        >>> weatherSystem.temperature = 27\n        >>> weatherSystem.celsius_to_fahrenheit()\n        80.6\n\n        \"\"\"\n        # Convert the temperature from Celsius to Fahrenheit and return the result\n        return (self.temperature * 9/5) + 32\n\n    def fahrenheit_to_celsius(self):\n        \"\"\"\n        Convert the temperature from Fahrenheit to Celsius.\n        :return: the temperature in Celsius, float.\n        >>> weatherSystem = WeatherSystem('New York')\n        >>> weatherSystem.temperature = 80.6\n        >>> weatherSystem.fahrenheit_to_celsius()\n        26.999999999999996\n\n        \"\"\"\n        # Convert the temperature from Fahrenheit to Celsius and return the result\n        return (self.temperature - 32) * 5/9"}, {"id": "97", "llm_annotated_code": "class Words2Numbers:\n    \"\"\"\n    The class provides a text-to-number conversion utility, allowing conversion of written numbers (in words) to their numerical representation.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the word lists and dictionaries required for conversion\n        \"\"\"\n        # Initialize the list of units, tens, and scales\n        self.units = [\n            \"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\",\n            \"nine\", \"ten\", \"eleven\", \"twelve\", \"thirteen\", \"fourteen\", \"fifteen\",\n            \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\",\n        ]\n        self.tens = [\"\", \"\", \"twenty\", \"thirty\", \"forty\", \"fifty\", \"sixty\", \"seventy\", \"eighty\", \"ninety\"]\n        self.scales = [\"hundred\", \"thousand\", \"million\", \"billion\", \"trillion\"]\n\n        # Initialize the dictionary to store the numerical values of the words\n        self.numwords = {\"and\": (1, 0)}\n        for idx, word in enumerate(self.units):\n            self.numwords[word] = (1, idx)\n        for idx, word in enumerate(self.tens):\n            self.numwords[word] = (1, idx * 10)\n        for idx, word in enumerate(self.scales):\n            self.numwords[word] = (10 ** (idx * 3 or 2), 0)\n\n        # Initialize the dictionary to store the numerical values of the ordinal words\n        self.ordinal_words = {'first': 1, 'second': 2, 'third': 3, 'fifth': 5, 'eighth': 8, 'ninth': 9, 'twelfth': 12}\n        self.ordinal_endings = [('ieth', 'y'), ('th', '')]\n\n\n    def text2int(self, textnum):\n        \"\"\"\n        Convert the word string to the corresponding integer string\n        :param textnum: string, the word string to be converted\n        :return: string, the final converted integer string\n        \"\"\"\n\n        # Replace hyphens in the input string with spaces\n        textnum = textnum.replace('-', ' ')\n\n        # Initialize the current and result variables to 0, and the curstring variable to an empty string\n        current = result = 0\n        curstring = \"\"\n        onnumber = False\n\n        # Iterate over each word in the input string\n        for word in textnum.split():\n            # If the word is in the ordinal_words dictionary, update the current variable accordingly\n            if word in self.ordinal_words:\n                scale, increment = (1, self.ordinal_words[word])\n                current = current * scale + increment\n                onnumber = True\n            else:\n                # If the word ends with an ordinal ending, replace the ending with the corresponding replacement\n                for ending, replacement in self.ordinal_endings:\n                    if word.endswith(ending):\n                        word = \"%s%s\" % (word[:-len(ending)], replacement)\n                \n                # If the word is not in the numwords dictionary, add the current result to the curstring variable and reset the current and result variables\n                if word not in self.numwords:\n                    if onnumber:\n                        curstring += repr(result + current) + \" \"\n                        curstring += word + \" \"\n                    result = current = 0\n                    onnumber = False\n                else:\n                    # If the word is in the numwords dictionary, update the current and result variables accordingly\n                    scale, increment = self.numwords[word]\n                    current = current * scale + increment\n                    if scale > 100:\n                        result += current\n                        current = 0\n                    onnumber = True\n\n        # If the last word in the input string was a number, add the current result to the curstring variable\n        if onnumber:\n            curstring += repr(result + current)\n        \n        # Return the final converted integer string\n        return curstring\n\n    def is_valid_input(self, textnum):\n        \"\"\"\n        Check if the input text contains only valid words that can be converted into numbers.\n        :param textnum: The input text containing words representing numbers.\n        :return: True if input is valid, False otherwise.\n        \"\"\"\n\n        # Replace hyphens in the input string with spaces\n        textnum = textnum.replace('-', ' ')\n        \n        # Iterate over each word in the input string\n        for word in textnum.split():\n            # If the word is in the ordinal_words dictionary, continue to the next word\n            if word in self.ordinal_words:\n                continue\n            else:\n                # If the word ends with an ordinal ending, replace the ending with the corresponding replacement\n                for ending, replacement in self.ordinal_endings:\n                    if word.endswith(ending):\n                        word = \"%s%s\" % (word[:-len(ending)], replacement)\n                \n                # If the word is not in the numwords dictionary, return False\n                if word not in self.numwords:\n                    return False\n        \n        # If all words in the input string are valid, return True\n        return True"}, {"id": "98", "llm_annotated_code": "import xml.etree.ElementTree as ET\n\nclass XMLProcessor:\n    \"\"\"\n    This is a class as XML files handler, including reading, writing, processing as well as finding elements in a XML file.\n    \"\"\"\n\n    def __init__(self, file_name):\n        \"\"\"\n        Initialize the XMLProcessor object with the given file name.\n        :param file_name:string, the name of the XML file to be processed.\n        \"\"\"\n        # Store the file name\n        self.file_name = file_name\n        # Initialize the root element to None\n        self.root = None\n\n    def read_xml(self):\n        \"\"\"\n        Reads the XML file and returns the root element.\n        :return: Element, the root element of the XML file.\n        >>> xml_processor = XMLProcessor('test.xml')\n        >>> root_element = xml_processor.read_xml()\n        >>> print(root_element)\n        <Element 'root' at 0x7f8e3b7eb180>\n        \"\"\"\n        try:\n            # Parse the XML file using the ET.parse function\n            tree = ET.parse(self.file_name)\n            # Get the root element of the XML file and store it in self.root\n            self.root = tree.getroot()\n            # Return the root element\n            return self.root\n        except:\n            # If an error occurs while reading the XML file, return None\n            return None\n\n\n    def write_xml(self, file_name):\n        \"\"\"\n        Writes the XML data to the specified file.\n        :param file_name: string, the name of the file to write the XML data.\n        :return: bool, True if the write operation is successful, False otherwise.\n        >>> xml_processor = XMLProcessor('test.xml')\n        >>> root = xml_processor.read_xml()\n        >>> success = xml_processor.write_xml('output.xml')\n        >>> print(success)\n        True\n        \"\"\"\n        try:\n            # Create an ElementTree object with the root element\n            tree = ET.ElementTree(self.root)\n            # Write the XML data to the specified file\n            tree.write(file_name)\n            # If the write operation is successful, return True\n            return True\n        except:\n            # If an error occurs while writing the XML data, return False\n            return False\n\n\n    def process_xml_data(self, file_name):\n        \"\"\"\n        Modifies the data in XML elements and writes the updated XML data to a new file.\n        :param file_name: string, the name of the file to write the modified XML data.\n        :return: bool, True if the write operation is successful, False otherwise.\n        >>> xml_processor = XMLProcessor('test.xml')\n        >>> root = xml_processor.read_xml()\n        >>> success = xml_processor.process_xml_data('processed.xml')\n        >>> print(success)\n        True\n        \"\"\"\n        # Iterate over all 'item' elements in the XML file\n        for element in self.root.iter('item'):\n            # Get the text of the element\n            text = element.text\n            # Convert the text to uppercase and set it as the new text of the element\n            element.text = text.upper()\n        # Write the modified XML data to the specified file and return the result\n        return self.write_xml(file_name)\n\n\n    def find_element(self, element_name):\n        \"\"\"\n        Finds the XML elements with the specified name.\n        :param element_name: string, the name of the elements to find.\n        :return: list, a list of found elements with the specified name.\n        >>> xml_processor = XMLProcessor('test.xml')\n        >>> root = xml_processor.read_xml()\n        >>> items = xml_processor.find_element('item')\n        >>> for item in items:\n        >>>     print(item.text)\n        apple\n        banana\n        orange\n        \"\"\"\n        # Use the findall method of the root element to find all elements with the specified name\n        elements = self.root.findall(element_name)\n        # Return the list of found elements\n        return elements"}, {"id": "99", "llm_annotated_code": "import zipfile\n\nclass ZipFileProcessor:\n    \"\"\"\n    This is a compressed file processing class that provides the ability to read and decompress compressed files\n    \"\"\"\n\n    def __init__(self, file_name):\n        \"\"\"\n        Initialize file name\n        :param file_name:string\n        \"\"\"\n        # Store the name of the zip file to be processed\n        self.file_name = file_name\n\n    def read_zip_file(self):\n        \"\"\"\n        Get open file object\n        :return:If successful, returns the open file object; otherwise, returns None\n        >>> zfp = ZipFileProcessor(\"aaa.zip\")\n        >>> file = zfp.read_zip_file()\n        \"\"\"\n        try:\n            # Try to open the zip file in read mode\n            zip_file = zipfile.ZipFile(self.file_name, 'r')\n            # If successful, return the ZipFile object\n            return zip_file\n        except:\n            # If an error occurs (e.g., file not found), return None\n            return None\n\n    def extract_all(self, output_path):\n        \"\"\"\n        Extract all zip files and place them in the specified path\n        :param output_path: string, The location of the extracted file\n        :return: True or False, representing whether the extraction operation was successful\n        >>> zfp = ZipFileProcessor(\"aaa.zip\")\n        >>> zfp.extract_all(\"result/aaa\")\n        \"\"\"\n        try:\n            # Try to open the zip file in read mode\n            with zipfile.ZipFile(self.file_name, 'r') as zip_file:\n                # Extract all files to the specified output path\n                zip_file.extractall(output_path)\n            # If successful, return True\n            return True\n        except:\n            # If an error occurs (e.g., file not found, output path not writable), return False\n            return False\n\n    def extract_file(self, file_name, output_path):\n        \"\"\"\n        Extract the file with the specified name from the zip file and place it in the specified path\n        :param file_name:string, The name of the file to be uncompressed\n        :param output_path:string, The location of the extracted file\n        :return: True or False, representing whether the extraction operation was successful\n        >>> zfp = ZipFileProcessor(\"aaa.zip\")\n        >>> zfp.extract_file(\"bbb.txt\", \"result/aaa\")\n        \"\"\"\n        try:\n            # Try to open the zip file in read mode\n            with zipfile.ZipFile(self.file_name, 'r') as zip_file:\n                # Extract the specified file to the specified output path\n                zip_file.extract(file_name, output_path)\n            # If successful, return True\n            return True\n        except:\n            # If an error occurs (e.g., file not found in zip, output path not writable), return False\n            return False\n\n    def create_zip_file(self, files, output_file_name):\n        \"\"\"\n        Compress the specified file list into a zip file and place it in the specified path\n        :param files:list of string, List of files to compress\n        :param output_file_name: string, Specified output path\n        :return:True or False, representing whether the compression operation was successful\n        >>> zfp = ZipFileProcessor(\"aaa.zip\")\n        >>> zfp.create_zip_file([\"bbb.txt\", \"ccc,txt\", \"ddd.txt\"], \"output/bcd\")\n        \"\"\"\n        try:\n            # Try to create a new zip file in write mode\n            with zipfile.ZipFile(output_file_name, 'w') as zip_file:\n                # For each file in the list of files to compress\n                for file in files:\n                    # Add the file to the zip\n                    zip_file.write(file)\n            # If successful, return True\n            return True\n        except:\n            # If an error occurs (e.g., file not found, output path not writable), return False\n            return False"}]