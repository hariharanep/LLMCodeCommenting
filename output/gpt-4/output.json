[{"id": "1", "llm_annotated_code": "class AreaCalculator:\n    \"\"\"\n    This is a class for calculating the area of different shapes, including circle, sphere, cylinder, sector and annulus.\n    \"\"\"\n\n    def __init__(self, radius):\n        \"\"\"\n        Initialize the AreaCalculator with a radius.\n        :param radius: float, radius of the shape\n        >>> AreaCalculator(5)\n        \"\"\"\n\n        # Store the radius as an instance variable\n        self.radius = radius\n\n    def calculate_circle_area(self):\n        \"\"\"\n        Calculate the area of a circle using the formula pi*r^2.\n        :return: float, area of the circle\n        >>> ac = AreaCalculator(5)\n        >>> ac.calculate_circle_area()\n        78.53981633974483\n        \"\"\"\n\n        # Use the math.pi constant and the radius to calculate the area of the circle\n        return math.pi * self.radius ** 2\n\n    def calculate_sphere_area(self):\n        \"\"\"\n        Calculate the surface area of a sphere using the formula 4*pi*r^2.\n        :return: float, surface area of the sphere\n        >>> ac = AreaCalculator(5)\n        >>> ac.calculate_sphere_area()\n        314.1592653589793\n        \"\"\"\n\n        # Use the math.pi constant and the radius to calculate the surface area of the sphere\n        return 4 * math.pi * self.radius ** 2\n\n    def calculate_cylinder_area(self, height):\n        \"\"\"\n        Calculate the surface area of a cylinder using the formula 2*pi*r*(r+h).\n        :param height: float, height of the cylinder\n        :return: float, surface area of the cylinder\n        >>> ac = AreaCalculator(5)\n        >>> ac.calculate_cylinder_area(10)\n        471.23889803846896\n        \"\"\"\n\n        # Use the math.pi constant, the radius, and the height to calculate the surface area of the cylinder\n        return 2 * math.pi * self.radius * (self.radius + height)\n\n    def calculate_sector_area(self, angle):\n        \"\"\"\n        Calculate the area of a sector using the formula r^2*angle/2.\n        :param angle: float, angle of the sector in radians\n        :return: float, area of the sector\n        >>> ac = AreaCalculator(5)\n        >>> ac.calculate_sector_area(math.pi)\n        39.269908169872416\n        \"\"\"\n\n        # Use the radius and the angle to calculate the area of the sector\n        return self.radius ** 2 * angle / 2\n\n    def calculate_annulus_area(self, inner_radius, outer_radius):\n        \"\"\"\n        Calculate the area of an annulus using the formula pi*(R^2-r^2), where R is the outer radius and r is the inner radius.\n        :param inner_radius: float, inner radius of the annulus\n        :param outer_radius: float, outer radius of the annulus\n        :return: float, area of the annulus\n        >>> ac = AreaCalculator(5)\n        >>> ac.calculate_annulus_area(3, 5)\n        50.26548245743669\n        \"\"\"\n\n        # Use the math.pi constant, the inner radius, and the outer radius to calculate the area of the annulus\n        return math.pi * (outer_radius ** 2 - inner_radius ** 2)"}, {"id": "2", "llm_annotated_code": "class ArgumentParser:\n    \"\"\"\n    This is a class for parsing command line arguments to a dictionary.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the ArgumentParser with empty dictionaries for arguments and types, and an empty set for required arguments.\n        self.arguments: dict, stores the parsed command line arguments\n        self.required: set, stores the names of the required arguments\n        self.types: dict, stores the expected type of each argument\n        \"\"\"\n\n        self.arguments = {}\n        self.required = set()\n        self.types = {}\n\n    def parse_arguments(self, command_string):\n        \"\"\"\n        Parses the given command line argument string into the arguments dictionary.\n        Checks for missing required arguments, if any, and returns False with the missing argument names, otherwise returns True.\n        :param command_string: str, command line argument string, formatted like \"python script.py --arg1=value1 -arg2 value2 --option1 -option2\"\n        :return tuple: (True, None) if parsing is successful, (False, missing_args) if parsing fails,\n            where missing_args is a set of the missing argument names which are str.\n        \"\"\"\n\n        # Split the command string into individual arguments\n        args = command_string.split()[1:]\n\n        # Iterate over the arguments\n        for i in range(len(args)):\n            arg = args[i]\n\n            # If the argument starts with '--', it's a key-value pair\n            if arg.startswith('--'):\n                key_value = arg[2:].split('=')\n\n                # If there's an equals sign, store the key and value in the arguments dictionary\n                # Convert the value to the appropriate type using the _convert_type method\n                if len(key_value) == 2:\n                    self.arguments[key_value[0]] = self._convert_type(key_value[0], key_value[1])\n                else:\n                    # If there's no equals sign, it's a flag, so store the key with a value of True\n                    self.arguments[key_value[0]] = True\n\n            # If the argument starts with '-', it's a key-value pair or a flag\n            elif arg.startswith('-'):\n                key = arg[1:]\n\n                # If the next argument doesn't start with '-', it's the value for this key\n                # Store the key and value in the arguments dictionary\n                # Convert the value to the appropriate type using the _convert_type method\n                if i + 1 < len(args) and not args[i + 1].startswith('-'):\n                    self.arguments[key] = self._convert_type(key, args[i + 1])\n                else:\n                    # If the next argument starts with '-', this argument is a flag, so store the key with a value of True\n                    self.arguments[key] = True\n\n        # Check for missing required arguments\n        missing_args = self.required - set(self.arguments.keys())\n        if missing_args:\n            return False, missing_args\n\n        return True, None\n\n    def get_argument(self, arg):\n        \"\"\"\n        Retrieves the value of the specified argument from the arguments dictionary.\n        :param arg: str, argument name\n        :return: The value of the argument, or None if the argument does not exist.\n        \"\"\"\n\n        # Return the value of the specified argument from the arguments dictionary\n        # If the argument does not exist, return None\n        return self.arguments.get(arg)\n\n    def add_argument(self, arg, required=False, arg_type=str):\n        \"\"\"\n        Adds an argument to the types dictionary and, if necessary, the required set.\n        :param arg: str, argument name\n        :param required: bool, whether the argument is required, default is False\n        :param arg_type: type, the expected type of the argument, default is str\n        \"\"\"\n\n        # If the argument is required, add it to the required set\n        if required:\n            self.required.add(arg)\n\n        # Add the argument and its expected type to the types dictionary\n        self.types[arg] = arg_type\n\n    def _convert_type(self, arg, value):\n        \"\"\"\n        Converts the value of an argument to its expected type.\n        :param arg: str, argument name\n        :param value: str, the value to be converted\n        :return: the converted value, or the original value if the conversion fails\n        \"\"\"\n\n        # Try to convert the value to its expected type\n        # If the conversion fails, return the original value\n        try:\n            return self.types[arg](value)\n        except (ValueError, KeyError):\n            return value"}, {"id": "3", "llm_annotated_code": "class ArrangementCalculator:\n    \"\"\"\n    The ArrangementCalculator class provides permutation calculations and selection operations for a given set of data elements.\n    \"\"\"\n\n    def __init__(self, datas):\n        \"\"\"\n        Initializes the ArrangementCalculator object with a list of datas.\n        :param datas: List, the data elements to be used for arrangements.\n        \"\"\"\n        # Store the input data elements in the instance variable self.datas\n        self.datas = datas\n\n    @staticmethod\n    def count(n, m=None):\n        \"\"\"\n        Counts the number of arrangements by choosing m items from n items (permutations).\n        If m is not provided or n equals m, returns factorial(n).\n        :param n: int, the total number of items.\n        :param m: int, the number of items to be chosen (default=None).\n        :return: int, the count of arrangements.\n        \"\"\"\n\n        # If m is not provided or n equals m, return the factorial of n\n        # Otherwise, return the factorial of n divided by the factorial of (n - m)\n        if m is None or n == m:\n            return ArrangementCalculator.factorial(n)\n        else:\n            return ArrangementCalculator.factorial(n) // ArrangementCalculator.factorial(n - m)\n\n    @staticmethod\n    def count_all(n):\n        \"\"\"\n        Counts the total number of all possible arrangements by choosing at least 1 item and at most n items from n items.\n        :param n: int, the total number of items.\n        :return: int, the count of all arrangements.\n        \"\"\"\n\n        # Initialize total to 0\n        # For each number i from 1 to n (inclusive), add the count of arrangements of n items taken i at a time to total\n        total = 0\n        for i in range(1, n + 1):\n            total += ArrangementCalculator.count(n, i)\n        \n        # Return the total count of all possible arrangements\n        return total\n\n\n    def select(self, m=None):\n        \"\"\"\n        Generates a list of arrangements by selecting m items from the internal datas.\n        If m is not provided, selects all items.\n        :param m: int, the number of items to be chosen (default=None).\n        :return: List, a list of arrangements.\n        \"\"\"\n\n        # If m is not provided, set m to the length of self.datas\n        if m is None:\n            m = len(self.datas)\n\n        # Initialize an empty list result\n        # For each permutation of m items from self.datas, append the permutation as a list to result\n        result = []\n        for permutation in itertools.permutations(self.datas, m):\n            result.append(list(permutation))\n        \n        # Return the list of all arrangements\n        return result\n\n\n    def select_all(self):\n        \"\"\"\n        Generates a list of all arrangements by selecting at least 1 item and at most the number of internal datas.\n        :return: List, a list of all arrangements.\n        \"\"\"\n\n        # Initialize an empty list result\n        # For each number i from 1 to the length of self.datas (inclusive), extend result with the list of all arrangements of self.datas taken i at a time\n        result = []\n        for i in range(1, len(self.datas) + 1):\n            result.extend(self.select(i))\n        \n        # Return the list of all possible arrangements\n        return result\n\n\n    @staticmethod\n    def factorial(n):\n        \"\"\"\n        Calculates the factorial of a given number.\n        :param n: int, the number to calculate the factorial.\n        :return: int, the factorial of the given number.\n        \"\"\"\n\n        # Initialize result to 1\n        # For each number i from 2 to n (inclusive), multiply result by i\n        result = 1\n        for i in range(2, n + 1):\n            result *= i\n        # Return the factorial of n\n        return result"}, {"id": "4", "llm_annotated_code": "class AssessmentSystem:\n    \"\"\"\n    This is a class as an student assessment system, which supports add student, add course score, calculate GPA, and other functions for students and courses.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the students dict in assessment system.\n        The students dict will store all student information, with student name as key and a dict as value.\n        The value dict contains student's grade, major and a dict of courses with their scores.\n        \"\"\"\n\n        self.students = {}\n\n    def add_student(self, name, grade, major):\n        \"\"\"\n        Add a new student into self.students dict\n        :param name: str, student name\n        :param grade: int, student grade\n        :param major: str, student major\n        The method will create a new dict with student's name, grade, major and an empty dict for courses, then add it to self.students.\n        \"\"\"\n\n        self.students[name] = {'name': name, 'grade': grade, 'major': major, 'courses': {}}\n\n    def add_course_score(self, name, course, score):\n        \"\"\"\n        Add score of specific course for student in self.students\n        :param name: str, student name\n        :param course: str, course name\n        :param score: int, course score\n        The method will add the course and its score to the 'courses' dict of the student specified by name.\n        \"\"\"\n\n        if name in self.students:\n            self.students[name]['courses'][course] = score\n\n    def get_gpa(self, name):\n        \"\"\"\n        Get average grade of one student.\n        :param name: str, student name\n        :return: if name is in students and this students have courses grade, return average grade(float)\n                    or None otherwise\n        The method will calculate the average score of all courses of the student specified by name.\n        \"\"\"\n\n        if name in self.students and self.students[name]['courses']:\n            return sum(self.students[name]['courses'].values()) / len(self.students[name]['courses'])\n        else:\n            return None\n\n    def get_all_students_with_fail_course(self):\n        \"\"\"\n        Get all students who have any score blow 60\n        :return: list of str ,student name\n        The method will iterate through all students and their courses, and return a list of students who have any course with score below 60.\n        \"\"\"\n\n        students = []\n        for name, student in self.students.items():\n            for course, score in student['courses'].items():\n                if score < 60:\n                    students.append(name)\n                    break\n        return students\n\n    def get_course_average(self, course):\n        \"\"\"\n        Get the average score of a specific course.\n        :param course: str, course name\n        :return: float, average scores of this course if anyone have score of this course, or None if nobody have records.\n        The method will calculate the average score of the specified course across all students.\n        \"\"\"\n\n        total = 0\n        count = 0\n        for student in self.students.values():\n            if course in student['courses']:\n                score = student['courses'][course]\n                if score is not None:\n                    total += score\n                    count += 1\n        return total / count if count > 0 else None\n\n    def get_top_student(self):\n        \"\"\"\n        Calculate every student's gpa with get_gpa method, and find the student with highest gpa\n        :return: str, name of student whose gpa is highest\n        The method will calculate the GPA of all students using the get_gpa method, and return the name of the student with the highest GPA.\n        \"\"\"\n\n        top_student = None\n        top_gpa = 0\n        for name, student in self.students.items():\n            gpa = self.get_gpa(name)\n            if gpa is not None and gpa > top_gpa:\n                top_gpa = gpa\n                top_student = name\n        return top_student"}, {"id": "5", "llm_annotated_code": "class AutomaticGuitarSimulator:\n\n    # This class is an automatic guitar simulator that can interpret and play based on the input guitar sheet music.\n\n    def __init__(self, text) -> None:\n        \"\"\"\n        Initialize the score to be played\n        :param text:str, score to be played\n        \"\"\"\n        # Store the input text (guitar sheet music) in the instance variable play_text\n        self.play_text = text\n\n    def interpret(self, display=False):\n        \"\"\"\n        Interpret the music score to be played\n        :param display:Bool, representing whether to print the interpreted score\n        :return: list of dict, The dict includes two fields, Chord and Tune, which are letters and numbers, respectively. If the input is empty or contains only whitespace, an empty list is returned.\n        \"\"\"\n\n        # If the input text is empty or contains only whitespace, return an empty list\n        if not self.play_text.strip():\n            return []\n        else:\n            # Initialize an empty list to store the interpreted score\n            play_list = []\n            # Split the input text into segments based on spaces\n            play_segs = self.play_text.split(\" \")\n            for play_seg in play_segs:\n                pos = 0\n                # Iterate through each character in the segment\n                for ele in play_seg:\n                    # If the character is a letter, increment the position counter and continue to the next character\n                    if ele.isalpha():\n                        pos += 1\n                        continue\n                    # If the character is not a letter, break the loop\n                    break\n                # Extract the chord and the tune from the segment based on the position counter\n                play_chord = play_seg[0:pos]\n                play_value = play_seg[pos:]\n                # Append the chord and the tune as a dictionary to the play list\n                play_list.append({'Chord': play_chord, 'Tune': play_value})\n                # If the display parameter is True, call the display method to print the chord and the tune\n                if display:\n                    self.display(play_chord, play_value)\n            # Return the play list\n            return play_list\n\n    def display(self, key, value):\n        \"\"\"\n        Print out chord and play tune with following format: Normal Guitar Playing -- Chord: %s, Play Tune: %s\n        :param key:str, chord\n        :param value:str, play tune\n        :return: str\n        \"\"\"\n\n        # Return a formatted string that includes the chord and the tune\n        return \"Normal Guitar Playing -- Chord: %s, Play Tune: %s\" % (key, value)"}, {"id": "6", "llm_annotated_code": "class AvgPartition:\n    \"\"\"\n    This is a class that partitions the given list into different blocks by specifying the number of partitions, with each block having a uniformly distributed length.\n    \"\"\"\n\n    def __init__(self, lst, limit):\n        \"\"\"\n        Initialize the class with the given list and the number of partitions, and check if the number of partitions is greater than 0.\n        :param lst: list, the list to be partitioned\n        :param limit: int, the number of partitions\n        >>> a = AvgPartition([1, 2, 3, 4], 2)\n        \"\"\"\n\n        self.lst = lst\n        self.limit = limit\n\n    def setNum(self):\n        \"\"\"\n        Calculate the size of each block and the remainder of the division.\n        :return: the size of each block and the remainder of the division, tuple.\n        >>> a = AvgPartition([1, 2, 3, 4], 2)\n        >>> a.setNum()\n        (2, 0)\n\n        \"\"\"\n\n        # Calculate the size of each block by dividing the length of the list by the limit\n        size = len(self.lst) // self.limit\n\n        # Calculate the remainder of the division\n        remainder = len(self.lst) % self.limit\n\n        # Return the size and remainder\n        return size, remainder\n\n\n    def get(self, index):\n        \"\"\"\n        Calculate the size of each block and the remainder of the division, and calculate the corresponding start and end positions based on the index of the partition.\n        :param index: the index of the partition,int.\n        :return: the corresponding block, list.\n        >>> a = AvgPartition([1, 2, 3, 4], 2)\n        >>> a.get(0)\n        [1, 2]\n\n        \"\"\"\n\n        # Get the size of each block and the remainder of the division\n        size, remainder = self.setNum()\n\n        # Calculate the start position of the block\n        start = index * size + min(index, remainder)\n\n        # Calculate the end position of the block\n        end = start + size\n\n        # If the index is less than the remainder, increment the end position by 1\n        if index + 1 <= remainder:\n            end += 1\n\n        # Return the block from the list\n        return self.lst[start:end]"}, {"id": "7", "llm_annotated_code": "class BalancedBrackets:\n    \"\"\"\n    This is a class that checks for bracket matching in a given expression.\n    \"\"\"\n\n    def __init__(self, expr):\n        \"\"\"\n        Initializes the class with an expression.\n        :param expr: str, The expression to check for balanced brackets.\n        \"\"\"\n        self.stack = []  # A list to use as a stack for checking bracket matching\n        self.left_brackets = [\"(\", \"{\", \"[\"]  # A list of left brackets\n        self.right_brackets = [\")\", \"}\", \"]\"]  # A list of right brackets\n        self.expr = expr  # The expression to check for balanced brackets\n\n    def clear_expr(self):\n        \"\"\"\n        Clears the expression of all characters that are not brackets.\n        :return: None\n        \"\"\"\n        # Use a generator expression to filter out non-bracket characters and join the result into a string\n        self.expr = ''.join(c for c in self.expr if (c in self.left_brackets or c in self.right_brackets))\n\n    def check_balanced_brackets(self):\n        \"\"\"\n        Checks if the expression has balanced brackets.\n        :return: bool, True if the expression has balanced brackets, False otherwise.\n        \"\"\"\n        # Clear the expression of non-bracket characters\n        self.clear_expr()\n\n        # Iterate over each character in the expression\n        for Brkt in self.expr:\n            # If the character is a left bracket, push it onto the stack\n            if Brkt in self.left_brackets:\n                self.stack.append(Brkt)\n            else:\n                # If the stack is not empty, pop the top bracket from the stack\n                # Otherwise, continue to the next iteration\n                if self.stack:\n                    Current_Brkt = self.stack.pop()\n                else:\n                    continue\n\n                # If the popped bracket is a left parenthesis and the current character is not a right parenthesis, return False\n                # Do the same for curly braces and square brackets\n                if Current_Brkt == \"(\":\n                    if Brkt != \")\":\n                        return False\n                if Current_Brkt == \"{\":\n                    if Brkt != \"}\":\n                        return False\n                if Current_Brkt == \"[\":\n                    if Brkt != \"]\":\n                        return False\n\n        # If the stack is not empty after iterating over the entire expression, return False\n        # Otherwise, return True\n        if self.stack:\n            return False\n        return True"}, {"id": "8", "llm_annotated_code": "class BankAccount:\n    \"\"\"\n    This is a class as a bank account system, which supports deposit money, withdraw money, view balance, and transfer money.\n    \"\"\"\n\n    def __init__(self, balance=0):\n        \"\"\"\n        Initializes a bank account object with an attribute balance, default value is 0.\n        :param balance: int, initial balance of the account, default is 0\n        \"\"\"\n        self.balance = balance\n\n    def deposit(self, amount):\n        \"\"\"\n        Deposits a certain amount into the account, increasing the account balance, return the current account balance.\n        If amount is negative, raise a ValueError(\"Invalid amount\").\n        :param amount: int, the amount to be deposited\n        :return: int, the current account balance after deposit\n        \"\"\"\n\n        # Check if the amount is negative, if so, raise a ValueError\n        if amount < 0:\n            raise ValueError(\"Invalid amount\")\n        \n        # Add the amount to the account balance\n        self.balance += amount\n        \n        # Return the current account balance\n        return self.balance\n\n    def withdraw(self, amount):\n        \"\"\"\n        Withdraws a certain amount from the account, decreasing the account balance, return the current account balance.\n        If amount is negative, raise a ValueError(\"Invalid amount\").\n        If the withdrawal amount is greater than the account balance, raise a ValueError(\"Insufficient balance.\").\n        :param amount: int, the amount to be withdrawn\n        :return: int, the current account balance after withdrawal\n        \"\"\"\n\n        # Check if the amount is negative, if so, raise a ValueError\n        if amount < 0:\n            raise ValueError(\"Invalid amount\")\n        \n        # Check if the withdrawal amount is greater than the account balance, if so, raise a ValueError\n        if amount > self.balance:\n            raise ValueError(\"Insufficient balance.\")\n        \n        # Subtract the amount from the account balance\n        self.balance -= amount\n        \n        # Return the current account balance\n        return self.balance\n\n    def view_balance(self):\n        \"\"\"\n        Return the account balance.\n        :return: int, the current account balance\n        \"\"\"\n        return self.balance\n\n    def transfer(self, other_account, amount):\n        \"\"\"\n        Transfers a certain amount from the current account to another account.\n        :param other_account: BankAccount, the account to transfer money to\n        :param amount: int, the amount to be transferred\n        \"\"\"\n\n        # Use the withdraw method to withdraw the amount from the current account\n        self.withdraw(amount)\n        \n        # Use the deposit method to deposit the amount into the other account\n        other_account.deposit(amount)"}, {"id": "10", "llm_annotated_code": "class BinaryDataProcessor:\n    \"\"\"\n    This is a class used to process binary data, which includes functions such as clearing non 0 or 1 characters, \n    counting binary string information, and converting to corresponding strings based on different encoding methods.\n    \"\"\"\n\n    def __init__(self, binary_string):\n        \"\"\"\n        Initialize the class with a binary string and clean it by removing all non 0 or 1 characters.\n        :param binary_string: str, the binary string to be processed\n        >>> bdp = BinaryDataProcessor(\"01101000daf3e4r01100101011011000110110001101111\")\n        \"\"\"\n\n        self.binary_string = binary_string\n        # Call the clean_non_binary_chars method to clean the binary string\n        self.clean_non_binary_chars()\n\n    def clean_non_binary_chars(self):\n        \"\"\"\n        Clean the binary string by removing all non 0 or 1 characters.\n        >>> bdp = BinaryDataProcessor(\"01101000daf3e4r01100101011011000110110001101111\")\n        >>> bdp.clean_non_binary_chars()\n        >>> bdp.binary_string\n        '0110100001100101011011000110110001101111'\n\n        \"\"\"\n        # Use the filter function to remove all non 0 or 1 characters from the binary string\n        self.binary_string = ''.join(filter(lambda x: x in '01', self.binary_string))\n\n    def calculate_binary_info(self):\n        \"\"\"\n        Calculate the binary string information, including the percentage of 0 and 1, and the total length of the binary string.\n        :return: dict, the binary string information\n        >>> bdp = BinaryDataProcessor(\"0110100001100101011011000110110001101111\")\n        >>> bdp.calculate_binary_info()\n        {'Zeroes': 0.475, 'Ones': 0.525, 'Bit length': 40}\n\n        \"\"\"\n        # Use the count method to count the number of 0s and 1s in the binary string\n        zeroes_count = self.binary_string.count('0')\n        ones_count = self.binary_string.count('1')\n        # Use the len function to get the total length of the binary string\n        total_length = len(self.binary_string)\n        # Calculate the percentage of 0s and 1s in the binary string\n        zeroes_percentage = (zeroes_count / total_length)\n        ones_percentage = (ones_count / total_length)\n\n        # Return the binary string information as a dictionary\n        return {\n            'Zeroes': zeroes_percentage,\n            'Ones': ones_percentage,\n            'Bit length': total_length\n        }\n\n    def convert_to_ascii(self):\n        \"\"\"\n        Convert the binary string to ascii string.\n        :return: str, the ascii string converted from the binary string\n        >>> bdp = BinaryDataProcessor(\"0110100001100101011011000110110001101111\")\n        >>> bdp.convert_to_ascii()\n        'hello'\n\n        \"\"\"\n\n        # Initialize an empty bytearray\n        byte_array = bytearray()\n        # Iterate over the binary string in steps of 8 (since 1 byte = 8 bits)\n        for i in range(0, len(self.binary_string), 8):\n            # Extract a byte from the binary string\n            byte = self.binary_string[i:i+8]\n            # Convert the byte to decimal\n            decimal = int(byte, 2)\n            # Append the decimal to the bytearray\n            byte_array.append(decimal)\n        # Convert the bytearray to an ascii string and return it\n        return byte_array.decode('ascii')\n\n    def convert_to_utf8(self):\n        \"\"\"\n        Convert the binary string to utf-8 string.\n        :return: str, the utf-8 string converted from the binary string\n        >>> bdp = BinaryDataProcessor(\"0110100001100101011011000110110001101111\")\n        >>> bdp.convert_to_utf8()\n        'hello'\n\n        \"\"\"\n\n        # Initialize an empty bytearray\n        byte_array = bytearray()\n        # Iterate over the binary string in steps of 8 (since 1 byte = 8 bits)\n        for i in range(0, len(self.binary_string), 8):\n            # Extract a byte from the binary string\n            byte = self.binary_string[i:i+8]\n            # Convert the byte to decimal\n            decimal = int(byte, 2)\n            # Append the decimal to the bytearray\n            byte_array.append(decimal)\n        # Convert the bytearray to a utf-8 string and return it\n        return byte_array.decode('utf-8')"}, {"id": "11", "llm_annotated_code": "class BitStatusUtil:\n    \"\"\"\n    This is a utility class that provides methods for manipulating and checking status using bitwise operations.\n    \"\"\"\n\n    @staticmethod\n    def add(states, stat):\n        \"\"\"\n        Add a status to the current status,and check the parameters wheather they are legal.\n        :param states: Current status,int.\n        :param stat: Status to be added,int.\n        :return: The status after adding the status,int.\n        >>> bit_status_util = BitStatusUtil()\n        >>> bit_status_util.add(2,4)\n        6\n\n        \"\"\"\n\n        # Check if the input parameters are valid\n        BitStatusUtil.check([states, stat])\n\n        # Use the bitwise OR operator to add the status to the current status\n        return states | stat\n\n    @staticmethod\n    def has(states, stat):\n        \"\"\"\n        Check if the current status contains the specified status,and check the parameters wheather they are legal.\n        :param states: Current status,int.\n        :param stat: Specified status,int.\n        :return: True if the current status contains the specified status,otherwise False,bool.\n        >>> bit_status_util = BitStatusUtil()\n        >>> bit_status_util.has(6,2)\n        True\n\n        \"\"\"\n\n        # Check if the input parameters are valid\n        BitStatusUtil.check([states, stat])\n\n        # Use the bitwise AND operator to check if the current status contains the specified status\n        return (states & stat) == stat\n\n    @staticmethod\n    def remove(states, stat):\n        \"\"\"\n        Remove the specified status from the current status,and check the parameters wheather they are legal.\n        :param states: Current status,int.\n        :param stat: Specified status,int.\n        :return: The status after removing the specified status,int.\n        >>> bit_status_util = BitStatusUtil()\n        >>> bit_status_util.remove(6,2)\n        4\n\n        \"\"\"\n\n        # Check if the input parameters are valid\n        BitStatusUtil.check([states, stat])\n\n        # Use the bitwise XOR operator to remove the specified status from the current status if it exists\n        if BitStatusUtil.has(states, stat):\n            return states ^ stat\n\n        # If the specified status does not exist in the current status, return the current status as is\n        return states\n\n    @staticmethod\n    def check(args):\n        \"\"\"\n        Check if the parameters are legal, args must be greater than or equal to 0 and must be even,if not,raise ValueError.\n        :param args: Parameters to be checked,list.\n        :return: None.\n        >>> bit_status_util = BitStatusUtil()\n        >>> bit_status_util.check([2,3,4])\n        Traceback (most recent call last):\n        ...\n        ValueError: 3 not even\n        \"\"\"\n\n        # Iterate through each argument in the input list\n        for arg in args:\n            # If the argument is less than 0, raise a ValueError\n            if arg < 0:\n                raise ValueError(f\"{arg} must be greater than or equal to 0\")\n\n            # If the argument is not even, raise a ValueError\n            if arg % 2 != 0:\n                raise ValueError(f\"{arg} not even\")"}, {"id": "12", "llm_annotated_code": "class BlackjackGame:\n    \"\"\"\n    This class represents a game of blackjack. It includes methods for creating a deck of cards, \n    calculating the value of a hand, and determining the winner based on the hand values of the player and dealer.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the BlackjackGame instance with an attribute for the deck of cards, the player's hand, and the dealer's hand.\n        The deck is created by calling the create_deck method and is a list of 52 shuffled cards (no Jokers).\n        The player's hand and the dealer's hand are both initialized as empty lists.\n        \"\"\"\n        self.deck = self.create_deck()\n        self.player_hand = []\n        self.dealer_hand = []\n\n    def create_deck(self):\n        \"\"\"\n        Create a deck of 52 cards, shuffle them, and return the shuffled deck.\n        The deck is a list of strings, where each string represents a card. The string is composed of the card's rank \n        followed by its suit. For example, 'AS' represents the Ace of Spades.\n        :return: list of strings, representing a shuffled deck of 52 cards\n        \"\"\"\n        deck = []\n        suits = ['S', 'C', 'D', 'H']  # Suits: Spades, Clubs, Diamonds, Hearts\n        ranks = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K']  # Ranks: Ace, 2-10, Jack, Queen, King\n        for suit in suits:\n            for rank in ranks:\n                deck.append(rank + suit)\n        random.shuffle(deck)  # Shuffle the deck\n        return deck\n\n    def calculate_hand_value(self, hand):\n        \"\"\"\n        Calculate the value of a hand in blackjack.\n        Number cards (2-10) count as their face value, face cards (J, Q, K) count as 10, and Aces count as 11.\n        However, if counting an Ace as 11 would cause the hand to exceed 21, it is counted as 1 instead.\n        :param hand: list of strings, representing a hand of cards\n        :return: int, the value of the hand\n        \"\"\"\n        value = 0\n        num_aces = 0  # Keep track of the number of Aces in the hand\n        for card in hand:\n            rank = card[:-1]  # The rank is all characters in the string except the last one (which is the suit)\n            if rank.isdigit():  # If the rank is a digit (2-10), add its value to the total hand value\n                value += int(rank)\n            elif rank in ['J', 'Q', 'K']:  # If the rank is a face card (J, Q, K), add 10 to the total hand value\n                value += 10\n            elif rank == 'A':  # If the rank is an Ace, add 11 to the total hand value and increment the number of Aces\n                value += 11\n                num_aces += 1\n        # If the total hand value exceeds 21 and there are Aces in the hand, subtract 10 for each Ace until the hand value is 21 or less\n        while value > 21 and num_aces > 0:\n            value -= 10\n            num_aces -= 1\n        return value\n\n    def check_winner(self, player_hand, dealer_hand):\n        \"\"\"\n        Determine the winner of a game of blackjack based on the values of the player's hand and the dealer's hand.\n        If both players have hand values of 21 or less, the player with the hand value closer to 21 wins.\n        If both players have hand values over 21, the player with the lower hand value wins.\n        If one player has a hand value over 21 and the other has a hand value of 21 or less, the player with the hand value of 21 or less wins.\n        :param player_hand: list of strings, representing the player's hand of cards\n        :param dealer_hand: list of strings, representing the dealer's hand of cards\n        :return: string, either 'Dealer wins' or 'Player wins'\n        \"\"\"\n        player_value = self.calculate_hand_value(player_hand)  # Calculate the value of the player's hand\n        dealer_value = self.calculate_hand_value(dealer_hand)  # Calculate the value of the dealer's hand\n        # If both players have hand values over 21, the player with the lower hand value wins\n        if player_value > 21 and dealer_value > 21:\n            if player_value < dealer_value:\n                return 'Player wins'\n            else:\n                return 'Dealer wins'\n        # If the player's hand value is over 21, the dealer wins\n        elif player_value > 21:\n            return 'Dealer wins'\n        # If the dealer's hand value is over 21, the player wins\n        elif dealer_value > 21:\n            return 'Player wins'\n        # If both players have hand values of 21 or less, the player with the hand value closer to 21 wins\n        else:\n            if player_value > dealer_value:\n                return 'Player wins'\n            else:\n                return 'Dealer wins'"}, {"id": "13", "llm_annotated_code": "class BookManagement:\n    \"\"\"\n    This is a class as managing books system, which supports to add and remove books from the inventory dict, view the inventory, and check the quantity of a specific book.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the inventory of Book Manager.\n        The inventory is a dictionary where the keys are book titles and the values are the quantities of the books.\n        \"\"\"\n\n        self.inventory = {}\n\n    def add_book(self, title, quantity=1):\n        \"\"\"\n        Add one or several books to inventory which is sorted by book title.\n        :param title: str, the book title\n        :param quantity: int, default value is 1.\n        If the book title already exists in the inventory, increment the quantity of the book by the specified quantity.\n        If the book title does not exist in the inventory, add the book title to the inventory with the specified quantity.\n        \"\"\"\n\n        if title in self.inventory:\n            self.inventory[title] += quantity\n        else:\n            self.inventory[title] = quantity\n\n    def remove_book(self, title, quantity):\n        \"\"\"\n        Remove one or several books from inventory which is sorted by book title.\n        Raise false while get invalid input.\n        :param title: str, the book title\n        :param quantity: int\n        If the book title does not exist in the inventory or the quantity of the book in the inventory is less than the specified quantity, raise an exception.\n        Otherwise, decrement the quantity of the book in the inventory by the specified quantity.\n        If the quantity of the book in the inventory becomes 0, remove the book title from the inventory.\n        \"\"\"\n\n        if title not in self.inventory or self.inventory[title] < quantity:\n            raise False\n        self.inventory[title] -= quantity\n        if self.inventory[title] == 0:\n            del (self.inventory[title])\n\n    def view_inventory(self):\n        \"\"\"\n        Get the inventory of the Book Management.\n        :return self.inventory: dictionary, {title(str): quantity(int), ...}\n        Return the inventory dictionary.\n        \"\"\"\n\n        return self.inventory\n\n    def view_book_quantity(self, title):\n        \"\"\"\n        Get the quantity of a book.\n        :param title: str, the title of the book.\n        :return quantity: the quantity of this book title. return 0 when the title does not exist in self.invenroty\n        If the book title exists in the inventory, return the quantity of the book.\n        If the book title does not exist in the inventory, return 0.\n        \"\"\"\n\n        if title not in self.inventory:\n            return 0\n        return self.inventory[title]"}, {"id": "14", "llm_annotated_code": "class BookManagementDB:\n    '''\n    This class interfaces with a SQLite database to manage a collection of books. It provides methods to create a table, add books, remove books, borrow books, return books, and search for books.\n    '''\n\n    def __init__(self, db_name):\n        '''\n        Initializes the class by creating a SQLite database connection and cursor. It also calls the create_table method to ensure the 'books' table exists.\n        :param db_name: str, the name of the SQLite database file\n        '''\n        # Connect to the SQLite database with the provided name and create a cursor for executing SQL commands\n        self.connection = sqlite3.connect(db_name)\n        self.cursor = self.connection.cursor()\n\n        # Call the create_table method to ensure the 'books' table exists\n        self.create_table()\n\n    def create_table(self):\n        '''\n        Creates a table named 'books' in the SQLite database if it does not already exist. The table has columns for 'id', 'title', 'author', and 'available'.\n        '''\n\n        # Execute a SQL command to create the 'books' table if it does not already exist\n        self.cursor.execute('''\n            CREATE TABLE IF NOT EXISTS books (\n                id INTEGER PRIMARY KEY,\n                title TEXT,\n                author TEXT,\n                available INTEGER\n            )\n        ''')\n\n        # Commit the changes to the database\n        self.connection.commit()\n\n    def add_book(self, title, author):\n        '''\n        Adds a new book to the 'books' table with the provided title and author. The book is initially marked as available.\n        :param title: str, the title of the book\n        :param author: str, the author of the book\n        '''\n\n        # Execute a SQL command to insert a new row into the 'books' table with the provided title and author, and an availability status of 1 (available)\n        self.cursor.execute('''\n            INSERT INTO books (title, author, available)\n            VALUES (?, ?, 1)\n        ''', (title, author))\n\n        # Commit the changes to the database\n        self.connection.commit()\n\n    def remove_book(self, book_id):\n        '''\n        Removes a book from the 'books' table based on the provided book ID.\n        :param book_id: int, the ID of the book to remove\n        '''\n\n        # Execute a SQL command to delete the row from the 'books' table with the provided book ID\n        self.cursor.execute('''\n            DELETE FROM books WHERE id = ?\n        ''', (book_id,))\n\n        # Commit the changes to the database\n        self.connection.commit()\n\n    def borrow_book(self, book_id):\n        '''\n        Marks a book as borrowed in the 'books' table based on the provided book ID. This is done by setting the 'available' column to 0.\n        :param book_id: int, the ID of the book to borrow\n        '''\n\n        # Execute a SQL command to update the 'available' column of the row with the provided book ID to 0 (not available)\n        self.cursor.execute('''\n            UPDATE books SET available = 0 WHERE id = ?\n        ''', (book_id,))\n\n        # Commit the changes to the database\n        self.connection.commit()\n\n    def return_book(self, book_id):\n        '''\n        Marks a book as returned in the 'books' table based on the provided book ID. This is done by setting the 'available' column to 1.\n        :param book_id: int, the ID of the book to return\n        '''\n\n        # Execute a SQL command to update the 'available' column of the row with the provided book ID to 1 (available)\n        self.cursor.execute('''\n            UPDATE books SET available = 1 WHERE id = ?\n        ''', (book_id,))\n\n        # Commit the changes to the database\n        self.connection.commit()\n\n    def search_books(self):\n        '''\n        Retrieves all books from the 'books' table and returns their information as a list of tuples.\n        :return: list of tuples, each tuple contains the information of a book in the format (id, title, author, available)\n        '''\n\n        # Execute a SQL command to select all rows from the 'books' table\n        self.cursor.execute('''\n            SELECT * FROM books\n        ''')\n\n        # Fetch all rows from the result of the SQL command and store them in the 'books' variable\n        books = self.cursor.fetchall()\n\n        # Return the 'books' variable\n        return books"}, {"id": "15", "llm_annotated_code": "class BoyerMooreSearch:\n    \"\"\"\n    This class implements the Boyer-Moore algorithm for string searching. The algorithm is used to find occurrences of a pattern within a given text.\n    \"\"\"\n\n    def __init__(self, text, pattern):\n        \"\"\"\n        Initializes the BoyerMooreSearch class with the given text and pattern.\n        :param text: str, the text to be searched\n        :param pattern: str, the pattern to be searched for\n        \"\"\"\n        self.text, self.pattern = text, pattern\n        self.textLen, self.patLen = len(text), len(pattern)\n\n    def match_in_pattern(self, char):\n        \"\"\"\n        Finds the rightmost occurrence of a character in the pattern.\n        :param char: str, the character to be searched for\n        :return: int, the index of the rightmost occurrence of the character in the pattern\n        \"\"\"\n\n        # Iterate from the end of the pattern to the start\n        # If the character matches, return its index\n        # If no match is found, return -1\n        for i in range(self.patLen - 1, -1, -1):\n            if char == self.pattern[i]:\n                return i\n        return -1\n\n    def mismatch_in_text(self, currentPos):\n        \"\"\"\n        Determines the position of the first mismatch between the pattern and the text.\n        :param currentPos: int, the current position in the text\n        :return: int, the position of the first mismatch between the pattern and the text, otherwise -1\n        \"\"\"\n\n        # Iterate from the end of the pattern to the start\n        # If a mismatch is found, return the index of the mismatch in the text\n        # If no mismatch is found, return -1\n        for i in range(self.patLen - 1, -1, -1):\n            if self.pattern[i] != self.text[currentPos + i]:\n                return currentPos + i\n        return -1\n\n    def bad_character_heuristic(self):\n        \"\"\"\n        Finds all occurrences of the pattern in the text.\n        :return: list, a list of all positions of the pattern in the text\n        \"\"\"\n\n        positions = []\n        i = 0\n\n        # Iterate through the text until the remaining characters are less than the pattern length\n        # If a mismatch is found, shift the pattern to align the mismatch with the rightmost occurrence of the mismatched character in the pattern\n        # If no mismatch is found, shift the pattern by one position to the right\n        while i <= self.textLen - self.patLen:\n            mismatch_index = self.mismatch_in_text(i)\n            if mismatch_index == -1:\n                positions.append(i)\n                i += 1\n            else:\n                match_index = self.match_in_pattern(self.text[mismatch_index])\n                i += max(1, mismatch_index - match_index)\n        return positions"}, {"id": "16", "llm_annotated_code": "class Calculator:\n    \"\"\"\n    This is a class for a calculator, capable of performing basic arithmetic calculations on numerical expressions using the operators +, -, *, /, and ^ (exponentiation).\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the operations performed by the five operators'+','-','*','/','^'\n        \"\"\"\n\n        # Define a dictionary of lambda functions for each operator\n        # Each lambda function takes two arguments (x, y) and performs the corresponding operation\n        self.operators = {\n            '+': lambda x, y: x + y,\n            '-': lambda x, y: x - y,\n            '*': lambda x, y: x * y,\n            '/': lambda x, y: x / y,\n            '^': lambda x, y: x ** y\n        }\n\n    def calculate(self, expression):\n        \"\"\"\n        Calculate the value of a given expression\n        :param expression: string, given expression\n        :return:If successful, returns the value of the expression; otherwise, returns None\n        \"\"\"\n\n        # Initialize two empty lists to store operands and operators\n        operand_stack = []\n        operator_stack = []\n        num_buffer = ''\n\n        # Iterate over each character in the expression\n        for char in expression:\n            # If the character is a digit or a decimal point, add it to the num_buffer\n            if char.isdigit() or char == '.':\n                num_buffer += char\n            else:\n                # If num_buffer is not empty, convert it to a float and add it to the operand stack, then clear num_buffer\n                if num_buffer:\n                    operand_stack.append(float(num_buffer))\n                    num_buffer = ''\n                # If the character is an operator, apply the operator to the top two operands in the stack\n                if char in '+-*/^':\n                    while (\n                            operator_stack and\n                            operator_stack[-1] != '(' and\n                            self.precedence(operator_stack[-1]) >= self.precedence(char)\n                    ):\n                        operand_stack, operator_stack = self.apply_operator(operand_stack, operator_stack)\n                    operator_stack.append(char)\n                # If the character is a left parenthesis, add it to the operator stack\n                elif char == '(':\n                    operator_stack.append(char)\n                # If the character is a right parenthesis, apply the operator to the top two operands in the stack until a left parenthesis is encountered\n                elif char == ')':\n                    while operator_stack and operator_stack[-1] != '(':\n                        operand_stack, operator_stack = self.apply_operator(operand_stack, operator_stack)\n                    operator_stack.pop()\n        # If num_buffer is not empty after iterating over the expression, convert it to a float and add it to the operand stack\n        if num_buffer:\n            operand_stack.append(float(num_buffer))\n        # Apply the remaining operators in the stack to the operands\n        while operator_stack:\n            operand_stack, operator_stack = self.apply_operator(operand_stack, operator_stack)\n        # Return the last operand in the stack, which is the result of the calculation\n        return operand_stack[-1] if operand_stack else None\n\n    def precedence(self, operator):\n        \"\"\"\n        Returns the priority of the specified operator, where the higher the priority, the greater the assignment. The priority of '^' is greater than '/' and '*', and the priority of '/' and '*' is greater than '+' and '-'\n        :param operator: string, given operator\n        :return: int, the priority of the given operator, otherwise return 0\n        \"\"\"\n\n        # Define a dictionary of precedences for each operator\n        precedences = {\n            '+': 1,\n            '-': 1,\n            '*': 2,\n            '/': 2,\n            '^': 3\n        }\n        # Return the precedence of the given operator, or 0 if the operator is not in the dictionary\n        return precedences.get(operator, 0)\n\n    def apply_operator(self, operand_stack, operator_stack):\n        \"\"\"\n        Use the operator at the top of the operator stack to perform the operation on the two numbers at the top of the operator stack, and store the results at the top of the operator stack\n        :param operand_stack:list\n        :param operator_stack:list\n        :return: the updated operand_stack and operator_stack\n        \"\"\"\n\n        # Pop the top operator from the operator stack\n        operator = operator_stack.pop()\n        # Pop the top two operands from the operand stack\n        operand2 = operand_stack.pop()\n        operand1 = operand_stack.pop()\n        # Calculate the result of applying the operator to the operands\n        result = self.operators[operator](operand1, operand2)\n        # Push the result onto the operand stack\n        operand_stack.append(result)\n        # Return the updated operand and operator stacks\n        return operand_stack, operator_stack"}, {"id": "17", "llm_annotated_code": "class CalendarUtil:\n    \"\"\"\n    This is a class as CalendarUtil that provides functionalities to manage calendar events, schedule appointments, and perform conflict checks.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the calendar with an empty list of events.\n        \"\"\"\n        # Initialize an empty list to store events\n        self.events = []\n\n    def add_event(self, event):\n        \"\"\"\n        Add an event to the calendar.\n        :param event: The event to be added to the calendar,dict.\n        \"\"\"\n        # Append the event to the events list\n        self.events.append(event)\n\n    def remove_event(self, event):\n        \"\"\"\n        Remove an event from the calendar.\n        :param event: The event to be removed from the calendar,dict.\n        \"\"\"\n        # Check if the event is in the events list\n        # If it is, remove it\n        if event in self.events:\n            self.events.remove(event)\n\n    def get_events(self, date):\n        \"\"\"\n        Get all events on a given date.\n        :param date: The date to get events for,datetime.\n        :return: A list of events on the given date,list.\n        \"\"\"\n        # Initialize an empty list to store events on the given date\n        events_on_date = []\n        # Iterate through each event in the events list\n        # If the date of the event matches the given date, append it to the events_on_date list\n        for event in self.events:\n            if event['date'].date() == date.date():\n                events_on_date.append(event)\n        # Return the list of events on the given date\n        return events_on_date\n\n    def is_available(self, start_time, end_time):\n        \"\"\"\n        Check if the calendar is available for a given time slot.\n        :param start_time: The start time of the time slot,datetime.\n        :param end_time: The end time of the time slot,datetime.\n        :return: True if the calendar is available for the given time slot, False otherwise,bool.\n        \"\"\"\n        # Iterate through each event in the events list\n        # If the start time of the time slot is before the end time of the event and the end time of the time slot is after the start time of the event, return False\n        for event in self.events:\n            if start_time < event['end_time'] and end_time > event['start_time']:\n                return False\n        # If no conflicts are found, return True\n        return True\n\n    def get_available_slots(self, date):\n        \"\"\"\n        Get all available time slots on a given date.\n        :param date: The date to get available time slots for,datetime.\n        :return: A list of available time slots on the given date,list.\n        \"\"\"\n        # Initialize an empty list to store available time slots\n        available_slots = []\n        # Initialize the start time as the start of the given date\n        start_time = datetime(date.year, date.month, date.day, 0, 0)\n        # Initialize the end time as the end of the given date\n        end_time = datetime(date.year, date.month, date.day, 23, 59)\n\n        # While the start time is before the end time, check if the calendar is available for the time slot from the start time to one hour later\n        # If it is, append the time slot to the available_slots list\n        # Increment the start time by one hour\n        while start_time < end_time:\n            slot_end_time = start_time + timedelta(minutes=60)\n            if self.is_available(start_time, slot_end_time):\n                available_slots.append((start_time, slot_end_time))\n            start_time += timedelta(minutes=60)\n        # Return the list of available time slots\n        return available_slots\n\n    def get_upcoming_events(self, num_events):\n        \"\"\"\n        Get the next n upcoming events from a given date.\n        :param date: The date to get upcoming events from,datetime.\n        :param n: The number of upcoming events to get,int.\n        :return: A list of the next n upcoming events from the given date,list.\n        \"\"\"\n        # Get the current date and time\n        now = datetime.now()\n        # Initialize an empty list to store upcoming events\n        upcoming_events = []\n\n        # Iterate through each event in the events list\n        # If the start time of the event is after the current date and time, append it to the upcoming_events list\n        # If the length of the upcoming_events list is equal to the number of events requested, break the loop\n        for event in self.events:\n            if event['start_time'] >= now:\n                upcoming_events.append(event)\n            if len(upcoming_events) == num_events:\n                break\n        \n        # Return the list of upcoming events\n        return upcoming_events"}, {"id": "18", "llm_annotated_code": "class CamelCaseMap:\n    \"\"\"\n    This is a custom class that allows keys to be in camel case style by converting them from underscore style, which provides dictionary-like functionality.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize data to an empty dictionary\n        \"\"\"\n        # Initialize an empty dictionary to store the data\n        self._data = {}\n\n    def __getitem__(self, key):\n        \"\"\"\n        Return the value corresponding to the key\n        :param key:str\n        :return:str,the value corresponding to the key\n        >>> camelize_map = CamelCaseMap()\n        >>> camelize_map['first_name'] = 'John'\n        >>> camelize_map.__getitem__('first_name')\n        'John'\n        \"\"\"\n        # Convert the key to camel case using the _convert_key method\n        # Return the value corresponding to the converted key from the _data dictionary\n        return self._data[self._convert_key(key)]\n\n    def __setitem__(self, key, value):\n        \"\"\"\n        Set the value corresponding to the key to the specified value\n        :param key:str\n        :param value:str, the specified value\n        :return:None\n        >>> camelize_map = CamelCaseMap()\n        >>> camelize_map['first_name'] = 'John'\n        >>> camelize_map.__setitem__('first_name', 'new name')\n        camelize_map['first_name'] = 'new name'\n        \"\"\"\n        # Convert the key to camel case using the _convert_key method\n        # Set the value corresponding to the converted key in the _data dictionary to the specified value\n        self._data[self._convert_key(key)] = value\n\n    def __delitem__(self, key):\n        \"\"\"\n        Delete the value corresponding to the key\n        :param key:str\n        :return:None\n        >>> camelize_map = CamelCaseMap()\n        >>> camelize_map['first_name'] = 'John'\n        >>> camelize_map.__delitem__('first_name')\n        >>> flag = 'first_name' in camelize_map\n        flag = False\n        \"\"\"\n        # Convert the key to camel case using the _convert_key method\n        # Delete the value corresponding to the converted key from the _data dictionary\n        del self._data[self._convert_key(key)]\n\n    def __iter__(self):\n        \"\"\"\n        Returning Iterateable Objects with Own Data\n        :return:Iterator\n        >>> camelize_map = CamelCaseMap()\n        >>> camelize_map['first_name'] = 'John'\n        >>> camelize_map['last_name'] = 'Doe'\n        >>> camelize_map['age'] = 30\n        >>> camelize_map.__iter__()\n        <dict_keyiterator object at 0x0000026739977C20>\n        \"\"\"\n        # Return an iterator over the _data dictionary\n        return iter(self._data)\n\n    def __len__(self):\n        \"\"\"\n        Returns the length of the own data\n        :return:int, length of data\n        >>> camelize_map = CamelCaseMap()\n        >>> camelize_map['first_name'] = 'John'\n        >>> camelize_map['last_name'] = 'Doe'\n        >>> camelize_map['age'] = 30\n        >>> camelize_map.__len__()\n        3\n        \"\"\"\n        # Return the length of the _data dictionary\n        return len(self._data)\n\n    def _convert_key(self, key):\n        \"\"\"\n        convert key string into camel case\n        :param key:str\n        :return:str, converted key string\n        >>> camelize_map = CamelCaseMap()\n        >>> camelize_map._convert_key('first_name')\n        'firstName'\n        \"\"\"\n        # Check if the key is a string\n        # If it is, convert it to camel case using the _to_camel_case method\n        # If it's not, return the key as is\n        if isinstance(key, str):\n            return self._to_camel_case(key)\n        return key\n\n    @staticmethod\n    def _to_camel_case(key):\n        \"\"\"\n        convert key string into camel case\n        :param key:str\n        :return:str, converted key string\n        >>> camelize_map = CamelCaseMap()\n        >>> camelize_map._to_camel_case('first_name')\n        'firstName'\n        \"\"\"\n        # Split the key into parts by underscore\n        # Return the first part concatenated with each of the remaining parts capitalized\n        parts = key.split('_')\n        return parts[0] + ''.join(part.title() for part in parts[1:])"}, {"id": "19", "llm_annotated_code": "class ChandrasekharSieve:\n    \"\"\"\n    This is a class that uses the Chandrasekhar's Sieve method to find all prime numbers within the range\n    \"\"\"\n\n    def __init__(self, n):\n        \"\"\"\n        Initialize the ChandrasekharSieve class with the given limit.\n        :param n: int, the upper limit for generating prime numbers\n        >>> cs = ChandrasekharSieve(20)\n\n        \"\"\"\n\n        # Store the upper limit for generating prime numbers\n        self.n = n\n\n        # Generate the list of prime numbers up to the upper limit and store it in self.primes\n        self.primes = self.generate_primes()\n\n    def generate_primes(self):\n        \"\"\"\n        Generate prime numbers up to the specified limit using the Chandrasekhar sieve algorithm.\n        :return: list, a list of prime numbers\n        >>> cs = ChandrasekharSieve(20)\n        >>> cs.generate_primes()\n        [2, 3, 5, 7, 11, 13, 17, 19]\n\n        \"\"\"\n\n        # If the upper limit is less than 2, return an empty list as there are no prime numbers\n        if self.n < 2:\n            return []\n\n        # Initialize a list of boolean values representing whether each index is a prime number\n        sieve = [True] * (self.n + 1)\n\n        # 0 and 1 are not prime numbers\n        sieve[0] = sieve[1] = False\n\n        # Start from 2, the first prime number\n        p = 2\n\n        # Iterate over each number up to the square root of the upper limit\n        while p * p <= self.n:\n            # If the current number is a prime number\n            if sieve[p]:\n                # Mark all multiples of the current number as not prime\n                for i in range(p * p, self.n + 1, p):\n                    sieve[i] = False\n            # Move to the next number\n            p += 1\n\n        # Initialize an empty list to store the prime numbers\n        primes = []\n\n        # Iterate over each number up to the upper limit\n        for i in range(2, self.n + 1):\n            # If the number is a prime number, add it to the list of prime numbers\n            if sieve[i]:\n                primes.append(i)\n\n        # Return the list of prime numbers\n        return primes\n\n    def get_primes(self):\n        \"\"\"\n        Get the list of generated prime numbers.\n        :return: list, a list of prime numbers\n        >>> cs = ChandrasekharSieve(20)\n        >>> cs.get_primes()\n        [2, 3, 5, 7, 11, 13, 17, 19]\n\n        \"\"\"\n\n        # Return the list of prime numbers generated by the Chandrasekhar sieve algorithm\n        return self.primes"}, {"id": "20", "llm_annotated_code": "class Chat:\n    \"\"\"\n    This is a chat class with the functions of adding users, removing users, sending messages, and obtaining messages.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the Chat with an attribute users, which is an empty dictionary.\n        The users dictionary will store the username as the key and a list of messages as the value.\n        Each message is a dictionary with keys 'sender', 'receiver', 'message', 'timestamp'.\n        \"\"\"\n        self.users = {}\n\n    def add_user(self, username):\n        \"\"\"\n        Add a new user to the Chat.\n        :param username: The user's name, str.\n        :return: If the user is already in the Chat, returns False, otherwise, returns True.\n        The method checks if the username is already a key in the users dictionary.\n        If it is, it returns False. If it is not, it adds the username as a key to the users dictionary with an empty list as the value and returns True.\n        \"\"\"\n\n        if username in self.users:\n            return False\n        else:\n            self.users[username] = []\n            return True\n\n    def remove_user(self, username):\n        \"\"\"\n        Remove a user from the Chat.\n        :param username: The user's name, str.\n        :return: If the user is already in the Chat, returns True, otherwise, returns False.\n        The method checks if the username is a key in the users dictionary.\n        If it is, it deletes the key-value pair from the dictionary and returns True. If it is not, it returns False.\n        \"\"\"\n\n        if username in self.users:\n            del self.users[username]\n            return True\n        else:\n            return False\n\n    def send_message(self, sender, receiver, message):\n        \"\"\"\n        Send a message from a user to another user.\n        :param sender: The sender's name, str.\n        :param receiver: The receiver's name, str.\n        :param message: The message, str.\n        :return: If the sender or the receiver is not in the Chat, returns False, otherwise, returns True.\n        The method checks if both the sender and receiver are keys in the users dictionary.\n        If either is not, it returns False. If both are, it creates a dictionary with the sender, receiver, message, and the current timestamp.\n        It then appends this dictionary to the list of messages for both the sender and receiver in the users dictionary and returns True.\n        \"\"\"\n\n        if sender not in self.users or receiver not in self.users:\n            return False\n\n        timestamp = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n        message_info = {\n            'sender': sender,\n            'receiver': receiver,\n            'message': message,\n            'timestamp': timestamp\n        }\n\n        self.users[sender].append(message_info)\n        self.users[receiver].append(message_info)\n        return True\n\n    def get_messages(self, username):\n        \"\"\"\n        Get all the messages of a user from the Chat.\n        :param username: The user's name, str.\n        :return: A list of messages, each message is a dictionary with keys 'sender', 'receiver', 'message', 'timestamp'.\n        The method checks if the username is a key in the users dictionary.\n        If it is not, it returns an empty list. If it is, it returns the list of messages associated with the username.\n        \"\"\"\n\n        if username not in self.users:\n            return []\n        \n        return self.users[username]"}, {"id": "21", "llm_annotated_code": "class Classroom:\n    \"\"\"\n    This is a class representing a classroom, capable of adding and removing courses, checking availability at a given time, and detecting conflicts when scheduling new courses.\n    \"\"\"\n\n    def __init__(self, id):\n        \"\"\"\n        Initialize the classroom management system.\n        :param id: int, the id of classroom\n        \"\"\"\n        # Store the id of the classroom\n        self.id = id\n        # Initialize an empty list to store the courses in the classroom\n        self.courses = []\n\n    def add_course(self, course):\n        \"\"\"\n        Add course to self.courses list if the course wasn't in it.\n        :param course: dict, information of the course, including 'start_time', 'end_time' and 'name'\n        \"\"\"\n        # Check if the course is not already in the list of courses\n        # If it's not, append it to the list\n        if course not in self.courses:\n            self.courses.append(course)\n\n    def remove_course(self, course):\n        \"\"\"\n        Remove course from self.courses list if the course was in it.\n        :param course: dict, information of the course, including 'start_time', 'end_time' and 'name'\n        \"\"\"\n        # Check if the course is in the list of courses\n        # If it is, remove it from the list\n        if course in self.courses:\n            self.courses.remove(course)\n\n    def is_free_at(self, check_time):\n        \"\"\"\n        Change the time format as '%H:%M' and check the time is free or not in the classroom.\n        :param check_time: str, the time need to be checked\n        :return: True if the check_time does not conflict with every course time, or False otherwise.\n        \"\"\"\n        # Convert the check_time string to a datetime object\n        check_time = datetime.strptime(check_time, '%H:%M')\n\n        # Iterate over the courses in the classroom\n        for course in self.courses:\n            # Convert the start and end times of the course to datetime objects\n            # If the check_time falls within the start and end times of the course, return False\n            if datetime.strptime(course['start_time'], '%H:%M') <= check_time <= datetime.strptime(course['end_time'], '%H:%M'):\n                return False\n        \n        # If the check_time does not conflict with any course, return True\n        return True\n\n    def check_course_conflict(self, new_course):\n        \"\"\"\n        Before adding a new course, check if the new course time conflicts with any other course.\n        :param new_course: dict, information of the course, including 'start_time', 'end_time' and 'name'\n        :return: False if the new course time conflicts(including two courses have the same boundary time) with other courses, or True otherwise.\n        \"\"\"\n        # Convert the start and end times of the new course to datetime objects\n        new_start_time = datetime.strptime(new_course['start_time'], '%H:%M')\n        new_end_time = datetime.strptime(new_course['end_time'], '%H:%M')\n\n        # Initialize a flag as True\n        flag = True\n        # Iterate over the courses in the classroom\n        for course in self.courses:\n            # Convert the start and end times of the course to datetime objects\n            start_time = datetime.strptime(course['start_time'], '%H:%M')\n            end_time = datetime.strptime(course['end_time'], '%H:%M')\n\n            # If the start or end time of the new course falls within the start and end times of the course, set the flag as False\n            if start_time <= new_start_time and end_time >= new_start_time:\n                flag = False\n            if start_time <= new_end_time and end_time >= new_end_time:\n                flag = False\n\n        # Return the flag\n        return flag"}, {"id": "22", "llm_annotated_code": "class ClassRegistrationSystem:\n\n    \"\"\"\n    This is a class as a class registration system, allowing to register students, register them for classes, retrieve students by major, get a list of all majors, and determine the most popular class within a specific major.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the registration system with the attribute students and students_registration_class.\n        students is a list of student dictionaries, each student dictionary has the key of name and major.\n        students_registration_classes is a dictionary, key is the student name, value is a list of class names\n        \"\"\"\n        self.students = []  # List to store student dictionaries\n        self.students_registration_classes = {}  # Dictionary to store student's registered classes\n\n    def register_student(self, student):\n        \"\"\"\n        Register a student to the system, add the student to the students list, if the student is already registered, return 0, else return 1\n        :param student: dict\n        :return 0 if the student is already registered, else return 1\n        \"\"\"\n\n        # Check if student is already in the students list\n        if student in self.students:\n            return 0\n        else:\n            # If not, add student to the students list\n            self.students.append(student)\n            return 1\n\n    def register_class(self, student_name, class_name):\n        \"\"\"\n        Register a class to the student.\n        :param student_name: str\n        :param class_name: str\n        :return a list of class names that the student has registered\n        \"\"\"\n\n        # Check if student_name is already in the students_registration_classes dictionary\n        if student_name in self.students_registration_classes:\n            # If yes, append the class_name to the list of classes for that student\n            self.students_registration_classes[student_name].append(class_name)\n        else:\n            # If not, create a new list for that student with the class_name\n            self.students_registration_classes[student_name] = [class_name]\n        return self.students_registration_classes[student_name]\n\n    def get_students_by_major(self, major):\n        \"\"\"\n        Get all students in the major\n        :param major: str\n        :return a list of student name\n        \"\"\"\n\n        student_list = []  # List to store student names\n\n        # Iterate over students list\n        for student in self.students:\n            # If student's major matches the input major, append their name to student_list\n            if student[\"major\"] == major:\n                student_list.append(student[\"name\"])\n        \n        return student_list\n\n    def get_all_major(self):\n        \"\"\"\n        Get all majors in the system\n        :return a list of majors\n        \"\"\"\n\n        major_list = []  # List to store majors\n\n        # Iterate over students list\n        for student in self.students:\n            # If student's major is not already in major_list, append it\n            if student[\"major\"] not in major_list:\n                major_list.append(student[\"major\"])\n            \n        return major_list\n\n    def get_most_popular_class_in_major(self, major):\n        \"\"\"\n        Get the class with the highest enrollment in the major.\n        :return  a string of the most popular class in this major\n        \"\"\"\n\n        class_list = []  # List to store classes\n\n        # Iterate over students list\n        for student in self.students:\n            # If student's major matches the input major, append their classes to class_list\n            if student[\"major\"] == major:\n                class_list += self.students_registration_classes[student[\"name\"]]\n        \n        # Find the class that appears most frequently in class_list\n        most_popular_class = max(set(class_list), key=class_list.count)\n        return most_popular_class"}, {"id": "23", "llm_annotated_code": "class CombinationCalculator:\n    \"\"\"\n    This is a class that provides methods to calculate the number of combinations for a specific count, calculate all possible combinations, and generate combinations with a specified number of elements.\n    \"\"\"\n\n    def __init__(self, datas: List[str]):\n        \"\"\"\n        Initialize the calculator with a list of data.\n        :param datas: list of str, the data to be used for combinations\n        \"\"\"\n        self.datas = datas\n\n    @staticmethod\n    def count(n: int, m: int) -> int:\n        \"\"\"\n        Calculate the number of combinations for a specific count.\n        :param n: int, The total number of elements.\n        :param m: int, The number of elements in each combination.\n        :return: int, The number of combinations.\n        This method uses the math.factorial function to calculate the factorial of numbers.\n        \"\"\"\n\n        if m == 0 or n == m:\n            return 1\n        return math.factorial(n) // (math.factorial(n - m) * math.factorial(m))\n\n    @staticmethod\n    def count_all(n: int) -> int:\n        \"\"\"\n        Calculate the number of all possible combinations.\n        :param n: int, The total number of elements.\n        :return: int, The number of all possible combinations, if the number of combinations is greater than 2^63-1, return float(\"inf\").\n        \"\"\"\n\n        if n < 0 or n > 63:\n            return False\n        return (2 ** n) - 1 if n != 63 else float(\"inf\")\n\n    def select(self, m: int) -> List[List[str]]:\n        \"\"\"\n        Generate combinations with a specified number of elements.\n        :param m: int, The number of elements in each combination.\n        :return: list of list of str, A list of combinations.\n        This method uses the _select method to generate combinations.\n        \"\"\"\n\n        result = []\n        self._select(0, [None] * m, 0, result)\n        return result\n\n    def select_all(self) -> List[List[str]]:\n        \"\"\"\n        Generate all possible combinations of  selecting elements from the given data list,and it uses the select method.\n        :return: list of list of str, A list of combinations.\n        \"\"\"\n\n        result = []\n        for i in range(1, len(self.datas) + 1):\n            result.extend(self.select(i))\n        return result\n\n    def _select(self, dataIndex: int, resultList: List[str], resultIndex: int, result: List[List[str]]):\n        \"\"\"\n        Generate combinations with a specified number of elements by recursion.\n        :param dataIndex: int, The index of the data to be selected.\n        :param resultList: list of str, The list of elements in the combination.\n        :param resultIndex: int, The index of the element in the combination.\n        :param result: list of list of str, The list of combinations.\n        :return: None.\n        This method is a helper method used by the select method to generate combinations.\n        \"\"\"\n\n        resultLen = len(resultList)\n        resultCount = resultIndex + 1\n        if resultCount > resultLen:\n            result.append(resultList.copy())\n            return\n\n        for i in range(dataIndex, len(self.datas) + resultCount - resultLen):\n            resultList[resultIndex] = self.datas[i]\n            self._select(i + 1, resultList, resultIndex + 1, result)"}, {"id": "24", "llm_annotated_code": "class ComplexCalculator:\n\n    \"\"\"\n    This class provides methods for performing basic arithmetic operations (addition, subtraction, multiplication, and division) on complex numbers.\n    \"\"\"\n\n    def __init__(self):\n        pass\n\n    @staticmethod\n    def add(c1, c2):\n        \"\"\"\n        Adds two complex numbers.\n        :param c1: The first complex number, complex.\n        :param c2: The second complex number, complex.\n        :return: The sum of the two complex numbers, complex.\n        >>> complexCalculator = ComplexCalculator()\n        >>> complexCalculator.add(1+2j, 3+4j)\n        (4+6j)\n\n        \"\"\"\n\n        # Extract the real and imaginary parts from the complex numbers and add them separately\n        real = c1.real + c2.real\n        imaginary = c1.imag + c2.imag\n\n        # Combine the real and imaginary parts to form a new complex number and return it\n        answer = complex(real, imaginary)\n        return answer\n\n    @staticmethod\n    def subtract(c1, c2):\n        \"\"\"\n        Subtracts two complex numbers.\n        :param c1: The first complex number, complex.\n        :param c2: The second complex number, complex.\n        :return: The difference of the two complex numbers, complex.\n        >>> complexCalculator = ComplexCalculator()\n        >>> complexCalculator.subtract(1+2j, 3+4j)\n        (-2-2j)\n\n        \"\"\"\n\n        # Extract the real and imaginary parts from the complex numbers and subtract them separately\n        real = c1.real - c2.real\n        imaginary = c1.imag - c2.imag\n\n        # Combine the real and imaginary parts to form a new complex number and return it\n        return complex(real, imaginary)\n\n    @staticmethod\n    def multiply(c1, c2):\n        \"\"\"\n        Multiplies two complex numbers.\n        :param c1: The first complex number, complex.\n        :param c2: The second complex number, complex.\n        :return: The product of the two complex numbers, complex.\n        >>> complexCalculator = ComplexCalculator()\n        >>> complexCalculator.multiply(1+2j, 3+4j)\n        (-5+10j)\n\n        \"\"\"\n\n        # Multiply the complex numbers using the formula (a + bi)(c + di) = (ac - bd) + (bc + ad)i\n        real = c1.real * c2.real - c1.imag * c2.imag\n        imaginary = c1.real * c2.imag + c1.imag * c2.real\n\n        # Combine the real and imaginary parts to form a new complex number and return it\n        return complex(real, imaginary)\n\n    @staticmethod\n    def divide(c1, c2):\n        \"\"\"\n        Divides two complex numbers.\n        :param c1: The first complex number, complex.\n        :param c2: The second complex number, complex.\n        :return: The quotient of the two complex numbers, complex.\n        >>> complexCalculator = ComplexCalculator()\n        >>> complexCalculator.divide(1+2j, 3+4j)\n        (0.44+0.08j)\n\n        \"\"\"\n\n        # Calculate the denominator using the formula |c + di|^2 = c^2 + d^2\n        denominator = c2.real**2 + c2.imag**2\n\n        # Divide the complex numbers using the formula (a + bi) / (c + di) = [(ac + bd) / (c^2 + d^2)] + [(bc - ad) / (c^2 + d^2)]i\n        real = (c1.real * c2.real + c1.imag * c2.imag) / denominator\n        imaginary = (c1.imag * c2.real - c1.real * c2.imag) / denominator\n\n        # Combine the real and imaginary parts to form a new complex number and return it\n        return complex(real, imaginary)"}, {"id": "25", "llm_annotated_code": "class CookiesUtil:\n    \"\"\"\n    This is a class as utility for managing and manipulating Cookies, including methods for retrieving, saving, and setting Cookies data.\n    \"\"\"\n\n    def __init__(self, cookies_file):\n        \"\"\"\n        Initializes the CookiesUtil with the specified cookies file.\n        :param cookies_file: str, The cookies file to use.\n        \"\"\"\n        # Store the cookies file path\n        self.cookies_file = cookies_file\n        # Initialize cookies as None\n        self.cookies = None\n\n    def get_cookies(self, reponse):\n        \"\"\"\n        Gets the cookies from the specified response,and save it to cookies_file.\n        :param reponse: dict, The response to get cookies from.\n        >>> cookies_util = CookiesUtil('cookies.json')\n        >>> cookies_util.get_cookies({'cookies': {'key1': 'value1', 'key2': 'value2'}})\n        >>> cookies_util.cookies\n        {'key1': 'value1', 'key2': 'value2'}\n\n        \"\"\"\n        # Extract cookies from the response\n        self.cookies = reponse['cookies']\n        # Save the cookies to the file\n        self._save_cookies()\n\n    def load_cookies(self):\n        \"\"\"\n        Loads the cookies from the cookies_file to the cookies data.\n        :return: dict, The cookies data.\n        >>> cookies_util = CookiesUtil('cookies.json')\n        >>> cookies_util.load_cookies()\n        {'key1': 'value1', 'key2': 'value2'}\n\n        \"\"\"\n        try:\n            # Open the cookies file and load the cookies data\n            with open(self.cookies_file, 'r') as file:\n                cookies_data = json.load(file)\n                return cookies_data\n        except FileNotFoundError:\n            # If the file is not found, return an empty dictionary\n            return {}\n\n    def _save_cookies(self):\n        \"\"\"\n        Saves the cookies to the cookies_file, and returns True if successful, False otherwise.\n        :return: bool, True if successful, False otherwise.\n        >>> cookies_util = CookiesUtil('cookies.json')\n        >>> cookies_util.cookies = {'key1': 'value1', 'key2': 'value2'}\n        >>> cookies_util._save_cookies()\n        True\n\n        \"\"\"\n        try:\n            # Open the cookies file and save the cookies data\n            with open(self.cookies_file, 'w') as file:\n                json.dump(self.cookies, file)\n            return True\n        except:\n            # If an error occurs while saving, return False\n            return False"}, {"id": "26", "llm_annotated_code": "class CSVProcessor:\n\n    \"\"\"\n    This is a class for processing CSV files, including reading and writing CSV data, as well as processing specific operations and saving as a new CSV file.\n    \"\"\"\n\n    def __init__(self):\n        pass\n\n    def read_csv(self, file_name):\n        \"\"\"\n        Read the csv file by file_name, get the title and data from it\n        :param file_name: str, name of the csv file\n        :return title, data: (list, list), first row is title, the rest is data\n        >>> csvProcessor = CSVProcessor()\n        >>> csvProcessor.read_csv('read_test.csv')\n        (['a', 'b', 'c', 'd'], [['hElLo', 'YoU', 'ME', 'LoW']])\n        \"\"\"\n\n        # Initialize an empty list to store the data\n        data = []\n\n        # Open the CSV file in read mode\n        with open(file_name, 'r') as file:\n            # Use the csv.reader function to read the file\n            reader = csv.reader(file)\n\n            # Use the next function to get the first row of the CSV file, which is the title\n            title = next(reader)\n\n            # Iterate through the rest of the rows in the CSV file and append them to the data list\n            for row in reader:\n                data.append(row)\n\n        # Return the title and data\n        return title, data\n\n    def write_csv(self, data, file_name):\n        \"\"\"\n        Write data into a csv file.\n        :param file_name: str, name of the csv file\n        :return:int, if success return 1, or 0 otherwise\n        >>> csvProcessor = CSVProcessor()\n        >>> csvProcessor.write_csv([['a', 'b', 'c', 'd'], ['1', '2', '3', '4']], 'write_test.csv')\n        1\n        \"\"\"\n\n        try:\n            # Open the CSV file in write mode\n            with open(file_name, 'w', newline='') as file:\n                # Use the csv.writer function to write to the file\n                writer = csv.writer(file)\n\n                # Use the writerows method of the writer object to write the data to the file\n                writer.writerows(data)\n\n            # Return 1 if the operation is successful\n            return 1\n        except:\n            # Return 0 if an exception occurs\n            return 0\n\n    def process_csv_data(self, N, save_file_name):\n        \"\"\"\n        Read a csv file into variable title and data.\n        Only remain the N th (from 0) column data and Capitalize them, store the title and new data into a new csv file.\n        Add '_process' suffix after old file name, as a new file name.\n        :param N: int, the N th column(from 0)\n        :param save_file_name, the name of file that needs to be processed.\n        :return:int, if success return 1, or 0 otherwise\n        >>> csvProcessor = CSVProcessor()\n        >>> csvProcessor.read_csv('read_test.csv')\n        (['a', 'b', 'c', 'd'], [['hElLo', 'YoU', 'ME', 'LoW']])\n        >>> csvProcessor.process_csv_data(0, 'read_test.csv')\n        1\n        >>> csvProcessor.read_csv('read_test_process.csv')\n        (['a', 'b', 'c', 'd'], [['HELLO']])\n        \"\"\"\n\n        # Use the read_csv method to read the CSV file and get the title and data\n        title, data = self.read_csv(save_file_name)\n\n        # Use list comprehension to get the Nth column from the data and capitalize it\n        column_data = [row[N].upper() for row in data]\n\n        # Combine the title and the processed column data into a new data list\n        new_data = [title] + [column_data]\n\n        # Use the write_csv method to write the new data to a new CSV file with a '_process' suffix added to the original file name\n        # Use the split method to remove the file extension from the original file name\n        return self.write_csv(new_data, save_file_name.split('.')[0] + '_process.csv')"}, {"id": "27", "llm_annotated_code": "class CurrencyConverter:\n\n    \"\"\"\n    This is a class for currency conversion, which supports to convert amounts between different currencies, retrieve supported currencies, add new currency rates, and update existing currency rates.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the exchange rate of the US dollar against various currencies.\n        The rates are stored in a dictionary where the keys are the currency codes and the values are the exchange rates.\n        \"\"\"\n\n        self.rates = {\n            'USD': 1.0,\n            'EUR': 0.85,\n            'GBP': 0.72,\n            'JPY': 110.15,\n            'CAD': 1.23,\n            'AUD': 1.34,\n            'CNY': 6.40,\n        }\n\n    def convert(self, amount, from_currency, to_currency):\n        \"\"\"\n        Convert the value of a given currency to another currency type.\n        :param amount: float, The value of a given currency.\n        :param from_currency: string, source currency type.\n        :param to_currency: string, target currency type.\n        :return: float, value converted to another currency type.\n        If the source and target currencies are the same, return the original amount.\n        If either the source or target currency is not supported, return False.\n        Otherwise, calculate the converted amount by first converting the amount to USD (if the source currency is not USD), and then converting the USD amount to the target currency.\n        >>> cc = CurrencyConverter()\n        >>> cc.convert(64, 'CNY','USD')\n        10.0\n        \"\"\"\n\n        if from_currency == to_currency:\n            return amount\n        if from_currency not in self.rates or to_currency not in self.rates:\n            return False\n        from_rate = self.rates[from_currency]\n        to_rate = self.rates[to_currency]\n        converted_amount = (amount / from_rate) * to_rate\n        return converted_amount\n\n\n    def get_supported_currencies(self):\n        \"\"\"\n        Returns a list of supported currency types.\n        :return:list, All supported currency types.\n        The supported currencies are the keys of the rates dictionary.\n        >>> cc = CurrencyConverter()\n        >>> cc.get_supported_currencies()\n        ['USD','EUR','GBP','JPY','CAD','AUD','CNY']\n        \"\"\"\n\n        return list(self.rates.keys())\n\n\n    def add_currency_rate(self, currency, rate):\n        \"\"\"\n        Add a new supported currency type, return False if the currency type is already in the support list.\n        :param currency:string, currency type to be added.\n        :param rate:float, exchange rate for this type of currency.\n        :return:If successful, returns None; if unsuccessful, returns False.\n        If the currency is already in the rates dictionary, return False.\n        Otherwise, add the currency and its rate to the rates dictionary.\n        >>> cc = CurrencyConverter()\n        >>> cc.add_currency_rate('KRW', 1308.84)\n        self.rates['KRW'] = 1308.84\n        \"\"\"\n\n        if currency in self.rates:\n            return False\n        self.rates[currency] = rate\n\n\n    def update_currency_rate(self, currency, new_rate):\n        \"\"\"\n        Update the exchange rate for a certain currency.\n        :param currency:string.\n        :param new_rate:float.\n        :return:If successful, returns None; if unsuccessful, returns False.\n        If the currency is not in the rates dictionary, return False.\n        Otherwise, update the rate of the currency in the rates dictionary.\n        >>> cc = CurrencyConverter()\n        >>> cc.update_currency_rate('CNY', 7.18)\n        self.rates['CNY'] = 7.18\n        \"\"\"\n\n        if currency not in self.rates:\n            return False\n        self.rates[currency] = new_rate"}, {"id": "28", "llm_annotated_code": "class DatabaseProcessor:\n\n    \"\"\"\n    This is a class for processing a SQLite database. It supports creating tables, inserting data into the database, \n    searching for data based on name, and deleting data from the database.\n    \"\"\"\n\n    def __init__(self, database_name):\n        \"\"\"\n        Initialize the DatabaseProcessor with the name of the database to be processed.\n        :param database_name: str, the name of the database\n        \"\"\"\n\n        self.database_name = database_name\n\n\n    def create_table(self, table_name, key1, key2):\n        \"\"\"\n        Create a new table in the database if it doesn't exist.\n        The table will have an 'id' column as the primary key, and two additional columns with names specified by key1 and key2.\n        :param table_name: str, the name of the table to create\n        :param key1: str, the name of the first additional column in the table\n        :param key2: str, the name of the second additional column in the table\n        \"\"\"\n\n        # Connect to the SQLite database using the sqlite3.connect function\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n\n        # Create a SQL query to create a new table with the specified name and columns\n        create_table_query = f\"CREATE TABLE IF NOT EXISTS {table_name} (id INTEGER PRIMARY KEY, {key1} TEXT, {key2} INTEGER)\"\n\n        # Execute the SQL query using the cursor.execute method\n        cursor.execute(create_table_query)\n\n        # Commit the changes and close the connection to the database\n        conn.commit()\n        conn.close()\n\n\n    def insert_into_database(self, table_name, data):\n        \"\"\"\n        Insert data into the specified table in the database.\n        :param table_name: str, the name of the table to insert data into\n        :param data: list of dicts, a list of dictionaries where each dictionary represents a row of data to be inserted\n        \"\"\"\n\n        # Connect to the SQLite database using the sqlite3.connect function\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n\n        # Iterate over the data list and for each dictionary in the list, create a SQL query to insert the data into the specified table\n        for item in data:\n            insert_query = f\"INSERT INTO {table_name} (name, age) VALUES (?, ?)\"\n\n            # Execute the SQL query using the cursor.execute method\n            cursor.execute(insert_query, (item['name'], item['age']))\n\n        # Commit the changes and close the connection to the database\n        conn.commit()\n        conn.close()\n\n    def search_database(self, table_name, name):\n        \"\"\"\n        Search the specified table in the database for rows with a matching name.\n        :param table_name: str, the name of the table to search\n        :param name: str, the name to search for\n        :return: list of tuples, a list of tuples representing the rows with matching name, if any; otherwise, returns None\n        \"\"\"\n\n        # Connect to the SQLite database using the sqlite3.connect function\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n\n        # Create a SQL query to select all rows from the specified table where the name matches the specified name\n        select_query = f\"SELECT * FROM {table_name} WHERE name = ?\"\n\n        # Execute the SQL query using the cursor.execute method\n        cursor.execute(select_query, (name,))\n\n        # Fetch all the rows returned by the query using the cursor.fetchall method\n        result = cursor.fetchall()\n\n        # If the result is not empty, return the result; otherwise, return None\n        if result:\n            return result\n        else:\n            return None\n\n\n    def delete_from_database(self, table_name, name):\n        \"\"\"\n        Delete rows from the specified table in the database with a matching name.\n        :param table_name: str, the name of the table to delete rows from\n        :param name: str, the name to match for deletion\n        \"\"\"\n\n        # Connect to the SQLite database using the sqlite3.connect function\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n\n        # Create a SQL query to delete all rows from the specified table where the name matches the specified name\n        delete_query = f\"DELETE FROM {table_name} WHERE name = ?\"\n\n        # Execute the SQL query using the cursor.execute method\n        cursor.execute(delete_query, (name,))\n\n        # Commit the changes and close the connection to the database\n        conn.commit()\n        conn.close()"}, {"id": "29", "llm_annotated_code": "class DataStatistics:\n    \n    \"\"\"\n    This class is used for performing statistical operations on a given dataset. It supports the calculation of mean, median, and mode.\n    \"\"\"\n\n    def mean(self, data):\n        \"\"\"\n        Calculate the mean (average) of a list of numbers.\n        :param data: list, a list of numerical values\n        :return: float, the mean value of the data, rounded to two decimal places\n        >>> ds = DataStatistics()\n        >>> ds.mean([1, 2, 3, 4, 5])\n        3.00\n        \"\"\"\n\n        # Calculate the sum of the data and divide by the length of the data to get the mean\n        # Round the result to two decimal places using the round function\n        return round(sum(data) / len(data), 2)\n\n    def median(self, data):\n        \"\"\"\n        Calculate the median (middle value) of a list of numbers.\n        :param data: list, a list of numerical values\n        :return: float, the median value of the data\n        >>> ds = DataStatistics()\n        >>> ds.median([2, 5, 1, 3, 4])\n        3.00\n        \"\"\"\n\n        # Sort the data in ascending order\n        sorted_data = sorted(data)\n\n        # Calculate the index of the middle element\n        n = len(sorted_data)\n        if n % 2 == 0:\n            # If the length of the data is even, the median is the average of the two middle numbers\n            middle = n // 2\n            return round((sorted_data[middle - 1] + sorted_data[middle]) / 2, 2)\n        else:\n            # If the length of the data is odd, the median is the middle number\n            middle = n // 2\n            return sorted_data[middle]\n\n    def mode(self, data):\n        \"\"\"\n        Calculate the mode (most frequent value) of a list of numbers.\n        :param data: list, a list of numerical values\n        :return: list, a list of the mode(s) of the data\n        >>> ds = DataStatistics()\n        >>> ds.mode([2, 2, 3, 3, 4])\n        [2, 3]\n        \"\"\"\n\n        # Use the Counter class from the collections module to count the frequency of each number in the data\n        counter = Counter(data)\n\n        # Find the maximum count (the most frequent number(s))\n        mode_count = max(counter.values())\n\n        # Find all numbers that have the maximum count and return them as the mode(s)\n        mode = [x for x, count in counter.items() if count == mode_count]\n        return mode"}, {"id": "30", "llm_annotated_code": "class DataStatistics2:\n\n    \"\"\"\n    This class uses numpy library to perform statistical operations on a given dataset. \n    It supports operations to get the sum, minimum, maximum, variance, standard deviation, and correlation of the dataset.\n    \"\"\"\n\n    def __init__(self, data):\n        \"\"\"\n        Initialize the DataStatistics2 with a dataset.\n        :param data: list, the dataset on which statistical operations are to be performed\n        >>> ds2 = DataStatistics2([1, 2, 3, 4])\n        \"\"\"\n\n        # Convert the input data list to a numpy array and store it in self.data\n        self.data = np.array(data)\n\n    def get_sum(self):\n        \"\"\"\n        Calculate the sum of the dataset.\n        :return: float, the sum of the dataset\n        >>> ds2 = DataStatistics2([1, 2, 3, 4])\n        >>> ds2.get_sum()\n        10\n        \"\"\"\n\n        # Use numpy's sum function to calculate the sum of the dataset\n        return np.sum(self.data)\n\n    def get_min(self):\n        \"\"\"\n        Calculate the minimum value in the dataset.\n        :return: float, the minimum value in the dataset\n        >>> ds2 = DataStatistics2([1, 2, 3, 4])\n        >>> ds2.get_min()\n        1\n        \"\"\"\n\n        # Use numpy's min function to find the minimum value in the dataset\n        return np.min(self.data)\n\n    def get_max(self):\n        \"\"\"\n        Calculate the maximum value in the dataset.\n        :return: float, the maximum value in the dataset\n        >>> ds2 = DataStatistics2([1, 2, 3, 4])\n        >>> ds2.get_max()\n        4\n        \"\"\"\n\n        # Use numpy's max function to find the maximum value in the dataset\n        return np.max(self.data)\n\n    def get_variance(self):\n        \"\"\"\n        Calculate the variance of the dataset, accurate to two decimal places.\n        :return: float, the variance of the dataset\n        >>> ds2 = DataStatistics2([1, 2, 3, 4])\n        >>> ds2.get_variance()\n        1.25\n        \"\"\"\n\n        # Use numpy's var function to calculate the variance of the dataset\n        # Use Python's built-in round function to round the result to 2 decimal places\n        return round(np.var(self.data), 2)\n\n    def get_std_deviation(self):\n        \"\"\"\n        Calculate the standard deviation of the dataset, accurate to two decimal places.\n        :return: float, the standard deviation of the dataset\n        >>> ds2 = DataStatistics2([1, 2, 3, 4])\n        >>> ds2.get_std_deviation()\n        1.12\n        \"\"\"\n\n        # Use numpy's std function to calculate the standard deviation of the dataset\n        # Use Python's built-in round function to round the result to 2 decimal places\n        return round(np.std(self.data), 2)\n\n    def get_correlation(self):\n        \"\"\"\n        Calculate the correlation of the dataset.\n        :return: float, the correlation of the dataset\n        >>> ds2 = DataStatistics2([1, 2, 3, 4])\n        >>> ds2.get_correlation()\n        1.0\n        \"\"\"\n\n        # Use numpy's corrcoef function to calculate the correlation of the dataset\n        # The rowvar parameter is set to False to compute the correlation between columns (variables), not rows (observations)\n        return np.corrcoef(self.data, rowvar=False)"}, {"id": "31", "llm_annotated_code": "class DataStatistics4:\n\n    \"\"\"\n    This is a class that performs advanced mathematical calculations and statistics, including correlation coefficient, skewness, kurtosis, and probability density function (PDF) for a normal distribution.\n    \"\"\"\n\n    @staticmethod\n    def correlation_coefficient(data1, data2):\n        \"\"\"\n        Calculate the correlation coefficient of two sets of data.\n        :param data1: list, The first set of data.\n        :param data2: list, The second set of data.\n        :return: float, The correlation coefficient.\n        >>> DataStatistics4.correlation_coefficient([1, 2, 3], [4, 5, 6])\n        0.9999999999999998\n\n        \"\"\"\n\n        # Calculate the length of the data sets\n        n = len(data1)\n\n        # Calculate the mean of each data set\n        mean1 = sum(data1) / n\n        mean2 = sum(data2) / n\n\n        # Calculate the numerator of the correlation coefficient formula\n        numerator = sum((data1[i] - mean1) * (data2[i] - mean2) for i in range(n))\n\n        # Calculate the denominator of the correlation coefficient formula\n        denominator = math.sqrt(sum((data1[i] - mean1) ** 2 for i in range(n))) * math.sqrt(sum((data2[i] - mean2) ** 2 for i in range(n)))\n\n        # Return the correlation coefficient if the denominator is not zero, otherwise return zero\n        return numerator / denominator if denominator != 0 else 0\n\n    @staticmethod\n    def skewness(data):\n        \"\"\"\n        Calculate the skewness of a set of data.\n        :param data: list, The input data list.\n        :return: float, The skewness.\n        >>> DataStatistics4.skewness([1, 2, 5])\n        2.3760224064818463\n\n        \"\"\"\n\n        # Calculate the length of the data set\n        n = len(data)\n\n        # Calculate the mean of the data set\n        mean = sum(data) / n\n\n        # Calculate the variance of the data set\n        variance = sum((x - mean) ** 2 for x in data) / n\n\n        # Calculate the standard deviation of the data set\n        std_deviation = math.sqrt(variance)\n\n        # Calculate the skewness of the data set if the standard deviation is not zero, otherwise return zero\n        skewness = sum((x - mean) ** 3 for x in data) * n / ((n - 1) * (n - 2) * std_deviation ** 3) if std_deviation != 0 else 0\n\n        return skewness\n\n    @staticmethod\n    def kurtosis(data):\n        \"\"\"\n        Calculate the kurtosis of a set of data.\n        :param data: list, The input data list.\n        :return: float, The kurtosis.\n        >>> DataStatistics4.kurtosis([1, 20,100])\n        -1.5000000000000007\n\n        \"\"\"\n\n        # Calculate the length of the data set\n        n = len(data)\n\n        # Calculate the mean of the data set\n        mean = sum(data) / n\n\n        # Calculate the standard deviation of the data set\n        std_dev = math.sqrt(sum((x - mean) ** 2 for x in data) / n)\n\n        # If the standard deviation is zero, return NaN\n        if std_dev == 0:\n            return math.nan\n\n        # Calculate the centered data by subtracting the mean from each data point\n        centered_data = [(x - mean) for x in data]\n\n        # Calculate the fourth moment of the data set\n        fourth_moment = sum(x ** 4 for x in centered_data) / n\n\n        # Calculate the kurtosis of the data set\n        kurtosis_value = (fourth_moment / std_dev ** 4) - 3\n\n        return kurtosis_value\n\n    @staticmethod\n    def pdf(data, mu, sigma):\n        \"\"\"\n        Calculate the probability density function (PDF) of a set of data under a normal distribution.\n        :param data: list, The input data list.\n        :param mu: float, The mean of the normal distribution.\n        :param sigma: float, The standard deviation of the normal distribution.\n        :return: list, The probability density function (PDF).\n        >>> DataStatistics4.pdf([1, 2, 3], 1, 1)\n        [0.3989422804014327, 0.24197072451914337, 0.05399096651318806]\n\n        \"\"\"\n\n        # Calculate the PDF for each data point in the data set using the formula for the PDF of a normal distribution\n        pdf_values = [1 / (sigma * math.sqrt(2 * math.pi)) * math.exp(-0.5 * ((x - mu) / sigma) ** 2) for x in data]\n\n        return pdf_values"}, {"id": "32", "llm_annotated_code": "class DecryptionUtils:\n\n    \"\"\"\n    This class provides methods for decryption, including the Caesar cipher, Vigenere cipher, and Rail Fence cipher.\n    \"\"\"\n\n    def __init__(self, key):\n        \"\"\"\n        Initializes the decryption utility with a key.\n        :param key: str, The key to use for decryption.\n        \"\"\"\n        # Store the key as a class attribute\n        self.key = key\n\n    def caesar_decipher(self, ciphertext, shift):\n        \"\"\"\n        Deciphers the given ciphertext using the Caesar cipher\n        :param ciphertext: str, The ciphertext to decipher.\n        :param shift: int, The shift to use for decryption.\n        :return: str, The deciphered plaintext.\n        \"\"\"\n\n        plaintext = \"\"\n\n        # Loop through each character in the ciphertext\n        for char in ciphertext:\n\n            # Check if the character is a letter\n            if char.isalpha():\n                # If the character is an uppercase letter set the ascii offset to 65\n                # If the character is a lowercase letter set the ascii offset to 97\n                ascii_offset = 65 if char.isupper() else 97\n\n                # Calculate the shifted character by subtracting the ascii offset and the shift from the ascii value of the character,\n                # taking the modulus of 26 (the number of letters in the alphabet), and adding the ascii offset back.\n                shifted_char = chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n\n                # Add the shifted character to the plaintext\n                plaintext += shifted_char\n            else:\n                # If the character is not a letter, add it to the plaintext as is\n                plaintext += char\n\n        # Return the deciphered plaintext\n        return plaintext\n\n    def vigenere_decipher(self, ciphertext):\n        \"\"\"\n        Deciphers the given ciphertext using the Vigenere cipher\n        :param ciphertext: str, The ciphertext to decipher.\n        :return: str, The deciphered plaintext.\n        \"\"\"\n\n        decrypted_text = \"\"\n        key_index = 0\n\n        # Loop through each character in the ciphertext\n        for char in ciphertext:\n\n            # Check if the character is a letter\n            if char.isalpha():\n\n                # Calculate the shift based on the character at key_index in the key\n                shift = ord(self.key[key_index % len(self.key)].lower()) - ord('a')\n\n                # Calculate the decrypted character by subtracting the ascii value of 'a' and the shift from the ascii value of the character,\n                # taking the modulus of 26, and adding the ascii value of 'a' back.\n                decrypted_char = chr((ord(char.lower()) - ord('a') - shift) % 26 + ord('a'))\n\n                # If the character was uppercase, convert the decrypted character to uppercase\n                # Add the decrypted character to the deciphered text\n                decrypted_text += decrypted_char.upper() if char.isupper() else decrypted_char\n\n                # Move to the next character in the key\n                key_index += 1\n            else:\n                # If the character is not a letter, add it to the decrypted text as is\n                decrypted_text += char\n\n        # Return the deciphered text\n        return decrypted_text\n\n    def rail_fence_decipher(self, encrypted_text, rails):\n        \"\"\"\n        Deciphers the given ciphertext using the Rail Fence cipher\n        :param encrypted_text: str, The ciphertext to decipher.\n        :param rails: int, The number of rails to use for decryption.\n        :return: str, The deciphered plaintext.\n        \"\"\"\n\n        # Create a fence with new line characters that has dimensions rails x len(encrypted_text)\n        fence = [['\\n' for _ in range(len(encrypted_text))] for _ in range(rails)]\n        direction = -1\n        row, col = 0, 0\n\n        # Loop through each character in the encrypted text\n        for _ in range(len(encrypted_text)):\n\n            # Change direction when reaching the top or bottom rail\n            if row == 0 or row == rails - 1:\n                direction = -direction\n\n            # Mark the position in the fence with an empty string\n            fence[row][col] = ''\n\n            # Move to the next column and row\n            col += 1\n            row += direction\n\n        # Fill the marked positions in the fence with the characters from the encrypted text\n        index = 0\n        for i in range(rails):\n            for j in range(len(encrypted_text)):\n                if fence[i][j] == '':\n                    fence[i][j] = encrypted_text[index]\n                    index += 1\n\n        # Read the characters from the fence in a zigzag pattern to get the plaintext\n        plain_text = ''\n        direction = -1\n        row, col = 0, 0\n        for _ in range(len(encrypted_text)):\n            if row == 0 or row == rails - 1:\n                direction = -direction\n            plain_text += fence[row][col]\n            col += 1\n            row += direction\n\n        # Return the deciphered plaintext\n        return plain_text"}, {"id": "34", "llm_annotated_code": "class DocFileHandler:\n\n    \"\"\"\n    This is a class that handles Word documents and provides functionalities for reading, writing, and modifying the content of Word documents.\n    It uses the python-docx library to interact with Word documents.\n    \"\"\"\n\n    def __init__(self, file_path):\n        \"\"\"\n        Initializes the DocFileHandler object with the specified file path.\n        :param file_path: str, the path to the Word document file.\n        \"\"\"\n        # Store the file path to the Word document\n        self.file_path = file_path\n\n    def read_text(self):\n        \"\"\"\n        Reads the content of a Word document and returns it as a string.\n        :return: str, the content of the Word document.\n        \"\"\"\n\n        # Create a Document object from the Word document file\n        doc = Document(self.file_path)\n\n        # Initialize an empty list to store the text of each paragraph\n        text = []\n\n        # Iterate over each paragraph in the document\n        for paragraph in doc.paragraphs:\n            # Append the text of the paragraph to the list\n            text.append(paragraph.text)\n\n        # Join the list of paragraph texts into a single string with line breaks between paragraphs and return it\n        return \"\\n\".join(text)\n\n    def write_text(self, content, font_size=12, alignment='left'):\n        \"\"\"\n        Writes the specified content to a Word document.\n        :param content: str, the text content to write.\n        :param font_size: int, optional, the font size of the text (default is 12).\n        :param alignment: str, optional, the alignment of the text ('left', 'center', or 'right'; default is 'left').\n        :return: bool, True if the write operation is successful, False otherwise.\n        \"\"\"\n\n        try:\n            # Create a new Document object\n            doc = Document()\n\n            # Add a paragraph to the document and add a run to the paragraph with the specified content\n            paragraph = doc.add_paragraph()\n            run = paragraph.add_run(content)\n\n            # Set the font size of the run\n            font = run.font\n            font.size = Pt(font_size)\n\n            # Set the alignment of the paragraph\n            alignment_value = self._get_alignment_value(alignment)\n            paragraph.alignment = alignment_value\n\n            # Save the document to the specified file path\n            doc.save(self.file_path)\n\n            # Return True if the write operation is successful\n            return True\n        except:\n            # Return False if an exception occurs during the write operation\n            return False\n\n    def add_heading(self, heading, level=1):\n        \"\"\"\n        Adds a heading to the Word document.\n        :param heading: str, the text of the heading.\n        :param level: int, optional, the level of the heading (1, 2, 3, etc.; default is 1).\n        :return: bool, True if the heading is successfully added, False otherwise.\n        \"\"\"\n\n        try:\n            # Create a Document object from the Word document file\n            doc = Document(self.file_path)\n\n            # Add a heading to the document with the specified text and level\n            doc.add_heading(heading, level)\n\n            # Save the document to the specified file path\n            doc.save(self.file_path)\n\n            # Return True if the heading is successfully added\n            return True\n        except:\n            # Return False if an exception occurs during the heading addition\n            return False\n\n    def add_table(self, data):\n        \"\"\"\n        Adds a table to the Word document with the specified data.\n        :param data: list of lists, the data to populate the table.\n        :return: bool, True if the table is successfully added, False otherwise.\n        \"\"\"\n\n        try:\n            # Create a Document object from the Word document file\n            doc = Document(self.file_path)\n\n            # Add a table to the document with the specified number of rows and columns\n            table = doc.add_table(rows=len(data), cols=len(data[0]))\n\n            # Iterate over each row and column in the data\n            for i, row in enumerate(data):\n                for j, cell_value in enumerate(row):\n                    # Set the text of the corresponding cell in the table to the data value\n                    table.cell(i, j).text = str(cell_value)\n\n            # Save the document to the specified file path\n            doc.save(self.file_path)\n\n            # Return True if the table is successfully added\n            return True\n        except:\n            # Return False if an exception occurs during the table addition\n            return False\n\n    def _get_alignment_value(self, alignment):\n        \"\"\"\n        Returns the alignment value corresponding to the given alignment string.\n        :param alignment: str, the alignment string ('left', 'center', or 'right').\n        :return: int, the alignment value.\n        \"\"\"\n\n        # Define a dictionary mapping alignment strings to their corresponding alignment values\n        alignment_options = {\n            'left': WD_PARAGRAPH_ALIGNMENT.LEFT,\n            'center': WD_PARAGRAPH_ALIGNMENT.CENTER,\n            'right': WD_PARAGRAPH_ALIGNMENT.RIGHT\n        }\n\n        # Return the alignment value corresponding to the given alignment string, or the value for 'left' if the string is not recognized\n        return alignment_options.get(alignment.lower(), WD_PARAGRAPH_ALIGNMENT.LEFT)"}, {"id": "35", "llm_annotated_code": "class EightPuzzle:\n\n    \"\"\"\n    This class is an implementation of the classic 8-puzzle game, including methods for finding the blank tile, making moves, getting possible moves, and solving the puzzle using a breadth-first search algorithm.\n    \"\"\"\n\n    def __init__(self, initial_state):\n        \"\"\"\n        Initialize the EightPuzzle with an initial state and a predefined goal state.\n        :param initial_state: list of lists, a 3x3 matrix representing the initial state of the puzzle\n        \"\"\"\n\n        self.initial_state = initial_state\n        self.goal_state = [[1, 2, 3], [4, 5, 6], [7, 8, 0]]\n\n    def find_blank(self, state):\n        \"\"\"\n        Find the position of the blank tile (represented by 0) in the current state.\n        :param state: list of lists, a 3x3 matrix representing the current state of the puzzle\n        :return: tuple, the coordinates of the blank tile\n        \"\"\"\n\n        for i in range(3):\n            for j in range(3):\n                if state[i][j] == 0:\n                    return i, j\n\n    def move(self, state, direction):\n        \"\"\"\n        Make a move in the given direction if possible and return the new state.\n        :param state: list of lists, a 3x3 matrix representing the current state of the puzzle\n        :param direction: str, the direction of the move ('up', 'down', 'left', 'right')\n        :return: list of lists, a 3x3 matrix representing the new state after the move\n        \"\"\"\n\n        i, j = self.find_blank(state)\n        new_state = [row[:] for row in state]\n        if direction == 'up':\n            new_state[i][j], new_state[i - 1][j] = new_state[i - 1][j], new_state[i][j]\n        elif direction == 'down':\n            new_state[i][j], new_state[i + 1][j] = new_state[i + 1][j], new_state[i][j]\n        elif direction == 'left':\n            new_state[i][j], new_state[i][j - 1] = new_state[i][j - 1], new_state[i][j]\n        elif direction == 'right':\n            new_state[i][j], new_state[i][j + 1] = new_state[i][j + 1], new_state[i][j]\n\n        return new_state\n\n    def get_possible_moves(self, state):\n        \"\"\"\n        Get all possible moves from the current state.\n        :param state: list of lists, a 3x3 matrix representing the current state of the puzzle\n        :return: list of str, all possible moves ('up', 'down', 'left', 'right')\n        \"\"\"\n\n        moves = []\n        i, j = self.find_blank(state)\n        if i > 0:\n            moves.append('up')\n        if i < 2:\n            moves.append('down')\n        if j > 0:\n            moves.append('left')\n        if j < 2:\n            moves.append('right')\n        return moves\n\n    def solve(self):\n        \"\"\"\n        Solve the puzzle using a breadth-first search algorithm.\n        :return: list of str, the sequence of moves to solve the puzzle\n        \"\"\"\n\n        open_list = [(self.initial_state, [])]\n        closed_list = []\n        while open_list:\n            current_state, path = open_list.pop(0)\n            closed_list.append(current_state)\n            if current_state == self.goal_state:\n                return path\n            for move in self.get_possible_moves(current_state):\n                new_state = self.move(current_state, move)\n                if new_state not in closed_list:\n                    open_list.append((new_state, path + [move]))\n\n        return None"}, {"id": "36", "llm_annotated_code": "class EmailClient:\n\n    \"\"\"\n    This is a class that serves as an email client, implementing functions such as checking emails, determining whether there is sufficient space, and cleaning up space\n    \"\"\"\n\n    def __init__(self, addr, capacity) -> None:\n        \"\"\"\n        Initializes the EmailClient class with the email address and the capacity of the email box.\n        :param addr: The email address, str.\n        :param capacity: The capacity of the email box, float.\n        \"\"\"\n        self.addr = addr  # Email address of the client\n        self.capacity = capacity  # Maximum capacity of the email box\n        self.inbox = []  # List to store the emails in the inbox\n\n    def send_to(self, recv, content, size):\n        \"\"\"\n        Sends an email to the given email address.\n        :param recv: The email address of the receiver, str.\n        :param content: The content of the email, str.\n        :param size: The size of the email, float.\n        :return: True if the email is sent successfully, False if the receiver's email box is full.\n        \"\"\"\n\n        # Check if the receiver's email box has enough space for the new email\n        if not recv.is_full_with_one_more_email(size):\n            # If there is enough space, create a new email with the sender's address, receiver's address, content, size, current timestamp, and state as \"unread\"\n            timestamp = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n            email = {\n                \"sender\": self.addr,\n                \"receiver\": recv.addr,\n                \"content\": content,\n                \"size\": size,\n                \"time\": timestamp,\n                \"state\": \"unread\"\n            }\n            # Append the new email to the receiver's inbox\n            recv.inbox.append(email)\n            return True\n        else:\n            # If there is not enough space, clear the inbox to make space and return False\n            self.clear_inbox(size)\n            return False\n\n    def fetch(self):\n        \"\"\"\n        Retrieves the first unread email in the email box and marks it as read.\n        :return: The first unread email in the email box, dict.\n        \"\"\"\n\n        # If the inbox is empty, return None\n        if len(self.inbox) == 0:\n            return None\n        # Iterate over the emails in the inbox\n        for i in range(len(self.inbox)):\n            # If an email is unread, mark it as read and return it\n            if self.inbox[i]['state'] == \"unread\":\n                self.inbox[i]['state'] = \"read\"\n                return self.inbox[i]\n        # If all emails are read, return None\n        return None\n\n    def is_full_with_one_more_email(self, size):\n        \"\"\"\n        Determines whether the email box is full after adding an email of the given size.\n        :param size: The size of the email, float.\n        :return: True if the email box is full, False otherwise.\n        \"\"\"\n\n        # Calculate the total size of the emails in the inbox\n        occupied_size = self.get_occupied_size()\n        # If the total size plus the size of the new email exceeds the capacity, return True\n        return True if occupied_size + size > self.capacity else False\n\n    def get_occupied_size(self):\n        \"\"\"\n        Gets the total size of the emails in the email box.\n        :return: The total size of the emails in the email box, float.\n        \"\"\"\n\n        occupied_size = 0  # Initialize the total size as 0\n        # Iterate over the emails in the inbox and add up their sizes\n        for email in self.inbox:\n            occupied_size += email[\"size\"]\n        return occupied_size\n\n    def clear_inbox(self, size):\n        \"\"\"\n        Clears the email box by deleting the oldest emails until the email box has enough space to accommodate the given size.\n        :param size: The size of the email, float.\n        \"\"\"\n\n        # If the inbox is empty, return\n        if len(self.addr) == 0:\n            return\n        freed_space = 0  # Initialize the freed space as 0\n        # While the freed space is less than the size of the new email and there are still emails in the inbox\n        while freed_space < size and self.inbox:\n            # Remove the oldest email from the inbox and add its size to the freed space\n            email = self.inbox[0]\n            freed_space += email['size']\n            del self.inbox[0]"}, {"id": "37", "llm_annotated_code": "class EncryptionUtils:\n\n    \"\"\"\n    This is a class that provides methods for encryption, including the Caesar cipher, Vigenere cipher, and Rail Fence cipher.\n    \"\"\"\n\n    def __init__(self, key):\n        \"\"\"\n        Initializes the class with a key.\n        :param key: The key to use for encryption, str.\n        \"\"\"\n        # Store the key as a class attribute\n        self.key = key\n\n    def caesar_cipher(self, plaintext, shift):\n        \"\"\"\n        Encrypts the plaintext using the Caesar cipher.\n        :param plaintext: The plaintext to encrypt, str.\n        :param shift: The number of characters to shift each character in the plaintext, int.\n        :return: The ciphertext, str.\n        \"\"\"\n\n        # Initialize an empty string for the ciphertext\n        ciphertext = \"\"\n\n        # Iterate over each character in the plaintext\n        for char in plaintext:\n            # Check if the character is an alphabet letter\n            if char.isalpha():\n                # Determine the ASCII offset based on whether the character is uppercase or lowercase\n                if char.isupper():\n                    ascii_offset = 65\n                else:\n                    ascii_offset = 97\n                # Calculate the shifted character using the Caesar cipher formula\n                shifted_char = chr((ord(char) - ascii_offset + shift) % 26 + ascii_offset)\n                # Append the shifted character to the ciphertext\n                ciphertext += shifted_char\n            else:\n                # If the character is not an alphabet letter, append it to the ciphertext as is\n                ciphertext += char\n\n        # Return the ciphertext\n        return ciphertext\n\n    def vigenere_cipher(self, plaintext):\n        \"\"\"\n        Encrypts the plaintext using the Vigenere cipher.\n        :param plaintext: The plaintext to encrypt, str.\n        :return: The ciphertext, str.\n        \"\"\"\n\n        # Initialize an empty string for the encrypted text and a counter for the key index\n        encrypted_text = \"\"\n        key_index = 0\n\n        # Iterate over each character in the plaintext\n        for char in plaintext:\n            # Check if the character is an alphabet letter\n            if char.isalpha():\n                # Calculate the shift value based on the current character in the key\n                shift = ord(self.key[key_index % len(self.key)].lower()) - ord('a')\n                # Calculate the encrypted character using the Vigenere cipher formula\n                encrypted_char = chr((ord(char.lower()) - ord('a') + shift) % 26 + ord('a'))\n                # Append the encrypted character to the encrypted text, preserving the case of the original character\n                encrypted_text += encrypted_char.upper() if char.isupper() else encrypted_char\n                # Increment the key index\n                key_index += 1\n            else:\n                # If the character is not an alphabet letter, append it to the encrypted text as is\n                encrypted_text += char\n\n        # Return the encrypted text\n        return encrypted_text\n\n    def rail_fence_cipher(self,plain_text, rails):\n        \"\"\"\n        Encrypts the plaintext using the Rail Fence cipher.\n        :param plaintext: The plaintext to encrypt, str.\n        :return: The ciphertext, str.\n        \"\"\"\n\n        # Initialize a 2D list (fence) with the same number of rows as the number of rails and the same number of columns as the length of the plaintext\n        fence = [['\\n' for _ in range(len(plain_text))] for _ in range(rails)]\n        # Initialize the direction for moving along the fence and the current row and column\n        direction = -1\n        row, col = 0, 0\n\n        # Iterate over each character in the plaintext\n        for char in plain_text:\n            # Change the direction when reaching the top or bottom rail\n            if row == 0 or row == rails-1:\n                direction = -direction\n            # Place the character at the current position in the fence\n            fence[row][col] = char\n            # Move to the next column and the next row in the current direction\n            col += 1\n            row += direction\n\n        # Initialize an empty string for the encrypted text\n        encrypted_text = ''\n\n        # Iterate over each row in the fence\n        for i in range(rails):\n            # Iterate over each column in the fence\n            for j in range(len(plain_text)):\n                # If the cell is not empty, append the character in the cell to the encrypted text\n                if fence[i][j] != '\\n':\n                    encrypted_text += fence[i][j]\n\n        # Return the encrypted text\n        return encrypted_text"}, {"id": "38", "llm_annotated_code": "class ExcelProcessor:\n\n    \"\"\"\n    This is a class for processing excel files. It uses the openpyxl library to read and write data from and to Excel files.\n    \"\"\"\n\n    def __init__(self):\n        pass\n\n    def read_excel(self, file_name):\n        \"\"\"\n        Reads data from an Excel file.\n        :param file_name: str, name of the Excel file to read\n        :return: list, data from the Excel file, or None if an error occurs\n        \"\"\"\n\n        data = []\n        try:\n            # Load the workbook using openpyxl\n            workbook = openpyxl.load_workbook(file_name)\n            # Get the active sheet in the workbook\n            sheet = workbook.active\n            # Iterate over the rows in the sheet and append them to the data list\n            for row in sheet.iter_rows(values_only=True):\n                data.append(row)\n            # Close the workbook\n            workbook.close()\n            # Return the data\n            return data\n        except:\n            # If an error occurs, return None\n            return None\n\n\n    def write_excel(self, data, file_name):\n        \"\"\"\n        Writes data to an Excel file.\n        :param data: list, data to be written to the Excel file\n        :param file_name: str, name of the Excel file to write to\n        :return: int, 1 if the writing is successful, 0 if an error occurs\n        \"\"\"\n\n        try:\n            # Create a new workbook using openpyxl\n            workbook = openpyxl.Workbook()\n            # Get the active sheet in the workbook\n            sheet = workbook.active\n            # Iterate over the data and append each row to the sheet\n            for row in data:\n                sheet.append(row)\n            # Save the workbook to the specified file\n            workbook.save(file_name)\n            # Close the workbook\n            workbook.close()\n            # Return 1 to indicate that the writing was successful\n            return 1\n        except:\n            # If an error occurs, return 0\n            return 0\n\n\n    def process_excel_data(self, N, save_file_name):\n        \"\"\"\n        Changes the specified column in an Excel file to uppercase and saves the processed data to a new file.\n        :param N: int, the index of the column to change\n        :param save_file_name: str, name of the source file\n        :return: tuple, the first element is the return value of write_excel (1 if successful, 0 if an error occurs), the second element is the name of the saved file\n        \"\"\"\n\n        # Read the data from the source file\n        data = self.read_excel(save_file_name)\n        # If an error occurs while reading the data or if N is not a valid column index, return 0\n        if data is None or N >= len(data[0]):\n            return 0\n        \n        new_data = []\n        # Iterate over the rows in the data\n        for row in data:\n            # Create a copy of the row\n            new_row = list(row[:])\n            # If the Nth element of the row is not a digit, change it to uppercase\n            if not str(row[N]).isdigit():\n                new_row.append(str(row[N]).upper())\n            else:\n                new_row.append(row[N])\n            # Append the processed row to the new data\n            new_data.append(new_row)\n        # Create a new file name by appending '_process' to the name of the source file\n        new_file_name = save_file_name.split('.')[0] + '_process.xlsx'\n        # Write the processed data to the new file\n        success = self.write_excel(new_data, new_file_name)\n        # Return the result of the write operation and the name of the new file\n        return success, new_file_name"}, {"id": "39", "llm_annotated_code": "class ExpressionCalculator:\n\n    \"\"\"\n    This class performs calculations on expressions involving basic arithmetic operations: addition, subtraction, multiplication, division, and modulo.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the expression calculator with an empty deque for storing postfix notation and a list of operator priorities.\n        \"\"\"\n        self.postfix_stack = deque()  # A deque for storing the postfix notation of the expression\n        self.operat_priority = [0, 3, 2, 1, -1, 1, 0, 2]  # A list of operator priorities\n\n    def calculate(self, expression):\n        \"\"\"\n        Calculate the result of the given infix expression by converting it to postfix notation and evaluating it.\n        :param expression: string, the infix expression to be calculated\n        :return: float, the calculated result\n        \"\"\"\n        self.prepare(self.transform(expression))  # Transform the infix expression to a suitable format and prepare it for conversion to postfix notation\n        result_stack = deque()  # A deque for storing the intermediate results of the calculation\n        self.postfix_stack.reverse()  # Reverse the postfix_stack to start the calculation from the left\n\n        while self.postfix_stack:  # While there are elements in the postfix_stack\n            current_op = self.postfix_stack.pop()  # Pop the top element from the postfix_stack\n\n            if not self.is_operator(current_op):  # If the current_op is not an operator, it's an operand\n                current_op = current_op.replace(\"~\", \"-\")  # Replace the unary minus operator with the standard minus sign\n                result_stack.append(current_op)  # Append the operand to the result_stack\n            else:  # If the current_op is an operator\n                second_value = result_stack.pop()  # Pop the top two elements from the result_stack as the operands\n                first_value = result_stack.pop()\n\n                first_value = first_value.replace(\"~\", \"-\")  # Replace the unary minus operator with the standard minus sign in the operands\n                second_value = second_value.replace(\"~\", \"-\")\n\n                temp_result = self._calculate(first_value, second_value, current_op)  # Calculate the result of the operation\n                result_stack.append(str(temp_result))  # Append the result to the result_stack\n\n        return float(eval(\"*\".join(result_stack)))  # Evaluate the final result in the result_stack and return it as a float\n\n    def prepare(self, expression):\n        \"\"\"\n        Prepare the infix expression for conversion to postfix notation by separating the operands and operators and arranging them in the postfix_stack.\n        :param expression: string, the infix expression to be prepared\n        \"\"\"\n        op_stack = deque([','])  # A deque for storing the operators in the expression, initialized with a comma\n        arr = list(expression)  # Convert the expression to a list of characters\n\n        current_index = 0  # The current index in the expression\n        count = 0  # The count of consecutive operands or operators\n\n        for i, current_op in enumerate(arr):  # For each character in the expression\n\n            if self.is_operator(current_op):  # If the current character is an operator\n                if count > 0:  # If the previous characters were operands\n                    self.postfix_stack.append(\"\".join(arr[current_index: current_index + count]))  # Append the operand to the postfix_stack\n                \n                peek_op = op_stack[-1]  # Peek the top operator from the op_stack\n                if current_op == ')':  # If the current operator is a closing parenthesis\n                    while op_stack[-1] != '(':  # While the top operator in the op_stack is not an opening parenthesis\n                        self.postfix_stack.append(str(op_stack.pop()))  # Pop the top operator from the op_stack and append it to the postfix_stack\n                    op_stack.pop()  # Pop the opening parenthesis from the op_stack\n                else:  # If the current operator is not a closing parenthesis\n                    while current_op != '(' and peek_op != ',' and self.compare(current_op, peek_op):  # While the current operator is not an opening parenthesis, the top operator in the op_stack is not a comma, and the current operator has higher or equal precedence than the top operator in the op_stack\n                        self.postfix_stack.append(str(op_stack.pop()))  # Pop the top operator from the op_stack and append it to the postfix_stack\n\n                        peek_op = op_stack[-1]  # Peek the top operator from the op_stack\n                    \n                    op_stack.append(current_op)  # Append the current operator to the op_stack\n\n                count = 0  # Reset the count of consecutive operands or operators\n\n                current_index = i + 1  # Update the current index in the expression\n            else:  # If the current character is an operand\n                count += 1  # Increment the count of consecutive operands or operators\n\n        if count > 1 or (count == 1 and not self.is_operator(arr[current_index])):  # If the last characters in the expression were operands\n            self.postfix_stack.append(\"\".join(arr[current_index: current_index + count]))  # Append the operand to the postfix_stack\n\n        while op_stack[-1] != ',':  # While the top operator in the op_stack is not a comma\n            self.postfix_stack.append(str(op_stack.pop()))  # Pop the top operator from the op_stack and append it to the postfix_stack\n\n    @staticmethod\n    def is_operator(c):\n        \"\"\"\n        Check if a character is an operator.\n        :param c: string, the character to be checked\n        :return: bool, True if the character is an operator, False otherwise\n        \"\"\"\n        return c in {'+', '-', '*', '/', '(', ')', '%'}  # Return True if the character is in the set of operators, False otherwise\n\n    def compare(self, cur, peek):\n        \"\"\"\n        Compare the precedence of two operators.\n        :param cur: string, the current operator\n        :param peek: string, the operator at the top of the operator stack\n        :return: bool, True if the current operator has higher or equal precedence, False otherwise\n        \"\"\"\n        if cur == '%':  # If the current operator is modulo, treat it as division for the purpose of precedence comparison\n            cur = '/'\n        if peek == '%':  # If the top operator in the operator stack is modulo, treat it as division for the purpose of precedence comparison\n            peek = '/'\n        \n        return self.operat_priority[ord(peek) - 40] >= self.operat_priority[ord(cur) - 40]  # Return True if the precedence of the top operator in the operator stack is higher or equal to the precedence of the current operator, False otherwise\n\n    @staticmethod\n    def _calculate(first_value, second_value, current_op):\n        \"\"\"\n        Perform the mathematical calculation based on the given operands and operator.\n        :param first_value: string, the first operand\n        :param second_value: string, the second operand\n        :param current_op: string, the operator\n        :return: decimal.Decimal, the calculated result\n        \"\"\"\n        if current_op == '+':  # If the operator is addition\n            return Decimal(first_value) + Decimal(second_value)  # Return the sum of the operands\n        elif current_op == '-':  # If the operator is subtraction\n            return Decimal(first_value) - Decimal(second_value)  # Return the difference of the operands\n        elif current_op == '*':  # If the operator is multiplication\n            return Decimal(first_value) * Decimal(second_value)  # Return the product of the operands\n        elif current_op == '/':  # If the operator is division\n            return Decimal(first_value) / Decimal(second_value)  # Return the quotient of the operands\n        elif current_op == '%':  # If the operator is modulo\n            return Decimal(first_value) % Decimal(second_value)  # Return the remainder of the division of the operands\n        else:  # If the operator is not recognized\n            raise ValueError(\"Unexpected operator: {}\".format(current_op))  # Raise a ValueError\n\n    @staticmethod\n    def transform(expression):\n        \"\"\"\n        Transform the infix expression to a format suitable for conversion to postfix notation by replacing unary minus operators with a tilde and adding a zero before unary minus operators at the beginning of the expression.\n        :param expression: string, the infix expression to be transformed\n        :return: string, the transformed expression\n        \"\"\"\n        expression = re.sub(r\"\\s+\", \"\", expression)  # Remove all whitespace characters from the expression\n        expression = re.sub(r\"=$\", \"\", expression)  # Remove any trailing equal sign from the expression\n        arr = list(expression)  # Convert the expression to a list of characters\n\n        for i, c in enumerate(arr):  # For each character in the expression\n            if c == '-':  # If the character is a minus sign\n                if i == 0:  # If the character is at the beginning of the expression\n                    arr[i]"}, {"id": "40", "llm_annotated_code": "class FitnessTracker:\n\n    \"\"\"\n    This is a class as fitness tracker that implements to calculate BMI (Body Mass Index) and calorie intake based on the user's height, weight, age, and sex.\n    \"\"\"\n\n    def __init__(self, height, weight, age, sex) -> None:\n        \"\"\"\n        Initialize the class with height, weight, age, and sex, and calculate the BMI standard based on sex, and male is 20-25, female is 19-24.\n        :param height: float, user's height in meters\n        :param weight: float, user's weight in kilograms\n        :param age: int, user's age in years\n        :param sex: str, user's sex, either \"male\" or \"female\"\n        \"\"\"\n\n        self.height = height\n        self.weight = weight\n        self.age = age\n        self.sex = sex\n\n        # Define the standard BMI ranges for males and females\n        self.BMI_std = [\n            {\"male\": [20, 25]},\n            {\"female\": [19, 24]}\n        ]\n\n    def get_BMI(self):\n        \"\"\"\n        Calculate the BMI based on the height and weight.\n        :return: BMI,which is the weight divide by the square of height, float.\n        \"\"\"\n\n        # Calculate BMI using the formula weight / height^2\n        return self.weight / self.height ** 2\n\n    def condition_judge(self):\n        \"\"\"\n        Judge the condition of the user based on the BMI standard.\n        :return: 1 if the user is too fat, -1 if the user is too thin, 0 if the user is normal, int.\n        \"\"\"\n\n        # Get the user's BMI using the get_BMI method\n        BMI = self.get_BMI()\n\n        # Determine the standard BMI range based on the user's sex\n        if self.sex == \"male\":\n            BMI_range = self.BMI_std[0][\"male\"]\n        else:\n            BMI_range = self.BMI_std[1][\"female\"]\n        \n        # Return 1 if the user's BMI is above the standard range (too fat)\n        if BMI > BMI_range[1]:\n            return 1\n        # Return -1 if the user's BMI is below the standard range (too thin)\n        elif BMI < BMI_range[0]:\n            return -1\n        # Return 0 if the user's BMI is within the standard range (normal)\n        else:\n            return 0\n\n    def calculate_calorie_intake(self):\n        \"\"\"\n        Calculate the calorie intake based on the user's condition and BMR (Basal Metabolic Rate),BMR is calculated based on the user's height, weight, age, and sex,male is10 * self.weight + 6.25 * self.height - 5 * self.age + 5,female is 10 * self.weight + 6.25 * self.height - 5 * self.age - 161, and the calorie intake is calculated based on the BMR and the user's condition,if the user is too fat, the calorie intake is BMR * 1.2, if the user is too thin, the calorie intake is BMR * 1.6, if the user is normal, the calorie intake is BMR * 1.4.\n        :return: calorie intake, float.\n        \"\"\"\n\n        # Calculate the user's Basal Metabolic Rate (BMR) based on their sex, height, weight, and age\n        if self.sex == \"male\":\n            BMR = 10 * self.weight + 6.25 * self.height - 5 * self.age + 5\n        else:\n            BMR = 10 * self.weight + 6.25 * self.height - 5 * self.age - 161\n\n        # Determine the user's condition using the condition_judge method\n        # Calculate the user's calorie intake based on their BMR and condition\n        # If the user is too fat (condition 1), their calorie intake is BMR * 1.2\n        # If the user is too thin (condition -1), their calorie intake is BMR * 1.6\n        # If the user is normal (condition 0), their calorie intake is BMR * 1.4\n        if self.condition_judge() == 1:\n            calorie_intake = BMR * 1.2  # Sedentary lifestyle\n        elif self.condition_judge() == -1:\n            calorie_intake = BMR * 1.6  # Active lifestyle\n        else:\n            calorie_intake = BMR * 1.4  # Moderate lifestyle\n\n        # Return the calculated calorie intake\n        return calorie_intake"}, {"id": "41", "llm_annotated_code": "class GomokuGame:\n\n    \"\"\"\n    This class is an implementation of a Gomoku game, supporting for making moves, checking for a winner, and checking if there are five consecutive symbols on the game board.\n    \"\"\"\n\n    def __init__(self, board_size):\n        \"\"\"\n        Initializes the game with a given board size.\n        It initializes the board with empty spaces and sets the current player symbol as 'X'.\n        :param board_size: int, the size of the game board\n        >>> gomokuGame = GomokuGame(10)\n        \"\"\"\n\n        self.board_size = board_size\n        self.board = [[' ' for _ in range(board_size)] for _ in range(board_size)]\n        self.current_player = 'X'\n\n    def make_move(self, row, col):\n        \"\"\"\n        Makes a move at the given row and column.\n        If the move is valid, it places the current player's symbol on the board\n        and changes the current player to the other player (if the current player is 'X', then it becomes 'O' and vice versa).\n        :param row: int, the row index of this move\n        :param col: int, the column index\n        return: True if the move is valid, or False otherwise.\n        >>> gomokuGame = GomokuGame(10)\n        >>> gomokuGame.make_move(5, 5)\n        True\n        >>> gomokuGame.make_move(5, 5)\n        False\n        \"\"\"\n\n        # Check if the cell at the given row and column is empty\n        if self.board[row][col] == ' ':\n            # If it is, place the current player's symbol on the board\n            self.board[row][col] = self.current_player\n            # Change the current player to the other player\n            self.current_player = 'O' if self.current_player == 'X' else 'X'\n            return True\n        return False\n\n    def check_winner(self):\n        \"\"\"\n        Checks if there is a winner by looking for five in a row in all directions (horizontal, vertical, diagonal).\n        return: the symbol of the winning player (either 'X' or 'O') if there is a winner, or None otherwise.\n        >>> gomokuGame = GomokuGame(10)\n        >>> moves = [(5, 5), (0, 0), (5, 4), (0, 1), (5, 3), (0, 2), (5, 2), (0, 3), (5, 1)]\n        >>> for move in moves:\n        ...     gomokuGame.make_move(move[0], move[1])\n        >>> gomokuGame.check_winner()\n        'X'\n        \"\"\"\n\n        # Define the directions to check for five in a row\n        directions = [(0, 1), (1, 0), (1, 1), (1, -1)]\n        # Iterate over each cell on the board\n        for row in range(self.board_size):\n            for col in range(self.board_size):\n                # If the cell is not empty\n                if self.board[row][col] != ' ':\n                    # Check each direction for five in a row\n                    for direction in directions:\n                        if self._check_five_in_a_row(row, col, direction):\n                            # If there is a winner, return the symbol of the winning player\n                            return self.board[row][col]\n        # If there is no winner, return None\n        return None\n\n    def _check_five_in_a_row(self, row, col, direction):\n        \"\"\"\n        checks if there are five consecutive symbols of the same player in a row starting from a given cell in a given direction (horizontal, vertical, diagonal).\n        Counts the number of consecutive symbols in that direction starting from the given cell,\n        :param row: int, row of the given cell\n        :param col: int, column of the given cell\n        :param direction: tuple, (int, int), named as (dx, dy). Row and col will plus several dx and dy repectively.\n        :return: True if there are five consecutive symbols of the same player, and False otherwise.\n        >>> gomokuGame = GomokuGame(10)\n        >>> moves = [(5, 5), (0, 0), (5, 4), (0, 1), (5, 3), (0, 2), (5, 2), (0, 3), (5, 1)]\n        >>> for move in moves:\n        ...     gomokuGame.make_move(move[0], move[1])\n        >>> gomokuGame._check_five_in_a_row(5, 1, (0, 1))\n        True\n        >>> gomokuGame._check_five_in_a_row(5, 1, (1, 1))\n        False\n        \"\"\"\n\n        dx, dy = direction\n        count = 1\n        symbol = self.board[row][col]\n        # Check the next 4 cells in the given direction\n        for i in range(1, 5):\n            new_row = row + dx * i\n            new_col = col + dy * i\n            # If the cell is outside the board, return False\n            if not (0 <= new_row < self.board_size and 0 <= new_col < self.board_size):\n                return False\n            # If the cell does not contain the same symbol, return False\n            if self.board[new_row][new_col] != symbol:\n                return False\n            count += 1\n        # If there are five consecutive symbols of the same player, return True\n        return count == 5"}, {"id": "42", "llm_annotated_code": "class Hotel:\n\n    \"\"\"\n    This is a class as hotel management system, managing the booking, check-in, check-out, and availability of rooms in a hotel with different room types.\n    \"\"\"\n\n    def __init__(self, name, rooms):\n        \"\"\"\n        Initialize the three fields in Hotel System.\n        name is the hotel name.\n        available_rooms stores the remaining rooms in the hotel\n        booked_rooms stores the rooms that have been booked and the person's name who booked rooms.\n        :param name: str, the name of the hotel\n        :param rooms: dict, the available rooms in the hotel with room type as key and quantity as value\n        \"\"\"\n\n        self.name = name\n        self.available_rooms = rooms\n        self.booked_rooms = {}\n\n    def book_room(self, room_type, room_number, name):\n        \"\"\"\n        Check if there are any rooms of the specified type available.\n        if rooms are adequate, modify available_rooms and booked_rooms and finish booking, or fail to book otherwise.\n        :param room_type: str, the type of room to be booked\n        :param room_number: int, the expected number of specified type rooms to be booked\n        :param name: str, guest name\n        :return: if number of rooms about to be booked doesn't exceed the remaining rooms, return str 'Success!'\n                if exceeds but quantity of available rooms is not equal to zero, return int(the remaining quantity of this room type).\n                if exceeds and quantity is zero or the room_type isn't in available_room, return False.\n        \"\"\"\n\n        # Check if the room type is available in the hotel\n        if room_type not in self.available_rooms.keys():\n            return False\n\n        # Check if the number of rooms to be booked is less than or equal to the available rooms of that type\n        if room_number <= self.available_rooms[room_type]:\n\n            # If the room type is not already booked, initialize it in the booked_rooms dictionary\n            if room_type not in self.booked_rooms.keys():\n                self.booked_rooms[room_type] = {}\n\n            # Add the guest name and the number of rooms booked to the booked_rooms dictionary\n            self.booked_rooms[room_type][name] = room_number\n\n            # Subtract the number of rooms booked from the available_rooms dictionary\n            self.available_rooms[room_type] -= room_number\n\n            return \"Success!\"\n        elif self.available_rooms[room_type] != 0:\n            return self.available_rooms[room_type]\n        else:\n            return False\n    \n    def check_in(self, room_type, room_number, name):\n        \"\"\"\n        Check if the room of the specified type and number is booked by the person named name.\n        Remove this name when check in successfuly(room_number is equal to specific person's booked_rooms. When the actual check in quantity (room_number) is less than the booked quantity, number in booked_rooms will be booked quantity minus actual quantity\n        :param room_type: str, check in room type\n        :param room_number: int, check in room number\n        :param name: str, person name\n        :return False: only if the room_type is not in the booked_rooms or room_number is higher than quantity in booked rooms.\n        \"\"\"\n\n        # Check if the room type is in the booked_rooms dictionary\n        if room_type not in self.booked_rooms.keys():\n            return False\n\n        # Check if the guest name is in the booked_rooms dictionary for the room type\n        if name in self.booked_rooms[room_type]:\n\n            # Check if the number of rooms to be checked in is less than or equal to the number of rooms booked by the guest\n            if room_number > self.booked_rooms[room_type][name]:\n                return False\n            elif room_number == self.booked_rooms[room_type][name]:\n\n                # If the number of rooms to be checked in is equal to the number of rooms booked by the guest, remove the guest name from the booked_rooms dictionary\n                self.booked_rooms[room_type].pop(name)\n            else:\n\n                # If the number of rooms to be checked in is less than the number of rooms booked by the guest, subtract the number of rooms to be checked in from the number of rooms booked by the guest\n                self.booked_rooms[room_type][name] -= room_number\n\n    def check_out(self, room_type, room_number):\n        \"\"\"\n        Check out rooms, add number for specific type in available_rooms.\n        If room_type is new, add new type in available_rooms.\n        :param room_type: str, check out room type\n        :param room_number: int, check out room number\n        \"\"\"\n\n        # Check if the room type is in the available_rooms dictionary\n        if room_type in self.available_rooms:\n\n            # If the room type is in the available_rooms dictionary, add the number of rooms to be checked out to the available_rooms dictionary\n            self.available_rooms[room_type] += room_number\n        else:\n\n            # If the room type is not in the available_rooms dictionary, add the room type and the number of rooms to be checked out to the available_rooms dictionary\n            self.available_rooms[room_type] = room_number\n\n    def get_available_rooms(self, room_type):\n        \"\"\"\n        Get the number of specific type of available rooms.\n        :param room_type: str, the room type that want to know\n        :return: int, the remaining number of this type rooms.\n        \"\"\"\n\n        # Return the number of available rooms of the specified type\n        return self.available_rooms[room_type]"}, {"id": "43", "llm_annotated_code": "class HRManagementSystem:\n\n    \"\"\"\n    This is a class as personnel management system that implements functions such as adding, deleting, querying, and updating employees\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the HRManagementSystem with an attribute employees, which is an empty dictionary.\n        This dictionary will store all the employee data with employee_id as the key and employee details as the value.\n        \"\"\"\n        self.employees = {}\n\n    def add_employee(self, employee_id, name, position, department, salary):\n        \"\"\"\n        Add a new employee to the HRManagementSystem.\n        :param employee_id: The employee's id, int.\n        :param name: The employee's name, str.\n        :param position: The employee's position, str.\n        :param department: The employee's department, str.\n        :param salary: The employee's salary, int.\n        :return: If the employee is already in the HRManagementSystem, returns False, otherwise, adds the employee to the employees dictionary and returns True.\n        \"\"\"\n\n        # Check if the employee_id already exists in the employees dictionary\n        if employee_id in self.employees:\n            return False\n        else:\n            # If not, add the employee details to the employees dictionary with employee_id as the key\n            self.employees[employee_id] = {\n                'name': name,\n                'position': position,\n                'department': department,\n                'salary': salary\n            }\n            return True\n\n    def remove_employee(self, employee_id):\n        \"\"\"\n        Remove an employee from the HRManagementSystem.\n        :param employee_id: The employee's id, int.\n        :return: If the employee is already in the HRManagementSystem, removes the employee from the employees dictionary and returns True, otherwise, returns False.\n        \"\"\"\n\n        # Check if the employee_id exists in the employees dictionary\n        if employee_id in self.employees:\n            # If yes, remove the employee details from the employees dictionary\n            del self.employees[employee_id]\n            return True\n        else:\n            return False\n\n    def update_employee(self, employee_id: int, employee_info: dict):\n        \"\"\"\n        Update an employee's information in the HRManagementSystem.\n        :param employee_id: The employee's id, int.\n        :param employee_info: The employee's information, dict.\n        :return: If the employee is already in the HRManagementSystem, updates the employee's information in the employees dictionary and returns True, otherwise, returns False.\n        \"\"\"\n\n        # Use the get_employee method to get the employee details from the employees dictionary\n        employee = self.get_employee(employee_id)\n        if employee == False:\n            return False\n        else:\n            # Check if all the keys in the employee_info dictionary exist in the employee details\n            for key, value in employee_info.items():\n                if key not in employee:\n                    return False\n            # If all keys exist, update the employee details with the new information\n            for key, value in employee_info.items():\n                employee[key] = value\n            return True\n\n    def get_employee(self, employee_id):\n        \"\"\"\n        Get an employee's information from the HRManagementSystem.\n        :param employee_id: The employee's id, int.\n        :return: If the employee is already in the HRManagementSystem, returns the employee's information from the employees dictionary, otherwise, returns False.\n        \"\"\"\n\n        # Check if the employee_id exists in the employees dictionary\n        if employee_id in self.employees:\n            # If yes, return the employee details\n            return self.employees[employee_id]\n        else:\n            return False\n\n    def list_employees(self):\n        \"\"\"\n        List all employees' information in the HRManagementSystem.\n        :return: A dictionary of all employees' information, with employee_id as the key and employee details as the value.\n        \"\"\"\n\n        employee_data = {}\n        if self.employees:\n            # Iterate through all the items in the employees dictionary\n            for employee_id, employee_info in self.employees.items():\n                employee_details = {}\n                employee_details[\"employee_ID\"] = employee_id\n                # Add each key-value pair in the employee_info dictionary to the employee_details dictionary\n                for key, value in employee_info.items():\n                    employee_details[key] = value\n                # Add the employee_details dictionary to the employee_data dictionary with employee_id as the key\n                employee_data[employee_id] = employee_details\n        return employee_data"}, {"id": "44", "llm_annotated_code": "class HtmlUtil:\n\n    \"\"\"\n    This is a class as util for HTML, supporting for formatting and extracting code from HTML text, including cleaning up the text and converting certain elements into specific marks.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize a series of labels to be used in the class methods.\n        \"\"\"\n\n        self.SPACE_MARK = '-SPACE-'\n        self.JSON_MARK = '-JSON-'\n        self.MARKUP_LANGUAGE_MARK = '-MARKUP_LANGUAGE-'\n        self.URL_MARK = '-URL-'\n        self.NUMBER_MARK = '-NUMBER-'\n        self.TRACE_MARK = '-TRACE-'\n        self.COMMAND_MARK = '-COMMAND-'\n        self.COMMENT_MARK = '-COMMENT-'\n        self.CODE_MARK = '-CODE-'\n\n    @staticmethod\n    def __format_line_feed(text):\n        \"\"\"\n        Replace consecutive line breaks with a single line break\n        :param text: string with consecutive line breaks\n        :return:string, replaced text with single line break\n        \"\"\"\n\n        # Use the re.sub function to replace consecutive line breaks with a single line break\n        return re.sub(re.compile(r'\\n+'), '\\n', text)\n\n    def format_line_html_text(self, html_text):\n        \"\"\"\n        Get the HTML text without the code, and add the code tag -CODE- where the code is\n        :param html_text:string\n        :return:string\n        \"\"\"\n\n        # If the input HTML text is None or empty, return an empty string\n        if html_text is None or len(html_text) == 0:\n            return ''\n        \n        # Use the BeautifulSoup library to parse the HTML text\n        soup = BeautifulSoup(html_text, 'lxml')\n        \n        # Find all the 'pre' and 'blockquote' tags in the parsed HTML, which usually contain code\n        code_tag = soup.find_all(name=['pre', 'blockquote'])\n        \n        # Replace the text in each 'pre' and 'blockquote' tag with the code mark\n        for tag in code_tag:\n            tag.string = self.CODE_MARK\n        \n        # Find all the 'ul' and 'ol' tags in the parsed HTML, which usually contain lists\n        ul_ol_group = soup.find_all(name=['ul', 'ol'])\n        \n        # For each 'li' tag in each 'ul' or 'ol' tag, format the text appropriately\n        for ul_ol_item in ul_ol_group:\n            li_group = ul_ol_item.find_all('li')\n            for li_item in li_group:\n                li_item_text = li_item.get_text().strip()\n                if len(li_item_text) == 0:\n                    continue\n                if li_item_text[-1] in string.punctuation:\n                    li_item.string = '[{0}]{1}'.format('-', li_item_text)\n                    continue\n                li_item.string = '[{0}]{1}.'.format('-', li_item_text)\n\n        # Find all the 'p' tags in the parsed HTML, which usually contain paragraphs\n        p_group = soup.find_all(name=['p'])\n        \n        # For each 'p' tag, format the text appropriately\n        for p_item in p_group:\n            p_item_text = p_item.get_text().strip()\n            if p_item_text:\n                if p_item_text[-1] in string.punctuation:\n                    p_item.string = p_item_text\n                    continue\n                next_sibling = p_item.find_next_sibling()\n                if next_sibling and self.CODE_MARK in next_sibling.get_text():\n                    p_item.string = p_item_text + ':'\n                    continue\n                p_item.string = p_item_text + '.'\n\n        # Use the gensim library to decode HTML entities in the text\n        clean_text = gensim.utils.decode_htmlentities(soup.get_text())\n        \n        # Return the formatted text with single line breaks\n        return self.__format_line_feed(clean_text)\n\n    def extract_code_from_html_text(self, html_text):\n        \"\"\"\n        Extract codes from the HTML body\n        :param html_text: string, HTML text\n        :return: the list of code\n        \"\"\"\n\n        # Use the format_line_html_text method to get the formatted HTML text with code marks\n        text_with_code_tag = self.format_line_html_text(html_text)\n        \n        # If there are no code marks in the text, return an empty list\n        if self.CODE_MARK not in text_with_code_tag:\n            return []\n\n        # Use the BeautifulSoup library to parse the HTML text\n        soup = BeautifulSoup(html_text, 'lxml')\n        \n        # Find all the 'pre' and 'blockquote' tags in the parsed HTML, which usually contain code\n        code_tag = soup.find_all(name=['pre', 'blockquote'])\n        \n        # Count the number of code marks in the text\n        code_count = text_with_code_tag.count(self.CODE_MARK)\n        \n        # Initialize an empty list to store the extracted code\n        code_list = []\n\n        # For each code mark, extract the corresponding code and add it to the list\n        for code_index in range(code_count):\n            code = code_tag[code_index].get_text()\n            if code:\n                code_list.append(code)\n        \n        # Return the list of extracted code\n        return code_list"}, {"id": "45", "llm_annotated_code": "class ImageProcessor:\n\n    \"\"\"\n    This class uses the Python Imaging Library (PIL) to perform various operations on images, such as loading, saving, resizing, rotating, and adjusting brightness.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the ImageProcessor with an empty image attribute.\n        \"\"\"\n\n        self.image = None\n\n    def load_image(self, image_path):\n        \"\"\"\n        Load an image from a given path using the open function from the PIL Image module.\n        :param image_path: str, path of the image to be loaded\n        >>> processor = ImageProcessor()\n        >>> processor.load_image('test.jpg')\n        >>> processor.image\n        <PIL.JpegImagePlugin.JpegImageFile image mode=RGB size=3072x4096 at 0x194F2412A48>\n        \"\"\"\n\n        self.image = Image.open(image_path)\n\n    def save_image(self, save_path):\n        \"\"\"\n        Save the loaded image to a specified path using the save method of the PIL Image object, if an image has been loaded.\n        :param save_path: str, the path where the image will be saved\n        >>> processor = ImageProcessor()\n        >>> processor.load_image('test.jpg')\n        >>> processor.save_image('test2.jpg')\n        \"\"\"\n\n        if self.image:\n            self.image.save(save_path)\n\n    def resize_image(self, width, height):\n        \"\"\"\n        Resize the loaded image to the specified width and height using the resize method of the PIL Image object, if an image has been loaded.\n        :param width: int, the target width of the image\n        :param height: int, the target height of the image\n        >>> processor = ImageProcessor()\n        >>> processor.load_image('test.jpg')\n        >>> processor.resize_image(300, 300)\n        >>> processor.image.width\n        300\n        >>> processor.image.height\n        300\n        \"\"\"\n\n        if self.image:\n            self.image = self.image.resize((width, height))\n\n    def rotate_image(self, degrees):\n        \"\"\"\n        Rotate the loaded image by the specified number of degrees using the rotate method of the PIL Image object, if an image has been loaded.\n        :param degrees: float, the number of degrees to rotate the image\n        >>> processor = ImageProcessor()\n        >>> processor.load_image('test.jpg')\n        >>> processor.rotate_image(90)\n        \"\"\"\n\n        if self.image:\n            self.image = self.image.rotate(degrees)\n\n    def adjust_brightness(self, factor):\n        \"\"\"\n        Adjust the brightness of the loaded image by the specified factor using the enhance method of the PIL ImageEnhance.Brightness object, if an image has been loaded.\n        :param factor: float, the factor by which to adjust the brightness of the image. A factor of 0.0 gives a black image. A factor of 1.0 gives the original image.\n        >>> processor = ImageProcessor()\n        >>> processor.load_image('test.jpg')\n        >>> processor.adjust_brightness(0.5)\n        \"\"\"\n\n        if self.image:\n            enhancer = ImageEnhance.Brightness(self.image)\n            self.image = enhancer.enhance(factor)"}, {"id": "46", "llm_annotated_code": "class Interpolation:\n\n    \"\"\"\n    This is a class that implements the Linear interpolation operation of one-dimensional and two-dimensional data\n    \"\"\"\n\n    def __init__(self):\n        pass\n\n    @staticmethod\n    def interpolate_1d(x, y, x_interp):\n        \"\"\"\n        Linear interpolation of one-dimensional data\n        :param x: list, The x-coordinate of the data point\n        :param y: list, The y-coordinate of the data point\n        :param x_interp: list, The x-coordinate of the interpolation point\n        :return: list, The y-coordinate of the interpolation point\n        >>> interpolation = Interpolation()\n        >>> interpolation.interpolate_1d([1, 2, 3], [1, 2, 3], [1.5, 2.5])\n        [1.5, 2.5]\n\n        \"\"\"\n\n        # Initialize an empty list to store the interpolated y-coordinates\n        y_interp = []\n\n        # Iterate over each x-coordinate in the interpolation points\n        for xi in x_interp:\n            # Iterate over each x-coordinate in the data points\n            for i in range(len(x) - 1):\n                # If the x-coordinate of the interpolation point is between two x-coordinates of the data points\n                if x[i] <= xi <= x[i+1]:\n                    # Calculate the corresponding y-coordinate using linear interpolation formula\n                    yi = y[i] + (y[i+1] - y[i]) * (xi - x[i]) / (x[i+1] - x[i])\n                    # Append the calculated y-coordinate to the list of interpolated y-coordinates\n                    y_interp.append(yi)\n                    break\n        # Return the list of interpolated y-coordinates\n        return y_interp\n\n    @staticmethod\n    def interpolate_2d(x, y, z, x_interp, y_interp):\n        \"\"\"\n        Linear interpolation of two-dimensional data\n        :param x: list, The x-coordinate of the data point\n        :param y: list, The y-coordinate of the data point\n        :param z: list of list, The z-coordinate of the data point\n        :param x_interp: list, The x-coordinate of the interpolation point\n        :param y_interp: list, The y-coordinate of the interpolation point\n        :return: list, The z-coordinate of the interpolation point\n        >>> interpolation = Interpolation()\n        >>> interpolation.interpolate_2d([1, 2, 3], [1, 2, 3], [[1, 2, 3], [4, 5, 6], [7, 8, 9]], [1.5, 2.5], [1.5, 2.5])\n        [3.0, 7.0]\n\n        \"\"\"\n\n        # Initialize an empty list to store the interpolated z-coordinates\n        z_interp = []\n\n        # Iterate over each pair of x and y coordinates in the interpolation points\n        for xi, yi in zip(x_interp, y_interp):\n            # Iterate over each x-coordinate in the data points\n            for i in range(len(x) - 1):\n                # If the x-coordinate of the interpolation point is between two x-coordinates of the data points\n                if x[i] <= xi <= x[i+1]:\n                    # Iterate over each y-coordinate in the data points\n                    for j in range(len(y) - 1):\n                        # If the y-coordinate of the interpolation point is between two y-coordinates of the data points\n                        if y[j] <= yi <= y[j+1]:\n                            # Get the z-coordinates of the four corners of the rectangle formed by the two x-coordinates and the two y-coordinates\n                            z00 = z[i][j]\n                            z01 = z[i][j+1]\n                            z10 = z[i+1][j]\n                            z11 = z[i+1][j+1]\n\n                            # Calculate the corresponding z-coordinate using bilinear interpolation formula\n                            zi = (z00 * (x[i+1] - xi) * (y[j+1] - yi) +\n                                  z10 * (xi - x[i]) * (y[j+1] - yi) +\n                                  z01 * (x[i+1] - xi) * (yi - y[j]) +\n                                  z11 * (xi - x[i]) * (yi - y[j])) / ((x[i+1] - x[i]) * (y[j+1] - y[j]))\n                            \n                            # Append the calculated z-coordinate to the list of interpolated z-coordinates\n                            z_interp.append(zi)\n                            break\n                    break\n        # Return the list of interpolated z-coordinates\n        return z_interp"}, {"id": "47", "llm_annotated_code": "class IPAddress:\n\n    \"\"\"\n    This class is used to process IP addresses. It includes methods for validating IP addresses, \n    extracting the octets of an IP address, and obtaining the binary representation of a valid IP address.\n    \"\"\"\n\n    def __init__(self, ip_address):\n        \"\"\"\n        Initialize the IPAddress instance with the specified IP address.\n        :param ip_address: str, the IP address to be processed\n        \"\"\"\n        self.ip_address = ip_address\n\n\n    def is_valid(self):\n        \"\"\"\n        Check whether the IP address is valid. A valid IP address consists of four decimal numbers separated by '.'. \n        Each number must be greater than or equal to 0 and less than or equal to 255.\n        :return: bool, True if the IP address is valid, False otherwise\n        \"\"\"\n\n        # Split the IP address into octets using the '.' delimiter\n        octets = self.ip_address.split('.')\n        \n        # Check if the IP address consists of exactly four octets\n        if len(octets) != 4:\n            return False\n            \n        # Check each octet to ensure it is a digit and within the valid range (0-255)\n        for octet in octets:\n            if not octet.isdigit() or int(octet) < 0 or int(octet) > 255:\n                return False    \n                \n        # If all checks pass, the IP address is valid\n        return True\n\n\n    def get_octets(self):\n        \"\"\"\n        If the IP address is valid, return a list of the four decimal numbers that constitute the IP address. \n        If the IP address is not valid, return an empty list.\n        :return: list, the octets of the IP address if it is valid, or an empty list if it is not\n        \"\"\"\n\n        # Check if the IP address is valid using the is_valid method\n        if self.is_valid():\n            # If the IP address is valid, split it into octets and return the list of octets\n            return self.ip_address.split('.')\n        else:\n            # If the IP address is not valid, return an empty list\n            return []\n\n\n    def get_binary(self):\n        \"\"\"\n        If the IP address is valid, return the binary representation of the IP address. \n        If the IP address is not valid, return an empty string.\n        :return: str, the binary representation of the IP address if it is valid, or an empty string if it is not\n        \"\"\"\n\n        # Check if the IP address is valid using the is_valid method\n        if self.is_valid():\n            # If the IP address is valid, convert each octet to binary and join them with '.' to form the binary representation of the IP address\n            binary_octets = []\n            for octet in self.get_octets():\n                binary_octets.append(format(int(octet), '08b'))\n            return '.'.join(binary_octets)\n        else:\n            # If the IP address is not valid, return an empty string\n            return \"\""}, {"id": "48", "llm_annotated_code": "class IpUtil:\n\n    \"\"\"\n    This is a class as tool for ip that can be used to obtain the local IP address, validate its validity, and also provides the functionality to retrieve the corresponding hostname.\n    \"\"\"\n\n    @staticmethod\n    def is_valid_ipv4(ip_address):\n        \"\"\"\n        Check if the given IP address is a valid IPv4 address.\n        :param ip_address: string, the IP address to check\n        :return: bool, True if the IP address is valid, False otherwise\n        This method uses the socket library's inet_pton function to try and convert the IP address to a packed binary format.\n        If the conversion is successful, the IP address is valid. If a socket error is raised, the IP address is not valid.\n        >>> IpUtil.is_valid_ipv4('192.168.0.123')\n        True\n        >>> IpUtil.is_valid_ipv4('256.0.0.0')\n        False\n\n        \"\"\"\n\n        try:\n            # Use the inet_pton function from the socket library to check if the IP address is valid\n            socket.inet_pton(socket.AF_INET, ip_address)\n            return True\n        except socket.error:\n            # If a socket error is raised, the IP address is not valid\n            return False\n\n    @staticmethod\n    def is_valid_ipv6(ip_address):\n        \"\"\"\n        Check if the given IP address is a valid IPv6 address.\n        :param ip_address:string, the IP address to check\n        :return:bool, True if the IP address is valid, False otherwise\n        This method uses the socket library's inet_pton function to try and convert the IP address to a packed binary format.\n        If the conversion is successful, the IP address is valid. If a socket error is raised, the IP address is not valid.\n        >>> IpUtil.is_valid_ipv6('2001:0db8:85a3:0000:0000:8a2e:0370:7334')\n        True\n        >>> IpUtil.is_valid_ipv6('2001:0db8:85a3:::8a2e:0370:7334')\n        False\n\n        \"\"\"\n\n        try:\n            # Use the inet_pton function from the socket library to check if the IP address is valid\n            socket.inet_pton(socket.AF_INET6, ip_address)\n            return True\n        except socket.error:\n            # If a socket error is raised, the IP address is not valid\n            return False\n\n\n    @staticmethod\n    def get_hostname(ip_address):\n        \"\"\"\n        Get the hostname associated with the given IP address.\n        :param ip_address:string, the IP address to get the hostname for\n        :return: string, the hostname associated with the IP address\n        This method uses the socket library's gethostbyaddr function to try and retrieve the hostname associated with the IP address.\n        If the retrieval is successful, the hostname is returned. If a socket error is raised, None is returned.\n        >>> IpUtil.get_hostname('110.242.68.3')\n        'www.baidu.com'\n        >>> IpUtil.get_hostname('10.0.0.1')\n\n        \"\"\"\n\n        try:\n            # Use the gethostbyaddr function from the socket library to get the hostname associated with the IP address\n            hostname = socket.gethostbyaddr(ip_address)[0]\n            return hostname\n        except socket.herror:\n            # If a socket error is raised, return None\n            return None"}, {"id": "49", "llm_annotated_code": "class JobMarketplace:\n\n    \"\"\"\n    This is a class that provides functionalities to publish positions, remove positions, submit resumes, withdraw resumes, search for positions, and obtain candidate information.\n    \"\"\"\n\n    def __init__(self):\n        # Initialize two empty lists to store job listings and resumes\n        self.job_listings = []\n        self.resumes = []\n\n    def post_job(self, job_title, company, requirements):\n        \"\"\"\n        This function is used to publish positions,and add the position information to the job_listings list.\n        :param job_title: The title of the position,str.\n        :param company: The company of the position,str.\n        :param requirements: The requirements of the position,list.\n        :return: None\n        \"\"\"\n\n        # Create a dictionary with the job details and append it to the job_listings list\n        job = {\"job_title\": job_title, \"company\": company, \"requirements\": requirements}\n        self.job_listings.append(job)\n\n    def remove_job(self, job):\n        \"\"\"\n        This function is used to remove positions,and remove the position information from the job_listings list.\n        :param job: The position information to be removed,dict.\n        :return: None\n        \"\"\"\n\n        # Remove the job from the job_listings list\n        self.job_listings.remove(job)\n\n    def submit_resume(self, name, skills, experience):\n        \"\"\"\n        This function is used to submit resumes,and add the resume information to the resumes list.\n        :param name: The name of the resume,str.\n        :param skills: The skills of the resume,list.\n        :param experience: The experience of the resume,str.\n        :return: None\n        \"\"\"\n\n        # Create a dictionary with the resume details and append it to the resumes list\n        resume = {\"name\": name, \"skills\": skills, \"experience\": experience}\n        self.resumes.append(resume)\n\n    def withdraw_resume(self, resume):\n        \"\"\"\n        This function is used to withdraw resumes,and remove the resume information from the resumes list.\n        :param resume: The resume information to be removed,dict.\n        :return: None\n        \"\"\"\n\n        # Remove the resume from the resumes list\n        self.resumes.remove(resume)\n\n    def search_jobs(self, criteria):\n        \"\"\"\n        This function is used to search for positions,and return the position information that meets the requirements.\n        :param criteria: The requirements of the position,str.\n        :return: The position information that meets the requirements,list.\n        \"\"\"\n\n        matching_jobs = []\n        # Iterate over the job_listings list\n        for job_listing in self.job_listings:\n            # If the criteria is found in the job title or requirements, append the job to the matching_jobs list\n            if criteria.lower() in job_listing[\"job_title\"].lower() or criteria.lower() in [r.lower() for r in job_listing[\"requirements\"]]:\n                matching_jobs.append(job_listing)\n        return matching_jobs\n\n    @staticmethod\n    def matches_requirements(resume, requirements):\n        \"\"\"\n        This function is used to check whether all the skills in the provided resume exist in the provided requirements for a job.\n        :param resume: The resume information,dict.\n        :param requirements: The requirements of some position,str.\n        :return: Whether all the skills in the resume exists in the requirements,boolean.\n\n        \"\"\"\n\n        # Iterate over the skills in the resume\n        for skill in resume[\"skills\"]:\n            # If a skill is not found in the requirements, return False\n            if skill not in requirements:\n                return False\n        # If all skills are found in the requirements, return True\n        return True\n\n    def get_job_applicants(self, job):\n        \"\"\"\n        This function is used to obtain candidate information,and return the candidate information that meets the requirements by calling the matches_requirements function.\n        :param job: The position information,dict.\n        :return: The candidate information that meets the requirements,list.\n        \"\"\"\n\n        applicants = []\n        # Iterate over the resumes list\n        for resume in self.resumes:\n            # If a resume matches the job requirements, append it to the applicants list\n            if self.matches_requirements(resume, job[\"requirements\"]):\n                applicants.append(resume)\n        return applicants"}, {"id": "50", "llm_annotated_code": "class JSONProcessor:\n    \"\"\"\n    This class provides methods to read, write and process JSON files.\n    \"\"\"\n\n    def read_json(self, file_path):\n        \"\"\"\n        Reads a JSON file and returns the data.\n        :param file_path: str, the path of the JSON file.\n        :return: dict, the data from the JSON file if read successfully, or return -1 if an error occurs during the reading process.\n                 return 0 if the file does not exist.\n        \"\"\"\n\n        # Check if the file exists using os.path.exists\n        if not os.path.exists(file_path):\n            return 0\n\n        try:\n            # Open the file in read mode\n            with open(file_path, 'r') as file:\n                # Use json.load to load the JSON data from the file\n                data = json.load(file)\n            # Return the loaded data\n            return data\n        except:\n            # If an error occurs during the reading process, return -1\n            return -1\n\n    def write_json(self, data, file_path):\n        \"\"\"\n        Writes data to a JSON file and saves it to the given path.\n        :param data: dict, the data to be written to the JSON file.\n        :param file_path: str, the path of the JSON file.\n        :return: 1 if the writing process is successful, or -1, if an error occurs during the writing process.\n        \"\"\"\n\n        try:\n            # Open the file in write mode\n            with open(file_path, 'w') as file:\n                # Use json.dump to write the data to the file\n                json.dump(data, file)\n            # Return 1 if the writing process is successful\n            return 1\n        except:\n            # If an error occurs during the writing process, return -1\n            return -1\n\n    def process_json(self, file_path, remove_key):\n        \"\"\"\n        Reads a JSON file, processes the data by removing a specified key, and rewrites the modified data back to the file.\n        :param file_path: str, the path of the JSON file.\n        :param remove_key: str, the key to be removed.\n        :return: 1, if the specified key is successfully removed and the data is written back.\n                 0, if the file does not exist or the specified key does not exist in the data.\n        \"\"\"\n\n        # Use the read_json method to read the JSON file\n        data = self.read_json(file_path)\n\n        # If the file does not exist or an error occurs during the reading process, return 0\n        if data == 0 or data == -1:\n            return 0\n\n        # If the specified key exists in the data\n        if remove_key in data:\n            # Remove the key from the data\n            del data[remove_key]\n            # Use the write_json method to write the modified data back to the file\n            self.write_json(data, file_path)\n            # Return 1 if the specified key is successfully removed and the data is written back\n            return 1\n        else:\n            # If the specified key does not exist in the data, return 0\n            return 0"}, {"id": "51", "llm_annotated_code": "import numpy as np\n\nclass KappaCalculator:\n    \"\"\"\n    This class calculates Cohen's and Fleiss' kappa coefficient, which are statistical measures of inter-rater reliability.\n    \"\"\"\n\n    @staticmethod\n    def kappa(testData, k):\n        \"\"\"\n        Calculate the Cohen's kappa value of a k-dimensional matrix.\n        Cohen's kappa measures the agreement between two raters who each classify N items into C mutually exclusive categories.\n\n        :param testData: list of lists, The k-dimensional matrix that needs to calculate the Cohen's kappa value.\n        :param k: int, Matrix dimension.\n        :return: float, the Cohen's kappa value of the matrix.\n        >>> KappaCalculator.kappa([[2, 1, 1], [1, 2, 1], [1, 1, 2]], 3)\n        0.25\n        \"\"\"\n        # Convert the input list to a numpy matrix for easier manipulation\n        dataMat = np.mat(testData)\n\n        # Initialize the observed agreement probability\n        P0 = 0.0\n\n        # Calculate the observed agreement probability\n        for i in range(k):\n            P0 += dataMat[i, i] * 1.0\n\n        # Calculate the sum of each row and column of the matrix\n        xsum = np.sum(dataMat, axis=1)\n        ysum = np.sum(dataMat, axis=0)\n\n        # Calculate the total sum of the matrix\n        sum = np.sum(dataMat)\n\n        # Calculate the expected agreement probability\n        Pe = float(ysum * xsum) / sum / sum\n\n        # Calculate the observed agreement probability\n        P0 = float(P0 / sum * 1.0)\n\n        # Calculate the Cohen's kappa coefficient\n        cohens_coefficient = float((P0 - Pe) / (1 - Pe))\n\n        return cohens_coefficient\n\n    @staticmethod\n    def fleiss_kappa(testData, N, k, n):\n        \"\"\"\n        Calculate the Fleiss' kappa value of an N * k matrix.\n        Fleiss' kappa is a statistical measure for assessing the reliability of agreement between a fixed number of raters when assigning categorical ratings to a number of items or classifying items.\n\n        :param testData: list of lists, Input data matrix, N * k.\n        :param N: int, Number of samples.\n        :param k: int, Number of categories.\n        :param n: int, Number of raters.\n        :return: float, Fleiss' kappa value.\n        >>> KappaCalculator.fleiss_kappa([[0, 0, 0, 0, 14],\n        >>>                              [0, 2, 6, 4, 2],\n        >>>                              [0, 0, 3, 5, 6],\n        >>>                              [0, 3, 9, 2, 0],\n        >>>            [2, 2, 8, 1, 1],\n        >>>                              [7, 7, 0, 0, 0],\n        >>>                              [3, 2, 6, 3, 0],\n        >>>                              [2, 5, 3, 2, 2],\n        >>>                              [6, 5, 2, 1, 0],\n        >>>                 [0, 2, 2, 3, 7]], 10, 5, 14)\n        0.20993070442195522\n        \"\"\"\n        # Convert the input list to a numpy matrix for easier manipulation\n        dataMat = np.mat(testData, float)\n\n        # Initialize a matrix of ones with the same dimensions as the input matrix\n        oneMat = np.ones((k, 1))\n\n        # Initialize the total sum\n        sum = 0.0\n\n        # Initialize the observed agreement probability\n        P0 = 0.0\n\n        # Calculate the observed agreement probability\n        for i in range(N):\n            temp = 0.0\n            for j in range(k):\n                sum += dataMat[i, j]\n                temp += 1.0 * dataMat[i, j] ** 2\n            temp -= n\n            temp /= (n - 1) * n\n            P0 += temp\n\n        # Calculate the observed agreement probability\n        P0 = 1.0 * P0 / N\n\n        # Calculate the sum of each column of the matrix\n        ysum = np.sum(dataMat, axis=0)\n\n        # Calculate the square of the sum of each column divided by the total sum\n        for i in range(k):\n            ysum[0, i] = (ysum[0, i] / sum) ** 2\n\n        # Calculate the expected agreement probability\n        Pe = ysum * oneMat * 1.0\n\n        # Calculate the Fleiss' kappa coefficient\n        ans = (P0 - Pe) / (1 - Pe)\n\n        return ans[0, 0]"}, {"id": "52", "llm_annotated_code": "import nltk\nfrom nltk.stem import WordNetLemmatizer\nfrom nltk import pos_tag, word_tokenize\nimport string\n\n# Download necessary NLTK packages\nnltk.download('averaged_perceptron_tagger')\nnltk.download('punkt')\nnltk.download('wordnet')\n\nclass Lemmatization:\n    \"\"\"\n    This class performs lemmatization and part-of-speech tagging on sentences using the nltk library.\n    It also provides functionality to remove punctuation from sentences.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the Lemmatization class by creating a WordNetLemmatizer object.\n        \"\"\"\n        self.lemmatizer = WordNetLemmatizer()\n\n    def lemmatize_sentence(self, sentence):\n        \"\"\"\n        Lemmatize a sentence. This involves removing punctuation, tokenizing the sentence into words,\n        tagging each word with its part of speech, and then lemmatizing each word based on its part of speech.\n        :param sentence: str, the sentence to lemmatize\n        :return: list, the lemmatized words of the sentence\n        \"\"\"\n        lemmatized_words = []\n\n        # Remove punctuation from the sentence\n        sentence = self.remove_punctuation(sentence)\n\n        # Tokenize the sentence into words\n        words = word_tokenize(sentence)\n\n        # Tag each word with its part of speech\n        tagged_words = pos_tag(words)\n\n        # Lemmatize each word based on its part of speech\n        for word, tag in tagged_words:\n            if tag.startswith('V'):\n                lemmatized_word = self.lemmatizer.lemmatize(word, pos='v')\n            elif tag.startswith('J'):\n                lemmatized_word = self.lemmatizer.lemmatize(word, pos='a')\n            elif tag.startswith('R'):\n                lemmatized_word = self.lemmatizer.lemmatize(word, pos='r')\n            else:\n                lemmatized_word = self.lemmatizer.lemmatize(word)\n            lemmatized_words.append(lemmatized_word)\n\n        return lemmatized_words\n\n    def get_pos_tag(self, sentence):\n        \"\"\"\n        Get the part of speech tag for each word in a sentence. This involves removing punctuation, tokenizing the sentence into words,\n        and then tagging each word with its part of speech.\n        :param sentence: str, the sentence to tag\n        :return: list, the part of speech tags for each word in the sentence\n        \"\"\"\n        pos_tags = []\n\n        # Remove punctuation from the sentence\n        sentence = self.remove_punctuation(sentence)\n\n        # Tokenize the sentence into words\n        words = word_tokenize(sentence)\n\n        # Tag each word with its part of speech\n        tagged_words = pos_tag(words)\n\n        # Extract the part of speech tag for each word\n        for tagged_word in tagged_words:\n            pos_tags.append(tagged_word[1])\n\n        return pos_tags\n\n    def remove_punctuation(self, sentence):\n        \"\"\"\n        Remove punctuation from a sentence.\n        :param sentence: str, the sentence from which to remove punctuation\n        :return: str, the sentence without punctuation\n        \"\"\"\n        # Use the translate method of the string class to remove punctuation\n        return sentence.translate(str.maketrans('', '', string.punctuation))"}, {"id": "53", "llm_annotated_code": "class LongestWord:\n    \"\"\"\n    This class allows to add words to a list and find the longest word in a given sentence by comparing the words with the ones in the word list.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize a list of words.\n        self.word_list: list, stores the words added to the list\n        \"\"\"\n        self.word_list = []\n\n    def add_word(self, word):\n        \"\"\"\n        Append the input word into self.word_list\n        :param word: str, input word\n        \"\"\"\n        # Append the input word to the word_list\n        self.word_list.append(word)\n\n    def find_longest_word(self, sentence):\n        \"\"\"\n        Remove punctuation marks and split a sentence into a list of words. Find the longest split word that is in the self.word_list.\n        Words are strictly case sensitive.\n        :param sentence: str, a sentence\n        :return str: longest split word that is in the self.word_list. return '' if self.word_list is empty.\n        \"\"\"\n        # Initialize the longest_word as an empty string\n        longest_word = \"\"\n\n        # Convert the sentence to lowercase\n        sentence = sentence.lower()\n\n        # Use the re.sub function to remove punctuation from the sentence\n        sentence = re.sub('[%s]' % re.escape(string.punctuation), '', sentence)\n\n        # Use the re.split function to split the sentence into a list of words\n        sentence = re.split(' ', sentence)\n\n        # Iterate through each word in the sentence\n        for word in sentence:\n            # If the word is in the word_list and its length is greater than the length of the current longest_word, update longest_word\n            if word in self.word_list and len(word) > len(longest_word):\n                longest_word = word\n\n        # Return the longest_word\n        return longest_word"}, {"id": "54", "llm_annotated_code": "class MahjongConnect:\n    \"\"\"\n    MahjongConnect is a class representing a game board for Mahjong Connect with features like creating the board, checking valid moves, finding paths, removing icons, and checking if the game \nis over.\n    \"\"\"\n\n    def __init__(self, BOARD_SIZE, ICONS):\n        \"\"\"\n        Initialize the board size and the icon list, create the game board\n        :param BOARD_SIZE: list of two integer numbers, representing the number of rows and columns of the game board\n        :param ICONS: list of string, representing the icons\n        \"\"\"\n        self.BOARD_SIZE = BOARD_SIZE  # Set the board size\n        self.ICONS = ICONS  # Set the icons\n        self.board = self.create_board()  # Create the game board\n\n    def create_board(self):\n        \"\"\"\n        Create the game board with the given board size and icons\n        :return: 2-dimensional list, the game board\n        \"\"\"\n        # Use list comprehension and random.choice to create a 2D list (game board) with random icons\n        board = [[random.choice(self.ICONS) for _ in range(self.BOARD_SIZE[1])] for _ in range(self.BOARD_SIZE[0])]\n        return board\n\n    def is_valid_move(self, pos1, pos2):\n        \"\"\"\n        Check if the move of two icons is valid (i.e. positions are within the game board range, the two positions are not the same, the two positions have the same icon, and there is a valid path between the two positions)\n        :param pos1: position tuple(x, y) of the first icon\n        :param pos2: position tuple(x, y) of the second icon\n        :return:True or False ,representing whether the move of two icons is valid\n        \"\"\"\n        x1, y1 = pos1  # Unpack the first position\n        x2, y2 = pos2  # Unpack the second position\n\n        # Check if positions are within the game board range\n        if not (0 <= x1 < self.BOARD_SIZE[0] and 0 <= y1 < self.BOARD_SIZE[1] and 0 <= x2 < self.BOARD_SIZE[\n            0] and 0 <= y2 < self.BOARD_SIZE[1]):\n            return False\n\n        # Check if the two positions are the same\n        if pos1 == pos2:\n            return False\n\n        # Check if the two positions have the same icon\n        if self.board[x1][y1] != self.board[x2][y2]:\n            return False\n\n        # Check if there is a valid path between the two positions\n        if not self.has_path(pos1, pos2):\n            return False\n\n        return True\n\n    def has_path(self, pos1, pos2):\n        \"\"\"\n        Check if there is a path between two icons\n        :param pos1: position tuple(x, y) of the first icon\n        :param pos2: position tuple(x, y) of the second icon\n        :return: True or False ,representing whether there is a path between two icons\n        \"\"\"\n        visited = set()  # Initialize a set to store visited positions\n        stack = [pos1]  # Initialize a stack with the first position\n\n        while stack:  # While there are positions in the stack\n            current_pos = stack.pop()  # Pop a position from the stack\n            if current_pos == pos2:  # If the current position is the second position, return True\n                return True\n\n            if current_pos in visited:  # If the current position has been visited, skip the current iteration\n                continue\n\n            visited.add(current_pos)  # Add the current position to the visited set\n            x, y = current_pos  # Unpack the current position\n\n            # Check adjacent positions (up, down, left, right)\n            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                new_x, new_y = x + dx, y + dy  # Calculate the new position\n                if 0 <= new_x < self.BOARD_SIZE[0] and 0 <= new_y < self.BOARD_SIZE[1]:  # If the new position is within the game board\n                    if (new_x, new_y) not in visited and self.board[new_x][new_y] == self.board[x][y]:  # If the new position has not been visited and has the same icon as the current position\n                        stack.append((new_x, new_y))  # Add the new position to the stack\n\n        return False  # If no path is found, return False\n\n    def remove_icons(self, pos1, pos2):\n        \"\"\"\n        Remove the connected icons on the game board\n        :param pos1: position tuple(x, y) of the first icon to be removed\n        :param pos2: position tuple(x, y) of the second icon to be removed\n        :return: None\n        \"\"\"\n        x1, y1 = pos1  # Unpack the first position\n        x2, y2 = pos2  # Unpack the second position\n        self.board[x1][y1] = ' '  # Remove the first icon by setting it to ' '\n        self.board[x2][y2] = ' '  # Remove the second icon by setting it to ' '\n\n    def is_game_over(self):\n        \"\"\"\n        Check if the game is over (i.e., if there are no more icons on the game board)\n        :return: True or False ,representing whether the game is over\n        \"\"\"\n        for row in self.board:  # Iterate over each row in the game board\n            if any(icon != ' ' for icon in row):  # If there is any icon (not ' ') in the row, return False\n                return False\n        return True  # If no icon is found, return True"}, {"id": "55", "llm_annotated_code": "class Manacher:\n    \"\"\"\n    This is a class that implements a manacher algorithm to find the Longest palindromic substring in a given string.\n    \"\"\"\n\n    def __init__(self, input_string) -> None:\n        \"\"\"\n        Initializes the Manacher class with the given input_string.\n        :param input_string: The input_string to be searched, str.\n        \"\"\"\n        # Store the input string to be searched for palindromic substrings\n        self.input_string = input_string\n\n    def palindromic_length(self, center, diff, string):\n        \"\"\"\n        Recursively calculates the length of the palindromic substring based on a given center, difference value, and input string.\n        :param center: The center of the palindromic substring, int.\n        :param diff: The difference between the center and the current position, int.\n        :param string: The string to be searched, str.\n        :return: The length of the palindromic substring, int.\n        >>> manacher = Manacher('ababa')\n        >>> manacher.palindromic_length(2, 1, 'a|b|a|b|a')\n        2\n\n        \"\"\"\n        # Base case: if the center minus the difference is -1, or the center plus the difference is the length of the string,\n        # or the characters at the positions (center - diff) and (center + diff) are not the same, return 0\n        if (center - diff == -1 or center + diff == len(string)\n                or string[center - diff] != string[center + diff]):\n            return 0\n\n        # Recursive case: return 1 plus the result of the recursive call with the same center and an incremented difference\n        return 1 + self.palindromic_length(center, diff + 1, string)\n\n    def palindromic_string(self):\n        \"\"\"\n        Finds the longest palindromic substring in the given string.\n        :return: The longest palindromic substring, str.\n        >>> manacher = Manacher('ababaxse')\n        >>> manacher.palindromic_string()\n        'ababa'\n\n        \"\"\"\n        # Initialize the maximum length of a palindromic substring to 0\n        max_length = 0\n\n        # Initialize a new input string with \"|\" inserted between every two characters of the original input string\n        new_input_string = \"\"\n        # Initialize the output string to store the longest palindromic substring\n        output_string = \"\"\n\n        # Construct the new input string\n        for i in self.input_string[:len(self.input_string) - 1]:\n            new_input_string += i + \"|\"\n        new_input_string += self.input_string[-1]\n\n        # Iterate through each character in the new input string\n        for i in range(len(new_input_string)):\n\n            # Calculate the length of the palindromic substring centered at the current character\n            length =self.palindromic_length(i, 1, new_input_string)\n\n            # If the calculated length is greater than the current maximum length, update the maximum length and the start position\n            if max_length < length:\n                max_length = length\n                start = i\n\n        # Construct the longest palindromic substring by removing \"|\" from the substring of the new input string centered at the start position with the maximum length\n        for i in new_input_string[start - max_length:start + max_length + 1]:\n            if i != \"|\":\n                output_string += i\n\n        # Return the longest palindromic substring\n        return output_string"}, {"id": "56", "llm_annotated_code": "class MetricsCalculator:\n    \"\"\"\n    This class calculates precision, recall, F1 score, and accuracy based on predicted and true labels.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the number of all four samples to 0.\n        true_positives, false_positives, false_negatives, true_negatives are counters for the four possible outcomes of a binary classification.\n        \"\"\"\n\n        self.true_positives = 0\n        self.false_positives = 0\n        self.false_negatives = 0\n        self.true_negatives = 0\n\n\n    def update(self, predicted_labels, true_labels):\n        \"\"\"\n        Update the number of all four samples(true_positives, false_positives, false_negatives, true_negatives)\n        based on the predicted and true labels.\n        :param predicted_labels: list, predicted results\n        :param true_labels: list, true labels\n        :return: None, change the number of corresponding samples\n        \"\"\"\n\n        # Iterate over the predicted and true labels simultaneously\n        for predicted, true in zip(predicted_labels, true_labels):\n            # Update the counters based on the comparison of predicted and true labels\n            if predicted == 1 and true == 1:\n                self.true_positives += 1\n            elif predicted == 1 and true == 0:\n                self.false_positives += 1\n            elif predicted == 0 and true == 1:\n                self.false_negatives += 1\n            elif predicted == 0 and true == 0:\n                self.true_negatives += 1\n\n\n    def precision(self, predicted_labels, true_labels):\n        \"\"\"\n        Calculate precision, which is the ratio of true positives to the sum of true positives and false positives.\n        :param predicted_labels: list, predicted results\n        :param true_labels: list, true labels\n        :return: float, precision score\n        \"\"\"\n\n        # Update the counters with the new predicted and true labels\n        self.update(predicted_labels, true_labels)\n\n        # If there are no true positives and false positives, return 0.0 to avoid division by zero\n        if self.true_positives + self.false_positives == 0:\n            return 0.0\n\n        # Calculate and return the precision score\n        return self.true_positives / (self.true_positives + self.false_positives)\n\n\n    def recall(self, predicted_labels, true_labels):\n        \"\"\"\n        Calculate recall, which is the ratio of true positives to the sum of true positives and false negatives.\n        :param predicted_labels: list, predicted results\n        :param true_labels: list, true labels\n        :return: float, recall score\n        \"\"\"\n\n        # Update the counters with the new predicted and true labels\n        self.update(predicted_labels, true_labels)\n\n        # If there are no true positives and false negatives, return 0.0 to avoid division by zero\n        if self.true_positives + self.false_negatives == 0:\n            return 0.0\n\n        # Calculate and return the recall score\n        return self.true_positives / (self.true_positives + self.false_negatives)\n\n\n    def f1_score(self, predicted_labels, true_labels):\n        \"\"\"\n        Calculate f1 score, which is the harmonic mean of precision and recall.\n        :param predicted_labels: list, predicted results\n        :param true_labels: list, true labels\n        :return: float, F1 score\n        \"\"\"\n\n        # Update the counters with the new predicted and true labels\n        self.update(predicted_labels, true_labels)\n\n        # Calculate precision and recall scores\n        precision = self.precision(predicted_labels, true_labels)\n        recall = self.recall(predicted_labels, true_labels)\n\n        # If both precision and recall are 0.0, return 0.0 to avoid division by zero\n        if precision + recall == 0.0:\n            return 0.0\n\n        # Calculate and return the F1 score\n        return (2 * precision * recall) / (precision + recall)\n\n\n    def accuracy(self, predicted_labels, true_labels):\n        \"\"\"\n        Calculate accuracy, which is the ratio of correct predictions (true positives and true negatives) to the total number of predictions.\n        :param predicted_labels: list, predicted results\n        :param true_labels: list, true labels\n        :return: float, accuracy score\n        \"\"\"\n\n        # Update the counters with the new predicted and true labels\n        self.update(predicted_labels, true_labels)\n\n        # Calculate the total number of predictions\n        total = self.true_positives + self.true_negatives + self.false_positives + self.false_negatives\n\n        # If the total number of predictions is 0, return 0.0 to avoid division by zero\n        if total == 0:\n            return 0.0\n\n        # Calculate and return the accuracy score\n        return (self.true_positives + self.true_negatives) / total"}, {"id": "57", "llm_annotated_code": "import numpy as np\n\nclass MetricsCalculator2:\n    \"\"\"\n    The class provides to calculate Mean Reciprocal Rank (MRR) and Mean Average Precision (MAP) based on input data, where MRR measures the ranking quality and MAP measures the average precision.\n    \"\"\"\n\n    def __init__(self):\n        pass\n\n    @staticmethod\n    def mrr(data):\n        \"\"\"\n        Compute the Mean Reciprocal Rank (MRR) of the input data. MRR is a widely used evaluation index. It is the mean of reciprocal rank.\n        :param data: The data must be a tuple, list 0,1,eg.([1,0,...],5).  In each tuple (actual result,ground truth num),ground truth num is the total ground num.\n         ([1,0,...],5),\n        or list of tuple eg. [([1,0,1,...],5),([1,0,...],6),([0,0,...],5)].\n        1 stands for a correct answer, 0 stands for a wrong answer.\n        :return: If input data is list, return the recall of this list. If the input data is list of list, return the\n        average recall on all list. The second return value is a list of precision for each input.\n        \"\"\"\n        # Check if the input data is a list or a tuple, if not raise an exception\n        if type(data) != list and type(data) != tuple:\n            raise Exception(\"the input must be a tuple([0,...,1,...],int) or a iteration of list of tuple\")\n\n        # If the input data is empty, return 0.0 and a list containing 0.0\n        if len(data) == 0:\n            return 0.0, [0.0]\n\n        # If the input data is a tuple, calculate the MRR for the tuple\n        if type(data) == tuple:\n            (sub_list, total_num) = data\n            sub_list = np.array(sub_list)\n            if total_num == 0:\n                return 0.0, [0.0]\n            else:\n                # Calculate the ranking array\n                ranking_array = 1.0 / (np.array(list(range(len(sub_list)))) + 1)\n                mr_np = sub_list * ranking_array\n\n                mr = 0.0\n                for team in mr_np:\n                    if team > 0:\n                        mr = team\n                        break\n                return mr, [mr]\n\n        # If the input data is a list, calculate the MRR for each tuple in the list and return the average MRR and a list of MRRs\n        if type(data) == list:\n            separate_result = []\n            for (sub_list, total_num) in data:\n                sub_list = np.array(sub_list)\n\n                if total_num == 0:\n                    mr = 0.0\n                else:\n                    # Calculate the ranking array\n                    ranking_array = 1.0 / (np.array(list(range(len(sub_list)))) + 1)\n                    mr_np = sub_list * ranking_array\n\n                    mr = 0.0\n                    for team in mr_np:\n                        if team > 0:\n                            mr = team\n                            break\n\n                separate_result.append(mr)\n            return np.mean(separate_result), separate_result\n\n\n    @staticmethod\n    def map(data):\n        \"\"\"\n        Compute the Mean Average Precision (MAP) of the input data. MAP is a widely used evaluation index. It is the mean of AP (average precision).\n        :param data: The data must be a tuple, list 0,1,eg.([1,0,...],5).  In each tuple (actual result,ground truth num),ground truth num is the total ground num.\n         ([1,0,...],5),\n        or list of tuple eg. [([1,0,1,...],5),([1,0,...],6),([0,0,...],5)].\n        1 stands for a correct answer, 0 stands for a wrong answer.\n        :return: If input data is list, return the recall of this list. If the input data is list of list, return the\n        average recall on all list. The second return value is a list of precision for each input.\n        \"\"\"\n        # Check if the input data is a list or a tuple, if not raise an exception\n        if type(data) != list and type(data) != tuple:\n            raise Exception(\"the input must be a tuple([0,...,1,...],int) or a iteration of list of tuple\")\n\n        # If the input data is empty, return 0.0 and a list containing 0.0\n        if len(data) == 0:\n            return 0.0, [0.0]\n\n        # If the input data is a tuple, calculate the MAP for the tuple\n        if type(data) == tuple:\n            (sub_list, total_num) = data\n            sub_list = np.array(sub_list)\n            if total_num == 0:\n                return 0.0, [0.0]\n            else:\n                # Calculate the ranking array\n                ranking_array = 1.0 / (np.array(list(range(len(sub_list)))) + 1)\n\n                right_ranking_list = []\n                count = 1\n                for t in sub_list:\n                    if t == 0:\n                        right_ranking_list.append(0)\n                    else:\n                        right_ranking_list.append(count)\n                        count += 1\n\n                ap = np.sum(np.array(right_ranking_list) * ranking_array) / total_num\n                return ap, [ap]\n\n        # If the input data is a list, calculate the MAP for each tuple in the list and return the average MAP and a list of MAPs\n        if type(data) == list:\n            separate_result = []\n            for (sub_list, total_num) in data:\n                sub_list = np.array(sub_list)\n\n                if total_num == 0:\n                    ap = 0.0\n                else:\n                    # Calculate the ranking array\n                    ranking_array = 1.0 / (np.array(list(range(len(sub_list)))) + 1)\n\n                    right_ranking_list = []\n                    count = 1\n                    for t in sub_list:\n                        if t == 0:\n                            right_ranking_list.append(0)\n                        else:\n                            right_ranking_list.append(count)\n                            count += 1\n\n                    ap = np.sum(np.array(right_ranking_list) * ranking_array) / total_num\n\n                separate_result.append(ap)\n            return np.mean(separate_result), separate_result"}, {"id": "58", "llm_annotated_code": "class MinesweeperGame:\n    \"\"\"\n    This class implements a simple version of the game Minesweeper. It includes methods for generating the game board, \n    sweeping a cell, and checking if the game has been won.\n    \"\"\"\n\n    def __init__(self, n, k) -> None:\n        \"\"\"\n        Initializes the MinesweeperGame with the size of the board and the number of mines.\n        :param n: int, the size of the board (n x n)\n        :param k: int, the number of mines\n        \"\"\"\n        self.n = n  # Size of the game board\n        self.k = k  # Number of mines\n        self.minesweeper_map = self.generate_mine_sweeper_map()  # The actual game board with mines and numbers\n        self.player_map = self.generate_playerMap()  # The game board that the player sees\n        self.score = 0  # The player's score\n\n    def generate_mine_sweeper_map(self):\n        \"\"\"\n        Generates a minesweeper map with the given size of the board and the number of mines.\n        'X' represents a mine and numbers represent the number of mines in the surrounding cells.\n        :return: list, the minesweeper map\n        \"\"\"\n        # Initialize an empty game board\n        arr = [[0 for row in range(self.n)] for column in range(self.n)]\n\n        # Randomly place the mines and update the numbers in the surrounding cells\n        for num in range(self.k):\n            x = random.randint(0, self.n-1)\n            y = random.randint(0, self.n-1)\n            arr[y][x] = 'X'\n            # Update the numbers in the surrounding cells\n            for dx in [-1, 0, 1]:\n                for dy in [-1, 0, 1]:\n                    nx, ny = x + dx, y + dy\n                    if (0 <= nx < self.n) and (0 <= ny < self.n) and arr[ny][nx] != 'X':\n                        arr[ny][nx] += 1\n\n        return arr\n\n    def generate_playerMap(self):\n        \"\"\"\n        Generates a player map with the given size of the board.\n        '-' represents an unopened cell.\n        :return: list, the player map\n        \"\"\"\n        # Initialize an empty player map\n        arr = [['-' for row in range(self.n)] for column in range(self.n)]\n        return arr\n\n    def check_won(self,map):\n        \"\"\"\n        Checks whether the player has won the game.\n        The player wins if all non-mine cells have been opened.\n        :return: bool, True if the player has won the game, False otherwise\n        \"\"\"\n        # Check each cell in the player map\n        for i in range(self.n):\n            for j in range(self.n):\n                # If there is an unopened cell that is not a mine, the player has not won yet\n                if map[i][j] == '-' and self.minesweeper_map[i][j] != 'X':\n                    return False\n        # If all non-mine cells have been opened, the player has won\n        return True\n\n    def sweep(self, x, y):\n        \"\"\"\n        Sweeps the given cell and updates the player map and the score.\n        :param x: int, the x coordinate of the cell to sweep\n        :param y: int, the y coordinate of the cell to sweep\n        :return: list or bool, the updated player map if the game continues, or False if a mine is swept, or True if the player has won\n        \"\"\"\n        # If the cell is a mine, the game is over\n        if (self.minesweeper_map[x][y] == 'X'):\n            return False\n        else:\n            # Open the cell and update the score\n            self.player_map[x][y] = self.minesweeper_map[x][y]\n            self.score += 1\n            # Check if the player has won\n            if self.check_won(self.player_map) == True:\n                return True\n            # If the game is not over, return the updated player map\n            return self.player_map"}, {"id": "59", "llm_annotated_code": "class MovieBookingSystem:\n    \"\"\"\n    This class represents a movie booking system, which allows to add movies, book tickets and check the available movies within a given time range.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the MovieBookingSystem with an empty list of movies.\n        Each movie is a dictionary containing the movie's name, price, start time, end time, and a 2D numpy array representing the seats.\n        The seats are represented as a 2D numpy array of zeros, where 0 represents an available seat and 1 represents a booked seat.\n        \"\"\"\n        self.movies = []\n\n    def add_movie(self, name, price, start_time, end_time, n):\n        \"\"\"\n        Add a new movie to the system.\n        :param name: str, the name of the movie\n        :param price: float, the price of a ticket for the movie\n        :param start_time: str, the start time of the movie in the format 'HH:MM'\n        :param end_time: str, the end time of the movie in the format 'HH:MM'\n        :param n: int, the size of the theater (the theater is assumed to be a square with n rows and n columns)\n        The start_time and end_time are converted to datetime objects for easier comparison in the available_movies method.\n        \"\"\"\n        movie = {\n            'name': name,\n            'price': price,\n            'start_time': datetime.strptime(start_time, '%H:%M'),\n            'end_time': datetime.strptime(end_time, '%H:%M'),\n            'seats': np.zeros((n, n))\n        }\n        self.movies.append(movie)\n\n    def book_ticket(self, name, seats_to_book):\n        \"\"\"\n        Book tickets for a movie.\n        :param name: str, the name of the movie\n        :param seats_to_book: list of tuples, each tuple represents a seat to book in the format (row, column)\n        :return: str, a message indicating the status of the booking\n        The method iterates over the list of movies to find the movie with the given name.\n        For each seat to book, it checks if the seat is available (represented by 0 in the seats array).\n        If the seat is available, it books the seat by setting the corresponding element in the seats array to 1.\n        If the seat is not available, it returns a message indicating that the booking failed.\n        If the movie is not found in the list of movies, it returns a message indicating that the movie was not found.\n        \"\"\"\n        for movie in self.movies:\n            if movie['name'] == name:\n                for seat in seats_to_book:\n                    if movie['seats'][seat[0]][seat[1]] == 0:\n                        movie['seats'][seat[0]][seat[1]] = 1\n                    else:\n                        return \"Booking failed.\"\n                return \"Booking success.\"\n        return \"Movie not found.\"\n\n    def available_movies(self, start_time, end_time):\n        \"\"\"\n        Get a list of available movies within a specified time range.\n        :param start_time: str, the start of the time range in the format 'HH:MM'\n        :param end_time: str, the end of the time range in the format 'HH:MM'\n        :return: list of str, the names of the movies that are available within the specified time range\n        The method converts the start_time and end_time to datetime objects for easier comparison.\n        It then iterates over the list of movies and checks if the start time and end time of each movie falls within the specified time range.\n        If a movie falls within the time range, its name is added to the list of available movies.\n        \"\"\"\n        start_time = datetime.strptime(start_time, '%H:%M')\n        end_time = datetime.strptime(end_time, '%H:%M')\n\n        available_movies = []\n        for movie in self.movies:\n            if start_time <= movie['start_time'] and movie['end_time'] <= end_time:\n                available_movies.append(movie['name'])\n\n        return available_movies"}, {"id": "60", "llm_annotated_code": "class MovieTicketDB:\n    \"\"\"\n    This class handles operations on a SQLite database for a movie ticketing system. It allows for creating a table for storing ticket information, inserting new ticket records, searching for tickets by customer name, and deleting tickets by ticket ID.\n    \"\"\"\n\n    def __init__(self, db_name):\n        \"\"\"\n        Initializes the MovieTicketDB object with the specified database name.\n        :param db_name: str, the name of the SQLite database.\n        \"\"\"\n        # Connect to the SQLite database with the provided name and create a cursor for executing SQL commands\n        self.connection = sqlite3.connect(db_name)\n        self.cursor = self.connection.cursor()\n\n        # Call the create_table method to ensure the \"tickets\" table exists in the database\n        self.create_table()\n\n\n    def create_table(self):\n        \"\"\"\n        Creates a \"tickets\" table in the database if it does not exist already. The table has fields for ID (integer), movie name (text), theater name (text), seat number (text), and customer name (text).\n        :return: None\n        \"\"\"\n        # Execute a SQL command to create the \"tickets\" table if it does not already exist\n        self.cursor.execute(\"\"\"\n            CREATE TABLE IF NOT EXISTS tickets (\n                id INTEGER PRIMARY KEY,\n                movie_name TEXT,\n                theater_name TEXT,\n                seat_number TEXT,\n                customer_name TEXT\n            )\n        \"\"\")\n\n        # Commit the changes to the database\n        self.connection.commit()\n\n    def insert_ticket(self, movie_name, theater_name, seat_number, customer_name):\n        \"\"\"\n        Inserts a new ticket record into the \"tickets\" table.\n        :param movie_name: str, the name of the movie.\n        :param theater_name: str, the name of the theater.\n        :param seat_number: str, the seat number.\n        :param customer_name: str, the name of the customer.\n        :return: None\n        \"\"\"\n        # Execute a SQL command to insert a new record into the \"tickets\" table with the provided movie name, theater name, seat number, and customer name\n        self.cursor.execute(\"\"\"\n            INSERT INTO tickets (movie_name, theater_name, seat_number, customer_name)\n            VALUES (?, ?, ?, ?)\n        \"\"\", (movie_name, theater_name, seat_number, customer_name))\n\n        # Commit the changes to the database\n        self.connection.commit()\n\n    def search_tickets_by_customer(self, customer_name):\n        \"\"\"\n        Searches for ticket records in the \"tickets\" table by customer name.\n        :param customer_name: str, the name of the customer to search for.\n        :return: list of tuples, the rows from the \"tickets\" table that match the search criteria.\n        \"\"\"\n        # Execute a SQL command to select all records from the \"tickets\" table where the customer name matches the provided customer name\n        self.cursor.execute(\"\"\"\n            SELECT * FROM tickets WHERE customer_name = ?\n        \"\"\", (customer_name,))\n\n        # Fetch all rows from the query result and return them as a list of tuples\n        tickets = self.cursor.fetchall()\n        return tickets\n\n    def delete_ticket(self, ticket_id):\n        \"\"\"\n        Deletes a ticket record from the \"tickets\" table by ticket ID.\n        :param ticket_id: int, the ID of the ticket to delete.\n        :return: None\n        \"\"\"\n        # Execute a SQL command to delete the record from the \"tickets\" table where the ID matches the provided ticket ID\n        self.cursor.execute(\"\"\"\n            DELETE FROM tickets WHERE id = ?\n        \"\"\", (ticket_id,))\n\n        # Commit the changes to the database\n        self.connection.commit()"}, {"id": "61", "llm_annotated_code": "class MusicPlayer:\n    \"\"\"\n    This is a class as a music player that provides to play, stop, add songs, remove songs, set volume, shuffle, and switch to the next or previous song.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initializes the music player with an empty playlist, no current song, and a default volume of 50.\n        \"\"\"\n        # Initialize an empty playlist\n        self.playlist = []\n        # Initialize no current song\n        self.current_song = None\n        # Initialize a default volume of 50\n        self.volume = 50\n\n    def add_song(self, song):\n        \"\"\"\n        Adds a song to the playlist.\n        :param song: The song to add to the playlist, str.\n        \"\"\"\n        # Append the song to the playlist\n        self.playlist.append(song)\n\n    def remove_song(self, song):\n        \"\"\"\n        Removes a song from the playlist.\n        :param song: The song to remove from the playlist, str.\n        \"\"\"\n        # Check if the song is in the playlist\n        if song in self.playlist:\n            # Remove the song from the playlist\n            self.playlist.remove(song)\n            # If the current song is the song to be removed, stop the song\n            if self.current_song == song:\n                self.stop()\n\n    def play(self):\n        \"\"\"\n        Plays the current song in the playlist.\n        :return: The current song in the playlist, or False if there is no current song.\n        \"\"\"\n        # If there is a playlist and a current song, return the first song in the playlist\n        if self.playlist and self.current_song:\n            return self.playlist[0]\n        # If there is no current song but there is a playlist, return False\n        elif len(self.playlist):\n            return False\n\n    def stop(self):\n        \"\"\"\n        Stops the current song in the playlist.\n        :return: True if the current song was stopped, False if there was no current song.\n        \"\"\"\n        # If there is a current song, stop the song and return True\n        if self.current_song:\n            self.current_song = None\n            return True\n        # If there is no current song, return False\n        else:\n            return False\n\n    def switch_song(self):\n        \"\"\"\n        Switches to the next song in the playlist.\n        :return: True if the next song was switched to, False if there was no next song.\n        \"\"\"\n        # If there is a current song, switch to the next song in the playlist\n        if self.current_song:\n            # Get the index of the current song in the playlist\n            current_index = self.playlist.index(self.current_song)\n            # If the current song is not the last song in the playlist, switch to the next song and return True\n            if current_index < len(self.playlist) - 1:\n                self.current_song = self.playlist[current_index + 1]\n                return True\n            # If the current song is the last song in the playlist, return False\n            else:\n                return False\n        # If there is no current song, return False\n        else:\n            return False\n\n    def previous_song(self):\n        \"\"\"\n        Switches to the previous song in the playlist.\n        :return: True if the previous song was switched to, False if there was no previous song.\n        \"\"\"\n        # If there is a current song, switch to the previous song in the playlist\n        if self.current_song:\n            # Get the index of the current song in the playlist\n            current_index = self.playlist.index(self.current_song)\n            # If the current song is not the first song in the playlist, switch to the previous song and return True\n            if current_index > 0:\n                self.current_song = self.playlist[current_index - 1]\n                return True\n            # If the current song is the first song in the playlist, return False\n            else:\n                return False\n        # If there is no current song, return False\n        else:\n            return False\n\n    def set_volume(self, volume):\n        \"\"\"\n        Sets the volume of the music player,ifthe volume is between 0 and 100 is valid.\n        :param volume: The volume to set the music player to,int.\n        :return: True if the volume was set, False if the volume was invalid.\n        \"\"\"\n        # If the volume is between 0 and 100, set the volume and return True\n        if 0 <= volume <= 100:\n            self.volume = volume\n        # If the volume is not between 0 and 100, return False\n        else:\n            return False\n\n    def shuffle(self):\n        \"\"\"\n        Shuffles the playlist.\n        :return: True if the playlist was shuffled, False if the playlist was empty.\n        \"\"\"\n        # If there is a playlist, shuffle the playlist and return True\n        if self.playlist:\n            import random\n            random.shuffle(self.playlist)\n            return True\n        # If the playlist is empty, return False\n        else:\n            return False"}, {"id": "62", "llm_annotated_code": "class NLPDataProcessor:\n    \"\"\"\n    The class processes NLP data by removing stop words from a list of strings using a pre-defined stop word list.\n    \"\"\"\n\n    def construct_stop_word_list(self):\n        \"\"\"\n        Construct a stop word list including 'a', 'an', 'the'.\n        :return: a list of stop words\n        >>> NLPDataProcessor.construct_stop_word_list()\n        ['a', 'an', 'the']\n        \"\"\"\n\n        # Define a list of stop words\n        stop_word_list = ['a', 'an', 'the']\n\n        # Return the list of stop words\n        return stop_word_list\n\n    def remove_stop_words(self, string_list, stop_word_list):\n        \"\"\"\n        Remove all the stop words from the list of strings.\n        :param string_list: a list of strings\n        :param stop_word_list: a list of stop words\n        :return: a list of words without stop words\n        >>> NLPDataProcessor.process(['This is a test.'])\n        [['This', 'is', 'test.']]\n        \"\"\"\n\n        # Initialize an empty list to store the processed strings\n        answer = []\n\n        # Iterate over each string in the input list\n        for string in string_list:\n\n            # Split the string into words\n            string_split = string.split()\n\n            # Iterate over each word in the split string\n            for word in string_split:\n\n                # If the word is in the stop word list, remove it from the split string\n                if word in stop_word_list:\n                    string_split.remove(word)\n\n            # Append the processed string to the answer list\n            answer.append(string_split)\n\n        # Return the list of processed strings\n        return answer\n\n    def process(self, string_list):\n        \"\"\"\n        Construct a stop word list including 'a', 'an', 'the', and remove all the stop words from the list of strings.\n        :param string_list: a list of strings\n        :return: a list of words without stop words\n        >>> NLPDataProcessor.process(['This is a test.'])\n        [['This', 'is', 'test.']]\n        \"\"\"\n\n        # Call the construct_stop_word_list method to get the list of stop words\n        stop_word_list = self.construct_stop_word_list()\n\n        # Call the remove_stop_words method to remove the stop words from the input list of strings\n        words_list = self.remove_stop_words(string_list, stop_word_list)\n\n        # Return the processed list of strings\n        return words_list"}, {"id": "63", "llm_annotated_code": "class NLPDataProcessor2:\n    \"\"\"\n    The class processes NLP data by extracting words from a list of strings, calculating the frequency of each word, and returning the top 5 most frequent words.\n    \"\"\"\n\n    def process_data(self, string_list):\n        \"\"\"\n        This method processes a list of strings by keeping only English letters and spaces in each string, converting each string to lower case, and splitting each string into a list of words.\n        :param string_list: list of str, a list of strings to be processed\n        :return: words_list: list of list of str, a list of lists of words extracted from each string in the input list\n        >>> NLPDataProcessor.process_data(['This is a test.'])\n        [['this', 'is', 'a', 'test']]\n        \"\"\"\n        words_list = []\n        for string in string_list:\n            # Use the re.sub function to remove non-English letters from the string and convert it to lowercase\n            processed_string = re.sub(r'[^a-zA-Z\\s]', '', string.lower())\n            # Use the str.split method to split the processed string into words\n            words = processed_string.split()\n            words_list.append(words)\n        return words_list\n\n    def calculate_word_frequency(self, words_list):\n        \"\"\"\n        This method calculates the frequency of each word in a list of lists of words, sorts the word frequency dictionary by value in descending order, and returns the top 5 most frequent words.\n        :param words_list: list of list of str, a list of lists of words for which to calculate frequencies\n        :return: top_5_word_frequency: dict, a dictionary of the top 5 most frequent words and their frequencies\n        >>> NLPDataProcessor.calculate_word_frequency([['this', 'is', 'a', 'test'], ['this', 'is', 'another', 'test']])\n        {'this': 2, 'is': 2, 'test': 2, 'a': 1, 'another': 1}\n        \"\"\"\n        # Use the collections.Counter class to create a counter object for counting word frequencies\n        word_frequency = Counter()\n        for words in words_list:\n            # Use the collections.Counter.update method to count the frequencies of words in each list of words\n            word_frequency.update(words)\n        # Use the built-in sorted function to sort the word frequency dictionary by value in descending order\n        sorted_word_frequency = dict(sorted(word_frequency.items(), key=lambda x: x[1], reverse=True))\n        # Extract the top 5 most frequent words and their frequencies\n        top_5_word_frequency = dict(list(sorted_word_frequency.items())[:5])\n        return top_5_word_frequency\n\n    def process(self, string_list):\n        \"\"\"\n        This method processes a list of strings by extracting words, calculating word frequencies, and returning the top 5 most frequent words.\n        :param string_list: list of str, a list of strings to be processed\n        :return: word_frequency_dict: dict, a dictionary of the top 5 most frequent words and their frequencies\n        >>> NLPDataProcessor.process(['This is a test.', 'This is another test.'])\n        {'this': 2, 'is': 2, 'test': 2, 'a': 1, 'another': 1}\n        \"\"\"\n        # Call the process_data method to extract words from the list of strings\n        words_list = self.process_data(string_list)\n        # Call the calculate_word_frequency method to calculate word frequencies and return the top 5 most frequent words\n        word_frequency_dict = self.calculate_word_frequency(words_list)\n        return word_frequency_dict"}, {"id": "64", "llm_annotated_code": "class NumberConverter:\n    \"\"\"\n    This class provides methods to convert numbers between decimal, binary, octal, and hexadecimal formats.\n    \"\"\"\n\n    @staticmethod\n    def decimal_to_binary(decimal_num):\n        \"\"\"\n        Convert a number from decimal format to binary format.\n        :param decimal_num: int, decimal number\n        :return: str, the binary representation of the decimal number.\n        >>> NumberConverter.decimal_to_binary(42423)\n        '1010010110110111'\n        \"\"\"\n\n        # Use the built-in bin function to convert the decimal number to binary.\n        # The bin function returns a string that starts with '0b', so use slicing to remove the first two characters.\n        binary_num = bin(decimal_num)[2:]\n        return binary_num\n\n    @staticmethod\n    def binary_to_decimal(binary_num):\n        \"\"\"\n        Convert a number from binary format to decimal format.\n        :param binary_num: str, binary number\n        :return: int, the decimal representation of the binary number.\n        >>> NumberConverter.binary_to_decimal('1010010110110111')\n        42423\n        \"\"\"\n\n        # Use the built-in int function with base 2 to convert the binary number to decimal.\n        decimal_num = int(binary_num, 2)\n        return decimal_num\n\n    @staticmethod\n    def decimal_to_octal(decimal_num):\n        \"\"\"\n        Convert a number from decimal format to octal format.\n        :param decimal_num: int, decimal number\n        :return: str, the octal representation of the decimal number.\n        >>> NumberConverter.decimal_to_octal(42423)\n        '122667'\n        \"\"\"\n\n        # Use the built-in oct function to convert the decimal number to octal.\n        # The oct function returns a string that starts with '0o', so use slicing to remove the first two characters.\n        octal_num = oct(decimal_num)[2:]\n        return octal_num\n\n    @staticmethod\n    def octal_to_decimal(octal_num):\n        \"\"\"\n        Convert a number from octal format to decimal format.\n        :param octal_num: str, octal number\n        :return: int, the decimal representation of the octal number.\n        >>> NumberConverter.octal_to_decimal('122667')\n        42423\n        \"\"\"\n\n        # Use the built-in int function with base 8 to convert the octal number to decimal.\n        decimal_num = int(octal_num, 8)\n        return decimal_num\n\n    @staticmethod\n    def decimal_to_hex(decimal_num):\n        \"\"\"\n        Convert a number from decimal format to hexadecimal format.\n        :param decimal_num: int, decimal number\n        :return: str, the hexadecimal representation of the decimal number.\n        >>> NumberConverter.decimal_to_hex(42423)\n        'a5b7'\n        \"\"\"\n\n        # Use the built-in hex function to convert the decimal number to hexadecimal.\n        # The hex function returns a string that starts with '0x', so use slicing to remove the first two characters.\n        hex_num = hex(decimal_num)[2:]\n        return hex_num\n\n    @staticmethod\n    def hex_to_decimal(hex_num):\n        \"\"\"\n        Convert a number from hexadecimal format to decimal format.\n        :param hex_num: str, hexadecimal number\n        :return: int, the decimal representation of the hexadecimal number.\n        >>> NumberConverter.hex_to_decimal('a5b7')\n        42423\n        \"\"\"\n\n        # Use the built-in int function with base 16 to convert the hexadecimal number to decimal.\n        decimal_num = int(hex_num, 16)\n        return decimal_num"}, {"id": "65", "llm_annotated_code": "class NumberWordFormatter:\n    \"\"\"\n    This is a class that provides to convert numbers into their corresponding English word representation, including handling the conversion of both the integer and decimal parts, and incorporating appropriate connectors and units.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize NumberWordFormatter object.\n        Define the word representation for numbers from 1 to 9, 10 to 19, multiples of 10, and the suffixes for thousands, millions, and billions.\n        \"\"\"\n\n        # Define the word representation for numbers from 1 to 9\n        self.NUMBER = [\"\", \"ONE\", \"TWO\", \"THREE\", \"FOUR\", \"FIVE\", \"SIX\", \"SEVEN\", \"EIGHT\", \"NINE\"]\n\n        # Define the word representation for numbers from 10 to 19\n        self.NUMBER_TEEN = [\"TEN\", \"ELEVEN\", \"TWELVE\", \"THIRTEEN\", \"FOURTEEN\", \"FIFTEEN\", \"SIXTEEN\", \"SEVENTEEN\",\n                            \"EIGHTEEN\", \"NINETEEN\"]\n\n        # Define the word representation for multiples of 10\n        self.NUMBER_TEN = [\"TEN\", \"TWENTY\", \"THIRTY\", \"FORTY\", \"FIFTY\", \"SIXTY\", \"SEVENTY\", \"EIGHTY\", \"NINETY\"]\n\n        # Define the suffixes for thousands, millions, and billions\n        self.NUMBER_MORE = [\"\", \"THOUSAND\", \"MILLION\", \"BILLION\"]\n\n        # Define the suffixes for thousands, millions, and billions in short form\n        self.NUMBER_SUFFIX = [\"k\", \"w\", \"\", \"m\", \"\", \"\", \"b\", \"\", \"\", \"t\", \"\", \"\", \"p\", \"\", \"\", \"e\"]\n\n    def format(self, x):\n        \"\"\"\n        Converts a number into words format\n        :param x: int or float, the number to be converted into words format\n        :return: str, the number in words format\n        If x is None, return an empty string.\n        Otherwise, convert x to a string and pass it to the format_string method.\n        \"\"\"\n        if x is not None:\n            return self.format_string(str(x))\n        else:\n            return \"\"\n\n\n    def format_string(self, x):\n        \"\"\"\n        Converts a string representation of a number into words format\n        :param x: str, the string representation of a number\n        :return: str, the number in words format\n        Split x into the integer part (lstr) and the decimal part (rstr).\n        Reverse lstr and store it in lstrrev.\n        If the length of lstrrev is not a multiple of 3, pad it with zeros until it is.\n        Initialize lm as an empty string.\n        For every 3 digits in lstrrev, convert them to words using the trans_three method and append the appropriate suffix using the parse_more method.\n        If rstr is not empty, convert it to words using the trans_two method and append it to the end of lm.\n        If lm is empty after stripping leading and trailing whitespace, return \"ZERO ONLY\".\n        Otherwise, return lm followed by \"ONLY\".\n        \"\"\"\n        lstr, rstr = (x.split('.') + [''])[:2]\n        lstrrev = lstr[::-1]\n        a = [''] * 5\n\n        if len(lstrrev) % 3 == 1:\n            lstrrev += \"00\"\n        elif len(lstrrev) % 3 == 2:\n            lstrrev += \"0\"\n\n        lm = \"\"\n        for i in range(len(lstrrev) // 3):\n            a[i] = lstrrev[3 * i:3 * i + 3][::-1]\n            if a[i] != \"000\":\n                lm = self.trans_three(a[i]) + \" \" + self.parse_more(i) + \" \" + lm\n            else:\n                lm += self.trans_three(a[i])\n\n        xs = f\"AND CENTS {self.trans_two(rstr)} \" if rstr else \"\"\n        if not lm.strip():\n            return \"ZERO ONLY\"\n        else:\n            return f\"{lm.strip()} {xs}ONLY\"\n\n\n    def trans_two(self, s):\n        \"\"\"\n        Converts a two-digit number into words format\n        :param s: str, the two-digit number\n        :return: str, the number in words format\n        If the first digit is 0, return the word representation of the second digit.\n        If the first digit is 1, return the word representation of the number in the teens.\n        If the second digit is 0, return the word representation of the number in the tens.\n        Otherwise, return the word representation of the number in the tens followed by the word representation of the second digit.\n        \"\"\"\n        s = s.zfill(2)\n        if s[0] == \"0\":\n            return self.NUMBER[int(s[-1])]\n        elif s[0] == \"1\":\n            return self.NUMBER_TEEN[int(s) - 10]\n        elif s[1] == \"0\":\n            return self.NUMBER_TEN[int(s[0]) - 1]\n        else:\n            return self.NUMBER_TEN[int(s[0]) - 1] + \" \" + self.NUMBER[int(s[-1])]\n\n\n    def trans_three(self, s):\n        \"\"\"\n        Converts a three-digit number into words format\n        :param s: str, the three-digit number\n        :return: str, the number in words format\n        If the first digit is 0, return the word representation of the last two digits.\n        If the last two digits are 00, return the word representation of the first digit followed by \"HUNDRED\".\n        Otherwise, return the word representation of the first digit followed by \"HUNDRED AND\" and the word representation of the last two digits.\n        \"\"\"\n        if s[0] == \"0\":\n            return self.trans_two(s[1:])\n        elif s[1:] == \"00\":\n            return f\"{self.NUMBER[int(s[0])]} HUNDRED\"\n        else:\n            return f\"{self.NUMBER[int(s[0])]} HUNDRED AND {self.trans_two(s[1:])}\"\n\n    def parse_more(self, i):\n        \"\"\"\n        Parses the thousand/million/billion suffix based on the index\n        :param i: int, the index representing the magnitude (thousand, million, billion)\n        :return: str, the corresponding suffix for the magnitude\n        Return the suffix for the magnitude represented by i in the NUMBER_MORE list.\n        \"\"\"\n        return self.NUMBER_MORE[i]"}, {"id": "66", "llm_annotated_code": "class NumericEntityUnescaper:\n    \"\"\"\n    This is a class that provides functionality to replace numeric entities with their corresponding characters in a given string.\n    \"\"\"\n\n    def __init__(self):\n        pass\n\n    def replace(self, string):\n        \"\"\"\n        Replaces numeric character references (HTML entities) in the input string with their corresponding Unicode characters.\n        :param string: str, the input string containing numeric character references.\n        :return: str, the input string with numeric character references replaced with their corresponding Unicode characters.\n        >>> unescaper = NumericEntityUnescaper()\n        >>> unescaper.replace(\"&#65;&#66;&#67;\")\n        'ABC'\n\n        \"\"\"\n        # Initialize an empty list to store the output characters\n        out = []\n        # Initialize the position to start from\n        pos = 0\n        # Get the length of the input string\n        length = len(string)\n\n        # Loop through the string until the second last character\n        while pos < length - 2:\n            # If the current character and the next one form the start of a numeric entity\n            if string[pos] == '&' and string[pos + 1] == '#':\n                # The start of the numeric entity (excluding the '&#')\n                start = pos + 2\n                # Flag to indicate if the numeric entity is in hexadecimal form\n                is_hex = False\n                # The first character of the numeric entity\n                first_char = string[start]\n\n                # If the numeric entity is in hexadecimal form\n                if first_char == 'x' or first_char == 'X':\n                    # Skip the 'x' or 'X'\n                    start += 1\n                    # Set the flag to True\n                    is_hex = True\n\n                # If we have reached the end of the string, return the output string\n                if start == length:\n                    return ''.join(out)\n\n                # Find the end of the numeric entity\n                end = start\n                while end < length and self.is_hex_char(string[end]):\n                    end += 1\n\n                # If the numeric entity is properly terminated with a semicolon\n                if end < length and string[end] == ';':\n                    try:\n                        # Convert the numeric entity to an integer\n                        entity_value = int(string[start:end], 16 if is_hex else 10)\n                    except:\n                        # If the conversion fails, return the output string\n                        return ''.join(out)\n\n                    # Append the corresponding Unicode character to the output list\n                    out.append(chr(entity_value))\n                    # Move the position to the character after the semicolon\n                    pos = end + 1\n                    # Continue with the next iteration of the loop\n                    continue\n\n            # If the current character does not form the start of a numeric entity, append it to the output list\n            out.append(string[pos])\n            # Move to the next character\n            pos += 1\n\n        # Return the output string\n        return ''.join(out)\n\n\n    @staticmethod\n    def is_hex_char(char):\n        \"\"\"\n        Determines whether a given character is a hexadecimal digit.\n        :param char: str, the character to check.\n        :return: bool, True if the character is a hexadecimal digit, False otherwise.\n        >>> NumericEntityUnescaper.is_hex_char('a')\n        True\n\n        \"\"\"\n        # Return True if the character is a digit or a lowercase or uppercase letter from 'a' to 'f'\n        # Otherwise, return False\n        return char.isdigit() or ('a' <= char.lower() <= 'f')"}, {"id": "67", "llm_annotated_code": "class Order:\n    \"\"\"\n    The class manages restaurant orders by allowing the addition of dishes, calculation of the total cost, and checkout.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the order management system\n        self.menu stores the dishes of restaurant inventory\n        menu = [{\"dish\": dish name, \"price\": price, \"count\": count}, ...]\n        self.selected_dishes stores the dishes selected by customer\n        selected_dish = {\"dish\": dish name, \"count\": count, price: price}\n        self.sales stores the sales of each dish\n        sales = {dish name: sales}\n        \"\"\"\n        self.menu = []  # List to store the menu items\n        self.selected_dishes = []  # List to store the selected dishes\n        self.sales = {}  # Dictionary to store the sales of each dish\n\n    def add_dish(self, dish):\n        \"\"\"\n        Check the self.menu and add into self.selected_dish if the dish count is valid.\n        And if the dish has successfully been added, change the count in self.menu.\n        :param dish: dict, the information of dish. dish = {\"dish\": dish name, \"count\": count, price: price}\n        :return: True if successfully added, or False otherwise.\n        \"\"\"\n        # Iterate over the menu items\n        for menu_dish in self.menu:\n            # If the dish is in the menu\n            if dish[\"dish\"] == menu_dish[\"dish\"]:\n                # If the count of the dish in the menu is less than the count of the dish to be added, return False\n                if menu_dish[\"count\"] < dish[\"count\"]:\n                    return False\n                else:\n                    # Otherwise, subtract the count of the dish to be added from the count of the dish in the menu\n                    menu_dish[\"count\"] -= dish[\"count\"]\n                    break\n        # Add the dish to the selected dishes\n        self.selected_dishes.append(dish)\n        return True\n\n    def calculate_total(self):\n        \"\"\"\n        Calculate the total price of dishes that have been ordered. Multiply the count, price and sales.\n        :return total: float, the final total price.\n        \"\"\"\n        total = 0  # Initialize the total price\n        # Iterate over the selected dishes\n        for dish in self.selected_dishes:\n            # Add the product of the price, count, and sales of the dish to the total price\n            total += dish[\"price\"] * dish[\"count\"] * self.sales[dish[\"dish\"]]\n        return total  # Return the total price\n\n    def checkout(self):\n        \"\"\"\n        Check out the dishes ordered. If the self.selected_dishes is not empty, invoke the calculate_total\n        method to check out.\n        :return False if the self.selected_dishes is empty, or total(return value of calculate_total) otherwise.\n        \"\"\"\n        # If there are no selected dishes, return False\n        if len(self.selected_dishes) == 0:\n            return False\n        # Otherwise, calculate the total price\n        total = self.calculate_total()\n        # Empty the list of selected dishes\n        self.selected_dishes = []\n        # Return the total price\n        return total"}, {"id": "68", "llm_annotated_code": "class PageUtil:\n    \"\"\"\n    PageUtil class is a versatile utility for handling pagination and search functionalities in an efficient and convenient manner.\n    \"\"\"\n\n    def __init__(self, data, page_size):\n        \"\"\"\n        Initialize the PageUtil object with the given data and page size.\n        :param data: list, the data to be paginated\n        :param page_size: int, the number of items per page\n        >>> data = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n        >>> page_size = 2\n        >>> page_util = PageUtil(data, page_size)\n        \"\"\"\n\n        # Store the input data and page size as instance variables\n        self.data = data\n        self.page_size = page_size\n\n        # Calculate the total number of items and pages, and store them as instance variables\n        self.total_items = len(data)\n        self.total_pages = (self.total_items + page_size - 1) // page_size\n\n    def get_page(self, page_number):\n        \"\"\"\n        Retrieve a specific page of data.\n        :param page_number: int, the page number to fetch\n        :return: list, the data on the specified page\n        >>> page_util = PageUtil([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 2)\n        >>> page_util.get_page(1)\n        [1, 2]\n        \"\"\"\n\n        # If the page number is out of range, return an empty list\n        if page_number < 1 or page_number > self.total_pages:\n            return []\n\n        # Calculate the start and end indices for the data on the specified page\n        start_index = (page_number - 1) * self.page_size\n        end_index = start_index + self.page_size\n\n        # Return the data on the specified page\n        return self.data[start_index:end_index]\n\n\n    def get_page_info(self, page_number):\n        \"\"\"\n        Retrieve information about a specific page.\n        :param page_number: int, the page number to fetch information about\n        :return: dict, containing page information such as current page number, total pages, etc.\n        >>> page_util = PageUtil([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 2)\n        >>> page_util.get_page_info(1)\n        {\n            \"current_page\": 1,\n            \"per_page\": 2,\n            \"total_pages\": 5,\n            \"total_items\": 10,\n            \"has_previous\": False,\n            \"has_next\": True,\n            \"data\": [1, 2]\n        }\n        \"\"\"\n\n        # If the page number is out of range, return an empty dictionary\n        if page_number < 1 or page_number > self.total_pages:\n            return {}\n\n        # Calculate the start and end indices for the data on the specified page\n        start_index = (page_number - 1) * self.page_size\n        end_index = min(start_index + self.page_size, self.total_items)\n\n        # Retrieve the data on the specified page\n        page_data = self.data[start_index:end_index]\n\n        # Construct a dictionary containing information about the specified page\n        page_info = {\n            \"current_page\": page_number,\n            \"per_page\": self.page_size,\n            \"total_pages\": self.total_pages,\n            \"total_items\": self.total_items,\n            \"has_previous\": page_number > 1,\n            \"has_next\": page_number < self.total_pages,\n            \"data\": page_data\n        }\n\n        # Return the page information\n        return page_info\n\n\n    def search(self, keyword):\n        \"\"\"\n        Search for items in the data that contain the given keyword.\n        :param keyword: str, the keyword to search for\n        :return: dict, containing search information such as total results and matching items\n        >>> page_util = PageUtil([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 2)\n        >>> page_util.search(\"1\")\n        {\n            \"keyword\": \"1\",\n            \"total_results\": 2,\n            \"total_pages\": 1,\n            \"results\": [1, 10]\n        }\n        \"\"\"\n\n        # Use a list comprehension to find all items in the data that contain the keyword\n        results = [item for item in self.data if keyword in str(item)]\n\n        # Calculate the total number of results and pages\n        num_results = len(results)\n        num_pages = (num_results + self.page_size - 1) // self.page_size\n\n        # Construct a dictionary containing information about the search\n        search_info = {\n            \"keyword\": keyword,\n            \"total_results\": num_results,\n            \"total_pages\": num_pages,\n            \"results\": results\n        }\n\n        # Return the search information\n        return search_info"}, {"id": "69", "llm_annotated_code": "class PDFHandler:\n    \"\"\"\n    This class allows merging multiple PDF files into one and extracting text from PDFs using the PyPDF2 library.\n    \"\"\"\n\n    def __init__(self, filepaths):\n        \"\"\"\n        Initialize the PDFHandler with a list of file paths.\n        :param filepaths: list of str, paths to the PDF files\n        >>> handler = PDFHandler(['a.pdf', 'b.pdf'])\n\n        \"\"\"\n\n        # Store the file paths\n        self.filepaths = filepaths\n\n        # Create a list of PdfFileReader objects, one for each file path\n        self.readers = [PyPDF2.PdfFileReader(fp) for fp in filepaths]\n\n    def merge_pdfs(self, output_filepath):\n        \"\"\"\n        Merge the PDF files specified in self.filepaths into a single PDF file.\n        :param output_filepath: str, path to the output file\n        :return: str, success message\n        >>> handler = PDFHandler(['a.pdf', 'b.pdf'])\n        >>> handler.merge_pdfs('out.pdf')\n        'Merged PDFs saved at out.pdf'\n\n        \"\"\"\n\n        # Create a PdfWriter object\n        pdf_writer = PyPDF2.PdfWriter()\n\n        # Iterate over each PdfFileReader object in self.readers\n        for reader in self.readers:\n            # Iterate over each page in the current PdfFileReader object\n            for page_num in range(len(reader.pages)):\n                # Get the current page\n                page = reader.pages[page_num]\n                # Add the current page to the PdfWriter object\n                pdf_writer.add_page(page)\n\n        # Write the merged PDF to the output file\n        with open(output_filepath, 'wb') as out:\n            pdf_writer.write(out)\n\n        # Return a success message\n        return f\"Merged PDFs saved at {output_filepath}\"\n\n    def extract_text_from_pdfs(self):\n        \"\"\"\n        Extract text from the PDF files specified in self.filepaths.\n        :return: list of str, the extracted text from each PDF file\n        >>> handler = PDFHandler(['a.pdf', 'b.pdf'])\n        >>> handler.extract_text_from_pdfs()\n        ['Test a.pdf', 'Test b.pdf']\n\n        \"\"\"\n\n        # Initialize an empty list to store the extracted text\n        pdf_texts = []\n\n        # Iterate over each PdfFileReader object in self.readers\n        for reader in self.readers:\n            # Iterate over each page in the current PdfFileReader object\n            for page_num in range(len(reader.pages)):\n                # Get the current page\n                page = reader.pages[page_num]\n                # Extract the text from the current page and append it to pdf_texts\n                pdf_texts.append(page.extract_text())\n\n        # Return the list of extracted text\n        return pdf_texts"}, {"id": "70", "llm_annotated_code": "class PersonRequest:\n    \"\"\"\n    This class validates input personal information data and sets invalid fields to None based to specific rules.\n    \"\"\"\n\n    def __init__(self, name: str, sex: str, phoneNumber: str):\n        \"\"\"\n        Initialize PersonRequest object with the provided information.\n        :param name: str, the name of the person\n        :param sex: str, the sex of the person\n        :param phoneNumber: str, the phone number of the person\n        \"\"\"\n\n        # Validate the input name, sex, and phone number using the corresponding private methods\n        # Store the validated values in the instance variables\n        self.name = self._validate_name(name)\n        self.sex = self._validate_sex(sex)\n        self.phoneNumber = self._validate_phoneNumber(phoneNumber)\n\n\n    def _validate_name(self, name: str) -> str:\n        \"\"\"\n        Validate the name and return it. If name is empty or exceeds 33 characters in length, set to None.\n        :param name: str, the name to validate\n        :return: str, the validated name or None if invalid\n        \"\"\"\n\n        # If the name is empty or its length exceeds 33 characters, return None\n        # Otherwise, return the name as it is\n        if not name or len(name) > 33:\n            return None\n        return name\n\n\n    def _validate_sex(self, sex: str) -> str:\n        \"\"\"\n        Validate the sex and return it. If sex is not Man, Woman, or UGM, set to None.\n        :param sex: str, the sex to validate\n        :return: str, the validated sex or None if invalid\n        \"\"\"\n\n        # If the sex is not one of the valid options (\"Man\", \"Woman\", \"UGM\"), return None\n        # Otherwise, return the sex as it is\n        if sex not in [\"Man\", \"Woman\", \"UGM\"]:\n            return None\n        return sex\n\n    def _validate_phoneNumber(self, phoneNumber: str) -> str:\n        \"\"\"\n        Validate the phone number and return it. If phoneNumber is empty or not an 11 digit number, set to None.\n        :param phoneNumber: str, the phone number to validate\n        :return: str, the validated phone number or None if invalid\n        \"\"\"\n\n        # If the phone number is empty, or its length is not 11, or it contains non-digit characters, return None\n        # Otherwise, return the phone number as it is\n        if not phoneNumber or len(phoneNumber) != 11 or not phoneNumber.isdigit():\n            return None\n        return phoneNumber"}, {"id": "71", "llm_annotated_code": "class PushBoxGame:\n    \"\"\"\n    This class implements a functionality of a sokoban game, where the player needs to move boxes to designated targets in order to win.\n    \"\"\"\n\n    def __init__(self, map):\n        \"\"\"\n        Initialize the push box game with the map and various attributes.\n        :param map: list[str], the map of the push box game, represented as a list of strings.\n            Each character on the map represents a different element, including the following:\n            - '#' represents a wall that neither the player nor the box can pass through;\n            - 'O' represents the initial position of the player;\n            - 'G' represents the target position;\n            - 'X' represents the initial position of the box.\n        \"\"\"\n\n        # Store the map of the game\n        self.map = map\n\n        # Initialize the player's position\n        self.player_row = 0\n        self.player_col = 0\n\n        # Initialize the list of target positions and boxes\n        self.targets = []\n        self.boxes = []\n\n        # Initialize the count of targets\n        self.target_count = 0\n\n        # Initialize the game over status\n        self.is_game_over = False\n\n        # Call the init_game method to set up the game\n        self.init_game()\n\n    def init_game(self):\n        \"\"\"\n        Initialize the game by setting the positions of the player, targets, and boxes based on the map.\n        \"\"\"\n\n        # Iterate over the rows and columns of the map\n        for row in range(len(self.map)):\n            for col in range(len(self.map[row])):\n\n                # If the character at the current position is 'O', set the player's position\n                if self.map[row][col] == \"O\":\n                    self.player_row = row\n                    self.player_col = col\n\n                # If the character at the current position is 'G', add the position to the targets list and increment the target count\n                elif self.map[row][col] == \"G\":\n                    self.targets.append((row, col))\n                    self.target_count += 1\n\n                # If the character at the current position is 'X', add the position to the boxes list\n                elif self.map[row][col] == \"X\":\n                    self.boxes.append((row, col))\n\n    def check_win(self):\n        \"\"\"\n        Check if the game is won. The game is won when all the boxes are placed on target positions.\n        And update the value of self.is_game_over.\n        :return self.is_game_over: True if all the boxes are placed on target positions, or False otherwise.\n        \"\"\"\n\n        # Initialize the count of boxes on target positions\n        box_on_target_count = 0\n\n        # Iterate over the boxes\n        for box in self.boxes:\n\n            # If the box is on a target position, increment the count\n            if box in self.targets:\n                box_on_target_count += 1\n\n        # If all boxes are on target positions, set the game over status to True\n        if box_on_target_count == self.target_count:\n            self.is_game_over = True\n\n        # Return the game over status\n        return self.is_game_over\n\n\n    def move(self, direction):\n        \"\"\"\n        Move the player based on the specified direction and check if the game is won.\n        :param direction: str, the direction of the player's movement.\n            It can be 'w', 's', 'a', or 'd' representing up, down, left, or right respectively.\n\n        :return: True if the game is won, False otherwise.\n        \"\"\"\n\n        # Initialize the new player's position to the current position\n        new_player_row = self.player_row\n        new_player_col = self.player_col\n\n        # Update the new player's position based on the direction\n        if direction == \"w\":\n            new_player_row -= 1\n        elif direction == \"s\":\n            new_player_row += 1\n        elif direction == \"a\":\n            new_player_col -= 1\n        elif direction == \"d\":\n            new_player_col += 1\n\n        # If the new position is not a wall\n        if self.map[new_player_row][new_player_col] != \"#\":\n\n            # If the new position is a box\n            if (new_player_row, new_player_col) in self.boxes:\n\n                # Calculate the new box's position\n                new_box_row = new_player_row + (new_player_row - self.player_row)\n                new_box_col = new_player_col + (new_player_col - self.player_col)\n\n                # If the new box's position is not a wall\n                if self.map[new_box_row][new_box_col] != \"#\":\n\n                    # Move the box and the player\n                    self.boxes.remove((new_player_row, new_player_col))\n                    self.boxes.append((new_box_row, new_box_col))\n                    self.player_row = new_player_row\n                    self.player_col = new_player_col\n\n            # If the new position is not a box, move the player\n            else:\n                self.player_row = new_player_row\n                self.player_col = new_player_col\n\n        # Return the result of the check_win method\n        return self.check_win()"}, {"id": "72", "llm_annotated_code": "class RegexUtils:\n    \"\"\"\n    This class provides methods to match, find all occurrences, split, and substitute text using regular expressions. \n    It also includes predefined patterns for validating phone numbers and extracting email addresses.\n    \"\"\"\n\n    def match(self, pattern, text):\n        \"\"\"\n        Check if the text matches the regular expression pattern.\n        :param pattern: str, Regular expression pattern\n        :param text: str, Text to match\n        :return: bool, True if the text matches the regular expression, False otherwise\n        \"\"\"\n        # Use the re.match function to match the pattern at the start of the text\n        # Return True if a match is found, False otherwise\n        ans = re.match(pattern, text)\n        if ans:\n            return True\n        else:\n            return False\n\n    def findall(self, pattern, text):\n        \"\"\"\n        Find all matching substrings in the text that match the regular expression pattern.\n        :param pattern: str, Regular expression pattern\n        :param text: str, Text to match\n        :return: list of str, List of all matching substrings\n        \"\"\"\n        # Use the re.findall function to find all occurrences of the pattern in the text\n        # Return a list of all matching substrings\n        return re.findall(pattern, text)\n\n    def split(self, pattern, text):\n        \"\"\"\n        Split the text based on the regular expression pattern.\n        :param pattern: str, Regular expression pattern\n        :param text: str, Text to be split\n        :return: list of str, List of substrings after splitting the text\n        \"\"\"\n        # Use the re.split function to split the text at every match of the pattern\n        # Return a list of substrings\n        return re.split(pattern, text)\n\n    def sub(self, pattern, replacement, text):\n        \"\"\"\n        Replace the substrings in the text that match the regular expression pattern with the replacement string.\n        :param pattern: str, Regular expression pattern\n        :param replacement: str, Text to replace with\n        :param text: str, Text to be replaced\n        :return: str, Text after replacement\n        \"\"\"\n        # Use the re.sub function to replace all occurrences of the pattern in the text with the replacement string\n        # Return the text after replacement\n        return re.sub(pattern, replacement, text)\n\n    def generate_email_pattern(self):\n        \"\"\"\n        Generate a regular expression pattern that matches email addresses.\n        :return: str, Regular expression pattern that matches email addresses\n        \"\"\"\n        # Define a regular expression pattern for email addresses\n        pattern = r'[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Z|a-z]{2,}'\n        return pattern\n\n    def generate_phone_number_pattern(self):\n        \"\"\"\n        Generate a regular expression pattern that matches phone numbers.\n        :return: str, Regular expression pattern that matches phone numbers\n        \"\"\"\n        # Define a regular expression pattern for phone numbers\n        pattern = r'\\d{3}-\\d{3}-\\d{4}'\n        return pattern\n\n    def generate_split_sentences_pattern(self):\n        \"\"\"\n        Generate a regular expression pattern that matches the middle characters of two sentences.\n        :return: str, Regular expression pattern that matches the middle characters of two sentences\n        \"\"\"\n        # Define a regular expression pattern for the middle characters of two sentences\n        pattern = r'[.!?][\\s]{1,2}(?=[A-Z])'\n        return pattern\n\n    def split_sentences(self, text):\n        \"\"\"\n        Split the text into a list of sentences.\n        :param text: str, Text to be split\n        :return: list of str, List of sentences\n        \"\"\"\n        # Use the generate_split_sentences_pattern method to get the regular expression pattern for splitting sentences\n        pattern = self.generate_split_sentences_pattern()\n        # Use the split method to split the text into sentences\n        return self.split(pattern, text)\n\n    def validate_phone_number(self, phone_number):\n        \"\"\"\n        Validate if the phone number matches the regular expression pattern.\n        :param phone_number: str, Phone number to be validated\n        :return: bool, True if the phone number is valid, False otherwise\n        \"\"\"\n        # Use the generate_phone_number_pattern method to get the regular expression pattern for phone numbers\n        pattern = self.generate_phone_number_pattern()\n        # Use the match method to check if the phone number matches the pattern\n        return self.match(pattern, phone_number)\n\n    def extract_email(self, text):\n        \"\"\"\n        Extract all email addresses from the text.\n        :param text: str, Text to extract email addresses from\n        :return: list of str, List of extracted email addresses\n        \"\"\"\n        # Use the generate_email_pattern method to get the regular expression pattern for email addresses\n        pattern = self.generate_email_pattern()\n        # Use the findall method to find all email addresses in the text\n        return self.findall(pattern, text)"}, {"id": "73", "llm_annotated_code": "class RPGCharacter:\n    \"\"\"\n    The class represents a role-playing game character, which allows to attack other characters, heal, gain experience, level up, and check if the character is alive.\n    \"\"\"\n\n    def __init__(self, name, hp, attack_power, defense, level=1):\n        \"\"\"\n        Initialize an RPG character object.\n        :param name: str, the name of the character.\n        :param hp: int, The health points of the character.\n        :param attack_power: int, the attack power of the character.\n        :param defense: int, the defense points of the character.\n        :param level: int, the level of the character. Default is 1.\n        \"\"\"\n        # Initialize the character's name, health points, attack power, defense points, level, and experience points\n        self.name = name\n        self.hp = hp\n        self.attack_power = attack_power\n        self.defense = defense\n        self.level = level\n        self.exp = 0\n\n    def attack(self, other_character):\n        \"\"\"\n        Attack another character. The damage caused needs to offset the defense value.\n        :param other_character: RPGCharacter object, The character being attacked.\n        >>> player_1 = RPGCharacter('player 1', 100, 10, 3)\n        >>> player_2 = RPGCharacter('player 2', 100, 7, 2)\n        >>> player_1.attack(player_2)\n        >>> player_2.hp\n        92\n        \"\"\"\n        # Calculate the damage by subtracting the defense of the other character from the attack power of the current character\n        # The minimum damage is 1\n        damage = max(self.attack_power - other_character.defense, 1)\n        # Subtract the damage from the health points of the other character\n        other_character.hp -= damage\n\n    def heal(self):\n        \"\"\"\n        Heal the character with 10 hp and the max hp is 100.\n        :return: int, the current health points after healing.\n        >>> player_1 = RPGCharacter('player 1', 93, 10, 3)\n        >>> player_1.heal()\n        100\n        \"\"\"\n        # Increase the health points by 10\n        self.hp += 10\n        # If the health points exceed 100, set them to 100\n        if self.hp > 100:\n            self.hp = 100\n        # Return the current health points\n        return self.hp\n\n    def gain_exp(self, amount):\n        \"\"\"\n        Gain experience points for the character and level_up when the exp has reached the values that is 100 times the current level\n        The experience that overflows should be used to calculate the next level up until exhausts\n        :param amount: int, the amount of experience points to gain.\n        >>> player_1 = RPGCharacter('player 1', 100, 10, 3)\n        >>> player_1.gain_exp(1100)\n        >>> player_1.exp\n        100\n        >>> player_1.level\n        5\n        \"\"\"\n        # While there is still experience to gain\n        while amount != 0:\n            # If the current experience plus the amount to gain is greater than or equal to the level times 100\n            if self.exp + amount >= self.level * 100:\n                # Subtract the amount needed to level up from the amount to gain\n                amount -= (self.level * 100 - self.exp)\n                # Level up\n                self.level_up()\n            else:\n                # Add the remaining amount to the current experience\n                self.exp += amount\n                # Set the amount to gain to 0\n                amount = 0\n\n    def level_up(self):\n         \"\"\"\n        Level up the character and return to zero experience points, increase hp by 20 points, attack power and defense points by 5 points.\n        max level is 100\n        :return: tuple[int, int, int, int], the new level, health points, attack power, and defense points after leveling up.\n        >>> player_1 = RPGCharacter('player 1', 100, 10, 3)\n        >>> player_1.level_up()\n        (2, 120, 15, 8)\n        \"\"\"\n         # If the level is less than 100\n         if self.level < 100:\n            # Increase the level by 1\n            self.level += 1\n            # Reset the experience points to 0\n            self.exp = 0\n            # Increase the health points by 20\n            self.hp += 20\n            # Increase the attack power and defense points by 5\n            self.attack_power += 5\n            self.defense += 5\n        # Return the new level, health points, attack power, and defense points\n        return self.level, self.hp, self.attack_power, self.defense\n\n    def is_alive(self):\n        \"\"\"\n        Check if player is alive.\n        :return: True if the hp is larger than 0, or False otherwise.\n        >>> player_1 = RPGCharacter('player 1', 100, 10, 3)\n        >>> player_1.is_alive()\n        True\n        \"\"\"\n        # Return True if the health points are greater than 0, False otherwise\n        return self.hp > 0"}, {"id": "74", "llm_annotated_code": "class Server:\n    \"\"\"\n    This is a class as a server, which handles a white list, message sending and receiving, and information display.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the whitelist as an empty list, and initialize the sending and receiving information as an empty dictionary\n        \"\"\"\n        # Initialize the white_list attribute as an empty list\n        self.white_list = []\n        # Initialize the send_struct attribute as an empty dictionary\n        self.send_struct = {}\n        # Initialize the receive_struct attribute as an empty dictionary\n        self.receive_struct = {}\n\n    def add_white_list(self, addr):\n        \"\"\"\n        Add an address to the whitelist and do nothing if it already exists\n        :param addr: int, address to be added\n        :return: new whitelist, return False if the address already exists\n        \"\"\"\n        # Check if the address is already in the white_list\n        if addr in self.white_list:\n            # If it is, return False\n            return False\n        else:\n            # If it's not, append it to the white_list and return the updated white_list\n            self.white_list.append(addr)\n            return self.white_list\n\n    def del_white_list(self, addr):\n        \"\"\"\n        Remove an address from the whitelist and do nothing if it does not exist\n        :param addr: int, address to be deleted\n        :return: new whitelist, return False if the address does not exist\n        \"\"\"\n        # Check if the address is in the white_list\n        if addr not in self.white_list:\n            # If it's not, return False\n            return False\n        else:\n            # If it is, remove it from the white_list and return the updated white_list\n            self.white_list.remove(addr)\n            return self.white_list\n\n    def recv(self, info):\n        \"\"\"\n        Receive information containing address and content. If the address is on the whitelist, receive the content; otherwise, do not receive it\n        :param info: dict, information dictionary containing address and content\n        :return: if successfully received, return the content of the infomation; otherwise, return False\n        \"\"\"\n        # Check if the info is a dictionary and contains the keys \"addr\" and \"content\"\n        if not isinstance(info, dict) or \"addr\" not in info or \"content\" not in info:\n            # If it's not, return -1\n            return -1\n        # Extract the address and content from the info\n        addr = info[\"addr\"]\n        content = info[\"content\"]\n        # Check if the address is in the white_list\n        if addr not in self.white_list:\n            # If it's not, return False\n            return False\n        else:\n            # If it is, update the receive_struct with the address and content and return the content\n            self.receive_struct = {\"addr\": addr, \"content\": content}\n            return self.receive_struct[\"content\"]\n\n    def send(self, info):\n        \"\"\"\n        Send information containing address and content\n        :param info: dict, information dictionary containing address and content\n        :return: if successfully sent, return nothing; otherwise, return a string indicating an error message\n        \"\"\"\n        # Check if the info is a dictionary and contains the keys \"addr\" and \"content\"\n        if not isinstance(info, dict) or \"addr\" not in info or \"content\" not in info:\n            # If it's not, return an error message\n            return \"info structure is not correct\"\n        # If it is, update the send_struct with the address and content\n        self.send_struct = {\"addr\": info[\"addr\"], \"content\": info[\"content\"]}\n\n    def show(self, type):\n        \"\"\"\n        Returns struct of the specified type\n        :param type: string, the type of struct to be returned, which can be 'send' or 'receive'\n        :return: if type is equal to 'send' or 'receive', return the corresponding struct; otherwise, return False\n        \"\"\"\n        # Check if the type is \"send\"\n        if type == \"send\":\n            # If it is, return the send_struct\n            return self.send_struct\n        # Check if the type is \"receive\"\n        elif type == \"receive\":\n            # If it is, return the receive_struct\n            return self.receive_struct\n        else:\n            # If it's neither, return False\n            return False"}, {"id": "75", "llm_annotated_code": "class ShoppingCart:\n    \"\"\"\n    The class manages items, their prices, quantities, and allows to for add, remove, view items, and calculate the total price.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the items representing the shopping list as an empty dictionary.\n        The items dictionary will store item names as keys and a dictionary of price and quantity as values.\n        \"\"\"\n        self.items = {}\n\n\n    def add_item(self, item, price, quantity=1):\n        \"\"\"\n        Add item information to the shopping list items, including price and quantity. The default quantity is 1.\n        If the item already exists in the shopping list, update its price and quantity.\n        :param item: string, Item to be added\n        :param price: float, The price of the item\n        :param quantity:int, The number of items, defaults to 1\n        :return:None\n        \"\"\"\n        if item in self.items:\n            self.items[item] = {'price': price, 'quantity': quantity}\n        else:\n            self.items[item] = {'price': price, 'quantity': quantity}\n\n\n    def remove_item(self, item, quantity=1):\n        \"\"\"\n        Subtract the specified quantity of item from the shopping list items.\n        If the item does not exist in the shopping list, do nothing.\n        :param item:string, Item to be subtracted in quantity\n        :param quantity:int, Quantity to be subtracted\n        :return:None\n        \"\"\"\n        if item in self.items:\n            self.items[item]['quantity'] -= quantity\n        else:\n            pass\n\n\n    def view_items(self) -> dict:\n        \"\"\"\n        Return the current shopping list items.\n        :return:dict, the current shopping list items\n        \"\"\"\n        return self.items\n\n\n    def total_price(self) -> float:\n        \"\"\"\n        Calculate the total price of all items in the shopping list, which is the quantity of each item multiplied by the price.\n        :return:float, the total price of all items in the shopping list\n        \"\"\"\n        return sum([item['quantity'] * item['price'] for item in self.items.values()])"}, {"id": "76", "llm_annotated_code": "class SignInSystem:\n    \"\"\"\n    This is a class as sign-in system, including adding users, signing in/out, checking sign-in status, and retrieving signed-in/not signed-in users.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the sign-in system.\n        The users attribute is a dictionary where the keys are usernames and the values are boolean values indicating whether the user is signed in.\n        \"\"\"\n        self.users = {}\n\n    def add_user(self, username):\n        \"\"\"\n        Add a user to the sign-in system if the user wasn't in the self.users.\n        And the initial state is False.\n        :param username: str, the username to be added.\n        :return: bool, True if the user is added successfully, False if the user already exists.\n        \"\"\"\n        # Check if the username is already in the users dictionary\n        if username in self.users:\n            return False\n        else:\n            # Add the username to the users dictionary with a value of False indicating that the user is not signed in\n            self.users[username] = False\n            return True\n\n    def sign_in(self, username):\n        \"\"\"\n        Sign in a user if the user was in the self.users and change the state to True.\n        :param username: str, the username to be signed in.\n        :return: bool, True if the user is signed in successfully, False if the user does not exist.\n        \"\"\"\n        # Check if the username is in the users dictionary\n        if username not in self.users:\n            return False\n        else:\n            # Set the value of the username key in the users dictionary to True indicating that the user is signed in\n            self.users[username] = True\n            return True\n\n    def check_sign_in(self, username):\n        \"\"\"\n        Check if a user is signed in.\n        :param username: str, the username to be checked.\n        :return: bool, True if the user is signed in, False if the user does not exist or is not signed in.\n        \"\"\"\n        # Check if the username is in the users dictionary\n        if username not in self.users:\n            return False\n        else:\n            # Return the value of the username key in the users dictionary\n            # This will be True if the user is signed in and False if they are not\n            return self.users[username]\n\n    def all_signed_in(self):\n        \"\"\"\n        Check if all users are signed in.\n        :return: bool, True if all users are signed in, False otherwise.\n        \"\"\"\n        # Use the all function to check if all values in the users dictionary are True\n        # This will return True if all users are signed in and False otherwise\n        return all(self.users.values())\n\n    def all_not_signed_in(self):\n        \"\"\"\n        Get a list of usernames that are not signed in.\n        :return: list[str], a list of usernames that are not signed in.\n        \"\"\"\n        not_signed_in_users = []\n        # Iterate over the items in the users dictionary\n        for username, signed_in in self.users.items():\n            # If the value is False (indicating the user is not signed in), append the username to the not_signed_in_users list\n            if not signed_in:\n                not_signed_in_users.append(username)\n        # Return the list of usernames that are not signed in\n        return not_signed_in_users"}, {"id": "77", "llm_annotated_code": "class Snake:\n    \"\"\"\n    This class represents a snake game, which allows the snake to move and eat food. It also provides functionality to reset the game and generate a random food position.\n    \"\"\"\n\n    def __init__(self, SCREEN_WIDTH, SCREEN_HEIGHT, BLOCK_SIZE, food_position):\n        \"\"\"\n        Initialize the Snake with screen dimensions, block size, and initial food position.\n        :param SCREEN_WIDTH: int, width of the game screen\n        :param SCREEN_HEIGHT: int, height of the game screen\n        :param BLOCK_SIZE: int, size of each block (or grid cell) on the game screen\n        :param food_position: tuple, initial position of the food on the game screen\n        \"\"\"\n\n        self.length = 1  # Initial length of the snake\n        self.SCREEN_WIDTH = SCREEN_WIDTH  # Width of the game screen\n        self.SCREEN_HEIGHT = SCREEN_HEIGHT  # Height of the game screen\n        self.BLOCK_SIZE = BLOCK_SIZE  # Size of each block (or grid cell) on the game screen\n        self.positions = [((SCREEN_WIDTH / 2), (SCREEN_HEIGHT / 2))]  # Initial position of the snake's head\n        self.score = 0  # Initial score\n        self.food_position = food_position  # Initial position of the food\n\n\n    def move(self, direction):\n        \"\"\"\n        Move the snake in the specified direction. If the new position of the snake's head is the same as the position of the food, the snake eats the food. If the new position of the snake's head is the same as any position in its body, the game is reset. Otherwise, the snake moves to the new position.\n        :param direction: tuple, direction of movement (x, y)\n        :return: None\n        \"\"\"\n\n        cur = self.positions[0]  # Current position of the snake's head\n        x, y = direction  # Direction of movement\n\n        # Calculate the new position of the snake's head based on the direction of movement\n        new = (\n            ((cur[0] + (x * self.BLOCK_SIZE)) % self.SCREEN_WIDTH),\n            (cur[1] + (y * self.BLOCK_SIZE)) % self.SCREEN_HEIGHT,\n        )\n\n        # If the new position is the same as the food position, the snake eats the food\n        if new == self.food_position:\n            self.eat_food()\n\n        # If the new position is the same as any position in the snake's body (excluding the head), the game is reset\n        elif len(self.positions) > 2 and new in self.positions[2:]:\n            self.reset()\n\n        # Otherwise, the snake moves to the new position\n        else:\n            self.positions.insert(0, new)  # Insert the new position at the beginning of the positions list\n            if len(self.positions) > self.length:  # If the length of the positions list is greater than the length of the snake\n                self.positions.pop()  # Remove the last position from the positions list\n\n\n    def random_food_position(self):\n        \"\"\"\n        Generate a random position for the food on the game screen. The food position must not be the same as any position in the snake's body.\n        :return: None\n        \"\"\"\n\n        # Generate a random position for the food until it is not the same as any position in the snake's body\n        while self.food_position in self.positions:\n            self.food_position = (random.randint(0, self.SCREEN_WIDTH // self.BLOCK_SIZE - 1) * self.BLOCK_SIZE,\n                                  random.randint(0, self.SCREEN_HEIGHT // self.BLOCK_SIZE - 1) * self.BLOCK_SIZE)\n\n\n    def reset(self):\n        \"\"\"\n        Reset the game to its initial state. The length of the snake is set to 1, the position of the snake's head is set to the center of the game screen, the score is set to 0, and a new random position for the food is generated.\n        :return: None\n        \"\"\"\n\n        self.length = 1  # Reset the length of the snake to 1\n        self.positions = [((self.SCREEN_WIDTH / 2), (self.SCREEN_HEIGHT / 2))]  # Reset the position of the snake's head to the center of the game screen\n        self.score = 0  # Reset the score to 0\n        self.random_food_position()  # Generate a new random position for the food\n\n\n    def eat_food(self):\n        \"\"\"\n        Increase the length of the snake by 1 and the score by 100. Generate a new random position for the food.\n        :return: None\n        \"\"\"\n\n        self.length += 1  # Increase the length of the snake by 1\n        self.score += 100  # Increase the score by 100\n        self.random_food_position()  # Generate a new random position for the food"}, {"id": "78", "llm_annotated_code": "class SplitSentence:\n    \"\"\"\n    The class allows to split sentences, count words in a sentence, and process a text file to find the maximum word count.\n    \"\"\"\n\n    def split_sentences(self, sentences_string):\n        \"\"\"\n        Split a string into a list of sentences. Sentences end with . or ? and with a space after that. Please note that Mr. also end with . but are not sentences.\n        :param sentences_string: string, string to split\n        :return:list, split sentence list\n        >>> ss = SplitSentence()\n        >>> ss.split_sentences(\"aaa aaaa. bb bbbb bbb? cccc cccc. dd ddd?\")\n        ['aaa aaaa.', 'bb bbbb bbb?', 'cccc cccc.', 'dd ddd?']\n        \"\"\"\n\n        # Use the re.split method to split the sentences_string into sentences based on the regular expression pattern.\n        # The pattern splits the string at every . or ? followed by a space, but not when . is part of an abbreviation like Mr.\n        sentences = re.split(r'(?<!\\w\\.\\w.)(?<![A-Z][a-z]\\.)(?<=\\.|\\?)\\s', sentences_string)\n        return sentences\n\n    def count_words(self, sentence):\n        \"\"\"\n        Count the number of words in a sentence. Note that words are separated by spaces and that punctuation marks and numbers are not counted as words.\n        :param sentence:string, sentence to be counted, where words are separated by spaces\n        :return:int, number of words in the sentence\n        >>> ss.count_words(\"abc def\")\n        2\n        \"\"\"\n\n        # Use the re.sub method to replace all non-alphabetic characters in the sentence with an empty string.\n        sentence = re.sub(r'[^a-zA-Z\\s]', '', sentence)\n\n        # Use the split method to split the sentence into words based on spaces.\n        words = sentence.split()\n\n        # Return the number of words in the sentence.\n        return len(words)\n\n    def process_text_file(self, sentences_string):\n        \"\"\"\n        Given a text, return the number of words in the longest sentence\n        :param sentences_string: string, undivided long sentence\n        :return:int, the number of words in the longest sentence\n        >>> ss.process_text_file(\"aaa aaaa. bb bbbb bbb? cccc ccccccc cc ccc. dd ddd?\")\n        4\n        \"\"\"\n\n        # Use the split_sentences method to split the sentences_string into sentences.\n        sentences = self.split_sentences(sentences_string)\n\n        # Initialize max_count to 0 to keep track of the maximum word count.\n        max_count = 0\n\n        # Iterate over each sentence in sentences.\n        for sentence in sentences:\n\n            # Use the count_words method to count the number of words in the sentence.\n            count = self.count_words(sentence)\n\n            # If the word count of the current sentence is greater than max_count, update max_count.\n            if count > max_count:\n                max_count = count\n\n        # Return the maximum word count.\n        return max_count"}, {"id": "79", "llm_annotated_code": "class SQLGenerator:\n    \"\"\"\n    This class generates SQL statements for common operations on a table, such as SELECT, INSERT, UPDATE, and DELETE.\n    \"\"\"\n\n    def __init__(self, table_name):\n        \"\"\"\n        Initialize the SQLGenerator with a table name.\n        :param table_name: str, the name of the table to generate SQL statements for\n        \"\"\"\n        self.table_name = table_name\n\n    def select(self, fields=None, condition=None):\n        \"\"\"\n        Generates a SELECT SQL statement based on the specified fields and conditions.\n        :param fields: list of str, optional. Default is None. The list of fields to be queried.\n        :param condition: str, optional. Default is None. The condition expression for the query.\n        :return: str, the generated SQL statement.\n        \"\"\"\n        # If no fields are specified, select all fields\n        if fields is None:\n            fields = \"*\"\n        else:\n            # Join the fields with commas\n            fields = \", \".join(fields)\n        \n        # Start building the SQL statement\n        sql = f\"SELECT {fields} FROM {self.table_name}\"\n        \n        # If a condition is specified, add a WHERE clause to the SQL statement\n        if condition is not None:\n            sql += f\" WHERE {condition}\"\n        \n        # End the SQL statement with a semicolon\n        return sql + \";\"\n\n    def insert(self, data):\n        \"\"\"\n        Generates an INSERT SQL statement based on the given data.\n        :param data: dict, the data to be inserted, in dictionary form where keys are field names and values are field values.\n        :return: str, the generated SQL statement.\n        \"\"\"\n        # Extract the field names and values from the data dictionary\n        fields = \", \".join(data.keys())\n        values = \", \".join([f\"'{value}'\" for value in data.values()])\n        \n        # Build the SQL statement\n        sql = f\"INSERT INTO {self.table_name} ({fields}) VALUES ({values})\"\n        \n        # End the SQL statement with a semicolon\n        return sql + \";\"\n\n    def update(self, data, condition):\n        \"\"\"\n        Generates an UPDATE SQL statement based on the given data and condition.\n        :param data: dict, the data to be updated, in dictionary form where keys are field names and values are new field values.\n        :param condition: str, the condition expression for the update.\n        :return: str, the generated SQL statement.\n        \"\"\"\n        # Build the SET clause of the SQL statement from the data dictionary\n        set_clause = \", \".join([f\"{field} = '{value}'\" for field, value in data.items()])\n        \n        # Build the SQL statement\n        sql = f\"UPDATE {self.table_name} SET {set_clause} WHERE {condition}\"\n        \n        # End the SQL statement with a semicolon\n        return sql + \";\"\n\n    def delete(self, condition):\n        \"\"\"\n        Generates a DELETE SQL statement based on the given condition.\n        :param condition: str, the condition expression for the delete.\n        :return: str, the generated SQL statement.\n        \"\"\"\n        # Build the SQL statement\n        sql = f\"DELETE FROM {self.table_name} WHERE {condition}\"\n        \n        # End the SQL statement with a semicolon\n        return sql + \";\"\n\n    def select_female_under_age(self, age):\n        \"\"\"\n        Generates a SQL statement to select females under a specified age.\n        :param age: int, the specified age.\n        :return: str, the generated SQL statement.\n        \"\"\"\n        # Build the condition for the SQL statement\n        condition = f\"age < {age} AND gender = 'female'\"\n        \n        # Use the select method to generate the SQL statement\n        return self.select(condition=condition)\n\n    def select_by_age_range(self, min_age, max_age):\n        \"\"\"\n        Generates a SQL statement to select records within a specified age range.\n        :param min_age: int, the minimum age.\n        :param max_age: int, the maximum age.\n        :return: str, the generated SQL statement.\n        \"\"\"\n        # Build the condition for the SQL statement\n        condition = f\"age BETWEEN {min_age} AND {max_age}\"\n        \n        # Use the select method to generate the SQL statement\n        return self.select(condition=condition)"}, {"id": "80", "llm_annotated_code": "class SQLQueryBuilder:\n    \"\"\"\n    This class provides methods to build SQL queries, including SELECT, INSERT, UPDATE, and DELETE statements.\n    \"\"\"\n\n    @staticmethod\n    def select(table, columns='*', where=None):\n        \"\"\"\n        Generate a SELECT SQL statement from the given parameters.\n        :param table: str, the name of the table in the database to query from.\n        :param columns: list of str or '*', the columns to select in the query. Default is '*', which selects all columns.\n        :param where: dict, optional, the conditions for the WHERE clause in the query. Keys are column names and values are the corresponding values to match in the query.\n        :return: str, the generated SQL SELECT statement.\n        >>> SQLQueryBuilder.select('users', columns=['name', 'age'], where={'age': 21})\n        \"SELECT name, age FROM users WHERE age='21'\"\n        \"\"\"\n\n        # If columns is not '*', join the column names with ', ' to form a string\n        if columns != '*':\n            columns = ', '.join(columns)\n\n        # Start building the SELECT query\n        query = f\"SELECT {columns} FROM {table}\"\n\n        # If a WHERE clause is provided, add it to the query\n        if where:\n            query += \" WHERE \" + ' AND '.join(f\"{k}='{v}'\" for k, v in where.items())\n\n        # Return the generated query\n        return query\n\n    @staticmethod\n    def insert(table, data):\n        \"\"\"\n        Generate an INSERT SQL statement from the given parameters.\n        :param table: str, the name of the table in the database to insert into.\n        :param data: dict, the data to insert into the table. Keys are column names and values are the corresponding values to insert.\n        :return: str, the generated SQL INSERT statement.\n        >>> SQLQueryBuilder.insert('users', {'name': 'John', 'age': 21})\n        \"INSERT INTO users (name, age) VALUES ('John', '21')\"\n        \"\"\"\n\n        # Extract the keys (column names) and values (data to insert) from the data dictionary\n        keys = ', '.join(data.keys())\n        values = ', '.join(f\"'{v}'\" for v in data.values())\n\n        # Build and return the INSERT query\n        return f\"INSERT INTO {table} ({keys}) VALUES ({values})\"\n\n    @staticmethod\n    def delete(table, where=None):\n        \"\"\"\n        Generate a DELETE SQL statement from the given parameters.\n        :param table: str, the name of the table in the database to delete from.\n        :param where: dict, optional, the conditions for the WHERE clause in the query. Keys are column names and values are the corresponding values to match in the query.\n        :return: str, the generated SQL DELETE statement.\n        >>> SQLQueryBuilder.delete('users', where={'name': 'John'})\n        \"DELETE FROM users WHERE name='John'\"\n        \"\"\"\n\n        # Start building the DELETE query\n        query = f\"DELETE FROM {table}\"\n\n        # If a WHERE clause is provided, add it to the query\n        if where:\n            query += \" WHERE \" + ' AND '.join(f\"{k}='{v}'\" for k, v in where.items())\n\n        # Return the generated query\n        return query\n\n    @staticmethod\n    def update(table, data, where=None):\n        \"\"\"\n        Generate an UPDATE SQL statement from the given parameters.\n        :param table: str, the name of the table in the database to update.\n        :param data: dict, the data to update in the table. Keys are column names and values are the new values to set.\n        :param where: dict, optional, the conditions for the WHERE clause in the query. Keys are column names and values are the corresponding values to match in the query.\n        :return: str, the generated SQL UPDATE statement.\n        >>> SQLQueryBuilder.update('users', {'age': 22}, where={'name': 'John'})\n        \"UPDATE users SET age='22' WHERE name='John'\"\n        \"\"\"\n\n        # Convert the data dictionary to a string of 'column=value' pairs separated by ', '\n        update_str = ', '.join(f\"{k}='{v}'\" for k, v in data.items())\n\n        # Start building the UPDATE query\n        query = f\"UPDATE {table} SET {update_str}\"\n\n        # If a WHERE clause is provided, add it to the query\n        if where:\n            query += \" WHERE \" + ' AND '.join(f\"{k}='{v}'\" for k, v in where.items())\n\n        # Return the generated query\n        return query"}, {"id": "81", "llm_annotated_code": "class Statistics3:\n    \"\"\"\n    This class provides methods for calculating statistical indicators such as median, mode, correlation matrix, and Z-score.\n    \"\"\"\n\n    @staticmethod\n    def median(data):\n        \"\"\"\n        Calculates the median of the given list.\n        :param data: list, the given list of numbers\n        :return: float, the median of the given list\n        >>> statistics3 = Statistics3()\n        >>> statistics3.median([1, 2, 3, 4])\n        2.5\n\n        \"\"\"\n        # Sort the data\n        sorted_data = sorted(data)\n        n = len(sorted_data)\n        \n        # If the length of the data is odd, return the middle element\n        # If the length of the data is even, return the average of the two middle elements\n        if n % 2 == 1:\n            return sorted_data[n // 2]\n        else:\n            return (sorted_data[n // 2 - 1] + sorted_data[n // 2]) / 2\n\n    @staticmethod\n    def mode(data):\n        \"\"\"\n        Calculates the mode of the given list.\n        :param data: list, the given list of numbers\n        :return: list, the mode(s) of the given list\n        >>> statistics3 = Statistics3()\n        >>> statistics3.mode([1, 2, 3, 3])\n        [3]\n\n        \"\"\"\n        # Create a dictionary to count the frequency of each value in the data\n        counts = {}\n        for value in data:\n            counts[value] = counts.get(value, 0) + 1\n        \n        # Find the maximum count\n        max_count = max(counts.values())\n        \n        # Return all values that have the maximum count\n        mode_values = [value for value, count in counts.items() if count == max_count]\n        return mode_values\n\n    @staticmethod\n    def correlation(x, y):\n        \"\"\"\n        Calculates the correlation between two lists.\n        :param x: list, the first list of numbers\n        :param y: list, the second list of numbers\n        :return: float, the correlation between x and y\n        >>> statistics3 = Statistics3()\n        >>> statistics3.correlation([1, 2, 3], [4, 5, 6])\n        1.0\n\n        \"\"\"\n        # Calculate the mean of x and y\n        n = len(x)\n        mean_x = sum(x) / n\n        mean_y = sum(y) / n\n        \n        # Calculate the numerator of the correlation formula\n        numerator = sum((xi - mean_x) * (yi - mean_y) for xi, yi in zip(x, y))\n        \n        # Calculate the denominator of the correlation formula\n        denominator = math.sqrt(sum((xi - mean_x) ** 2 for xi in x) * sum((yi - mean_y) ** 2 for yi in y))\n        \n        # If the denominator is 0, return None\n        if denominator == 0:\n            return None\n        \n        # Return the correlation\n        return numerator / denominator\n\n    @staticmethod\n    def mean(data):\n        \"\"\"\n        Calculates the mean of the given list.\n        :param data: list, the given list of numbers\n        :return: float, the mean of the given list\n        >>> statistics3 = Statistics3()\n        >>> statistics3.mean([1, 2, 3])\n        2.0\n\n        \"\"\"\n        # If the data is empty, return None\n        if len(data) == 0:\n            return None\n        \n        # Return the mean of the data\n        return sum(data) / len(data)\n\n    @staticmethod\n    def correlation_matrix(data):\n        \"\"\"\n        Calculates the correlation matrix of the given list of lists.\n        :param data: list of lists, the given list of lists of numbers\n        :return: list of lists, the correlation matrix of the given list\n        >>> statistics3 = Statistics3()\n        >>> statistics3.correlation_matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n        [[1.0, 1.0, 1.0], [1.0, 1.0, 1.0], [1.0, 1.0, 1.0]]\n\n        \"\"\"\n        # Initialize the correlation matrix\n        matrix = []\n        \n        # Calculate the correlation between each pair of lists in data\n        for i in range(len(data[0])):\n            row = []\n            for j in range(len(data[0])):\n                column1 = [row[i] for row in data]\n                column2 = [row[j] for row in data]\n                correlation = Statistics3.correlation(column1, column2)\n                row.append(correlation)\n            matrix.append(row)\n        \n        # Return the correlation matrix\n        return matrix\n\n    @staticmethod\n    def standard_deviation(data):\n        \"\"\"\n        Calculates the standard deviation of the given list.\n        :param data: list, the given list of numbers\n        :return: float, the standard deviation of the given list\n        >>> statistics3 = Statistics3()\n        >>> statistics3.standard_deviation([1, 2, 3])\n        1.0\n\n        \"\"\"\n        # If the length of the data is less than 2, return None\n        n = len(data)\n        if n < 2:\n            return None\n        \n        # Calculate the mean of the data\n        mean_value = Statistics3.mean(data)\n        \n        # Calculate the variance of the data\n        variance = sum((x - mean_value) ** 2 for x in data) / (n - 1)\n        \n        # Return the standard deviation of the data\n        return math.sqrt(variance)\n\n    @staticmethod\n    def z_score(data):\n        \"\"\"\n        Calculates the z-score of the given list.\n        :param data: list, the given list of numbers\n        :return: list, the z-score of the given list\n        >>> statistics3 = Statistics3()\n        >>> statistics3.z_score([1, 2, 3, 4])\n        [-1.161895003862225, -0.3872983346207417, 0.3872983346207417, 1.161895003862225]\n\n        \"\"\"\n        # Calculate the mean of the data\n        mean = Statistics3.mean(data)\n        \n        # Calculate the standard deviation of the data\n        std_deviation = Statistics3.standard_deviation(data)\n        \n        # If the standard deviation is None or 0, return None\n        if std_deviation is None or std_deviation == 0:\n            return None\n        \n        # Return the z-score of the data\n        return [(x - mean) / std_deviation for x in data]"}, {"id": "82", "llm_annotated_code": "class StockPortfolioTracker:\n    \"\"\"\n    This class, StockPortfolioTracker, allows to manage a stock portfolio. It provides functionalities to add stocks, remove stocks, buy stocks, sell stocks, calculate the total value of the portfolio, and obtain a summary of the portfolio.\n    \"\"\"\n\n    def __init__(self, cash_balance):\n        \"\"\"\n        Initialize the StockPortfolioTracker class with a cash balance and an empty portfolio.\n        :param cash_balance: float, the initial cash balance\n        \"\"\"\n        self.portfolio = []  # Initialize an empty portfolio\n        self.cash_balance = cash_balance  # Set the initial cash balance\n\n    def add_stock(self, stock):\n        \"\"\"\n        Add a stock to the portfolio.\n        :param stock: dict, a dictionary with keys \"name\", \"price\", and \"quantity\" representing a stock\n        \"\"\"\n        # Iterate over the portfolio to check if the stock is already present\n        for pf in self.portfolio:\n            # If the stock is present, increase its quantity and return\n            if pf['name'] == stock['name']:\n                pf['quantity'] += stock['quantity']\n                return\n\n        # If the stock is not present in the portfolio, add it\n        self.portfolio.append(stock)\n\n    def remove_stock(self, stock):\n        \"\"\"\n        Remove a stock from the portfolio.\n        :param stock: dict, a dictionary with keys \"name\", \"price\", and \"quantity\" representing a stock\n        :return: bool, True if the stock was removed successfully, False otherwise\n        \"\"\"\n        # Iterate over the portfolio to find the stock\n        for pf in self.portfolio:\n            # If the stock is found and the quantity is sufficient, decrease its quantity\n            if pf['name'] == stock['name'] and pf['quantity'] >= stock['quantity']:\n                pf['quantity'] -= stock['quantity']\n                # If the quantity becomes zero, remove the stock from the portfolio\n                if pf['quantity'] == 0:\n                    self.portfolio.remove(pf)\n                return True\n        # If the stock is not found or the quantity is insufficient, return False\n        return False\n\n    def buy_stock(self, stock):\n        \"\"\"\n        Buy a stock and add it to the portfolio.\n        :param stock: dict, a dictionary with keys \"name\", \"price\", and \"quantity\" representing a stock\n        :return: bool, True if the stock was bought successfully, False if the cash balance is not enough\n        \"\"\"\n        # Check if the cash balance is sufficient to buy the stock\n        if stock['price'] * stock['quantity'] > self.cash_balance:\n            return False\n        else:\n            # If the cash balance is sufficient, add the stock to the portfolio and decrease the cash balance\n            self.add_stock(stock)\n            self.cash_balance -= stock['price'] * stock['quantity']\n            return True\n\n    def sell_stock(self, stock):\n        \"\"\"\n        Sell a stock and remove it from the portfolio and add the cash to the cash balance.\n        :param stock: dict, a dictionary with keys \"name\", \"price\", and \"quantity\" representing a stock\n        :return: bool, True if the stock was sold successfully, False if the quantity of the stock is not enough\n        \"\"\"\n        # Try to remove the stock from the portfolio\n        if self.remove_stock(stock) == False:\n            return False\n        # If the stock is removed successfully, increase the cash balance\n        self.cash_balance += stock['price'] * stock['quantity']\n        return True\n\n    def calculate_portfolio_value(self):\n        \"\"\"\n        Calculate the total value of the portfolio.\n        :return: float, the total value of the portfolio\n        \"\"\"\n        # Initialize the total value with the cash balance\n        total_value = self.cash_balance\n        # Add the value of each stock to the total value\n        for stock in self.portfolio:\n            total_value += stock['price'] * stock['quantity']\n        return total_value\n\n    def get_portfolio_summary(self):\n        \"\"\"\n        Get a summary of the portfolio.\n        :return: tuple, a tuple of the total value of the portfolio and a list of dictionaries with keys \"name\" and \"value\" representing each stock\n        \"\"\"\n        # Initialize an empty summary list\n        summary = []\n        # Add each stock's name and value to the summary list\n        for stock in self.portfolio:\n            value = self.get_stock_value(stock)\n            summary.append({\"name\": stock[\"name\"], \"value\": value})\n        # Calculate the total value of the portfolio\n        portfolio_value = self.calculate_portfolio_value()\n        return portfolio_value, summary\n\n    def get_stock_value(self, stock):\n        \"\"\"\n        Get the value of a stock.\n        :param stock: dict, a dictionary with keys \"name\", \"price\", and \"quantity\" representing a stock\n        :return: float, the value of the stock\n        \"\"\"\n        # Calculate and return the value of the stock\n        return stock['price'] * stock['quantity']"}, {"id": "83", "llm_annotated_code": "class StudentDatabaseProcessor:\n    \"\"\"\n    This class provides methods for interacting with a SQLite database, specifically for operations related to a \"students\" table.\n    \"\"\"\n\n    def __init__(self, database_name):\n        \"\"\"\n        Initializes the StudentDatabaseProcessor with the specified SQLite database name.\n        :param database_name: str, the name of the SQLite database.\n        \"\"\"\n        self.database_name = database_name\n\n    def create_student_table(self):\n        \"\"\"\n        Creates a \"students\" table in the SQLite database if it does not exist already. The table includes fields for id, name, age, gender, and grade.\n        :return: None\n        \"\"\"\n        # Connect to the SQLite database\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n\n        # SQL query to create the \"students\" table if it does not exist\n        create_table_query = \"\"\"\n        CREATE TABLE IF NOT EXISTS students (\n            id INTEGER PRIMARY KEY,\n            name TEXT,\n            age INTEGER,\n            gender TEXT,\n            grade INTEGER\n        )\n        \"\"\"\n        # Execute the SQL query\n        cursor.execute(create_table_query)\n\n        # Commit the changes and close the connection to the database\n        conn.commit()\n        conn.close()\n\n    def insert_student(self, student_data):\n        \"\"\"\n        Inserts a new student record into the \"students\" table.\n        :param student_data: dict, a dictionary containing the student's information (name, age, gender, grade).\n        :return: None\n        \"\"\"\n        # Connect to the SQLite database\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n\n        # SQL query to insert a new record into the \"students\" table\n        insert_query = \"\"\"\n        INSERT INTO students (name, age, gender, grade)\n        VALUES (?, ?, ?, ?)\n        \"\"\"\n        # Execute the SQL query with the student data\n        cursor.execute(insert_query,\n                       (student_data['name'], student_data['age'], student_data['gender'], student_data['grade']))\n\n        # Commit the changes and close the connection to the database\n        conn.commit()\n        conn.close()\n\n    def search_student_by_name(self, name):\n        \"\"\"\n        Searches for a student record in the \"students\" table by their name.\n        :param name: str, the name of the student to search for.\n        :return: list of tuples, the rows from the \"students\" table that match the search criteria.\n        \"\"\"\n        # Connect to the SQLite database\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n\n        # SQL query to select records from the \"students\" table where the name matches the provided name\n        select_query = \"SELECT * FROM students WHERE name = ?\"\n        cursor.execute(select_query, (name,))\n        \n        # Fetch all rows that match the query\n        result = cursor.fetchall()\n\n        # Close the connection to the database\n        conn.close()\n\n        # Return the result\n        return result\n\n    def delete_student_by_name(self, name):\n        \"\"\"\n        Deletes a student record from the \"students\" table by their name.\n        :param name: str, the name of the student to delete.\n        :return: None\n        \"\"\"\n        # Connect to the SQLite database\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n\n        # SQL query to delete records from the \"students\" table where the name matches the provided name\n        delete_query = \"DELETE FROM students WHERE name = ?\"\n        cursor.execute(delete_query, (name,))\n\n        # Commit the changes and close the connection to the database\n        conn.commit()\n        conn.close()"}, {"id": "84", "llm_annotated_code": "class TextFileProcessor:\n    \"\"\"\n    The class handles reading, writing, and processing text files. It can read the file as JSON, read the raw text, write content to the file, and process the file by removing non-alphabetic characters.\n    \"\"\"\n\n    def __init__(self, file_path):\n        \"\"\"\n        Initialize the TextFileProcessor with a file path.\n        :param file_path: str, path to the file to be processed\n        >>> textFileProcessor = TextFileProcessor('test.json')\n        \"\"\"\n        self.file_path = file_path\n\n    def read_file_as_json(self):\n        \"\"\"\n        Read the file at self.file_path as JSON.\n        If the file content doesn't obey JSON format, the code will raise a JSONDecodeError.\n        :return data: dict if the file is stored as JSON format, or str/int/float.. according to the file content otherwise.\n        >>> textFileProcessor = TextFileProcessor('test.json')\n        >>> textFileProcessor.read_file_as_json()\n        {'name': 'test', 'age': 12}\n        >>> type(textFileProcessor.read_file_as_json())\n        <class 'dict'>\n        \"\"\"\n        # Open the file in read mode\n        with open(self.file_path, 'r') as file:\n            # Use the json.load method to parse the file content as JSON\n            data = json.load(file)\n\n        # Return the parsed data\n        return data\n\n    def read_file(self):\n        \"\"\"\n        Read and return the content of the file at self.file_path.\n        :return: str, the content of the file\n        >>> textFileProcessor = TextFileProcessor('test.json')\n        >>> textFileProcessor.read_file()\n        '{\n    \"name\": \"test\",\n    \"age\": 12\n}'\n        \"\"\"\n        # Open the file in read mode\n        with open(self.file_path, 'r') as file:\n            # Use the read method to get the file content\n            return file.read()\n\n    def write_file(self, content):\n        \"\"\"\n        Write content into the file at self.file_path, overwriting if the file already exists.\n        :param content: str, the content to be written to the file\n        >>> textFileProcessor = TextFileProcessor('test.json')\n        >>> textFileProcessor.write_file('Hello world!')\n        >>> textFileProcessor.read_file()\n        'Hello world!'\n        \"\"\"\n        # Open the file in write mode\n        with open(self.file_path, 'w') as file:\n            # Use the write method to write the content to the file\n            file.write(content)\n\n    def process_file(self):\n        \"\"\"\n        Read the file at self.file_path and filter out non-alphabetic characters from the content string.\n        Overwrite the processed data into the same file.\n        :return: str, the processed content of the file\n        >>> textFileProcessor = TextFileProcessor('test.json')\n        >>> textFileProcessor.read_file()\n        '{\n    \"name\": \"test\",\n    \"age\": 12\n}'\n        >>> textFileProcessor.process_file()\n        'nametestage'\n        \"\"\"\n        # Use the read_file method to get the file content\n        content = self.read_file()\n        # Use a list comprehension to filter out non-alphabetic characters from the content\n        content = ''.join([char for char in content if char.isalpha()])\n        # Use the write_file method to overwrite the file with the processed content\n        self.write_file(content)\n        # Return the processed content\n        return content"}, {"id": "85", "llm_annotated_code": "class Thermostat:\n    \"\"\"\n    The class manages temperature control, including setting and retrieving the target temperature, adjusting the mode, and simulating temperature operation.\n    \"\"\"\n\n    def __init__(self, current_temperature, target_temperature, mode):\n        \"\"\"\n        Initialize instances of the Thermostat class, including the current temperature, target temperature, and operating mode.\n        :param current_temperature: float, the current temperature of the environment\n        :param target_temperature: float, the desired temperature to be achieved\n        :param mode: str, the operating mode of the thermostat, can be either 'heat' or 'cool'\n        \"\"\"\n        self.current_temperature = current_temperature\n        self.target_temperature = target_temperature\n        self.mode = mode\n\n    def get_target_temperature(self):\n        \"\"\"\n        Get the target temperature of an instance of the Thermostat class.\n        :return: float, the target temperature set for the thermostat\n        \"\"\"\n        return self.target_temperature\n\n    def set_target_temperature(self, temperature):\n        \"\"\"\n        Set the target temperature for the thermostat.\n        :param temperature: float, the desired temperature to be set as the target temperature\n        \"\"\"\n        self.target_temperature = temperature\n\n    def get_mode(self):\n        \"\"\"\n        Get the current operating mode of the thermostat.\n        :return: str, the current operating mode of the thermostat, can be either 'heat' or 'cool'\n        \"\"\"\n        return self.mode\n\n    def set_mode(self, mode):\n        \"\"\"\n        Set the operating mode of the thermostat.\n        :param mode: str, the desired operating mode to be set, can be either 'heat' or 'cool'\n        :return: bool, False if the provided mode is not 'heat' or 'cool'\n        \"\"\"\n        if mode in ['heat', 'cool']:\n            self.mode = mode\n        else:\n            return False\n\n    def auto_set_mode(self):\n        \"\"\"\n        Automatically set the operating mode of the thermostat based on the current and target temperatures.\n        If the current temperature is lower than the target temperature, the mode is set to 'heat'.\n        If the current temperature is higher than the target temperature, the mode is set to 'cool'.\n        \"\"\"\n        if self.current_temperature < self.target_temperature:\n            self.mode = 'heat'\n        else:\n            self.mode = 'cool'\n\n    def auto_check_conflict(self):\n        \"\"\"\n        Check if there is a conflict between the current operating mode and the relationship between the current and target temperatures.\n        If there is a conflict, the operating mode is automatically adjusted.\n        :return: bool, True if there is no conflict, False otherwise\n        \"\"\"\n        if self.current_temperature > self.target_temperature:\n            if self.mode == 'cool':\n                return True\n            else:\n                self.auto_set_mode()\n                return False\n        else:\n            if self.mode == 'heat':\n                return True\n            else:\n                self.auto_set_mode()\n                return False\n\n    def simulate_operation(self):\n        \"\"\"\n        Simulate the operation of the thermostat. The thermostat automatically sets the operating mode and adjusts the current temperature\n        until the target temperature is reached. The time taken for the simulation is returned.\n        :return: int, the time taken for the simulation\n        \"\"\"\n        self.auto_set_mode()\n        use_time = 0\n        if self.mode == 'heat':\n            while(self.current_temperature < self.target_temperature):\n                self.current_temperature += 1\n                use_time += 1\n        else:\n            while(self.current_temperature > self.target_temperature):\n                self.current_temperature -= 1\n                use_time += 1\n        return use_time"}, {"id": "86", "llm_annotated_code": "class TicTacToe:\n    \"\"\"\n    The class represents a game of Tic-Tac-Toe. It includes methods for making a move on the game board, checking for a winner, and determining if the game board is full.\n    \"\"\"\n\n    def __init__(self, N=3):\n        \"\"\"\n        Initialize a 3x3 game board with all empty spaces and set the current player to 'X'.\n        :param N: int, the size of the game board (default is 3)\n        \"\"\"\n\n        # Initialize a 2D list to represent the game board. The size of the board is NxN.\n        # Each cell in the board is initially set to ' ' (empty space).\n        self.board = [[' ' for _ in range(N)] for _ in range(3)]\n\n        # Initialize the current player to 'X'.\n        self.current_player = 'X'\n\n    def make_move(self, row, col):\n        \"\"\"\n        Place the current player's mark at the specified position on the game board and switch the current player.\n        :param row: int, the row index of the position\n        :param col: int, the column index of the position\n        :return: bool, indicating whether the move was successful or not\n        \"\"\"\n\n        # Check if the specified cell on the game board is empty.\n        # If it is, place the current player's mark in the cell and switch the current player.\n        # If it is not, return False to indicate that the move was unsuccessful.\n        if self.board[row][col] == ' ':\n            self.board[row][col] = self.current_player\n            self.current_player = 'O' if self.current_player == 'X' else 'X'\n            return True\n        else:\n            return False\n\n    def check_winner(self):\n        \"\"\"\n        Check if there is a winner on the game board.\n        :return: str or None, the mark of the winner ('X' or 'O'), or None if there is no winner yet\n        \"\"\"\n\n        # Check each row on the game board for a winner.\n        for row in self.board:\n            if row[0] == row[1] == row[2] != ' ':\n                return row[0]\n\n        # Check each column on the game board for a winner.\n        for col in range(3):\n            if self.board[0][col] == self.board[1][col] == self.board[2][col] != ' ':\n                return self.board[0][col]\n\n        # Check the two diagonals on the game board for a winner.\n        if self.board[0][0] == self.board[1][1] == self.board[2][2] != ' ':\n            return self.board[0][0]\n        if self.board[0][2] == self.board[1][1] == self.board[2][0] != ' ':\n            return self.board[0][2]\n\n        # If no winner is found, return None.\n        return None\n\n    def is_board_full(self):\n        \"\"\"\n        Check if the game board is completely filled.\n        :return: bool, indicating whether the game board is full or not\n        \"\"\"\n\n        # Iterate over each row on the game board.\n        # If an empty space is found, return False to indicate that the game board is not full.\n        for row in self.board:\n            if ' ' in row:\n                return False\n\n        # If no empty spaces are found, return True to indicate that the game board is full.\n        return True"}, {"id": "87", "llm_annotated_code": "class TimeUtils:\n    \"\"\"\n    This is a time util class, including getting the current time and date, adding seconds to a datetime, converting between strings and datetime objects, calculating the time difference in minutes, and formatting a datetime object.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the TimeUtils class by getting the current datetime and storing it in self.datetime.\n        \"\"\"\n        self.datetime = datetime.datetime.now()\n\n    def get_current_time(self):\n        \"\"\"\n        Return the current time in the format of '%H:%M:%S'.\n        :return: string, current time in the format of '%H:%M:%S'\n        \"\"\"\n        # Define the time format\n        format = \"%H:%M:%S\"\n        \n        # Use the strftime method to format the current datetime stored in self.datetime to the defined format and return it\n        return self.datetime.strftime(format)\n\n    def get_current_date(self):\n        \"\"\"\n        Return the current date in the format of \"%Y-%m-%d\".\n        :return: string, current date in the format of \"%Y-%m-%d\"\n        \"\"\"\n        # Define the date format\n        format = \"%Y-%m-%d\"\n        \n        # Use the strftime method to format the current datetime stored in self.datetime to the defined format and return it\n        return self.datetime.strftime(format)\n\n    def add_seconds(self, seconds):\n        \"\"\"\n        Add the specified number of seconds to the current time.\n        :param seconds: int, number of seconds to add\n        :return: string, time after adding the specified number of seconds in the format '%H:%M:%S'\n        \"\"\"\n        # Use the timedelta method to add the specified number of seconds to the current datetime stored in self.datetime\n        new_datetime = self.datetime + datetime.timedelta(seconds=seconds)\n        \n        # Define the time format\n        format = \"%H:%M:%S\"\n        \n        # Use the strftime method to format the new datetime to the defined format and return it\n        return new_datetime.strftime(format)\n\n    def string_to_datetime(self, string):\n        \"\"\"\n        Convert the time string to a datetime instance.\n        :param string: string, string before converting format\n        :return: datetime instance\n        \"\"\"\n        # Use the strptime method to convert the string to a datetime object in the \"%Y-%m-%d %H:%M:%S\" format and return it\n        return datetime.datetime.strptime(string, \"%Y-%m-%d %H:%M:%S\")\n\n    def datetime_to_string(self, datetime):\n        \"\"\"\n        Convert a datetime instance to a string.\n        :param datetime: the datetime instance to convert\n        :return: string, converted time string\n        \"\"\"\n        # Use the strftime method to convert the datetime object to a string in the \"%Y-%m-%d %H:%M:%S\" format and return it\n        return datetime.strftime(\"%Y-%m-%d %H:%M:%S\")\n\n    def get_minutes(self, string_time1, string_time2):\n        \"\"\"\n        Calculate how many minutes have passed between two times, and round the results to the nearest.\n        :param string_time1: string, the first time string\n        :param string_time2: string, the second time string\n        :return: int, the number of minutes between two times, rounded off\n        \"\"\"\n        # Use the string_to_datetime method to convert the time strings to datetime objects\n        time1 = self.string_to_datetime(string_time1)\n        time2 = self.string_to_datetime(string_time2)\n        \n        # Calculate the difference between the two times in seconds, divide by 60 to get the difference in minutes, round the result, and return it\n        return round((time2 - time1).seconds / 60)\n\n    def get_format_time(self, year, month, day, hour, minute, second):\n        \"\"\"\n        Get formatted time string.\n        :param year: int\n        :param month: int\n        :param day: int\n        :param hour: int\n        :param minute: int\n        :param second: int\n        :return: string, formatted time string\n        \"\"\"\n        # Define the time format\n        format = \"%Y-%m-%d %H:%M:%S\"\n        \n        # Create a datetime object with the specified year, month, day, hour, minute, and second\n        time_item = datetime.datetime(year, month, day, hour, minute, second)\n        \n        # Use the strftime method to format the datetime object to the defined format and return it\n        return time_item.strftime(format)"}, {"id": "88", "llm_annotated_code": "class TriCalculator:\n    \"\"\"\n    The class allows to calculate trigonometric values, including cosine, sine, and tangent, using Taylor series approximations.\n    \"\"\"\n\n    def __init__(self):\n        pass\n\n    def cos(self, x):\n        \"\"\"\n        Calculate the cosine value of the x-degree angle using the Taylor series approximation.\n        :param x: float, angle in degrees\n        :return: float, cosine value of the angle\n        >>> tricalculator = TriCalculator()\n        >>> tricalculator.cos(60)\n        0.5\n        \"\"\"\n        # Use the taylor method to calculate the cosine value\n        return round(self.taylor(x, 50), 10)\n\n    def factorial(self, a):\n        \"\"\"\n        Calculate the factorial of a number.\n        :param a: int, the number to calculate the factorial of\n        :return: int, the factorial of the number\n        >>> tricalculator.factorial(5)\n        120\n        \"\"\"\n        b = 1\n        # Calculate the factorial by multiplying the number by each of its predecessors until 1\n        while a != 1:\n            b *= a\n            a -= 1\n        return b\n\n    def taylor(self, x, n):\n        \"\"\"\n        Calculate the n-order Taylor series expansion value of cos (x/180 * pi).\n        :param x: int, angle in degrees\n        :param n: int, the order of the Taylor series expansion\n        :return: float, the Taylor series expansion value\n        >>> tricalculator.taylor(60, 50)\n        0.5000000000000001\n        \"\"\"\n        a = 1\n        # Convert the angle from degrees to radians\n        x = x / 180 * pi\n        count = 1\n        # Calculate the Taylor series expansion\n        for k in range(1, n):\n            if count % 2 != 0:\n                a -= (x ** (2 * k)) / self.factorial(2 * k)\n            else:\n                a += (x ** (2 * k)) / self.factorial(2 * k)\n            count += 1\n        return a\n\n    def sin(self, x):\n        \"\"\"\n        Calculate the sine value of the x-degree angle using the Taylor series approximation.\n        :param x: float, angle in degrees\n        :return: float, sine value of the angle\n        >>> tricalculator.sin(30)\n        0.5\n        \"\"\"\n        # Convert the angle from degrees to radians\n        x = x / 180 * pi\n        g = 0\n        t = x\n        n = 1\n        # Calculate the sine value using the Taylor series approximation\n        while fabs(t) >= 1e-15:\n            g += t\n            n += 1\n            t = -t * x * x / (2 * n - 1) / (2 * n - 2)\n        return round(g, 10)\n\n    def tan(self, x):\n        \"\"\"\n        Calculate the tangent value of the x-degree angle using the Taylor series approximation.\n        :param x: float, angle in degrees\n        :return: float, tangent value of the angle\n        >>> tricalculator.tan(45)\n        1.0\n        \"\"\"\n        # Check if the cosine of the angle is not zero to avoid division by zero\n        if self.cos(x) != 0:\n            # Calculate the tangent value as the ratio of the sine to the cosine of the angle\n            result = self.sin(x) / self.cos(x)\n            return round(result, 10)\n        else:\n            # Return False if the cosine of the angle is zero\n            return False"}, {"id": "89", "llm_annotated_code": "class TwentyFourPointGame:\n    \"\"\"\n    This is a class for a game of twenty-four points. It generates four random numbers and checks whether a player's mathematical expression using these numbers equals 24.\n    \"\"\"\n\n    def __init__(self) -> None:\n        \"\"\"\n        Initialize the TwentyFourPointGame with an empty list of numbers.\n        \"\"\"\n        self.nums = []\n\n    def _generate_cards(self):\n        \"\"\"\n        Generate four random numbers between 1 and 9 (inclusive) and store them in self.nums.\n        Uses the random.randint function from the random module.\n        \"\"\"\n        for i in range(4):\n            self.nums.append(random.randint(1, 9))\n        assert len(self.nums) == 4\n\n    def get_my_cards(self):\n        \"\"\"\n        Generate a new set of four random numbers and return them.\n        :return: list of integers, the four generated numbers\n        >>> game = TwentyFourPointGame()\n        >>> game.get_my_cards()\n        [3, 7, 1, 9]\n\n        \"\"\"\n        self.nums = []\n        self._generate_cards()\n        return self.nums\n\n    def answer(self, expression):\n        \"\"\"\n        Check if a given mathematical expression using the numbers in self.nums can evaluate to 24.\n        :param expression: string, mathematical expression using the numbers\n        :return: bool, True if the expression evaluates to 24, False otherwise\n        >>> game = TwentyFourPointGame()\n        >>> game.nums = [4, 3, 6, 6]\n        >>> ans = \"4*3+6+6\"\n        >>> ret = game.answer(ans)\n        True\n\n        \"\"\"\n        # If the expression is 'pass', generate a new set of numbers and return them\n        if expression == 'pass':\n            return self.get_my_cards()\n\n        # Create a dictionary to count the occurrences of each number in the expression\n        statistic = {}\n        for c in expression:\n            if c.isdigit() and int(c) in self.nums:\n                statistic[c] = statistic.get(c, 0) + 1\n\n        # Create a copy of the dictionary to track the numbers used\n        nums_used = statistic.copy()\n\n        # Check if each number in self.nums is used in the expression\n        for num in self.nums:\n            if nums_used.get(str(num), -100) != -100 and nums_used[str(num)] > 0:\n                nums_used[str(num)] -= 1\n            else:\n                return False\n\n        # If all numbers are used, evaluate the expression\n        if all(count == 0 for count in nums_used.values()) == True:\n            return self.evaluate_expression(expression)\n        else:\n            return False\n\n    def evaluate_expression(self, expression):\n        \"\"\"\n        Evaluate a mathematical expression and check if the result is 24.\n        :param expression: string, mathematical expression\n        :return: bool, True if the expression evaluates to 24, False otherwise\n        >>> game = TwentyFourPointGame()\n        >>> nums = [4, 3, 6, 6]\n        >>> ans = \"4*3+6+6\"\n        >>> ret = game.evaluate_expression(ans)\n        True\n\n        \"\"\"\n        try:\n            # Use the eval function to evaluate the expression\n            if eval(expression) == 24:\n                return True\n            else:\n                return False\n        except Exception as e:\n            # If an exception occurs during evaluation, return False\n            return False"}, {"id": "90", "llm_annotated_code": "class URLHandler:\n    \"\"\"\n    The class supports to handle URLs, including extracting the scheme, host, path, query parameters, and fragment.\n    \"\"\"\n\n    def __init__(self, url):\n        \"\"\"\n        Initialize URLHandler's URL\n        :param url: str, the URL to be handled\n        >>> urlhandler = URLHandler(\"https://www.example.com/path?param=value#fragment\")\n        \"\"\"\n        self.url = url\n\n    def get_scheme(self):\n        \"\"\"\n        Get the scheme of the URL\n        :return: str, the scheme of the URL if it exists, None otherwise\n        >>> urlhandler = URLHandler(\"https://www.example.com/path?param=value#fragment\")\n        >>> urlhandler.get_scheme()\n        \"https\"\n        \"\"\"\n        # Find the end of the scheme in the URL\n        scheme_end = self.url.find(\"://\")\n        \n        # If a scheme exists, return it\n        if scheme_end != -1:\n            return self.url[:scheme_end]\n        \n        # If no scheme exists, return None\n        return None\n\n    def get_host(self):\n        \"\"\"\n        Get the host domain name of the URL\n        :return: str, the host domain name of the URL if it exists, None otherwise\n        >>> urlhandler = URLHandler(\"https://www.example.com/path?param=value#fragment\")\n        >>> urlhandler.get_host()\n        \"www.example.com\"\n        \"\"\"\n        # Find the end of the scheme in the URL\n        scheme_end = self.url.find(\"://\")\n        \n        # If a scheme exists, find the end of the host in the URL\n        if scheme_end != -1:\n            url_without_scheme = self.url[scheme_end + 3:]\n            host_end = url_without_scheme.find(\"/\")\n            \n            # If a host exists, return it\n            if host_end != -1:\n                return url_without_scheme[:host_end]\n            \n            # If no host exists, return the remaining URL\n            return url_without_scheme\n        \n        # If no scheme exists, return None\n        return None\n\n    def get_path(self):\n        \"\"\"\n        Get the path of the URL\n        :return: str, the path of the URL if it exists, None otherwise\n        >>> urlhandler = URLHandler(\"https://www.example.com/path?param=value#fragment\")\n        >>> urlhandler.get_path()\n        \"/path?param=value#fragment\"\n        \"\"\"\n        # Find the end of the scheme in the URL\n        scheme_end = self.url.find(\"://\")\n        \n        # If a scheme exists, find the start of the path in the URL\n        if scheme_end != -1:\n            url_without_scheme = self.url[scheme_end + 3:]\n            host_end = url_without_scheme.find(\"/\")\n            \n            # If a path exists, return it\n            if host_end != -1:\n                return url_without_scheme[host_end:]\n        \n        # If no scheme exists, return None\n        return None\n\n    def get_query_params(self):\n        \"\"\"\n        Get the query parameters of the URL\n        :return: dict, the query parameters of the URL if they exist, None otherwise\n        >>> urlhandler = URLHandler(\"https://www.example.com/path?param=value#fragment\")\n        >>> urlhandler.get_query_params()\n        {\"param\": \"value\"}\n        \"\"\"\n        # Find the start of the query parameters in the URL\n        query_start = self.url.find(\"?\")\n        \n        # Find the start of the fragment in the URL\n        fragment_start = self.url.find(\"#\")\n        \n        # If query parameters exist, parse them into a dictionary\n        if query_start != -1:\n            query_string = self.url[query_start + 1:fragment_start]\n            params = {}\n            if len(query_string) > 0:\n                param_pairs = query_string.split(\"&\")\n                for pair in param_pairs:\n                    key_value = pair.split(\"=\")\n                    if len(key_value) == 2:\n                        key, value = key_value\n                        params[key] = value\n            return params\n        \n        # If no query parameters exist, return None\n        return None\n\n    def get_fragment(self):\n        \"\"\"\n        Get the fragment of the URL\n        :return: str, the fragment of the URL if it exists, None otherwise\n        >>> urlhandler = URLHandler(\"https://www.example.com/path?param=value#fragment\")\n        >>> urlhandler.get_fragment()\n        \"fragment\"\n        \"\"\"\n        # Find the start of the fragment in the URL\n        fragment_start = self.url.find(\"#\")\n        \n        # If a fragment exists, return it\n        if fragment_start != -1:\n            return self.url[fragment_start + 1:]\n        \n        # If no fragment exists, return None\n        return None"}, {"id": "91", "llm_annotated_code": "class UrlPath:\n    \"\"\"\n    The UrlPath class is a utility for encapsulating and manipulating the path component of a URL. \n    It includes methods for adding nodes to the path, parsing path strings, and building path strings with optional encoding.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initializes the UrlPath object with an empty list of segments and a flag indicating the presence of an end tag.\n        \"\"\"\n        # Initialize an empty list to store the segments of the URL path\n        self.segments = []\n        # Initialize a flag to indicate whether the URL path ends with a slash\n        self.with_end_tag = False\n\n    def add(self, segment):\n        \"\"\"\n        Adds a segment to the list of segments in the UrlPath.\n        :param segment: str, the segment to add.\n        \"\"\"\n        # Call the fix_path method to remove leading and trailing slashes from the segment\n        # Append the fixed segment to the list of segments\n        self.segments.append(self.fix_path(segment))\n\n    def parse(self, path, charset):\n        \"\"\"\n        Parses a given path string and populates the list of segments in the UrlPath.\n        :param path: str, the path string to parse.\n        :param charset: str, the character encoding of the path string.\n        \"\"\"\n        # If the path is not empty\n        if path:\n            # If the path ends with a slash, set the with_end_tag flag to True\n            if path.endswith('/'):\n                self.with_end_tag = True\n\n            # Call the fix_path method to remove leading and trailing slashes from the path\n            path = self.fix_path(path)\n            if path:\n                # Split the path into segments using the slash as a delimiter\n                split = path.split('/')\n                for seg in split:\n                    # Decode each segment using the provided character set and append it to the list of segments\n                    decoded_seg = urllib.parse.unquote(seg, encoding=charset)\n                    self.segments.append(decoded_seg)\n\n    @staticmethod\n    def fix_path(path):\n        \"\"\"\n        Fixes the given path string by removing leading and trailing slashes.\n        :param path: str, the path string to fix.\n        :return: str, the fixed path string.\n        \"\"\"\n        # If the path is empty, return an empty string\n        if not path:\n            return ''\n\n        # Remove leading and trailing slashes from the path and return the result\n        segment_str = path.strip('/')\n        return segment_str"}, {"id": "92", "llm_annotated_code": "class UserLoginDB:\n    \"\"\"\n    This is a database management class for user login verification, providing functions for inserting user information, searching user information, deleting user information, and validating user login.\n    \"\"\"\n\n    def __init__(self, db_name):\n        \"\"\"\n        Initializes the UserLoginDB object with the specified database name.\n        :param db_name: str, the name of the SQLite database.\n        \"\"\"\n        # Connect to the SQLite database with the given name and create a cursor for executing SQL commands\n        self.connection = sqlite3.connect(db_name)\n        self.cursor = self.connection.cursor()\n\n    def insert_user(self, username, password):\n        \"\"\"\n        Inserts a new user into the \"users\" table.\n        :param username: str, the username of the user.\n        :param password: str, the password of the user.\n        :return: None\n        \"\"\"\n        # Execute an SQL command to insert a new row into the \"users\" table with the given username and password\n        self.cursor.execute(\"\"\"\n            INSERT INTO users (username, password)\n            VALUES (?, ?)\n        \"\"\", (username, password))\n        # Commit the changes to the database\n        self.connection.commit()\n\n\n    def search_user_by_username(self, username):\n        \"\"\"\n        Searches for users in the \"users\" table by username.\n        :param username: str, the username of the user to search for.\n        :return:list of tuples, the rows from the \"users\" table that match the search criteria.\n        \"\"\"\n        # Execute an SQL command to select the row from the \"users\" table where the username matches the given username\n        self.cursor.execute(\"\"\"\n            SELECT * FROM users WHERE username = ?\n        \"\"\", (username,))\n        # Fetch the first row from the results of the SQL command\n        user = self.cursor.fetchone()\n        # Return the fetched row\n        return user\n\n\n    def delete_user_by_username(self, username):\n        \"\"\"\n        Deletes a user from the \"users\" table by username.\n        :param username: str, the username of the user to delete.\n        :return: None\n        \"\"\"\n        # Execute an SQL command to delete the row from the \"users\" table where the username matches the given username\n        self.cursor.execute(\"\"\"\n            DELETE FROM users WHERE username = ?\n        \"\"\", (username,))\n        # Commit the changes to the database\n        self.connection.commit()\n\n\n    def validate_user_login(self, username, password):\n        \"\"\"\n        Determine whether the user can log in, that is, the user is in the database and the password is correct\n        :param username:str, the username of the user to validate.\n        :param password:str, the password of the user to validate.\n        :return:bool, representing whether the user can log in correctly\n        \"\"\"\n        # Use the search_user_by_username method to fetch the user with the given username\n        user = self.search_user_by_username(username)\n        # If the user exists and the password matches the given password, return True\n        # Otherwise, return False\n        if user is not None and user[1] == password:\n            return True\n        return False"}, {"id": "94", "llm_annotated_code": "class VendingMachine:\n    \"\"\"\n    This class simulates a vending machine, including adding products, inserting coins, purchasing products, viewing balance, \n    replenishing product inventory, and displaying product information.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initializes the vending machine's inventory and balance.\n        The inventory is a dictionary where the keys are the item names and the values are another dictionary containing the price and quantity of the item.\n        The balance is a float that represents the total amount of money inserted into the vending machine.\n        \"\"\"\n        self.inventory = {}\n        self.balance = 0\n\n    def add_item(self, item_name, price, quantity):\n        \"\"\"\n        Adds a product to the vending machine's inventory.\n        If the item already exists in the inventory, it calls the restock_item method to increase the quantity of the item.\n        If the item does not exist in the inventory, it creates a new entry in the inventory dictionary with the item name as the key and a dictionary containing the price and quantity as the value.\n        :param item_name: str, The name of the product to be added.\n        :param price: float, The price of the product to be added.\n        :param quantity: int, The quantity of the product to be added.\n        :return: None\n        \"\"\"\n        if not self.restock_item(item_name, quantity):\n            self.inventory[item_name] = {'price': price, 'quantity': quantity}\n\n    def insert_coin(self, amount):\n        \"\"\"\n        Inserts coins into the vending machine.\n        It increases the balance of the vending machine by the amount of the inserted coins.\n        :param amount: float, The amount of coins to be inserted.\n        :return: float, The balance of the vending machine after the coins are inserted.\n        \"\"\"\n        self.balance += amount\n        return self.balance\n\n    def purchase_item(self, item_name):\n        \"\"\"\n        Purchases a product from the vending machine.\n        It checks if the item exists in the inventory and if the quantity of the item is more than 0 and if the balance is enough to purchase the item.\n        If all conditions are met, it decreases the balance by the price of the item and decreases the quantity of the item by 1.\n        :param item_name: str, The name of the product to be purchased.\n        :return: float or bool, If the purchase is successful, it returns the balance of the vending machine after the product is purchased. If the purchase is unsuccessful, it returns False.\n        \"\"\"\n        if item_name in self.inventory:\n            item = self.inventory[item_name]\n            if item['quantity'] > 0 and self.balance >= item['price']:\n                self.balance -= item['price']\n                item['quantity'] -= 1\n                return self.balance\n            else:\n                return False\n        else:\n            return False\n\n    def restock_item(self, item_name, quantity):\n        \"\"\"\n        Replenishes the inventory of a product already in the vending machine.\n        It checks if the item exists in the inventory. If it does, it increases the quantity of the item by the specified quantity.\n        :param item_name: str, The name of the product to be replenished.\n        :param quantity: int, The quantity of the product to be replenished.\n        :return: bool, If the product is already in the vending machine, it returns True. If the product is not in the vending machine, it returns False.\n        \"\"\"\n        if item_name in self.inventory:\n            self.inventory[item_name]['quantity'] += quantity\n            return True\n        else:\n            return False\n\n    def display_items(self):\n        \"\"\"\n        Displays the products in the vending machine.\n        It checks if the inventory is empty. If it is, it returns False.\n        If the inventory is not empty, it creates a list of strings where each string contains the item name, price, and quantity, and returns the list joined by a newline character.\n        :return: str or bool, If the vending machine is empty, it returns False. If the vending machine is not empty, it returns a string containing the item names, prices, and quantities.\n        \"\"\"\n        if not self.inventory:\n            return False\n        else:\n            items = []\n            for item_name, item_info in self.inventory.items():\n                items.append(f\"{item_name} - ${item_info['price']} [{item_info['quantity']}]\")\n            return \"\\n\".join(items)"}, {"id": "95", "llm_annotated_code": "class Warehouse:\n    \"\"\"\n    The class manages inventory and orders, including adding products, updating product quantities, retrieving product quantities, creating orders, changing order statuses, and tracking orders.    \n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize two dictionaries to store the inventory and orders.\n        self.inventory: A dictionary to store the products with product ID as the key and a dictionary of product details (name and quantity) as the value.\n        self.orders: A dictionary to store the orders with order ID as the key and a dictionary of order details (product ID, quantity, and status) as the value.\n        \"\"\"\n        self.inventory = {}  # Product ID: Product\n        self.orders = {}  # Order ID: Order\n\n    def add_product(self, product_id, name, quantity):\n        \"\"\"\n        Add a product to the inventory or update the quantity of an existing product.\n        :param product_id: int, the ID of the product\n        :param name: str, the name of the product\n        :param quantity: int, the quantity of the product\n        \"\"\"\n        # If the product ID is not in the inventory, add a new product with the given name and quantity\n        # If the product ID is already in the inventory, update the quantity of the product by adding the given quantity\n        if product_id not in self.inventory:\n            self.inventory[product_id] = {'name': name, 'quantity': quantity}\n        else:\n            self.inventory[product_id]['quantity'] += quantity\n\n    def update_product_quantity(self, product_id, quantity):\n        \"\"\"\n        Update the quantity of a product in the inventory.\n        :param product_id: int, the ID of the product\n        :param quantity: int, the quantity to be added to the current quantity of the product\n        \"\"\"\n        # If the product ID is in the inventory, update the quantity of the product by adding the given quantity\n        if product_id in self.inventory:\n            self.inventory[product_id]['quantity'] += quantity\n\n    def get_product_quantity(self, product_id):\n        \"\"\"\n        Get the quantity of a product in the inventory.\n        :param product_id: int, the ID of the product\n        :return: int or False, the quantity of the product if the product ID is in the inventory, False otherwise\n        \"\"\"\n        # If the product ID is in the inventory, return the quantity of the product\n        # If the product ID is not in the inventory, return False\n        if product_id in self.inventory:\n            return self.inventory[product_id]['quantity']\n        else:\n            return False\n\n    def create_order(self, order_id, product_id, quantity):\n        \"\"\"\n        Create an order with a product and its quantity.\n        :param order_id: int, the ID of the order\n        :param product_id: int, the ID of the product\n        :param quantity: int, the quantity of the product in the order\n        :return: False, if the product ID is not in the inventory or the quantity is not enough\n        \"\"\"\n        # If the quantity of the product in the inventory is enough, create an order with the product ID, quantity, and a default status of 'Shipped'\n        # If the quantity of the product in the inventory is not enough, return False\n        if self.get_product_quantity(product_id) >= quantity:\n            self.update_product_quantity(product_id, -quantity)\n            self.orders[order_id] = {'product_id': product_id, 'quantity': quantity, 'status': 'Shipped'}\n        else:\n            return False\n\n    def change_order_status(self, order_id, status):\n        \"\"\"\n        Change the status of an order.\n        :param order_id: int, the ID of the order\n        :param status: str, the new status of the order\n        :return: False, if the order ID is not in the orders\n        \"\"\"\n        # If the order ID is in the orders, change the status of the order to the given status\n        # If the order ID is not in the orders, return False\n        if order_id in self.orders:\n            self.orders[order_id]['status'] = status\n        else:\n            return False\n\n    def track_order(self, order_id):\n        \"\"\"\n        Track the status of an order.\n        :param order_id: int, the ID of the order\n        :return: str or False, the status of the order if the order ID is in the orders, False otherwise\n        \"\"\"\n        # If the order ID is in the orders, return the status of the order\n        # If the order ID is not in the orders, return False\n        if order_id in self.orders:\n            return self.orders[order_id]['status']\n        else:\n            return False"}, {"id": "96", "llm_annotated_code": "class WeatherSystem:\n    \"\"\"\n    This is a class representing a weather system that provides functionality to query weather information for a specific city and convert temperature units between Celsius and Fahrenheit.     \n    \"\"\"\n\n    def __init__(self, city) -> None:\n        \"\"\"\n        Initialize the weather system with a city name.\n        :param city: str, the name of the city\n        \"\"\"\n\n        # Initialize the temperature and weather attributes to None\n        self.temperature = None\n        self.weather = None\n\n        # Initialize the city attribute with the provided city name\n        self.city = city\n\n        # Initialize an empty dictionary to store the weather information\n        self.weather_list = {}\n\n    def query(self, weather_list, tmp_units = 'celsius'):\n        \"\"\"\n        Query the weather system for the weather and temperature of the city,and convert the temperature units based on the input parameter.\n        :param weather_list: a dictionary of weather information for different cities,dict.\n        :param tmp_units: the temperature units to convert to, str.\n        :return: the temperature and weather of the city, tuple.\n        \"\"\"\n\n        # Store the provided weather list in the weather_list attribute\n        self.weather_list = weather_list\n\n        # If the city is not in the weather list, return False\n        if self.city not in weather_list:\n            return False\n        else:\n            # Otherwise, store the temperature and weather of the city in the temperature and weather attributes\n            self.temperature = self.weather_list[self.city]['temperature']\n            self.weather = self.weather_list[self.city]['weather']\n\n        # If the temperature units in the weather list do not match the provided temperature units, convert the temperature to the provided units\n        if self.weather_list[self.city]['temperature units'] != tmp_units:\n            if tmp_units == 'celsius':\n                return self.fahrenheit_to_celsius(), self.weather\n            elif tmp_units == 'fahrenheit':\n                return self.celsius_to_fahrenheit(), self.weather\n        else:\n            # If the temperature units match, return the temperature and weather of the city\n            return self.temperature, self.weather\n\n    def set_city(self, city):\n        \"\"\"\n        Set the city of the weather system.\n        :param city: the city to set, str.\n        :return: None\n        \"\"\"\n\n        # Set the city attribute to the provided city name\n        self.city = city\n\n    def celsius_to_fahrenheit(self):\n        \"\"\"\n        Convert the temperature from Celsius to Fahrenheit.\n        :return: the temperature in Fahrenheit, float.\n        \"\"\"\n\n        # Convert the temperature from Celsius to Fahrenheit and return the result\n        return (self.temperature * 9/5) + 32\n\n    def fahrenheit_to_celsius(self):\n        \"\"\"\n        Convert the temperature from Fahrenheit to Celsius.\n        :return: the temperature in Celsius, float.\n        \"\"\"\n\n        # Convert the temperature from Fahrenheit to Celsius and return the result\n        return (self.temperature - 32) * 5/9"}, {"id": "97", "llm_annotated_code": "class Words2Numbers:\n    \"\"\"\n    The class provides a text-to-number conversion utility, allowing conversion of written numbers (in words) to their numerical representation.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the word lists and dictionaries required for conversion.\n        The units, tens, and scales lists are used to map words to their numerical values.\n        The numwords dictionary is used to store the numerical values of the words.\n        The ordinal_words dictionary is used to store the numerical values of ordinal words.\n        The ordinal_endings list is used to handle the endings of ordinal words.\n        \"\"\"\n\n        self.numwords = {}\n        self.units = [\n            \"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\",\n            \"nine\", \"ten\", \"eleven\", \"twelve\", \"thirteen\", \"fourteen\", \"fifteen\",\n            \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\",\n        ]\n        self.tens = [\"\", \"\", \"twenty\", \"thirty\", \"forty\", \"fifty\", \"sixty\", \"seventy\", \"eighty\", \"ninety\"]\n        self.scales = [\"hundred\", \"thousand\", \"million\", \"billion\", \"trillion\"]\n\n        # Populate the numwords dictionary with the numerical values of the words\n        self.numwords[\"and\"] = (1, 0)\n        for idx, word in enumerate(self.units):\n            self.numwords[word] = (1, idx)\n        for idx, word in enumerate(self.tens):\n            self.numwords[word] = (1, idx * 10)\n        for idx, word in enumerate(self.scales):\n            self.numwords[word] = (10 ** (idx * 3 or 2), 0)\n\n        # Define the ordinal words and their numerical values\n        self.ordinal_words = {'first': 1, 'second': 2, 'third': 3, 'fifth': 5, 'eighth': 8, 'ninth': 9, 'twelfth': 12}\n        self.ordinal_endings = [('ieth', 'y'), ('th', '')]\n\n\n    def text2int(self, textnum):\n        \"\"\"\n        Convert the word string to the corresponding integer string.\n        :param textnum: string, the word string to be converted\n        :return: string, the final converted integer string\n        The function works by splitting the input string into words and processing each word individually.\n        If the word is an ordinal word, it is converted to its numerical value.\n        If the word ends with an ordinal ending, the ending is replaced and the word is processed as a normal number.\n        If the word is a normal number, it is converted to its numerical value.\n        The numerical values are then combined to form the final number.\n        \"\"\"\n\n        # Replace hyphens with spaces to handle numbers like \"thirty-two\"\n        textnum = textnum.replace('-', ' ')\n\n        current = result = 0\n        curstring = \"\"\n        onnumber = False\n\n        # Iterate over each word in the input string\n        for word in textnum.split():\n            # If the word is an ordinal word, convert it to its numerical value\n            if word in self.ordinal_words:\n                scale, increment = (1, self.ordinal_words[word])\n                current = current * scale + increment\n                onnumber = True\n            else:\n                # If the word ends with an ordinal ending, replace the ending and process the word as a normal number\n                for ending, replacement in self.ordinal_endings:\n                    if word.endswith(ending):\n                        word = \"%s%s\" % (word[:-len(ending)], replacement)\n                \n                # If the word is not a number, add the current number to the result and reset the current number\n                if word not in self.numwords:\n                    if onnumber:\n                        curstring += repr(result + current) + \" \"\n                        curstring += word + \" \"\n                    result = current = 0\n                    onnumber = False\n                else:\n                    # If the word is a number, convert it to its numerical value and add it to the current number\n                    scale, increment = self.numwords[word]\n                    current = current * scale + increment\n                    if scale > 100:\n                        result += current\n                        current = 0\n                    onnumber = True\n\n        # If the last word was a number, add the current number to the result\n        if onnumber:\n            curstring += repr(result + current)\n        \n        # Return the final number as a string\n        return curstring\n\n    def is_valid_input(self, textnum):\n        \"\"\"\n        Check if the input text contains only valid words that can be converted into numbers.\n        :param textnum: The input text containing words representing numbers.\n        :return: True if input is valid, False otherwise.\n        The function works by splitting the input string into words and checking each word individually.\n        If the word is an ordinal word or a normal number, it is considered valid.\n        If the word ends with an ordinal ending, the ending is replaced and the word is checked as a normal number.\n        If the word is not a number, the function returns False.\n        If all words are valid, the function returns True.\n        \"\"\"\n\n        # Replace hyphens with spaces to handle numbers like \"thirty-two\"\n        textnum = textnum.replace('-', ' ')\n        \n        # Iterate over each word in the input string\n        for word in textnum.split():\n            # If the word is an ordinal word, it is considered valid\n            if word in self.ordinal_words:\n                continue\n            else:\n                # If the word ends with an ordinal ending, replace the ending and check the word as a normal number\n                for ending, replacement in self.ordinal_endings:\n                    if word.endswith(ending):\n                        word = \"%s%s\" % (word[:-len(ending)], replacement)\n                \n                # If the word is not a number, return False\n                if word not in self.numwords:\n                    return False\n        \n        # If all words are valid, return True\n        return True"}, {"id": "98", "llm_annotated_code": "class XMLProcessor:\n    \"\"\"\n    This class handles XML files, including reading, writing, processing, and finding elements in an XML file.\n    \"\"\"\n\n    def __init__(self, file_name):\n        \"\"\"\n        Initialize the XMLProcessor object with the given file name.\n        :param file_name: str, the name of the XML file to be processed.\n        \"\"\"\n        # Store the file name\n        self.file_name = file_name\n        # Initialize the root element of the XML file to None\n        self.root = None\n\n    def read_xml(self):\n        \"\"\"\n        Reads the XML file and returns the root element.\n        :return: Element, the root element of the XML file.\n        \"\"\"\n        try:\n            # Parse the XML file using the xml.etree.ElementTree.parse function\n            tree = ET.parse(self.file_name)\n            # Get the root element of the XML file\n            self.root = tree.getroot()\n            # Return the root element\n            return self.root\n        except:\n            # If an error occurs while reading the XML file, return None\n            return None\n\n    def write_xml(self, file_name):\n        \"\"\"\n        Writes the XML data to the specified file.\n        :param file_name: str, the name of the file to write the XML data.\n        :return: bool, True if the write operation is successful, False otherwise.\n        \"\"\"\n        try:\n            # Create an ElementTree object with the root element\n            tree = ET.ElementTree(self.root)\n            # Write the XML data to the specified file\n            tree.write(file_name)\n            # If the write operation is successful, return True\n            return True\n        except:\n            # If an error occurs while writing the XML file, return False\n            return False\n\n    def process_xml_data(self, file_name):\n        \"\"\"\n        Modifies the data in XML elements and writes the updated XML data to a new file.\n        :param file_name: str, the name of the file to write the modified XML data.\n        :return: bool, True if the write operation is successful, False otherwise.\n        \"\"\"\n        # Iterate over all 'item' elements in the XML file\n        for element in self.root.iter('item'):\n            # Get the text of the element\n            text = element.text\n            # Convert the text to uppercase and set it as the new text of the element\n            element.text = text.upper()\n        # Write the modified XML data to the specified file and return the result\n        return self.write_xml(file_name)\n\n    def find_element(self, element_name):\n        \"\"\"\n        Finds the XML elements with the specified name.\n        :param element_name: str, the name of the elements to find.\n        :return: list, a list of found elements with the specified name.\n        \"\"\"\n        # Use the findall method of the root element to find all elements with the specified name\n        elements = self.root.findall(element_name)\n        # Return the list of found elements\n        return elements"}, {"id": "99", "llm_annotated_code": "class ZipFileProcessor:\n    \"\"\"\n    This class provides methods to read, extract, and create zip files.\n    It uses the zipfile module from Python's standard library.\n    \"\"\"\n\n    def __init__(self, file_name):\n        \"\"\"\n        Initialize the ZipFileProcessor with a file name.\n        :param file_name: str, name of the zip file to be processed\n        \"\"\"\n        self.file_name = file_name\n\n    def read_zip_file(self):\n        \"\"\"\n        Open and read the zip file.\n        :return: zipfile.ZipFile object if the file is successfully opened, None otherwise\n        \"\"\"\n        try:\n            # Use the ZipFile constructor from the zipfile module to open the zip file in read mode\n            zip_file = zipfile.ZipFile(self.file_name, 'r')\n            return zip_file\n        except:\n            # If an exception occurs (e.g., the file does not exist), return None\n            return None\n\n    def extract_all(self, output_path):\n        \"\"\"\n        Extract all files from the zip file to a specified output path.\n        :param output_path: str, path where the files will be extracted\n        :return: bool, True if the extraction is successful, False otherwise\n        \"\"\"\n        try:\n            # Use the ZipFile constructor from the zipfile module to open the zip file in read mode\n            # Use the extractall method of the ZipFile object to extract all files to the output path\n            with zipfile.ZipFile(self.file_name, 'r') as zip_file:\n                zip_file.extractall(output_path)\n            return True\n        except:\n            # If an exception occurs (e.g., the file does not exist or the output path is not writable), return False\n            return False\n\n    def extract_file(self, file_name, output_path):\n        \"\"\"\n        Extract a specific file from the zip file to a specified output path.\n        :param file_name: str, name of the file to be extracted\n        :param output_path: str, path where the file will be extracted\n        :return: bool, True if the extraction is successful, False otherwise\n        \"\"\"\n        try:\n            # Use the ZipFile constructor from the zipfile module to open the zip file in read mode\n            # Use the extract method of the ZipFile object to extract the specified file to the output path\n            with zipfile.ZipFile(self.file_name, 'r') as zip_file:\n                zip_file.extract(file_name, output_path)\n            return True\n        except:\n            # If an exception occurs (e.g., the file does not exist in the zip file or the output path is not writable), return False\n            return False\n\n    def create_zip_file(self, files, output_file_name):\n        \"\"\"\n        Create a new zip file containing the specified files.\n        :param files: list of str, list of file names to be included in the zip file\n        :param output_file_name: str, name of the output zip file\n        :return: bool, True if the zip file is successfully created, False otherwise\n        \"\"\"\n        try:\n            # Use the ZipFile constructor from the zipfile module to create a new zip file in write mode\n            # Use the write method of the ZipFile object to add each file to the zip file\n            with zipfile.ZipFile(output_file_name, 'w') as zip_file:\n                for file in files:\n                    zip_file.write(file)\n            return True\n        except:\n            # If an exception occurs (e.g., a file does not exist or the output path is not writable), return False\n            return False"}]