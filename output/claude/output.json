[{"id": "1", "llm_annotated_code": "import math\n\nclass AreaCalculator:\n    \"\"\"\n    This is a class for calculating the area of different shapes, including circle, sphere, cylinder, sector and annulus.\n    \"\"\"\n\n    def __init__(self, radius):\n        \"\"\"\n        Initialize the radius for shapes.\n        :param radius: float\n        \"\"\"\n        self.radius = radius\n\n    def calculate_circle_area(self):\n        \"\"\"\n        calculate the area of circle based on self.radius\n        :return: area of circle, float\n        >>> areaCalculator = AreaCalculator(2)\n        >>> areaCalculator.calculate_circle_area()\n        12.566370614359172\n        \"\"\"\n        # Use math.pi constant from the math library\n        # Calculate the area of a circle using the formula: \u03c0 * r\u00b2\n        # self.radius is the radius initialized in the constructor\n        return math.pi * self.radius ** 2\n\n    def calculate_sphere_area(self):\n        \"\"\"\n        calculate the area of sphere based on self.radius\n        :return: area of sphere, float\n        >>> areaCalculator = AreaCalculator(2)\n        >>> areaCalculator.calculate_sphere_area()\n        50.26548245743669\n        \"\"\"\n        # Use math.pi constant from the math library\n        # Calculate the surface area of a sphere using the formula: 4 * \u03c0 * r\u00b2\n        # self.radius is the radius initialized in the constructor\n        return 4 * math.pi * self.radius ** 2\n\n    def calculate_cylinder_area(self, height):\n        \"\"\"\n        calculate the area of cylinder based on self.radius and height\n        :param height: height of cylinder, float\n        :return: area of cylinder, float\n        >>> areaCalculator = AreaCalculator(2)\n        >>> areaCalculator.calculate_cylinder_area(3)\n        62.83185307179586\n        \"\"\"\n        # Use math.pi constant from the math library\n        # Calculate the total surface area of a cylinder using the formula: 2 * \u03c0 * r * (r + h)\n        # self.radius is the radius initialized in the constructor\n        # height is passed as a parameter to this method\n        return 2 * math.pi * self.radius * (self.radius + height)\n\n    def calculate_sector_area(self, angle):\n        \"\"\"\n        calculate the area of sector based on self.radius and angle\n        :param angle: angle of sector, float\n        :return: area of sector, float\n        >>> areaCalculator = AreaCalculator(2)\n        >>> areaCalculator.calculate_sector_area(math.pi)\n        6.283185307179586\n        \"\"\"\n        # Calculate the area of a sector using the formula: r\u00b2 * \u03b8 / 2\n        # self.radius is the radius initialized in the constructor\n        # angle is passed as a parameter to this method (in radians)\n        return self.radius ** 2 * angle / 2\n\n    def calculate_annulus_area(self, inner_radius, outer_radius):\n        \"\"\"\n        calculate the area of annulus based on inner_radius and out_radius\n        :param inner_radius: inner radius of sector, float\n        :param outer_radius: outer radius of sector, float\n        :return: area of annulus, float\n        >>> areaCalculator.calculate_annulus_area(2, 3)\n        15.707963267948966\n        \"\"\"\n        # Use math.pi constant from the math library\n        # Calculate the area of an annulus using the formula: \u03c0 * (R\u00b2 - r\u00b2)\n        # where R is the outer radius and r is the inner radius\n        # Both inner_radius and outer_radius are passed as parameters to this method\n        # Note: This method doesn't use self.radius\n        return math.pi * (outer_radius ** 2 - inner_radius ** 2)"}, {"id": "2", "llm_annotated_code": "class ArgumentParser:\n    \"\"\"\n    This is a class for parsing command line arguments to a dictionary.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the fields.\n        self.arguments is a dict that stores the args in a command line\n        self.requried is a set that stores the required arguments\n        self.types is a dict that stores type of every arguments.\n        >>> parser.arguments\n        {'key1': 'value1', 'option1': True}\n        >>> parser.required\n        {'arg1'}\n        >>> parser.types\n        {'arg1': 'type1'}\n        \"\"\"\n        self.arguments = {}  # Dictionary to store parsed arguments and their values\n        self.required = set()  # Set to track which arguments are required\n        self.types = {}  # Dictionary mapping argument names to their expected types\n\n    def parse_arguments(self, command_string):\n        \"\"\"\n        Parses the given command line argument string and invoke _convert_type to stores the parsed result in specific type in the arguments dictionary.\n        Checks for missing required arguments, if any, and returns False with the missing argument names, otherwise returns True.\n        :param command_string: str, command line argument string, formatted like \"python script.py --arg1=value1 -arg2 value2 --option1 -option2\"\n        :return tuple: (True, None) if parsing is successful, (False, missing_args) if parsing fails,\n            where missing_args is a set of the missing argument names which are str.\n        >>> parser.parse_arguments(\"python script.py --arg1=value1 -arg2 value2 --option1 -option2\")\n        (True, None)\n        >>> parser.arguments\n        {'arg1': 'value1', 'arg2': 'value2', 'option1': True, 'option2': True}\n        \"\"\"\n\n        # Split the command string into individual arguments, skipping the script name\n        args = command_string.split()[1:]\n        \n        # Iterate through each argument\n        for i in range(len(args)):\n            arg = args[i]\n            # Handle long-form arguments (--arg)\n            if arg.startswith('--'):\n                key_value = arg[2:].split('=')\n                if len(key_value) == 2:\n                    # If argument is in format --arg=value\n                    self.arguments[key_value[0]] = self._convert_type(key_value[0], key_value[1])\n                else:\n                    # If argument is a flag (--arg without value)\n                    self.arguments[key_value[0]] = True\n            # Handle short-form arguments (-arg)\n            elif arg.startswith('-'):\n                key = arg[1:]\n                if i + 1 < len(args) and not args[i + 1].startswith('-'):\n                    # If next argument is a value (not starting with -)\n                    self.arguments[key] = self._convert_type(key, args[i + 1])\n                else:\n                    # If argument is a flag (-arg without value)\n                    self.arguments[key] = True\n\n        # Check if all required arguments are present\n        missing_args = self.required - set(self.arguments.keys())\n        if missing_args:\n            return False, missing_args\n\n        return True, None\n\n\n    def get_argument(self, arg):\n        \"\"\"\n        Retrieves the value of the specified argument from the arguments dictionary and returns it.\n        :param arg: str, argument name\n        :return: The value of the argument, or None if the argument does not exist.\n        >>> parser.arguments\n        {'arg1': 'value1', 'arg2': 'value2', 'option1': True, 'option2': True}\n        >>> parser.get_argument('arg2')\n        'value2'\n        \"\"\"\n\n        # Use the get method of the arguments dictionary to retrieve the value\n        # Returns None if the argument doesn't exist\n        return self.arguments.get(arg)\n\n    def add_argument(self, arg, required=False, arg_type=str):\n        \"\"\"\n        Adds an argument to self.types and self.required.\n        Check if it is a required argument and store the argument type.\n        If the argument is set as required, it wull be added to the required set.\n        The argument type and name are stored in the types dictionary as key-value pairs.\n        :param arg: str, argument name\n        :param required: bool, whether the argument is required, default is False\n        :param arg_type:str, Argument type, default is str\n        >>> parser.add_argument('arg1', True, 'int')\n        >>> parser.required\n        {'arg1'}\n        >>> parser.types\n        {'arg1': 'int'}\n        \"\"\"\n\n        # If the argument is required, add it to the required set\n        if required:\n            self.required.add(arg)\n        # Store the argument type in the types dictionary\n        self.types[arg] = arg_type\n\n\n    def _convert_type(self, arg, value):\n        \"\"\"\n        Try to convert the type of input value by searching in self.types.\n        :param value: str, the input value in command line\n        :return: return corresponding value in self.types if convert successfully, or the input value oherwise\n        >>> parser.types\n        {'arg1': int}\n        >>> parser._convert_type('arg1', '21')\n        21\n        \"\"\"\n\n        try:\n            # Attempt to convert the value to the type specified in self.types\n            # The type is used as a callable function to convert the value\n            return self.types[arg](value)\n        except (ValueError, KeyError):\n            # If the conversion fails (ValueError) or the argument doesn't have a type specified (KeyError)\n            # Return the original value without conversion\n            return value"}, {"id": "3", "llm_annotated_code": "import itertools\n\nclass ArrangementCalculator:\n    \"\"\"\n    The Arrangement class provides permutation calculations and selection operations for a given set of data elements.\n    \"\"\"\n\n    def __init__(self, datas):\n        \"\"\"\n        Initializes the ArrangementCalculator object with a list of datas.\n        :param datas: List, the data elements to be used for arrangements.\n        \"\"\"\n        # Store the input data elements for later use in permutation calculations\n        self.datas = datas\n\n    @staticmethod\n    def count(n, m=None):\n        \"\"\"\n        Counts the number of arrangements by choosing m items from n items (permutations).\n        If m is not provided or n equals m, returns factorial(n).\n        :param n: int, the total number of items.\n        :param m: int, the number of items to be chosen (default=None).\n        :return: int, the count of arrangements.\n        >>> ArrangementCalculator.count(5, 3)\n        60\n\n        \"\"\"\n\n        if m is None or n == m:\n            # If m is not provided or equals n, calculate n!\n            return ArrangementCalculator.factorial(n)\n        else:\n            # Calculate permutation P(n,m) = n! / (n-m)!\n            return ArrangementCalculator.factorial(n) // ArrangementCalculator.factorial(n - m)\n\n    @staticmethod\n    def count_all(n):\n        \"\"\"\n        Counts the total number of all possible arrangements by choosing at least 1 item and at most n items from n items.\n        :param n: int, the total number of items.\n        :return: int, the count of all arrangements.\n        >>> ArrangementCalculator.count_all(4)\n        64\n\n        \"\"\"\n\n        total = 0\n        # Sum up all permutation counts from choosing 1 to n items\n        for i in range(1, n + 1):\n            # Add P(n,i) for each i from 1 to n\n            total += ArrangementCalculator.count(n, i)\n        \n        return total\n\n\n    def select(self, m=None):\n        \"\"\"\n        Generates a list of arrangements by selecting m items from the internal datas.\n        If m is not provided, selects all items.\n        :param m: int, the number of items to be chosen (default=None).\n        :return: List, a list of arrangements.\n        >>> ac = ArrangementCalculator([1, 2, 3, 4])\n        >>> ac.select(2)\n        [[1, 2], [1, 3], [1, 4], [2, 1], [2, 3], [2, 4], [3, 1], [3, 2], [3, 4], [4, 1], [4, 2], [4, 3]]\n\n        \"\"\"\n\n        if m is None:\n            # If m is not provided, use the length of the data list\n            m = len(self.datas)\n\n        result = []\n        # Use itertools.permutations to generate all permutations of m items from self.datas\n        for permutation in itertools.permutations(self.datas, m):\n            # Convert each permutation tuple to a list and add to results\n            result.append(list(permutation))\n        \n        return result\n\n\n    def select_all(self):\n        \"\"\"\n        Generates a list of all arrangements by selecting at least 1 item and at most the number of internal datas.\n        :return: List, a list of all arrangements.\n        >>> ac = ArrangementCalculator([1, 2, 3])\n        >>> ac.select_all()\n        [[1], [2], [3], [1, 2], [1, 3], [2, 1], [2, 3], [3, 1], [3, 2], [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]\n\n        \"\"\"\n\n        result = []\n        # Generate permutations for all possible lengths from 1 to the length of data\n        for i in range(1, len(self.datas) + 1):\n            # Call the select method for each length and extend the result list\n            result.extend(self.select(i))\n        \n        return result\n\n\n    @staticmethod\n    def factorial(n):\n        \"\"\"\n        Calculates the factorial of a given number.\n        :param n: int, the number to calculate the factorial.\n        :return: int, the factorial of the given number.\n        >>> ArrangementCalculator.factorial(4)\n        24\n\n        \"\"\"\n\n        result = 1\n        # Multiply all integers from 2 to n to calculate factorial\n        for i in range(2, n + 1):\n            result *= i\n        return result"}, {"id": "4", "llm_annotated_code": "class AssessmentSystem:\n    \"\"\"\n    This is a class as an student assessment system, which supports add student, add course score, calculate GPA, and other functions for students and courses.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the students dict in assessment system.\n        \"\"\"\n        # Initialize an empty dictionary to store student information\n        self.students = {}\n\n    def add_student(self, name, grade, major):\n        \"\"\"\n        Add a new student into self.students dict\n        :param name: str, student name\n        :param grade: int, student grade\n        :param major: str, student major\n        >>> system.add_student('student 1', 3, 'SE')\n        >>> system.students\n        {'student 1': {'name': 'student 1', 'grade': 3, 'major': 'SE', 'courses': {}}}\n        \"\"\"\n        # Create a new entry in the students dictionary with the student's name as the key\n        # The value is a dictionary containing the student's details and an empty courses dictionary\n        self.students[name] = {'name': name, 'grade': grade, 'major': major, 'courses': {}}\n\n    def add_course_score(self, name, course, score):\n        \"\"\"\n        Add score of specific course for student in self.students\n        :param name: str, student name\n        :param course: str, course name\n        :param score: int, course score\n        >>> system.add_student('student 1', 3, 'SE')\n        >>> system.add_course_score('student 1', 'math', 94)\n        >>> system.students\n        {'student 1': {'name': 'student 1', 'grade': 3, 'major': 'SE', 'courses': {'math': 94}}}\n        \"\"\"\n        # Check if the student exists in the students dictionary\n        if name in self.students:\n            # Add the course and score to the student's courses dictionary\n            self.students[name]['courses'][course] = score\n\n    def get_gpa(self, name):\n        \"\"\"\n        Get average grade of one student.\n        :param name: str, student name\n        :return: if name is in students and this students have courses grade, return average grade(float)\n                    or None otherwise\n        >>> system.add_student('student 1', 3, 'SE')\n        >>> system.add_course_score('student 1', 'math', 94)\n        >>> system.add_course_score('student 1', 'Computer Network', 92)\n        >>> system.get_gpa('student 1')\n        93.0\n\n        \"\"\"\n        # Check if the student exists and has courses\n        if name in self.students and self.students[name]['courses']:\n            # Calculate the average of all course scores for the student\n            return sum(self.students[name]['courses'].values()) / len(self.students[name]['courses'])\n        else:\n            # Return None if the student doesn't exist or has no courses\n            return None\n\n    def get_all_students_with_fail_course(self):\n        \"\"\"\n        Get all students who have any score blow 60\n        :return: list of str ,student name\n        >>> system.add_course_score('student 1', 'Society', 59)\n        >>> system.get_all_students_with_fail_course()\n        ['student 1']\n        \"\"\"\n        # Initialize an empty list to store names of students with failing courses\n        students = []\n        \n        # Iterate through all students in the dictionary\n        for name, student in self.students.items():\n            # Check each course score for the student\n            for course, score in student['courses'].items():\n                # If any score is below 60, add the student to the list and break the inner loop\n                if score < 60:\n                    students.append(name)\n                    break\n        \n        # Return the list of students with failing courses\n        return students\n\n    def get_course_average(self, course):\n        \"\"\"\n        Get the average score of a specific course.\n        :param course: str, course name\n        :return: float, average scores of this course if anyone have score of this course, or None if nobody have records.\n        \"\"\"\n        # Initialize variables to track the total score and count of students\n        total = 0\n        count = 0\n        \n        # Iterate through all students\n        for student in self.students.values():\n            # Check if the student has taken the specified course\n            if course in student['courses']:\n                score = student['courses'][course]\n                # Only include non-None scores in the calculation\n                if score is not None:\n                    total += score\n                    count += 1\n        \n        # Return the average if at least one student has a score, otherwise return None\n        return total / count if count > 0 else None\n\n    def get_top_student(self):\n        \"\"\"\n        Calculate every student's gpa with get_gpa method, and find the student with highest gpa\n        :return: str, name of student whose gpa is highest\n        >>> system.add_student('student 1', 3, 'SE')\n        >>> system.add_student('student 2', 2, 'SE')\n        >>> system.add_course_score('student 1', 'Computer Network', 92)\n        >>> system.add_course_score('student 2', 'Computer Network', 97)\n        >>> system.get_top_student()\n        'student 2'\n        \"\"\"\n        # Initialize variables to track the top student and their GPA\n        top_student = None\n        top_gpa = 0\n        \n        # Iterate through all students\n        for name, student in self.students.items():\n            # Calculate the GPA for each student using the get_gpa method\n            gpa = self.get_gpa(name)\n            # Update top_student and top_gpa if this student has a higher GPA\n            if gpa is not None and gpa > top_gpa:\n                top_gpa = gpa\n                top_student = name\n        \n        # Return the name of the student with the highest GPA\n        return top_student"}, {"id": "5", "llm_annotated_code": "class AutomaticGuitarSimulator:\n\n    # This class is an automatic guitar simulator that can interpret and play based on the input guitar sheet music.\n\n    def __init__(self, text) -> None:\n        \"\"\"\n        Initialize the score to be played\n        :param text:str, score to be played\n        \"\"\"\n        # Store the input text as an instance variable to be used by other methods\n        self.play_text = text\n\n    def interpret(self, display=False):\n        \"\"\"\n        Interpret the music score to be played\n        :param display:Bool, representing whether to print the interpreted score\n        :return: list of dict, The dict includes two fields, Chord and Tune, which are letters and numbers, respectively. If the input is empty or contains only whitespace, an empty list is returned.\n        >>> context = AutomaticGuitarSimulator(\"C53231323 Em43231323 F43231323 G63231323\")\n        >>> play_list = context.interpret(display = False)\n        [{'Chord': 'C', 'Tune': '53231323'}, {'Chord': 'Em', 'Tune': '43231323'}, {'Chord': 'F', 'Tune': '43231323'}, {'Chord': 'G', 'Tune': '63231323'}]\n\n        \"\"\"\n\n        # Check if the input text is empty or contains only whitespace\n        if not self.play_text.strip():\n            return []\n        else:\n            # Initialize an empty list to store the interpreted score\n            play_list = []\n            # Split the input text by spaces to get individual chord-tune segments\n            play_segs = self.play_text.split(\" \")\n            # Process each segment\n            for play_seg in play_segs:\n                pos = 0\n                # Find the position where the chord ends and the tune begins\n                # Chords consist of alphabetic characters\n                for ele in play_seg:\n                    if ele.isalpha():\n                        pos += 1\n                        continue\n                    break\n                # Extract the chord and tune parts\n                play_chord = play_seg[0:pos]\n                play_value = play_seg[pos:]\n                # Add the chord and tune as a dictionary to the play list\n                play_list.append({'Chord': play_chord, 'Tune': play_value})\n                # If display is True, call the display method to print the chord and tune\n                if display:\n                    self.display(play_chord, play_value)\n            # Return the list of dictionaries containing chords and tunes\n            return play_list\n\n    def display(self, key, value):\n        \"\"\"\n        Print out chord and play tune with following format: Normal Guitar Playing -- Chord: %s, Play Tune: %s\n        :param key:str, chord\n        :param value:str, play tune\n        :return: str\n        >>> context = AutomaticGuitarSimulator(\"C53231323 Em43231323 F43231323 G63231323\")\n        >>> context.display(\"C\", \"53231323\")\n        Normal Guitar Playing -- Chord: C, Play Tune: 53231323\n\n        \"\"\"\n\n        # Format and return a string that displays the chord and tune information\n        # This is used by the interpret method when display=True\n        return \"Normal Guitar Playing -- Chord: %s, Play Tune: %s\" % (key, value)"}, {"id": "6", "llm_annotated_code": "class AvgPartition:\n    \"\"\"\n    This is a class that partitions the given list into different blocks by specifying the number of partitions, with each block having a uniformly distributed length.\n    \"\"\"\n\n    def __init__(self, lst, limit):\n        \"\"\"\n        Initialize the class with the given list and the number of partitions, and check if the number of partitions is greater than 0.\n        \"\"\"\n        # Store the input list in the instance variable\n        self.lst = lst\n        # Store the number of partitions in the instance variable\n        self.limit = limit\n\n    def setNum(self):\n        \"\"\"\n        Calculate the size of each block and the remainder of the division.\n        :return: the size of each block and the remainder of the division, tuple.\n        >>> a = AvgPartition([1, 2, 3, 4], 2)\n        >>> a.setNum()\n        (2, 0)\n\n        \"\"\"\n        # Calculate the base size of each partition by integer division\n        size = len(self.lst) // self.limit\n        # Calculate the remainder to determine how many partitions need an extra element\n        remainder = len(self.lst) % self.limit\n        # Return both values as a tuple\n        return size, remainder\n\n\n    def get(self, index):\n        \"\"\"\n        calculate the size of each block and the remainder of the division, and calculate the corresponding start and end positions based on the index of the partition.\n        :param index: the index of the partition,int.\n        :return: the corresponding block, list.\n        >>> a = AvgPartition([1, 2, 3, 4], 2)\n        >>> a.get(0)\n        [1, 2]\n\n        \"\"\"\n        # Call the setNum method to get the base size and remainder\n        size, remainder = self.setNum()\n        # Calculate the start position for this partition\n        # For partitions with index < remainder, they get an extra element\n        start = index * size + min(index, remainder)\n        # Calculate the end position based on the start and size\n        end = start + size\n        # If this partition should get an extra element (when index < remainder),\n        # increment the end position\n        if index + 1 <= remainder:\n            end += 1\n        # Return the slice of the list from start to end\n        return self.lst[start:end]"}, {"id": "7", "llm_annotated_code": "class BalancedBrackets:\n    \"\"\"\n    This is a class that checks for bracket matching\n    \"\"\"\n\n    def __init__(self, expr):\n        \"\"\"\n        Initializes the class with an expression.\n        :param expr: The expression to check for balanced brackets,str.\n        \"\"\"\n        # Initialize an empty stack to track opening brackets\n        self.stack = []\n        # Define the set of left (opening) brackets that will be pushed onto the stack\n        self.left_brackets = [\"(\", \"{\", \"[\"]\n        # Define the set of right (closing) brackets that will be matched with left brackets\n        self.right_brackets = [\")\", \"}\", \"]\"]\n        # Store the input expression to be processed\n        self.expr = expr\n\n    def clear_expr(self):\n        \"\"\"\n        Clears the expression of all characters that are not brackets.\n        >>> b = BalancedBrackets(\"a(b)c\")\n        >>> b.clear_expr()\n        >>> b.expr\n        '()'\n\n        \"\"\"\n        # Filter the expression to keep only characters that are either left or right brackets\n        # Uses a list comprehension to check each character against both bracket lists\n        # Joins the filtered characters back into a string and updates self.expr\n        self.expr = ''.join(c for c in self.expr if (c in self.left_brackets or c in self.right_brackets))\n\n    def check_balanced_brackets(self):\n        \"\"\"\n        Checks if the expression has balanced brackets.\n        :return: True if the expression has balanced brackets, False otherwise.\n        >>> b = BalancedBrackets(\"a(b)c\")\n        >>> b.check_balanced_brackets()\n        True\n\n        \"\"\"\n        # First call clear_expr to remove non-bracket characters from the expression\n        self.clear_expr()\n        \n        # Iterate through each character in the cleaned expression\n        for Brkt in self.expr:\n            # If the character is an opening bracket, push it onto the stack\n            if Brkt in self.left_brackets:\n                self.stack.append(Brkt)\n            # If the character is a closing bracket\n            else:\n                # Try to pop the most recent opening bracket from the stack\n                if self.stack:\n                    Current_Brkt = self.stack.pop()\n                # If the stack is empty, there's no matching opening bracket\n                else:\n                    continue\n                    \n                # Check if the current bracket pair matches\n                # For each type of opening bracket, verify the corresponding closing bracket\n                if Current_Brkt == \"(\":\n                    if Brkt != \")\":\n                        return False\n                if Current_Brkt == \"{\":\n                    if Brkt != \"}\":\n                        return False\n                if Current_Brkt == \"[\":\n                    if Brkt != \"]\":\n                        return False\n                        \n        # If there are still items in the stack, there are unclosed brackets\n        if self.stack:\n            return False\n            \n        # If we've processed all brackets and the stack is empty, the brackets are balanced\n        return True"}, {"id": "8", "llm_annotated_code": "class BankAccount:\n    \"\"\"\n    This is a class as a bank account system, which supports deposit money, withdraw money, view balance, and transfer money.\n    \"\"\"\n\n    def __init__(self, balance=0):\n        \"\"\"\n        Initializes a bank account object with an attribute balance, default value is 0.\n        \"\"\"\n        # Initialize the account with the provided balance (defaults to 0)\n        self.balance = balance\n\n    def deposit(self, amount):\n        \"\"\"\n        Deposits a certain amount into the account, increasing the account balance, return the current account balance.\n        If amount is negative, raise a ValueError(\"Invalid amount\").\n        :param amount: int\n        \"\"\"\n\n        # Check if the amount is negative and raise an error if it is\n        if amount < 0:\n            raise ValueError(\"Invalid amount\")\n        # Add the amount to the current balance\n        self.balance += amount\n        # Return the updated balance\n        return self.balance\n\n    def withdraw(self, amount):\n        \"\"\"\n        Withdraws a certain amount from the account, decreasing the account balance, return the current account balance.\n        If amount is negative, raise a ValueError(\"Invalid amount\").\n        If the withdrawal amount is greater than the account balance, raise a ValueError(\"Insufficient balance.\").\n        :param amount: int\n        \"\"\"\n\n        # Check if the amount is negative and raise an error if it is\n        if amount < 0:\n            raise ValueError(\"Invalid amount\")\n        # Check if there's enough balance for the withdrawal\n        if amount > self.balance:\n            raise ValueError(\"Insufficient balance.\")\n        # Subtract the amount from the current balance\n        self.balance -= amount\n        # Return the updated balance\n        return self.balance\n\n    def view_balance(self):\n        \"\"\"\n        Return the account balance.\n        \"\"\"\n        # Simply return the current balance\n        return self.balance\n\n    def transfer(self, other_account, amount):\n        \"\"\"\n        Transfers a certain amount from the current account to another account.\n        :param other_account: BankAccount\n        :param amount: int\n        >>> account1 = BankAccount()\n        >>> account2 = BankAccount()\n        >>> account1.deposit(1000)\n        >>> account1.transfer(account2, 300)\n        account1.balance = 700 account2.balance = 300\n        \"\"\"\n\n        # Call the withdraw method to remove the amount from this account\n        # This will handle validation like negative amounts and insufficient balance\n        self.withdraw(amount)\n        # Call the deposit method on the other account to add the amount\n        other_account.deposit(amount)"}, {"id": "10", "llm_annotated_code": "class BinaryDataProcessor:\n    \"\"\"\n    This is a class used to process binary data, which includes functions such as clearing non 0 or 1 characters, counting binary string information, and converting to corresponding strings based on different encoding methods.\n    \"\"\"\n\n    def __init__(self, binary_string):\n        \"\"\"\n        Initialize the class with a binary string and clean it by removing all non 0 or 1 characters.\n        \"\"\"\n        self.binary_string = binary_string\n        self.clean_non_binary_chars()\n\n    def clean_non_binary_chars(self):\n        \"\"\"\n        Clean the binary string by removing all non 0 or 1 characters.\n        >>> bdp = BinaryDataProcessor(\"01101000daf3e4r01100101011011000110110001101111\")\n        >>> bdp.clean_non_binary_chars()\n        >>> bdp.binary_string\n        '0110100001100101011011000110110001101111'\n\n        \"\"\"\n        # Use filter with a lambda function to keep only '0' and '1' characters\n        # Join the filtered characters back into a string and update self.binary_string\n        self.binary_string = ''.join(filter(lambda x: x in '01', self.binary_string))\n\n    def calculate_binary_info(self):\n        \"\"\"\n        Calculate the binary string information, including the percentage of 0 and 1, and the total length of the binary string.\n        >>> bdp = BinaryDataProcessor(\"0110100001100101011011000110110001101111\")\n        >>> bdp.calculate_binary_info()\n        {'Zeroes': 0.475, 'Ones': 0.525, 'Bit length': 40}\n\n        \"\"\"\n        # Count the number of '0' characters in the binary string\n        zeroes_count = self.binary_string.count('0')\n        # Count the number of '1' characters in the binary string\n        ones_count = self.binary_string.count('1')\n        # Get the total length of the binary string\n        total_length = len(self.binary_string)\n        # Calculate the percentage of '0' characters\n        zeroes_percentage = (zeroes_count / total_length)\n        # Calculate the percentage of '1' characters\n        ones_percentage = (ones_count / total_length)\n\n        # Return a dictionary containing the calculated information\n        return {\n            'Zeroes': zeroes_percentage,\n            'Ones': ones_percentage,\n            'Bit length': total_length\n        }\n\n    def convert_to_ascii(self):\n        \"\"\"\n        Convert the binary string to ascii string.\n        >>> bdp = BinaryDataProcessor(\"0110100001100101011011000110110001101111\")\n        >>> bdp.convert_to_ascii()\n        'hello'\n\n        \"\"\"\n        # Create an empty bytearray to store the bytes\n        byte_array = bytearray()\n        # Iterate through the binary string in 8-bit chunks\n        for i in range(0, len(self.binary_string), 8):\n            # Extract an 8-bit chunk\n            byte = self.binary_string[i:i+8]\n            # Convert the binary chunk to decimal\n            decimal = int(byte, 2)\n            # Append the decimal value to the byte array\n            byte_array.append(decimal)\n        # Decode the byte array using ASCII encoding and return the result\n        return byte_array.decode('ascii')\n\n    def convert_to_utf8(self):\n        \"\"\"\n        Convert the binary string to utf-8 string.\n        >>> bdp = BinaryDataProcessor(\"0110100001100101011011000110110001101111\")\n        >>> bdp.convert_to_utf8()\n        'hello'\n\n        \"\"\"\n        # Create an empty bytearray to store the bytes\n        byte_array = bytearray()\n        # Iterate through the binary string in 8-bit chunks\n        for i in range(0, len(self.binary_string), 8):\n            # Extract an 8-bit chunk\n            byte = self.binary_string[i:i+8]\n            # Convert the binary chunk to decimal\n            decimal = int(byte, 2)\n            # Append the decimal value to the byte array\n            byte_array.append(decimal)\n        # Decode the byte array using UTF-8 encoding and return the result\n        return byte_array.decode('utf-8')"}, {"id": "11", "llm_annotated_code": "class BitStatusUtil:\n    \"\"\"\n    This is a utility class that provides methods for manipulating and checking status using bitwise operations.\n    \"\"\"\n\n    @staticmethod\n    def add(states, stat):\n        \"\"\"\n        Add a status to the current status,and check the parameters wheather they are legal.\n        :param states: Current status,int.\n        :param stat: Status to be added,int.\n        :return: The status after adding the status,int.\n        >>> bit_status_util = BitStatusUtil()\n        >>> bit_status_util.add(2,4)\n        6\n\n        \"\"\"\n\n        # Call the check method to validate that both states and stat are legal values\n        BitStatusUtil.check([states, stat])\n        # Use bitwise OR operator to combine the states and stat\n        # This adds the bit flags in stat to states without duplicating any\n        return states | stat\n\n    @staticmethod\n    def has(states, stat):\n        \"\"\"\n        Check if the current status contains the specified status,and check the parameters wheather they are legal.\n        :param states: Current status,int.\n        :param stat: Specified status,int.\n        :return: True if the current status contains the specified status,otherwise False,bool.\n        >>> bit_status_util = BitStatusUtil()\n        >>> bit_status_util.has(6,2)\n        True\n\n        \"\"\"\n\n        # Call the check method to validate that both states and stat are legal values\n        BitStatusUtil.check([states, stat])\n        # Use bitwise AND to check if all bits in stat are also set in states\n        # If the result equals stat, then states contains all the bits in stat\n        return (states & stat) == stat\n\n    @staticmethod\n    def remove(states, stat):\n        \"\"\"\n        Remove the specified status from the current status,and check the parameters wheather they are legal.\n        :param states: Current status,int.\n        :param stat: Specified status,int.\n        :return: The status after removing the specified status,int.\n        >>> bit_status_util = BitStatusUtil()\n        >>> bit_status_util.remove(6,2)\n        4\n\n        \"\"\"\n\n        # Call the check method to validate that both states and stat are legal values\n        BitStatusUtil.check([states, stat])\n        # Check if states contains the stat using the has method\n        if BitStatusUtil.has(states, stat):\n            # Use bitwise XOR to remove the stat from states\n            # XOR will flip the bits that are set in stat, effectively removing them\n            return states ^ stat\n        # If states doesn't contain stat, return states unchanged\n        return states\n\n    @staticmethod\n    def check(args):\n        \"\"\"\n        Check if the parameters are legal, args must be greater than or equal to 0 and must be even,if not,raise ValueError.\n        :param args: Parameters to be checked,list.\n        :return: None.\n        >>> bit_status_util = BitStatusUtil()\n        >>> bit_status_util.check([2,3,4])\n        Traceback (most recent call last):\n        ...\n        ValueError: 3 not even\n        \"\"\"\n\n        # Iterate through each argument in the list\n        for arg in args:\n            # Check if the argument is negative\n            if arg < 0:\n                # Raise ValueError if the argument is negative\n                raise ValueError(f\"{arg} must be greater than or equal to 0\")\n            # Check if the argument is odd\n            if arg % 2 != 0:\n                # Raise ValueError if the argument is odd\n                raise ValueError(f\"{arg} not even\")"}, {"id": "12", "llm_annotated_code": "```python\nimport random\nclass BlackjackGame:\n    \"\"\"\n    This is a class representing a game of blackjack, which includes creating a deck, calculating the value of a hand, and determine the winner based on the hand values of the player and dealer.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the Blackjack Game with the attribute deck, player_hand and dealer_hand.\n        While initializing deck attribute, call the create_deck method to generate.\n        The deck stores 52 random order poker with the Jokers removed, format is ['AS', '2S', ...].\n        player_hand is a list which stores player's hand cards.\n        dealer_hand is is a list which stores dealer's hand cards.\n        \"\"\"\n        # Call the create_deck method to generate a shuffled deck of cards\n        self.deck = self.create_deck()\n        # Initialize an empty list to store the player's cards\n        self.player_hand = []\n        # Initialize an empty list to store the dealer's cards\n        self.dealer_hand = []\n\n    def create_deck(self):\n        \"\"\"\n        Create a deck of 52 cards, which stores 52 random order poker with the Jokers removed.\n        :return: a list of 52 random order poker with the Jokers removed, format is ['AS', '2S', ...].\n        >>> black_jack_game = BlackjackGame()\n        >>> black_jack_game.create_deck()\n        ['QD', '9D', 'JC', 'QH', '2S', 'JH', '7D', '6H', '9S', '5C', '7H', 'QS', '5H',\n        '6C', '7C', '3D', '10C', 'AD', '4C', '5D', 'AH', '2D', 'QC', 'KH', '9C', '9H',\n        '4H', 'JS', '6S', '8H', '8C', '4S', '3H', '10H', '7S', '6D', '3C', 'KC', '3S',\n        '2H', '10D', 'KS', '4D', 'AC', '10S', '2C', 'KD', '5S', 'JD', '8S', 'AS', '8D']\n        \"\"\"\n\n        # Initialize an empty list to store the deck of cards\n        deck = []\n        # Define the four suits in a standard deck of cards\n        suits = ['S', 'C', 'D', 'H']\n        # Define the thirteen ranks in a standard deck of cards\n        ranks = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K']\n        # Create each card by combining each rank with each suit\n        for suit in suits:\n            for rank in ranks:\n                deck.append(rank + suit)\n        # Use the random.shuffle function to randomize the order of the cards in the deck\n        random.shuffle(deck)\n        # Return the shuffled deck\n        return deck\n\n    def calculate_hand_value(self, hand):\n        \"\"\"\n        Calculate the value of the poker cards stored in hand list according to the rules of the Blackjack Game.\n        If the card is a digit, its value is added to the total hand value.\n        Value of J, Q, or K is 10, while Aces are worth 11.\n        If the total hand value exceeds 21 and there are Aces present, one Ace is treated as having a value of 1 instead of 11,\n        until the hand value is less than or equal to 21, or all Aces have been counted as value of 1.\n        :param hand: list\n        :return: the value of the poker cards stored in hand list, a number.\n        >>> black_jack_game.calculate_hand_value(['QD', '9D', 'JC', 'QH', 'AS'])\n        40\n        \"\"\"\n\n        # Initialize the total value of the hand to 0\n        value = 0\n        # Initialize a counter for the number of Aces in the hand\n        num_aces = 0\n        # Iterate through each card in the hand\n        for card in hand:\n            # Extract the rank of the card (all characters except the last one, which is the suit)\n            rank = card[:-1]\n            # If the rank is a digit, add its integer value to the total\n            if rank.isdigit():\n                value += int(rank)\n            # If the rank is a face card (J, Q, K), add 10 to the total\n            elif rank in ['J', 'Q', 'K']:\n                value += 10\n            # If the rank is an Ace, add 11 to the total and increment the Ace counter\n            elif rank == 'A':\n                value += 11\n                num_aces += 1\n        # If the total value exceeds 21 and there are Aces in the hand,\n        # convert Aces from value 11 to value 1 until the total is 21 or less,\n        # or until all Aces have been converted\n        while value > 21 and num_aces > 0:\n            value -= 10\n            num_aces -= 1\n        # Return the final calculated value of the hand\n        return value\n\n    def check_winner(self, player_hand, dealer_hand):\n        \"\"\"\n        Determines the winner of a game by comparing the hand values of the player and dealer.\n        rule:\n        If both players have hand values that are equal to or less than 21, the winner is the one whose hand value is closer to 21.\n        Otherwise, the winner is the one with the lower hand value.\n        :param player_hand: list\n        :param dealer_hand: list\n        :return: the result of the game, only two certain str: 'Dealer wins' or 'Player wins'\n        >>> black_jack_game.check_winner(['QD', '9D', 'JC', 'QH', 'AS'], ['QD', '9D', 'JC', 'QH', '2S'])\n        'Player wins'\n        \"\"\"\n        # Calculate the value of the player's hand using the calculate_hand_value method\n        player_value = self.calculate_hand_value(player_hand)\n        # Calculate the value of the dealer's hand using the calculate_hand_value method\n        dealer_value = self.calculate_hand_value(dealer_hand)\n        \n        # If both player and dealer bust (exceed 21), the one with the lower value wins\n        if player_value > 21 and dealer_value > 21:\n            if player_value < dealer_value:\n                return 'Player wins'\n            elif player_value > dealer_value:\n                return 'Dealer wins'\n        # If only the player busts, the dealer wins\n        elif player_value > 21:\n            return 'Dealer wins'\n        # If only the dealer busts, the player wins\n        elif dealer_value > 21:\n            return 'Player wins'\n        # If neither busts, the one with the higher value wins\n        else:\n            if player_value < dealer_value:\n                return 'Dealer wins'\n            elif player_value > dealer_value:\n                return 'Player wins'\n```"}, {"id": "13", "llm_annotated_code": "class BookManagement:\n    \"\"\"\n    This is a class as managing books system, which supports to add and remove books from the inventory dict, view the inventory, and check the quantity of a specific book.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the inventory of Book Manager.\n        \"\"\"\n        # Initialize an empty dictionary to store book titles as keys and quantities as values\n        self.inventory = {}\n\n    def add_book(self, title, quantity=1):\n        \"\"\"\n        Add one or several books to inventory which is sorted by book title.\n        :param title: str, the book title\n        :param quantity: int, default value is 1.\n        \"\"\"\n\n        # Check if the book title already exists in the inventory\n        if title in self.inventory:\n            # If it exists, increment the quantity by the specified amount\n            self.inventory[title] += quantity\n        else:\n            # If it doesn't exist, add a new entry with the specified quantity\n            self.inventory[title] = quantity\n\n    def remove_book(self, title, quantity):\n        \"\"\"\n        Remove one or several books from inventory which is sorted by book title.\n        Raise false while get invalid input.\n        :param title: str, the book title\n        :param quantity: int\n        \"\"\"\n\n        # Check if the book title doesn't exist or if there are not enough books to remove\n        if title not in self.inventory or self.inventory[title] < quantity:\n            # Raise False (note: this is unusual - typically would raise an Exception)\n            raise False\n        \n        # Decrement the quantity of the book by the specified amount\n        self.inventory[title] -= quantity\n        \n        # If the quantity becomes zero, remove the book from the inventory\n        if self.inventory[title] == 0:\n            del (self.inventory[title])\n\n    def view_inventory(self):\n        \"\"\"\n        Get the inventory of the Book Management.\n        :return self.inventory: dictionary, {title(str): quantity(int), ...}\n        >>> bookManagement = BookManagement()\n        >>> bookManagement.add_book(\"book1\", 1)\n        >>> bookManagement.add_book(\"book2\", 1)\n        >>> bookManagement.view_inventory()\n        {'book1': 1, 'book2': 1}\n        \"\"\"\n\n        # Return the entire inventory dictionary\n        return self.inventory\n\n    def view_book_quantity(self, title):\n        \"\"\"\n        Get the quantity of a book.\n        :param title: str, the title of the book.\n        :return quantity: the quantity of this book title. return 0 when the title does not exist in self.invenroty\n        >>> bookManagement = BookManagement()\n        >>> bookManagement.add_book(\"book1\", 1)\n        >>> bookManagement.view_book_quantity(\"book3\")\n        0\n        \"\"\"\n\n        # Check if the book title doesn't exist in the inventory\n        if title not in self.inventory:\n            # Return 0 if the book doesn't exist\n            return 0\n        \n        # Return the quantity of the specified book\n        return self.inventory[title]"}, {"id": "14", "llm_annotated_code": "import sqlite3\n\nclass BookManagementDB:\n    '''\n    This is a database class as a book management system, used to handle the operations of adding, removing, updating, and searching books.\n    '''\n\n\n    def __init__(self, db_name):\n        '''\n        Initializes the class by creating a database connection and cursor, \n        and creates the book table if it does not already exist\n        :param db_name: str, the name of db file\n        '''\n        # Create a connection to the SQLite database with the provided name\n        self.connection = sqlite3.connect(db_name)\n        # Create a cursor object to execute SQL commands\n        self.cursor = self.connection.cursor()\n        # Call the create_table method to ensure the books table exists\n        self.create_table()\n\n    def create_table(self):\n        '''\n        Creates the book table in the database if it does not already exist.\n        >>> book_db = BookManagementDB(\"test.db\")\n        >>> book_db.create_table()\n        '''\n\n        # Execute SQL to create the books table if it doesn't exist\n        # The table has columns for id (primary key), title, author, and availability status\n        self.cursor.execute('''\n            CREATE TABLE IF NOT EXISTS books (\n                id INTEGER PRIMARY KEY,\n                title TEXT,\n                author TEXT,\n                available INTEGER\n            )\n        ''')\n        # Commit the changes to the database\n        self.connection.commit()\n\n    def add_book(self, title, author):\n        '''\n        Adds a book to the database with the specified title and author, \n        setting its availability to 1 as free to borrow.\n        :param title: str, book title\n        :param author: str, author name\n        >>> book_db = BookManagementDB(\"test.db\")\n        >>> book_db.create_table()\n        >>> book_db.add_book('book1', 'author')\n        '''\n\n        # Execute SQL to insert a new book record with the given title and author\n        # The available field is set to 1 (available for borrowing)\n        self.cursor.execute('''\n            INSERT INTO books (title, author, available)\n            VALUES (?, ?, 1)\n        ''', (title, author))\n        # Commit the changes to the database\n        self.connection.commit()\n\n    def remove_book(self, book_id):\n        '''\n        Removes a book from the database based on the given book ID.\n        :param book_id: int\n        >>> book_db = BookManagementDB(\"test.db\")\n        >>> book_db.remove_book(1)\n        '''\n\n        # Execute SQL to delete the book with the specified ID\n        self.cursor.execute('''\n            DELETE FROM books WHERE id = ?\n        ''', (book_id,))\n        # Commit the changes to the database\n        self.connection.commit()\n\n    def borrow_book(self, book_id):\n        '''\n        Marks a book as borrowed in the database based on the given book ID.\n        :param book_id: int\n        >>> book_db = BookManagementDB(\"test.db\")\n        >>> book_db.borrow_book(1)\n        '''\n\n        # Execute SQL to update the book's available status to 0 (not available/borrowed)\n        self.cursor.execute('''\n            UPDATE books SET available = 0 WHERE id = ?\n        ''', (book_id,))\n        # Commit the changes to the database\n        self.connection.commit()\n\n    def return_book(self, book_id):\n        '''\n        Marks a book as returned in the database based on the given book ID.\n        :param book_id: int\n        >>> book_db = BookManagementDB(\"test.db\")\n        >>> book_db.return_book(1)\n        '''\n\n        # Execute SQL to update the book's available status to 1 (available/returned)\n        self.cursor.execute('''\n            UPDATE books SET available = 1 WHERE id = ?\n        ''', (book_id,))\n        # Commit the changes to the database\n        self.connection.commit()\n\n    def search_books(self):\n        '''\n        Retrieves all books from the database and returns their information.\n        :return books: list[tuple], the information of all books in database\n        >>> book_db.search_books()\n        [(1, 'book1', 'author', 1)]\n        '''\n\n        # Execute SQL to select all books from the database\n        self.cursor.execute('''\n            SELECT * FROM books\n        ''')\n        # Fetch all the results as a list of tuples\n        books = self.cursor.fetchall()\n        # Return the list of books\n        return books"}, {"id": "15", "llm_annotated_code": "class BoyerMooreSearch:\n    \"\"\"\n    This is a class that implements the Boyer-Moore algorithm for string searching, which is used to find occurrences of a pattern within a given text.\n    \"\"\"\n\n    def __init__(self, text, pattern):\n        \"\"\"\n        Initializes the BoyerMooreSearch class with the given text and pattern.\n        :param text: The text to be searched, str.\n        :param pattern: The pattern to be searched for, str.\n        \"\"\"\n        # Store the input text and pattern as instance variables\n        self.text, self.pattern = text, pattern\n        # Calculate and store the lengths of the text and pattern for later use\n        self.textLen, self.patLen = len(text), len(pattern)\n\n    def match_in_pattern(self, char):\n        \"\"\"\n        Finds the rightmost occurrence of a character in the pattern.\n        :param char: The character to be searched for, str.\n        :return: The index of the rightmost occurrence of the character in the pattern, int.\n        >>> boyerMooreSearch = BoyerMooreSearch(\"ABAABA\", \"AB\")\n        >>> boyerMooreSearch.match_in_pattern(\"A\")\n        0\n\n        \"\"\"\n        # Iterate through the pattern from right to left\n        for i in range(self.patLen - 1, -1, -1):\n            # If the character at the current position matches the input character\n            if char == self.pattern[i]:\n                # Return the index of the match\n                return i\n        # Return -1 if the character is not found in the pattern\n        return -1\n\n    def mismatch_in_text(self, currentPos):\n        \"\"\"\n        Determines the position of the first mismatch between the pattern and the text.\n        :param currentPos: The current position in the text, int.\n        :return: The position of the first mismatch between the pattern and the text, int,otherwise -1.\n        >>> boyerMooreSearch = BoyerMooreSearch(\"ABAABA\", \"ABC\")\n        >>> boyerMooreSearch.mismatch_in_text(0)\n        2\n\n        \"\"\"\n        # Iterate through the pattern from right to left\n        for i in range(self.patLen - 1, -1, -1):\n            # Compare the character in the pattern with the corresponding character in the text\n            if self.pattern[i] != self.text[currentPos + i]:\n                # Return the position in the text where the mismatch occurs\n                return currentPos + i\n        # Return -1 if no mismatch is found (pattern matches the text at the current position)\n        return -1\n\n    def bad_character_heuristic(self):\n        \"\"\"\n        Finds all occurrences of the pattern in the text.\n        :return: A list of all positions of the pattern in the text, list.\n        >>> boyerMooreSearch = BoyerMooreSearch(\"ABAABA\", \"AB\")\n        >>> boyerMooreSearch.bad_character_heuristic()\n        [0, 3]\n\n        \"\"\"\n        # Initialize an empty list to store the positions where the pattern is found\n        positions = []\n        # Start searching from the beginning of the text\n        i = 0\n        # Continue until we reach the end of the text minus the pattern length\n        while i <= self.textLen - self.patLen:\n            # Check for a mismatch at the current position using the mismatch_in_text method\n            mismatch_index = self.mismatch_in_text(i)\n            # If no mismatch is found, the pattern matches at the current position\n            if mismatch_index == -1:\n                # Add the current position to the list of matches\n                positions.append(i)\n                # Move to the next position in the text\n                i += 1\n            else:\n                # Find the rightmost occurrence of the mismatched character in the pattern\n                match_index = self.match_in_pattern(self.text[mismatch_index])\n                # Shift the pattern based on the bad character rule\n                # Take the maximum of 1 and the difference between the mismatch index and match index\n                i += max(1, mismatch_index - match_index)\n        # Return the list of positions where the pattern was found\n        return positions"}, {"id": "16", "llm_annotated_code": "class Calculator:\n    \"\"\"\n    This is a class for a calculator, capable of performing basic arithmetic calculations on numerical expressions using the operators +, -, *, /, and ^ (exponentiation).\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the operations performed by the five operators'+','-','*','/','^'\n        \"\"\"\n        # Define a dictionary mapping operators to their corresponding lambda functions\n        # Each lambda function takes two arguments and performs the appropriate operation\n        self.operators = {\n            '+': lambda x, y: x + y,\n            '-': lambda x, y: x - y,\n            '*': lambda x, y: x * y,\n            '/': lambda x, y: x / y,\n            '^': lambda x, y: x ** y\n        }\n\n    def calculate(self, expression):\n        \"\"\"\n        Calculate the value of a given expression\n        :param expression: string, given expression\n        :return:If successful, returns the value of the expression; otherwise, returns None\n        >>> calculator = Calculator()\n        >>> calculator.calculate('1+2-3')\n        0.0\n        \"\"\"\n\n        # Initialize stacks for operands and operators\n        operand_stack = []\n        operator_stack = []\n        num_buffer = ''\n        \n        # Iterate through each character in the expression\n        for char in expression:\n            # If the character is a digit or decimal point, add it to the number buffer\n            if char.isdigit() or char == '.':\n                num_buffer += char\n            else:\n                # If there's a number in the buffer, convert it to float and add to operand stack\n                if num_buffer:\n                    operand_stack.append(float(num_buffer))\n                    num_buffer = ''\n                \n                # Handle operators based on their type\n                if char in '+-*/^':\n                    # Apply operators with higher or equal precedence before adding current operator\n                    while (\n                            operator_stack and\n                            operator_stack[-1] != '(' and\n                            self.precedence(operator_stack[-1]) >= self.precedence(char)\n                    ):\n                        # Call apply_operator method to perform calculation with stacked operators\n                        operand_stack, operator_stack = self.apply_operator(operand_stack, operator_stack)\n                    # Add current operator to the stack\n                    operator_stack.append(char)\n                elif char == '(':\n                    # Push opening parenthesis to operator stack\n                    operator_stack.append(char)\n                elif char == ')':\n                    # Apply all operators until matching opening parenthesis is found\n                    while operator_stack and operator_stack[-1] != '(':\n                        operand_stack, operator_stack = self.apply_operator(operand_stack, operator_stack)\n                    # Remove the opening parenthesis\n                    operator_stack.pop()\n        \n        # Process any remaining number in the buffer\n        if num_buffer:\n            operand_stack.append(float(num_buffer))\n        \n        # Apply any remaining operators\n        while operator_stack:\n            operand_stack, operator_stack = self.apply_operator(operand_stack, operator_stack)\n        \n        # Return the final result or None if no result\n        return operand_stack[-1] if operand_stack else None\n\n    def precedence(self, operator):\n        \"\"\"\n        Returns the priority of the specified operator, where the higher the priority, the greater the assignment. The priority of '^' is greater than '/' and '*', and the priority of '/' and '*' is greater than '+' and '-'\n        :param operator: string, given operator\n        :return: int, the priority of the given operator, otherwise return 0\n        >>> calculator = Calculator()\n        >>> calculator.precedence('+')\n        1\n        >>> calculator.precedence('^')\n        3\n        \"\"\"\n\n        # Define a dictionary mapping operators to their precedence levels\n        # Higher number means higher precedence\n        precedences = {\n            '+': 1,\n            '-': 1,\n            '*': 2,\n            '/': 2,\n            '^': 3\n        }\n        # Return the precedence of the operator or 0 if not found\n        return precedences.get(operator, 0)\n\n    def apply_operator(self, operand_stack, operator_stack):\n        \"\"\"\n        Use the operator at the top of the operator stack to perform the operation on the two numbers at the top of the operator stack, and store the results at the top of the operator stack\n        :param operand_stack:list\n        :param operator_stack:list\n        :return: the updated operand_stack and operator_stack\n        >>> calculator = Calculator()\n        >>> calculator.apply_operator([1, 2, 3], ['+', '-'])\n        ([1, -1], ['-'])\n        \"\"\"\n\n        # Pop the top operator from the operator stack\n        operator = operator_stack.pop()\n        # Pop the top two operands from the operand stack\n        operand2 = operand_stack.pop()\n        operand1 = operand_stack.pop()\n        # Apply the operator to the operands using the lambda function from self.operators\n        result = self.operators[operator](operand1, operand2)\n        # Push the result back onto the operand stack\n        operand_stack.append(result)\n        # Return the updated stacks\n        return operand_stack, operator_stack"}, {"id": "17", "llm_annotated_code": "from datetime import datetime, timedelta\n\nclass CalendarUtil:\n    \"\"\"\n    This is a class as CalendarUtil that provides functionalities to manage calendar events, schedule appointments, and perform conflict checks.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the calendar with an empty list of events.\n        \"\"\"\n        # Initialize an empty list to store calendar events\n        self.events = []\n\n    def add_event(self, event):\n        \"\"\"\n        Add an event to the calendar.\n        :param event: The event to be added to the calendar,dict.\n        >>> calendar = CalendarUtil()\n        >>> calendar.add_event({'date': datetime(2023, 1, 1, 0, 0), 'start_time': datetime(2023, 1, 1, 0, 0), 'end_time': datetime(2023, 1, 1, 1, 0), 'description': 'New Year'})\n        >>> calendar.events\n        [{'date': datetime.datetime(2023, 1, 1, 0, 0), 'start_time': datetime.datetime(2023, 1, 1, 0, 0), 'end_time': datetime.datetime(2023, 1, 1, 1, 0), 'description': 'New Year'}]\n\n        \"\"\"\n        # Append the provided event dictionary to the events list\n        self.events.append(event)\n\n    def remove_event(self, event):\n        \"\"\"\n        Remove an event from the calendar.\n        :param event: The event to be removed from the calendar,dict.\n        >>> calendar = CalendarUtil()\n        >>> calendar.events = [{'date': datetime(2023, 1, 1, 0, 0), 'start_time': datetime(2023, 1, 1, 0, 0), 'end_time': datetime(2023, 1, 1, 1, 0), 'description': 'New Year'}]\n        >>> calendar.remove_event({'date': datetime(2023, 1, 1, 0, 0), 'start_time': datetime(2023, 1, 1, 0, 0), 'end_time': datetime(2023, 1, 1, 1, 0), 'description': 'New Year'})\n        >>> calendar.events\n        []\n\n        \"\"\"\n        # Check if the event exists in the events list\n        if event in self.events:\n            # Remove the event from the events list\n            self.events.remove(event)\n\n    def get_events(self, date):\n        \"\"\"\n        Get all events on a given date.\n        :param date: The date to get events for,datetime.\n        :return: A list of events on the given date,list.\n        >>> calendar = CalendarUtil()\n        >>> calendar.events = [{'date': datetime(2023, 1, 1, 0, 0), 'start_time': datetime(2023, 1, 1, 0, 0), 'end_time': datetime(2023, 1, 1, 1, 0), 'description': 'New Year'}]\n        >>> calendar.get_events(datetime(2023, 1, 1, 0, 0))\n        [{'date': datetime.datetime(2023, 1, 1, 0, 0), 'start_time': datetime.datetime(2023, 1, 1, 0, 0), 'end_time': datetime.datetime(2023, 1, 1, 1, 0), 'description': 'New Year'}]\n\n        \"\"\"\n        # Initialize an empty list to store events on the specified date\n        events_on_date = []\n        \n        # Iterate through all events in the calendar\n        for event in self.events:\n            # Compare the date part of the event's date with the date part of the input date\n            if event['date'].date() == date.date():\n                # If they match, add the event to the list\n                events_on_date.append(event)\n        \n        # Return the list of events on the specified date\n        return events_on_date\n\n    def is_available(self, start_time, end_time):\n        \"\"\"\n        Check if the calendar is available for a given time slot.\n        :param start_time: The start time of the time slot,datetime.\n        :param end_time: The end time of the time slot,datetime.\n        :return: True if the calendar is available for the given time slot, False otherwise,bool.\n        >>> calendar = CalendarUtil()\n        >>> calendar.events = [{'date': datetime(2023, 1, 1, 0, 0), 'start_time': datetime(2023, 1, 1, 0, 0), 'end_time': datetime(2023, 1, 1, 1, 0), 'description': 'New Year'}]\n        >>> calendar.is_available(datetime(2023, 1, 1, 0, 0), datetime(2023, 1, 1, 1, 0))\n        False\n\n        \"\"\"\n        # Iterate through all events in the calendar\n        for event in self.events:\n            # Check if the given time slot overlaps with any existing event\n            # An overlap occurs if the start time is before the event's end time\n            # and the end time is after the event's start time\n            if start_time < event['end_time'] and end_time > event['start_time']:\n                # If there's an overlap, the time slot is not available\n                return False\n        \n        # If no overlaps are found, the time slot is available\n        return True\n\n    def get_available_slots(self, date):\n        \"\"\"\n        Get all available time slots on a given date.\n        :param date: The date to get available time slots for,datetime.\n        :return: A list of available time slots on the given date,list.\n        >>> calendar = CalendarUtil()\n        >>> calendar.events = [{'date': datetime(2023, 1, 1, 0, 0), 'start_time': datetime(2023, 1, 1, 0, 0), 'end_time': datetime(2023, 1, 1, 23, 0), 'description': 'New Year'}]\n        >>> calendar.get_available_slots(datetime(2023, 1, 1))\n        [(datetime.datetime(2023, 1, 1, 23, 0), datetime.datetime(2023, 1, 2, 0, 0))]\n\n        \"\"\"\n        # Initialize an empty list to store available time slots\n        available_slots = []\n        \n        # Set the start time to the beginning of the specified date (midnight)\n        start_time = datetime(date.year, date.month, date.day, 0, 0)\n        \n        # Set the end time to the end of the specified date (23:59)\n        end_time = datetime(date.year, date.month, date.day, 23, 59)\n\n        # Iterate through the day in 1-hour increments\n        while start_time < end_time:\n            # Calculate the end time of the current 1-hour slot\n            slot_end_time = start_time + timedelta(minutes=60)\n            \n            # Check if the current time slot is available\n            if self.is_available(start_time, slot_end_time):\n                # If available, add the slot to the list of available slots\n                available_slots.append((start_time, slot_end_time))\n            \n            # Move to the next 1-hour slot\n            start_time += timedelta(minutes=60)\n        \n        # Return the list of available time slots\n        return available_slots\n\n    def get_upcoming_events(self, num_events):\n        \"\"\"\n        Get the next n upcoming events from a given date.\n        :param date: The date to get upcoming events from,datetime.\n        :param n: The number of upcoming events to get,int.\n        :return: A list of the next n upcoming events from the given date,list.\n        >>> calendar = CalendarUtil()\n        >>> calendar.events = [{'date': datetime(2023, 1, 1, 0, 0), 'start_time': datetime(2023, 1, 1, 0, 0), 'end_time': datetime(2023, 1, 1, 23, 0), 'description': 'New Year'},{'date': datetime(2023, 1, 2, 0, 0),'end_time': datetime(2023, 1, 2, 1, 0), 'description': 'New Year 2'}]\n        >>> calendar.get_upcoming_events(1)\n        [{'date': datetime.datetime(2023, 1, 1, 0, 0), 'start_time': datetime.datetime(2023, 1, 1, 0, 0), 'end_time': datetime.datetime(2023, 1, 1, 23, 0), 'description': 'New Year'}, {'date': datetime.datetime(2023, 1, 2, 0, 0), 'end_time': datetime.datetime(2023, 1, 2, 1, 0), 'description': 'New Year 2'}]\n\n        \"\"\"\n        # Get the current date and time\n        now = datetime.now()\n        \n        # Initialize an empty list to store upcoming events\n        upcoming_events = []\n\n        # Iterate through all events in the calendar\n        for event in self.events:\n            # Check if the event's start time is in the future\n            if event['start_time'] >= now:\n                # If it is, add it to the list of upcoming events\n                upcoming_events.append(event)\n            \n            # If we've collected the requested number of events, stop\n            if len(upcoming_events) == num_events:\n                break\n        \n        # Return the list of upcoming events\n        return upcoming_events"}, {"id": "18", "llm_annotated_code": "class CamelCaseMap:\n    \"\"\"\n    This is a custom class that allows keys to be in camel case style by converting them from underscore style, which provides dictionary-like functionality.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize data to an empty dictionary\n        \"\"\"\n        # Initialize an empty dictionary to store the data\n        self._data = {}\n\n    def __getitem__(self, key):\n        \"\"\"\n        Return the value corresponding to the key\n        :param key:str\n        :return:str,the value corresponding to the key\n        >>> camelize_map = CamelCaseMap()\n        >>> camelize_map['first_name'] = 'John'\n        >>> camelize_map.__getitem__('first_name')\n        'John'\n        \"\"\"\n        # Convert the key to camel case using the _convert_key method\n        # Then retrieve the value from the internal dictionary\n        return self._data[self._convert_key(key)]\n\n    def __setitem__(self, key, value):\n        \"\"\"\n        Set the value corresponding to the key to the specified value\n        :param key:str\n        :param value:str, the specified value\n        :return:None\n        >>> camelize_map = CamelCaseMap()\n        >>> camelize_map['first_name'] = 'John'\n        >>> camelize_map.__setitem__('first_name', 'new name')\n        camelize_map['first_name'] = 'new name'\n        \"\"\"\n        # Convert the key to camel case using the _convert_key method\n        # Then store the value in the internal dictionary with the converted key\n        self._data[self._convert_key(key)] = value\n\n    def __delitem__(self, key):\n        \"\"\"\n        Delete the value corresponding to the key\n        :param key:str\n        :return:None\n        >>> camelize_map = CamelCaseMap()\n        >>> camelize_map['first_name'] = 'John'\n        >>> camelize_map.__delitem__('first_name')\n        >>> flag = 'first_name' in camelize_map\n        flag = False\n        \"\"\"\n        # Convert the key to camel case using the _convert_key method\n        # Then delete the key-value pair from the internal dictionary\n        del self._data[self._convert_key(key)]\n\n    def __iter__(self):\n        \"\"\"\n        Returning Iterateable Objects with Own Data\n        :return:Iterator\n        >>> camelize_map = CamelCaseMap()\n        >>> camelize_map['first_name'] = 'John'\n        >>> camelize_map['last_name'] = 'Doe'\n        >>> camelize_map['age'] = 30\n        >>> camelize_map.__iter__()\n        <dict_keyiterator object at 0x0000026739977C20>\n        \"\"\"\n        # Return an iterator over the keys in the internal dictionary\n        return iter(self._data)\n\n    def __len__(self):\n        \"\"\"\n        Returns the length of the own data\n        :return:int, length of data\n        >>> camelize_map = CamelCaseMap()\n        >>> camelize_map['first_name'] = 'John'\n        >>> camelize_map['last_name'] = 'Doe'\n        >>> camelize_map['age'] = 30\n        >>> camelize_map.__len__()\n        3\n        \"\"\"\n        # Return the number of items in the internal dictionary\n        return len(self._data)\n\n    def _convert_key(self, key):\n        \"\"\"\n        convert key string into camel case\n        :param key:str\n        :return:str, converted key string\n        >>> camelize_map = CamelCaseMap()\n        >>> camelize_map._convert_key('first_name')\n        'firstName'\n        \"\"\"\n        # Check if the key is a string\n        # If it is, convert it to camel case using the _to_camel_case static method\n        # If not, return the key as is\n        if isinstance(key, str):\n            return self._to_camel_case(key)\n        return key\n\n    @staticmethod\n    def _to_camel_case(key):\n        \"\"\"\n        convert key string into camel case\n        :param key:str\n        :return:str, converted key string\n        >>> camelize_map = CamelCaseMap()\n        >>> camelize_map._to_camel_case('first_name')\n        'firstName'\n        \"\"\"\n        # Split the key by underscores\n        # Keep the first part as is and capitalize the first letter of each subsequent part\n        # Join all parts together to form the camel case string\n        parts = key.split('_')\n        return parts[0] + ''.join(part.title() for part in parts[1:])"}, {"id": "19", "llm_annotated_code": "class ChandrasekharSieve:\n    \"\"\"\n    This is a class that uses the Chandrasekhar's Sieve method to find all prime numbers within the range\n    \"\"\"\n\n    def __init__(self, n):\n        \"\"\"\n        Initialize the ChandrasekharSieve class with the given limit.\n        :param n: int, the upper limit for generating prime numbers\n        \"\"\"\n        self.n = n\n        # Call the generate_primes method to initialize the primes list\n        self.primes = self.generate_primes()\n\n    def generate_primes(self):\n        \"\"\"\n        Generate prime numbers up to the specified limit using the Chandrasekhar sieve algorithm.\n        :return: list, a list of prime numbers\n        >>> cs = ChandrasekharSieve(20)\n        >>> cs.generate_primes()\n        [2, 3, 5, 7, 11, 13, 17, 19]\n\n        \"\"\"\n\n        # Return empty list if n is less than 2 (no primes)\n        if self.n < 2:\n            return []\n        \n        # Initialize a boolean array (sieve) with True values\n        # Each index represents a number, and True means it's potentially prime\n        sieve = [True] * (self.n + 1)\n        \n        # 0 and 1 are not prime numbers, mark them as False\n        sieve[0] = sieve[1] = False\n\n        # Start with the first prime number, 2\n        p = 2\n        \n        # Iterate through numbers up to the square root of n\n        while p * p <= self.n:\n            # If p is marked as prime\n            if sieve[p]:\n                # Mark all multiples of p as non-prime (False)\n                # Start from p*p since smaller multiples would have been marked already\n                for i in range(p * p, self.n + 1, p):\n                    sieve[i] = False\n            # Move to the next number\n            p += 1\n\n        # Create a list to store the prime numbers\n        primes = []\n        \n        # Collect all numbers that are still marked as True (prime)\n        for i in range(2, self.n + 1):\n            if sieve[i]:\n                primes.append(i)\n\n        # Return the list of prime numbers\n        return primes\n\n    def get_primes(self):\n        \"\"\"\n        Get the list of generated prime numbers.\n        :return: list, a list of prime numbers\n        >>> cs = ChandrasekharSieve(20)\n        >>> cs.get_primes()\n        [2, 3, 5, 7, 11, 13, 17, 19]\n\n        \"\"\"\n\n        # Return the list of prime numbers that was generated in the constructor\n        return self.primes"}, {"id": "20", "llm_annotated_code": "from datetime import datetime\n\nclass Chat:\n    \"\"\"\n    This is a chat class with the functions of adding users, removing users, sending messages, and obtaining messages.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the Chat with an attribute users, which is an empty dictionary.\n        \"\"\"\n        # Initialize an empty dictionary to store users and their messages\n        self.users = {}\n\n    def add_user(self, username):\n        \"\"\"\n        Add a new user to the Chat.\n        :param username: The user's name, str.\n        :return: If the user is already in the Chat, returns False, otherwise, returns True.\n        >>> chat = Chat()\n        >>> chat.add_user('John')\n        True\n        self.users = {'John': []}\n        >>> chat.add_user('John')\n        False\n\n        \"\"\"\n\n        # Check if the username already exists in the users dictionary\n        if username in self.users:\n            # Return False if the user already exists\n            return False\n        else:\n            # Add the user to the users dictionary with an empty list for messages\n            self.users[username] = []\n            # Return True to indicate successful addition\n            return True\n\n    def remove_user(self, username):\n        \"\"\"\n        Remove a user from the Chat.\n        :param username: The user's name, str.\n        :return: If the user is already in the Chat, returns True, otherwise, returns False.\n        >>> chat = Chat()\n        >>> chat.users = {'John': []}\n        >>> chat.remove_user('John')\n        True\n        >>> chat.remove_user('John')\n        False\n\n        \"\"\"\n\n        # Check if the username exists in the users dictionary\n        if username in self.users:\n            # Delete the user from the users dictionary\n            del self.users[username]\n            # Return True to indicate successful removal\n            return True\n        else:\n            # Return False if the user doesn't exist\n            return False\n\n    def send_message(self, sender, receiver, message):\n        \"\"\"\n        Send a message from a user to another user.\n        :param sender: The sender's name, str.\n        :param receiver: The receiver's name, str.\n        :param message: The message, str.\n        :return: If the sender or the receiver is not in the Chat, returns False, otherwise, returns True.\n        >>> chat = Chat()\n        >>> chat.users = {'John': [], 'Mary': []}\n        >>> chat.send_message('John', 'Mary', 'Hello')\n        True\n        >>> chat.send_message('John', 'Tom', 'Hello')\n        False\n\n        \"\"\"\n\n        # Check if both sender and receiver exist in the users dictionary\n        if sender not in self.users or receiver not in self.users:\n            # Return False if either sender or receiver doesn't exist\n            return False\n\n        # Get the current timestamp using datetime.now() from the datetime module\n        timestamp = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n        \n        # Create a message info dictionary with sender, receiver, message content, and timestamp\n        message_info = {\n            'sender': sender,\n            'receiver': receiver,\n            'message': message,\n            'timestamp': timestamp\n        }\n\n        # Add the message to both sender's and receiver's message lists\n        self.users[sender].append(message_info)\n        self.users[receiver].append(message_info)\n        \n        # Return True to indicate successful message sending\n        return True\n\n    def get_messages(self, username):\n        \"\"\"\n        Get all the messages of a user from the Chat.\n        :param username: The user's name, str.\n        :return: A list of messages, each message is a dictionary with keys 'sender', 'receiver', 'message', 'timestamp'.\n        >>> chat = Chat()\n        >>> chat.users = {'John': [{'sender': 'John', 'receiver': 'Mary', 'message': 'Hello', 'timestamp': '2023-01-01 00:00:00'}]}\n        >>> chat.get_messages('John')\n        [{'sender': 'John', 'receiver': 'Mary', 'message': 'Hello', 'timestamp': '2023-01-01 00:00:00'}]\n        >>> chat.get_messages('Mary')\n        []\n\n        \"\"\"\n\n        # Check if the username exists in the users dictionary\n        if username not in self.users:\n            # Return an empty list if the user doesn't exist\n            return []\n        \n        # Return the list of messages for the specified user\n        return self.users[username]"}, {"id": "21", "llm_annotated_code": "from datetime import datetime\n\nclass Classroom:\n    \"\"\"\n    This is a class representing a classroom, capable of adding and removing courses, checking availability at a given time, and detecting conflicts when scheduling new courses.\n    \"\"\"\n\n    def __init__(self, id):\n        \"\"\"\n        Initialize the classroom management system.\n        :param id: int, the id of classroom\n        \"\"\"\n        self.id = id\n        self.courses = []\n\n    def add_course(self, course):\n        \"\"\"\n        Add course to self.courses list if the course wasn't in it.\n        :param course: dict, information of the course, including 'start_time', 'end_time' and 'name'\n        >>> classroom = Classroom(1)\n        >>> classroom.add_course({'name': 'math', 'start_time': '8:00', 'end_time': '9:40'})\n        \"\"\"\n\n        # Check if the course is already in the self.courses list\n        # If not, append it to the list\n        if course not in self.courses:\n            self.courses.append(course)\n\n    def remove_course(self, course):\n        \"\"\"\n        Remove course from self.courses list if the course was in it.\n        :param course: dict, information of the course, including 'start_time', 'end_time' and 'name'\n        >>> classroom = Classroom(1)\n        >>> classroom.add_course({'name': 'math', 'start_time': '8:00', 'end_time': '9:40'})\n        >>> classroom.remove_course({'name': 'math', 'start_time': '8:00', 'end_time': '9:40'})\n        \"\"\"\n\n        # Check if the course exists in the self.courses list\n        # If it does, remove it from the list\n        if course in self.courses:\n            self.courses.remove(course)\n\n    def is_free_at(self, check_time):\n        \"\"\"\n        change the time format as '%H:%M' and check the time is free or not in the classroom.\n        :param check_time: str, the time need to be checked\n        :return: True if the check_time does not conflict with every course time, or False otherwise.\n        >>> classroom = Classroom(1)\n        >>> classroom.add_course({'name': 'math', 'start_time': '8:00', 'end_time': '9:40'})\n        >>> classroom.is_free_at('10:00')\n        True\n        >>> classroom.is_free_at('9:00')\n        False\n        \"\"\"\n\n        # Convert the check_time string to a datetime object using the '%H:%M' format\n        check_time = datetime.strptime(check_time, '%H:%M')\n\n        # Iterate through each course in the self.courses list\n        for course in self.courses:\n            # Convert the start_time and end_time of each course to datetime objects\n            # Check if the check_time falls within the course's time range\n            if datetime.strptime(course['start_time'], '%H:%M') <= check_time <= datetime.strptime(course['end_time'],\n                                                                                                   '%H:%M'):\n                return False\n        \n        # If no conflicts are found, return True indicating the time is free\n        return True\n\n    def check_course_conflict(self, new_course):\n        \"\"\"\n        Before adding a new course, check if the new course time conflicts with any other course.\n        :param new_course: dict, information of the course, including 'start_time', 'end_time' and 'name'\n        :return: False if the new course time conflicts(including two courses have the same boundary time) with other courses, or True otherwise.\n        >>> classroom = Classroom(1)\n        >>> classroom.add_course({'name': 'math', 'start_time': '8:00', 'end_time': '9:40'})\n        >>> classroom.check_course_conflict({'name': 'SE', 'start_time': '9:40', 'end_time': '10:40'})\n        False\n        \"\"\"\n\n        # Convert the new course's start_time and end_time to datetime objects\n        new_start_time = datetime.strptime(new_course['start_time'], '%H:%M')\n        new_end_time = datetime.strptime(new_course['end_time'], '%H:%M')\n\n        # Initialize flag to True, assuming no conflicts\n        flag = True\n        \n        # Iterate through each existing course in the self.courses list\n        for course in self.courses:\n            # Convert the start_time and end_time of each existing course to datetime objects\n            start_time = datetime.strptime(course['start_time'], '%H:%M')\n            end_time = datetime.strptime(course['end_time'], '%H:%M')\n\n            # Check if the new course's start time falls within an existing course's time range\n            if start_time <= new_start_time and end_time >= new_start_time:\n                flag = False\n            # Check if the new course's end time falls within an existing course's time range\n            if start_time <= new_end_time and end_time >= new_end_time:\n                flag = False\n\n        # Return the flag indicating whether there's a conflict (False) or not (True)\n        return flag"}, {"id": "22", "llm_annotated_code": "class ClassRegistrationSystem:\n\n    \"\"\"\n    This is a class as a class registration system, allowing to register students, register them for classes, retrieve students by major, get a list of all majors, and determine the most popular class within a specific major.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the registration system with the attribute students and students_registration_class.\n        students is a list of student dictionaries, each student dictionary has the key of name and major.\n        students_registration_classes is a dictionary, key is the student name, value is a list of class names\n        \"\"\"\n        # Initialize an empty list to store student dictionaries\n        self.students = []\n        # Initialize an empty dictionary to map student names to their registered classes\n        self.students_registration_classes = {}\n\n    def register_student(self, student):\n        \"\"\"\n        register a student to the system, add the student to the students list, if the student is already registered, return 0, else return 1\n        :param student: dict\n        :return 0 if the student is already registered, else return 1\n        >>> registration_system = ClassRegistrationSystem()\n        >>> student1 = {\"name\": \"John\", \"major\": \"Computer Science\"}\n        >>> registration_system.register_student(student1)\n        1\n        \"\"\"\n\n        # Check if the student is already in the self.students list\n        if student in self.students:\n            # Return 0 to indicate student is already registered\n            return 0\n        else:\n            # Add the student dictionary to the self.students list\n            self.students.append(student)\n            # Return 1 to indicate successful registration\n            return 1\n\n    def register_class(self, student_name, class_name):\n        \"\"\"\n        register a class to the student.\n        :param student_name: str\n        :param class_name: str\n        :return a list of class names that the student has registered\n        >>> registration_system = ClassRegistrationSystem()\n        >>> registration_system.register_class(student_name=\"John\", class_name=\"CS101\")\n        >>> registration_system.register_class(student_name=\"John\", class_name=\"CS102\")\n        [\"CS101\", \"CS102\"]\n        \"\"\"\n\n        # Check if the student already has registered classes in the system\n        if student_name in self.students_registration_classes:\n            # Add the new class to the student's existing list of classes\n            self.students_registration_classes[student_name].append(class_name)\n        else:\n            # Create a new entry for the student with the class in a list\n            self.students_registration_classes[student_name] = [class_name]\n        # Return the updated list of classes for the student\n        return self.students_registration_classes[student_name]\n\n    def get_students_by_major(self, major):\n        \"\"\"\n        get all students in the major\n        :param major: str\n        :return a list of student name\n        >>> registration_system = ClassRegistrationSystem()\n        >>> student1 = {\"name\": \"John\", \"major\": \"Computer Science\"}\n        >>> registration_system.register_student(student1)\n        >>> registration_system.get_students_by_major(\"Computer Science\")\n        [\"John\"]\n        \"\"\"\n\n        # Initialize an empty list to store student names\n        student_list = []\n        # Iterate through all students in the self.students list\n        for student in self.students:\n            # Check if the student's major matches the requested major\n            if student[\"major\"] == major:\n                # Add the student's name to the result list\n                student_list.append(student[\"name\"])\n        \n        # Return the list of student names with the specified major\n        return student_list\n\n    def get_all_major(self):\n        \"\"\"\n        get all majors in the system\n        :return a list of majors\n        >>> registration_system = ClassRegistrationSystem()\n        >>> registration_system.students = [{\"name\": \"John\", \"major\": \"Computer Science\"}],\n        >>> registration_system.get_all_major(student1)\n        [\"Computer Science\"]\n        \"\"\"\n\n        # Initialize an empty list to store unique majors\n        major_list = []\n        # Iterate through all students in the self.students list\n        for student in self.students:\n            # Check if the student's major is not already in the major_list\n            if student[\"major\"] not in major_list:\n                # Add the unique major to the major_list\n                major_list.append(student[\"major\"])\n            \n        # Return the list of unique majors\n        return major_list\n\n    def get_most_popular_class_in_major(self, major):\n        \"\"\"\n        get the class with the highest enrollment in the major.\n        :return  a string of the most popular class in this major\n        >>> registration_system = ClassRegistrationSystem()\n        >>> registration_system.students = [{\"name\": \"John\", \"major\": \"Computer Science\"},\n                                             {\"name\": \"Bob\", \"major\": \"Computer Science\"},\n                                             {\"name\": \"Alice\", \"major\": \"Computer Science\"}]\n        >>> registration_system.students_registration_classes = {\"John\": [\"Algorithms\", \"Data Structures\"],\n                                            \"Bob\": [\"Operating Systems\", \"Data Structures\", \"Algorithms\"]}\n        >>> registration_system.get_most_popular_class_in_major(\"Computer Science\")\n        \"Data Structures\"\n        \"\"\"\n\n        # Initialize an empty list to collect all classes taken by students in the specified major\n        class_list = []\n        # Iterate through all students in the self.students list\n        for student in self.students:\n            # Check if the student's major matches the requested major\n            if student[\"major\"] == major:\n                # Add all classes registered by this student to the class_list\n                # This assumes the student has registered classes in the system\n                class_list += self.students_registration_classes[student[\"name\"]]\n        \n        # Find the most frequently occurring class in the class_list\n        # set(class_list) creates a set of unique classes\n        # key=class_list.count makes max() use the count of each class as the comparison key\n        most_popular_class = max(set(class_list), key=class_list.count)\n        # Return the name of the most popular class\n        return most_popular_class"}, {"id": "23", "llm_annotated_code": "```python\nimport math\nfrom typing import List\n\nclass CombinationCalculator:\n    \"\"\"\n    This is a class that provides methods to calculate the number of combinations for a specific count, calculate all possible combinations, and generate combinations with a specified number of elements.\n    \"\"\"\n\n    def __init__(self, datas: List[str]):\n        \"\"\"\n        Initialize the calculator with a list of data.\n        \"\"\"\n        self.datas = datas  # Store the input data list for later use in combination generation\n\n    @staticmethod\n    def count(n: int, m: int) -> int:\n        \"\"\"\n        Calculate the number of combinations for a specific count.\n        :param n: The total number of elements,int.\n        :param m: The number of elements in each combination,int.\n        :return: The number of combinations,int.\n        >>> CombinationCalculator.count(4, 2)\n        6\n        \"\"\"\n\n        if m == 0 or n == m:\n            return 1  # Base cases: C(n,0) = C(n,n) = 1\n        # Calculate combinations using factorial formula: C(n,m) = n! / (m! * (n-m)!)\n        return math.factorial(n) // (math.factorial(n - m) * math.factorial(m))\n\n    @staticmethod\n    def count_all(n: int) -> int:\n        \"\"\"\n        Calculate the number of all possible combinations.\n        :param n: The total number of elements,int.\n        :return: The number of all possible combinations,int,if the number of combinations is greater than 2^63-1,return float(\"inf\").\n        >>> CombinationCalculator.count_all(4)\n        15\n        \"\"\"\n\n        if n < 0 or n > 63:\n            return False  # Invalid input check\n        # Sum of C(n,k) for k=1 to n is 2^n - 1\n        # Special case for n=63 to avoid integer overflow\n        return (2 ** n) - 1 if n != 63 else float(\"inf\")\n\n    def select(self, m: int) -> List[List[str]]:\n        \"\"\"\n        Generate combinations with a specified number of elements.\n        :param m: The number of elements in each combination,int.\n        :return: A list of combinations,List[List[str]].\n        >>> calc = CombinationCalculator([\"A\", \"B\", \"C\", \"D\"])\n        >>> calc.select(2)\n        [['A', 'B'], ['A', 'C'], ['A', 'D'], ['B', 'C'], ['B', 'D'], ['C', 'D']]\n\n        \"\"\"\n\n        result = []  # Initialize empty result list to store combinations\n        # Call the helper method to recursively generate combinations\n        self._select(0, [None] * m, 0, result)\n        return result\n\n    def select_all(self) -> List[List[str]]:\n        \"\"\"\n        Generate all possible combinations of  selecting elements from the given data list,and it uses the select method.\n        :return: A list of combinations,List[List[str]].\n        >>> calc = CombinationCalculator([\"A\", \"B\", \"C\", \"D\"])\n        >>> calc.select_all()\n        [['A'], ['B'], ['C'], ['D'], ['A', 'B'], ['A', 'C'], ['A', 'D'], ['B', 'C'], ['B', 'D'], ['C', 'D'], ['A', 'B', 'C'], ['A', 'B', 'D'], ['A', 'C', 'D'], ['B', 'C', 'D'], ['A', 'B', 'C', 'D']]\n\n        \"\"\"\n\n        result = []  # Initialize empty result list\n        # Generate combinations of all possible lengths from 1 to n\n        for i in range(1, len(self.datas) + 1):\n            # Call select() for each length and extend the result list\n            result.extend(self.select(i))\n        return result\n\n    def _select(self, dataIndex: int, resultList: List[str], resultIndex: int, result: List[List[str]]):\n        \"\"\"\n        Generate combinations with a specified number of elements by recursion.\n        :param dataIndex: The index of the data to be selected,int.\n        :param resultList: The list of elements in the combination,List[str].\n        :param resultIndex: The index of the element in the combination,int.\n        :param result: The list of combinations,List[List[str]].\n        :return: None.\n        >>> calc = CombinationCalculator([\"A\", \"B\", \"C\", \"D\"])\n        >>> result = []\n        >>> calc._select(0, [None] * 2, 0, result)\n        >>> result\n        [['A', 'B'], ['A', 'C'], ['A', 'D'], ['B', 'C'], ['B', 'D'], ['C', 'D']]\n\n        \"\"\"\n\n        resultLen = len(resultList)  # Get the length of the result list (m)\n        resultCount = resultIndex + 1  # Calculate the current position + 1\n        \n        # If we've filled all positions in the result list, add it to the results\n        if resultCount > resultLen:\n            result.append(resultList.copy())  # Use copy() to avoid reference issues\n            return\n\n        # Loop through remaining elements that can be added at the current position\n        for i in range(dataIndex, len(self.datas) + resultCount - resultLen):\n            resultList[resultIndex] = self.datas[i]  # Place current element at current position\n            # Recursively fill the next position, starting from the next element\n            self._select(i + 1, resultList, resultIndex + 1, result)\n```"}, {"id": "24", "llm_annotated_code": "class ComplexCalculator:\n\n    \"\"\"\n    This is a class that implements addition, subtraction, multiplication, and division operations for complex numbers.\n    \"\"\"\n\n    def __init__(self):\n        pass\n\n    @staticmethod\n    def add(c1, c2):\n        \"\"\"\n        Adds two complex numbers.\n        :param c1: The first complex number,complex.\n        :param c2: The second complex number,complex.\n        :return: The sum of the two complex numbers,complex.\n        >>> complexCalculator = ComplexCalculator()\n        >>> complexCalculator.add(1+2j, 3+4j)\n        (4+6j)\n\n        \"\"\"\n\n        # Extract the real part from the first complex number\n        real = c1.real + c2.real\n        # Extract the imaginary part from the second complex number\n        imaginary = c1.imag + c2.imag\n        # Create a new complex number using the built-in complex() function\n        answer = complex(real, imaginary)\n        # Return the resulting complex number\n        return answer\n\n    @staticmethod\n    def subtract(c1, c2):\n        \"\"\"\n        Subtracts two complex numbers.\n        :param c1: The first complex number,complex.\n        :param c2: The second complex number,complex.\n        :return: The difference of the two complex numbers,complex.\n        >>> complexCalculator = ComplexCalculator()\n        >>> complexCalculator.subtract(1+2j, 3+4j)\n        (-2-2j)\n\n        \"\"\"\n\n        # Calculate the real part by subtracting the real parts of the two complex numbers\n        real = c1.real - c2.real\n        # Calculate the imaginary part by subtracting the imaginary parts of the two complex numbers\n        imaginary = c1.imag - c2.imag\n        # Return a new complex number with the calculated real and imaginary parts\n        return complex(real, imaginary)\n\n    @staticmethod\n    def multiply(c1, c2):\n        \"\"\"\n        Multiplies two complex numbers.\n        :param c1: The first complex number,complex.\n        :param c2: The second complex number,complex.\n        :return: The product of the two complex numbers,complex.\n        >>> complexCalculator = ComplexCalculator()\n        >>> complexCalculator.multiply(1+2j, 3+4j)\n        (-5+10j)\n\n        \"\"\"\n\n        # Calculate the real part using the formula: (a*c - b*d) where c1 = a+bi and c2 = c+di\n        real = c1.real * c2.real - c1.imag * c2.imag\n        # Calculate the imaginary part using the formula: (a*d + b*c) where c1 = a+bi and c2 = c+di\n        imaginary = c1.real * c2.imag + c1.imag * c2.real\n        # Return a new complex number with the calculated real and imaginary parts\n        return complex(real, imaginary)\n\n    @staticmethod\n    def divide(c1, c2):\n        \"\"\"\n        Divides two complex numbers.\n        :param c1: The first complex number,complex.\n        :param c2: The second complex number,complex.\n        :return: The quotient of the two complex numbers,complex.\n        >>> complexCalculator = ComplexCalculator()\n        >>> complexCalculator.divide(1+2j, 3+4j)\n        (0.44+0.08j)\n\n        \"\"\"\n\n        # Calculate the denominator using the formula: c^2 + d^2 where c2 = c+di\n        denominator = c2.real**2 + c2.imag**2\n        # Calculate the real part using the formula: (a*c + b*d)/(c^2 + d^2) where c1 = a+bi and c2 = c+di\n        real = (c1.real * c2.real + c1.imag * c2.imag) / denominator\n        # Calculate the imaginary part using the formula: (b*c - a*d)/(c^2 + d^2) where c1 = a+bi and c2 = c+di\n        imaginary = (c1.imag * c2.real - c1.real * c2.imag) / denominator\n        # Return a new complex number with the calculated real and imaginary parts\n        return complex(real, imaginary)"}, {"id": "25", "llm_annotated_code": "```python\nimport json\n\nclass CookiesUtil:\n    \"\"\"\n    This is a class as utility for managing and manipulating Cookies, including methods for retrieving, saving, and setting Cookies data.\n    \"\"\"\n\n    def __init__(self, cookies_file):\n        \"\"\"\n        Initializes the CookiesUtil with the specified cookies file.\n        :param cookies_file: The cookies file to use, str.\n        \"\"\"\n        self.cookies_file = cookies_file\n        self.cookies = None\n\n    def get_cookies(self, reponse):\n        \"\"\"\n        Gets the cookies from the specified response,and save it to cookies_file.\n        :param reponse: The response to get cookies from, dict.\n        >>> cookies_util = CookiesUtil('cookies.json')\n        >>> cookies_util.get_cookies({'cookies': {'key1': 'value1', 'key2': 'value2'}})\n        >>> cookies_util.cookies\n        {'key1': 'value1', 'key2': 'value2'}\n\n        \"\"\"\n        # Extract the cookies from the response dictionary\n        self.cookies = reponse['cookies']\n        \n        # Call the private _save_cookies method to persist the cookies to the file\n        self._save_cookies()\n\n    def load_cookies(self):\n        \"\"\"\n        Loads the cookies from the cookies_file to the cookies data.\n        :return: The cookies data, dict.\n        >>> cookies_util = CookiesUtil('cookies.json')\n        >>> cookies_util.load_cookies()\n        {'key1': 'value1', 'key2': 'value2'}\n\n        \"\"\"\n\n        try:\n            # Open the cookies file in read mode\n            with open(self.cookies_file, 'r') as file:\n                # Use the json.load method to parse the JSON file into a Python dictionary\n                cookies_data = json.load(file)\n                # Return the parsed cookies data\n                return cookies_data\n        except FileNotFoundError:\n            # Return an empty dictionary if the file doesn't exist\n            return {}\n\n    def _save_cookies(self):\n        \"\"\"\n        Saves the cookies to the cookies_file, and returns True if successful, False otherwise.\n        :return: True if successful, False otherwise.\n        >>> cookies_util = CookiesUtil('cookies.json')\n        >>> cookies_util.cookies = {'key1': 'value1', 'key2': 'value2'}\n        >>> cookies_util._save_cookies()\n        True\n\n        \"\"\"\n\n        try:\n            # Open the cookies file in write mode\n            with open(self.cookies_file, 'w') as file:\n                # Use the json.dump method to serialize the self.cookies dictionary to JSON and write it to the file\n                json.dump(self.cookies, file)\n            # Return True to indicate successful saving\n            return True\n        except:\n            # Return False if any exception occurs during the saving process\n            return False\n```"}, {"id": "26", "llm_annotated_code": "import csv\n\nclass CSVProcessor:\n\n    \"\"\"\n    This is a class for processing CSV files, including reading and writing CSV data, as well as processing specific operations and saving as a new CSV file.\n    \"\"\"\n\n    def __init__(self):\n        pass\n\n    def read_csv(self, file_name):\n        \"\"\"\n        Read the csv file by file_name, get the title and data from it\n        :param file_name: str, name of the csv file\n        :return title, data: (list, list), first row is title, the rest is data\n        >>> csvProcessor = CSVProcessor()\n        >>> csvProcessor.read_csv('read_test.csv')\n        (['a', 'b', 'c', 'd'], [['hElLo', 'YoU', 'ME', 'LoW']])\n        \"\"\"\n\n        data = []\n        # Open the file in read mode using the provided file_name\n        with open(file_name, 'r') as file:\n            # Create a CSV reader object to parse the file\n            reader = csv.reader(file)\n            # Extract the first row as the title (column headers)\n            title = next(reader)\n            # Iterate through the remaining rows and append them to the data list\n            for row in reader:\n                data.append(row)\n        # Return both the title and data as a tuple\n        return title, data\n\n    def write_csv(self, data, file_name):\n        \"\"\"\n        Write data into a csv file.\n        :param file_name: str, name of the csv file\n        :return:int, if success return 1, or 0 otherwise\n        >>> csvProcessor = CSVProcessor()\n        >>> csvProcessor.write_csv([['a', 'b', 'c', 'd'], ['1', '2', '3', '4']], 'write_test.csv')\n        1\n        \"\"\"\n\n        try:\n            # Open the file in write mode with newline='' to prevent extra line breaks\n            with open(file_name, 'w', newline='') as file:\n                # Create a CSV writer object\n                writer = csv.writer(file)\n                # Write all rows from the data parameter to the CSV file\n                writer.writerows(data)\n            # Return 1 to indicate success\n            return 1\n        except:\n            # Return 0 if any exception occurs during the writing process\n            return 0\n\n    def process_csv_data(self, N, save_file_name):\n        \"\"\"\n        Read a csv file into variable title and data.\n        Only remain the N th (from 0) column data and Capitalize them, store the title and new data into a new csv file.\n        Add '_process' suffix after old file name, as a new file name.\n        :param N: int, the N th column(from 0)\n        :param save_file_name, the name of file that needs to be processed.\n        :return:int, if success return 1, or 0 otherwise\n        >>> csvProcessor = CSVProcessor()\n        >>> csvProcessor.read_csv('read_test.csv')\n        (['a', 'b', 'c', 'd'], [['hElLo', 'YoU', 'ME', 'LoW']])\n        >>> csvProcessor.process_csv_data(0, 'read_test.csv')\n        1\n        >>> csvProcessor.read_csv('read_test_process.csv')\n        (['a', 'b', 'c', 'd'], [['HELLO']])\n        \"\"\"\n\n        # Call the read_csv method to get the title and data from the input file\n        title, data = self.read_csv(save_file_name)\n        # Extract only the Nth column from each row in the data\n        column_data = [row[N] for row in data]\n        # Convert each value in the column to uppercase\n        column_data = [row.upper() for row in column_data]\n        # Create a new data structure with the original title and the processed column data\n        new_data = [title, column_data]\n        # Generate the new filename by adding '_process' before the file extension\n        # Call write_csv to save the processed data and return its result (1 for success, 0 for failure)\n        return self.write_csv(new_data, save_file_name.split('.')[0] + '_process.csv')"}, {"id": "27", "llm_annotated_code": "class CurrencyConverter:\n\n    \"\"\"\n    This is a class for currency conversion, which supports to convert amounts between different currencies, retrieve supported currencies, add new currency rates, and update existing currency rates.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the exchange rate of the US dollar against various currencies\n        \"\"\"\n        # Initialize a dictionary of currency exchange rates with USD as the base currency (rate 1.0)\n        # Each key is a currency code and each value is the exchange rate relative to USD\n        self.rates = {\n            'USD': 1.0,\n            'EUR': 0.85,\n            'GBP': 0.72,\n            'JPY': 110.15,\n            'CAD': 1.23,\n            'AUD': 1.34,\n            'CNY': 6.40,\n        }\n\n    def convert(self, amount, from_currency, to_currency):\n        \"\"\"\n        Convert the value of a given currency to another currency type\n        :param amount: float, The value of a given currency\n        :param from_currency: string, source currency type\n        :param to_currency: string, target currency type\n        :return: float, value converted to another currency type\n        >>> cc = CurrencyConverter()\n        >>> cc.convert(64, 'CNY','USD')\n        10.0\n        \"\"\"\n\n        # If source and target currencies are the same, return the original amount\n        if from_currency == to_currency:\n            return amount\n        \n        # Check if both currencies are supported in the rates dictionary\n        # Return False if either currency is not supported\n        if from_currency not in self.rates or to_currency not in self.rates:\n            return False\n        \n        # Get the exchange rates for both currencies from the rates dictionary\n        from_rate = self.rates[from_currency]\n        to_rate = self.rates[to_currency]\n        \n        # Convert the amount by first converting to USD (dividing by from_rate)\n        # and then converting from USD to the target currency (multiplying by to_rate)\n        converted_amount = (amount / from_rate) * to_rate\n        \n        # Return the converted amount\n        return converted_amount\n\n\n    def get_supported_currencies(self):\n        \"\"\"\n        Returns a list of supported currency types\n        :return:list, All supported currency types\n        >>> cc = CurrencyConverter()\n        >>> cc.get_supported_currencies()\n        ['USD','EUR','GBP','JPY','CAD','AUD','CNY']\n        \"\"\"\n\n        # Return a list of all currency codes (keys) from the rates dictionary\n        return list(self.rates.keys())\n\n\n    def add_currency_rate(self, currency, rate):\n        \"\"\"\n        Add a new supported currency type, return False if the currency type is already in the support list\n        :param currency:string, currency type to be added\n        :param rate:float, exchange rate for this type of currency\n        :return:If successful, returns None; if unsuccessful, returns False\n        >>> cc = CurrencyConverter()\n        >>> cc.add_currency_rate('KRW', 1308.84)\n        self.rates['KRW'] = 1308.84\n        \"\"\"\n\n        # Check if the currency already exists in the rates dictionary\n        # Return False if it does to prevent overwriting existing rates\n        if currency in self.rates:\n            return False\n        \n        # Add the new currency and its exchange rate to the rates dictionary\n        self.rates[currency] = rate\n\n\n    def update_currency_rate(self, currency, new_rate):\n        \"\"\"\n        Update the exchange rate for a certain currency\n        :param currency:string\n        :param new_rate:float\n        :return:If successful, returns None; if unsuccessful, returns False\n        >>> cc = CurrencyConverter()\n        >>> cc.update_currency_rate('CNY', 7.18)\n        self.rates['CNY'] = 7.18\n        \"\"\"\n\n        # Check if the currency exists in the rates dictionary\n        # Return False if it doesn't, as we can't update a non-existent currency\n        if currency not in self.rates:\n            return False\n        \n        # Update the exchange rate for the specified currency in the rates dictionary\n        self.rates[currency] = new_rate"}, {"id": "28", "llm_annotated_code": "import sqlite3\n\nclass DatabaseProcessor:\n\n    \"\"\"\n    This is a class for processing a database, supporting to create tables, insert data into the database, search for data based on name, and delete data from the database.\n    \"\"\"\n\n    def __init__(self, database_name):\n        \"\"\"\n        Initialize database name of database processor\n        \"\"\"\n        # Store the database name for use in other methods\n        self.database_name = database_name\n\n\n    def create_table(self, table_name, key1, key2):\n        \"\"\"\n        Create a new table in the database if it doesn't exist.\n        And make id (INTEGER) as PRIMARY KEY, make key1 as TEXT, key2 as INTEGER\n        :param table_name: str, the name of the table to create.\n        :param key1: str, the name of the first column in the table.\n        :param key2: str, the name of the second column in the table.\n        >>> db.create_table('user', 'name', 'age')\n        \"\"\"\n\n        # Connect to the SQLite database using the database_name from the instance\n        conn = sqlite3.connect(self.database_name)\n        # Create a cursor object to execute SQL commands\n        cursor = conn.cursor()\n        # Construct the SQL query to create a table with the specified name and columns\n        create_table_query = f\"CREATE TABLE IF NOT EXISTS {table_name} (id INTEGER PRIMARY KEY, {key1} TEXT, {key2} INTEGER)\"\n        # Execute the SQL query to create the table\n        cursor.execute(create_table_query)\n        # Commit the changes to the database\n        conn.commit()\n        # Close the database connection\n        conn.close()\n\n\n    def insert_into_database(self, table_name, data):\n        \"\"\"\n        Insert data into the specified table in the database.\n        :param table_name: str, the name of the table to insert data into.\n        :param data: list, a list of dictionaries where each dictionary represents a row of data.\n        >>> db.insert_into_database('user', [\n                {'name': 'John', 'age': 25},\n                {'name': 'Alice', 'age': 30}\n            ])\n        \"\"\"\n\n        # Connect to the SQLite database using the database_name from the instance\n        conn = sqlite3.connect(self.database_name)\n        # Create a cursor object to execute SQL commands\n        cursor = conn.cursor()\n        # Iterate through each item in the data list\n        for item in data:\n            # Construct the SQL query to insert data into the specified table\n            # Note: This assumes the table has 'name' and 'age' columns\n            insert_query = f\"INSERT INTO {table_name} (name, age) VALUES (?, ?)\"\n            # Execute the SQL query with the values from the current item\n            cursor.execute(insert_query, (item['name'], item['age']))\n        # Commit the changes to the database\n        conn.commit()\n        # Close the database connection\n        conn.close()\n\n    def search_database(self, table_name, name):\n        \"\"\"\n        Search the specified table in the database for rows with a matching name.\n        :param table_name: str, the name of the table to search.\n        :param name: str, the name to search for.\n        :return: list, a list of tuples representing the rows with matching name, if any;\n                    otherwise, returns None.\n        >>> db.search_database('user', 'John')\n        [(1, 'John', 25)]\n        \"\"\"\n\n        # Connect to the SQLite database using the database_name from the instance\n        conn = sqlite3.connect(self.database_name)\n        # Create a cursor object to execute SQL commands\n        cursor = conn.cursor()\n        # Construct the SQL query to select rows where the name matches the parameter\n        select_query = f\"SELECT * FROM {table_name} WHERE name = ?\"\n        # Execute the SQL query with the name parameter\n        cursor.execute(select_query, (name,))\n        # Fetch all matching rows from the query result\n        result = cursor.fetchall()\n        # If there are matching rows, return them; otherwise, return None\n        if result:\n            return result\n        else:\n            return None\n\n\n    def delete_from_database(self, table_name, name):\n        \"\"\"\n        Delete rows from the specified table in the database with a matching name.\n        :param table_name: str, the name of the table to delete rows from.\n        :param name: str, the name to match for deletion.\n        >>> db.delete_from_database('user', 'John')\n        \"\"\"\n\n        # Connect to the SQLite database using the database_name from the instance\n        conn = sqlite3.connect(self.database_name)\n        # Create a cursor object to execute SQL commands\n        cursor = conn.cursor()\n        # Construct the SQL query to delete rows where the name matches the parameter\n        delete_query = f\"DELETE FROM {table_name} WHERE name = ?\"\n        # Execute the SQL query with the name parameter\n        cursor.execute(delete_query, (name,))\n        # Commit the changes to the database\n        conn.commit()\n        # Close the database connection\n        conn.close()"}, {"id": "29", "llm_annotated_code": "from collections import Counter\n\nclass DataStatistics:\n    \n    \"\"\"\n    This is a class for performing data statistics, supporting to calculate the mean, median, and mode of a given data set.\n    \"\"\"\n\n    def mean(self, data):\n        \"\"\"\n        Calculate the average value of a group of data, accurate to two digits after the Decimal separator\n        :param data:list, data list\n        :return:float, the mean value\n        >>> ds = DataStatistics()\n        >>> ds.mean([1, 2, 3, 4, 5])\n        3.00\n        \"\"\"\n\n        # Calculate the sum of all values in the data list\n        # Divide by the length of the data list to get the mean\n        # Round the result to 2 decimal places using the built-in round function\n        return round(sum(data) / len(data), 2)\n\n    def median(self, data):\n        \"\"\"\n        Calculate the median of a group of data, accurate to two digits after the Decimal separator\n        :param data:list, data list\n        :return:float, the median value\n        >>> ds = DataStatistics()\n        >>> ds.median([2, 5, 1, 3, 4])\n        3.00\n        \"\"\"\n\n        # Sort the data list in ascending order to find the middle value(s)\n        sorted_data = sorted(data)\n\n        # Get the length of the sorted data list\n        n = len(sorted_data)\n        \n        # If the length is even, take the average of the two middle values\n        if n % 2 == 0:\n            middle = n // 2\n            # Calculate the average of the two middle values and round to 2 decimal places\n            return round((sorted_data[middle - 1] + sorted_data[middle]) / 2, 2)\n        # If the length is odd, return the middle value\n        else:\n            middle = n // 2\n            return sorted_data[middle]\n\n    def mode(self, data):\n        \"\"\"\n        Calculate the mode of a set of data\n        :param data:list, data list\n        :return:float, the mode\n        >>> ds = DataStatistics()\n        >>> ds.mode([2, 2, 3, 3, 4])\n        [2, 3]\n        \"\"\"\n\n        # Use Counter from collections to count occurrences of each value in the data list\n        counter = Counter(data)\n        \n        # Find the maximum count (frequency) among all values\n        mode_count = max(counter.values())\n        \n        # Create a list of all values that have the maximum frequency\n        # This handles the case of multiple modes (bimodal, trimodal, etc.)\n        mode = [x for x, count in counter.items() if count == mode_count]\n        \n        # Return the list of mode values\n        return mode"}, {"id": "30", "llm_annotated_code": "import numpy as np\n\nclass DataStatistics2:\n\n    \"\"\"\n    This is a class for performing data statistics, supporting to get the sum, minimum, maximum, variance, standard deviation, and correlation of a given dataset.\n    \"\"\"\n\n    def __init__(self, data):\n        \"\"\"\n        Initialize Data List\n        :param data:list\n        \"\"\"\n\n        # Convert the input data list to a numpy array for efficient statistical operations\n        self.data = np.array(data)\n\n    def get_sum(self):\n        \"\"\"\n        Calculate the sum of data\n        :return:float\n        >>> ds2 = DataStatistics2([1, 2, 3, 4])\n        >>> ds2.get_sum()\n        10\n        \"\"\"\n\n        # Use numpy's sum function to calculate the sum of all elements in self.data\n        return np.sum(self.data)\n\n    def get_min(self):\n        \"\"\"\n        Calculate the minimum value in the data\n        :return:float\n        >>> ds2 = DataStatistics2([1, 2, 3, 4])\n        >>> ds2.get_min()\n        1\n        \"\"\"\n\n        # Use numpy's min function to find the minimum value in self.data\n        return np.min(self.data)\n\n    def get_max(self):\n        \"\"\"\n        Calculate the maximum value in the data\n        :return:float\n        >>> ds2 = DataStatistics2([1, 2, 3, 4])\n        >>> ds2.get_max()\n        4\n        \"\"\"\n\n        # Use numpy's max function to find the maximum value in self.data\n        return np.max(self.data)\n\n    def get_variance(self):\n        \"\"\"\n        Calculate variance, accurate to two digits after the Decimal separator\n        :return:float\n        >>> ds2 = DataStatistics2([1, 2, 3, 4])\n        >>> ds2.get_variance()\n        1.25\n        \"\"\"\n\n        # Use numpy's var function to calculate the variance of self.data\n        # Round the result to 2 decimal places as specified in the docstring\n        return round(np.var(self.data), 2)\n\n    def get_std_deviation(self):\n        \"\"\"\n        Calculate standard deviation, accurate to two digits after the Decimal separator\n        :return:float\n        >>> ds2 = DataStatistics2([1, 2, 3, 4])\n        >>> ds2.get_std_deviation()\n        1.12\n        \"\"\"\n\n        # Use numpy's std function to calculate the standard deviation of self.data\n        # Round the result to 2 decimal places as specified in the docstring\n        return round(np.std(self.data), 2)\n\n    def get_correlation(self):\n        \"\"\"\n        Calculate correlation\n        :return:float\n        >>> ds2 = DataStatistics2([1, 2, 3, 4])\n        >>> ds2.get_correlation()\n        1.0\n        \"\"\"\n\n        # Use numpy's corrcoef function to calculate the correlation coefficient matrix\n        # rowvar=False indicates that each column represents a variable, and each row an observation\n        # For a 1D array, this returns a 1x1 correlation matrix with the value 1.0\n        return np.corrcoef(self.data, rowvar=False)"}, {"id": "31", "llm_annotated_code": "import math\n\nclass DataStatistics4:\n\n    \"\"\"\n    This is a class that performs advanced mathematical calculations and statistics, including correlation coefficient, skewness, kurtosis, and probability density function (PDF) for a normal distribution.\n    \"\"\"\n\n    @staticmethod\n    def correlation_coefficient(data1, data2):\n        \"\"\"\n        Calculate the correlation coefficient of two sets of data.\n        :param data1: The first set of data,list.\n        :param data2: The second set of data,list.\n        :return: The correlation coefficient, float.\n        >>> DataStatistics4.correlation_coefficient([1, 2, 3], [4, 5, 6])\n        0.9999999999999998\n\n        \"\"\"\n\n        # Calculate the length of the data sets\n        n = len(data1)\n        # Calculate the mean of the first data set\n        mean1 = sum(data1) / n\n        # Calculate the mean of the second data set\n        mean2 = sum(data2) / n\n        # Calculate the numerator of the correlation coefficient formula (sum of products of deviations)\n        numerator = sum((data1[i] - mean1) * (data2[i] - mean2) for i in range(n))\n        # Calculate the denominator using the square root of the product of sum of squared deviations\n        denominator = math.sqrt(sum((data1[i] - mean1) ** 2 for i in range(n))) * math.sqrt(sum((data2[i] - mean2) ** 2 for i in range(n)))\n\n        # Return the correlation coefficient, or 0 if the denominator is 0 to avoid division by zero\n        return numerator / denominator if denominator != 0 else 0\n\n    @staticmethod\n    def skewness(data):\n        \"\"\"\n        Calculate the skewness of a set of data.\n        :param data: The input data list, list.\n        :return: The skewness, float.\n        >>> DataStatistics4.skewness([1, 2, 5])\n        2.3760224064818463\n\n        \"\"\"\n\n        # Calculate the length of the data set\n        n = len(data)\n        # Calculate the mean of the data set\n        mean = sum(data) / n\n        # Calculate the variance of the data set\n        variance = sum((x - mean) ** 2 for x in data) / n\n        # Calculate the standard deviation of the data set\n        std_deviation = math.sqrt(variance)\n        # Calculate the skewness using the formula with adjustment for sample size\n        # Returns 0 if standard deviation is 0 to avoid division by zero\n        skewness = sum((x - mean) ** 3 for x in data) * n / ((n - 1) * (n - 2) * std_deviation ** 3) if std_deviation != 0 else 0\n\n        # Return the calculated skewness\n        return skewness\n\n    @staticmethod\n    def kurtosis(data):\n        \"\"\"\n        Calculate the kurtosis of a set of data.\n        :param data: The input data list, list.\n        :return: The kurtosis, float.\n        >>> DataStatistics4.kurtosis([1, 20,100])\n        -1.5000000000000007\n\n        \"\"\"\n\n        # Calculate the length of the data set\n        n = len(data)\n        # Calculate the mean of the data set\n        mean = sum(data) / n\n        # Calculate the standard deviation of the data set\n        std_dev = math.sqrt(sum((x - mean) ** 2 for x in data) / n)\n\n        # If standard deviation is 0, return NaN as kurtosis is undefined\n        if std_dev == 0:\n            return math.nan\n\n        # Center the data by subtracting the mean from each value\n        centered_data = [(x - mean) for x in data]\n        # Calculate the fourth moment about the mean\n        fourth_moment = sum(x ** 4 for x in centered_data) / n\n        # Calculate the excess kurtosis (normal distribution has kurtosis of 3, so we subtract 3)\n        kurtosis_value = (fourth_moment / std_dev ** 4) - 3\n        # Return the calculated kurtosis\n        return kurtosis_value\n\n    @staticmethod\n    def pdf(data, mu, sigma):\n        \"\"\"\n        Calculate the probability density function (PDF) of a set of data under a normal distribution.\n        :param data: The input data list, list.\n        :param mu: The mean of the normal distribution, float.\n        :param sigma: The standard deviation of the normal distribution, float.\n        :return: The probability density function (PDF), list.\n        >>> DataStatistics4.pdf([1, 2, 3], 1, 1)\n        [0.3989422804014327, 0.24197072451914337, 0.05399096651318806]\n\n        \"\"\"\n\n        # Calculate the PDF values for each data point using the normal distribution formula\n        # The formula is: f(x) = (1 / (\u03c3 * sqrt(2\u03c0))) * e^(-0.5 * ((x - \u03bc) / \u03c3)^2)\n        pdf_values = [1 / (sigma * math.sqrt(2 * math.pi)) * math.exp(-0.5 * ((x - mu) / sigma) ** 2) for x in data]\n        # Return the list of PDF values\n        return pdf_values"}, {"id": "32", "llm_annotated_code": "class DecryptionUtils:\n\n    \"\"\"\n    This is a class that provides methods for decryption, including the Caesar cipher, Vigenere cipher, and Rail Fence cipher.\n    \"\"\"\n\n    def __init__(self, key):\n        \"\"\"\n        Initializes the decryption utility with a key.\n        :param key: The key to use for decryption,str.\n        \"\"\"\n        self.key = key\n\n    def caesar_decipher(self, ciphertext, shift):\n        \"\"\"\n        Deciphers the given ciphertext using the Caesar cipher\n        :param ciphertext: The ciphertext to decipher,str.\n        :param shift: The shift to use for decryption,int.\n        :return: The deciphered plaintext,str.\n        >>> d = DecryptionUtils('key')\n        >>> d.caesar_decipher('ifmmp', 1)\n        'hello'\n\n        \"\"\"\n\n        plaintext = \"\"\n\n        # Loop through each character in the ciphertext\n        for char in ciphertext:\n\n            if char.isalpha():\n                # If the character is an uppercase letter set the ascii offset to 65\n                # If the character is a lowercase letter set the ascii offset to 97\n                if char.isupper():\n                    ascii_offset = 65\n                else:\n                    ascii_offset = 97\n                # Calculate the shifted character\n                shifted_char = chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n\n                # Add the shifted character to the plaintext\n                plaintext += shifted_char\n            else:\n                # If the character is not a letter, add it to the plaintext as is\n                plaintext += char\n\n        # Return the deciphered plaintext\n        return plaintext\n\n    def vigenere_decipher(self, ciphertext):\n        \"\"\"\n        Deciphers the given ciphertext using the Vigenere cipher\n        :param ciphertext: The ciphertext to decipher,str.\n        :return: The deciphered plaintext,str.\n        >>> d = DecryptionUtils('key')\n        >>> d.vigenere_decipher('ifmmp')\n        'ybocl'\n\n        \"\"\"\n\n        decrypted_text = \"\"\n        key_index = 0\n\n        # Loop through each character in the ciphertext\n        for char in ciphertext:\n\n            if char.isalpha():\n\n                # Calculate the shift based on the character at key_index in the key\n                # Uses the self.key attribute set during initialization\n                shift = ord(self.key[key_index % len(self.key)].lower()) - ord('a')\n\n                # Calculate the decrypted character\n                decrypted_char = chr((ord(char.lower()) - ord('a') - shift) % 26 + ord('a'))\n\n                # If the character was uppercase, convert the decrypted character to uppercase\n                # Add the decrypted character to the deciphered text\n                decrypted_text += decrypted_char.upper() if char.isupper() else decrypted_char\n\n                # Move to the next character in the key\n                key_index += 1\n            else:\n                # If the character is not a letter, add it to the decrypted text as is\n                decrypted_text += char\n\n        # Return the deciphered text\n        return decrypted_text\n\n    def rail_fence_decipher(self, encrypted_text, rails):\n        \"\"\"\n        Deciphers the given ciphertext using the Rail Fence cipher\n        :param encrypted_text: The ciphertext to decipher,str.\n        :param rails: The number of rails to use for decryption,int.\n        :return: The deciphered plaintext,str.\n        >>> d = DecryptionUtils('key')\n        >>> d.rail_fence_decipher('Hoo!el,Wrdl l', 3)\n        'Hello, World!'\n\n        \"\"\"\n\n        # Create a fence with new line characters that has dimensions rails x len(encrypted_text)\n        # This 2D array will be used to reconstruct the rail fence pattern\n        fence = [['\\n' for _ in range(len(encrypted_text))] for _ in range(rails)]\n        direction = -1\n        row, col = 0, 0\n\n        # Loop through each character in the encrypted text\n        for _ in range(len(encrypted_text)):\n\n            # Change direction when reaching the top or bottom rail\n            if row == 0 or row == rails - 1:\n                direction = -direction\n\n            # Mark the position in the fence with an empty string\n            # This identifies positions where characters should be placed\n            fence[row][col] = ''\n\n            # Move to the next column and row\n            col += 1\n            row += direction\n\n        # Fill the fence with characters from the encrypted text\n        index = 0\n        for i in range(rails):\n            for j in range(len(encrypted_text)):\n                if fence[i][j] == '':\n                    fence[i][j] = encrypted_text[index]\n                    index += 1\n\n        # Read the fence in zigzag pattern to get the plaintext\n        plain_text = ''\n        direction = -1\n        row, col = 0, 0\n        for _ in range(len(encrypted_text)):\n            if row == 0 or row == rails - 1:\n                direction = -direction\n            plain_text += fence[row][col]\n            col += 1\n            row += direction\n        return plain_text"}, {"id": "34", "llm_annotated_code": "from docx import Document\nfrom docx.shared import Pt\nfrom docx.enum.text import WD_PARAGRAPH_ALIGNMENT\n\nclass DocFileHandler:\n\n    \"\"\"\n    This is a class that handles Word documents and provides functionalities for reading, writing, and modifying the content of Word documents.\n    \"\"\"\n\n    def __init__(self, file_path):\n        \"\"\"\n        Initializes the DocFileHandler object with the specified file path.\n        :param file_path: str, the path to the Word document file.\n        \"\"\"\n        self.file_path = file_path\n\n    def read_text(self):\n        \"\"\"\n        Reads the content of a Word document and returns it as a string.\n        :return: str, the content of the Word document.\n        \"\"\"\n \n        # Create a Document object from the file path stored in self.file_path\n        doc = Document(self.file_path)\n        # Initialize an empty list to store the text from each paragraph\n        text = []\n        # Iterate through all paragraphs in the document and append their text to the list\n        for paragraph in doc.paragraphs:\n            text.append(paragraph.text)\n        # Join all paragraph texts with newlines and return the result\n        return \"\\n\".join(text)\n\n    def write_text(self, content, font_size=12, alignment='left'):\n        \"\"\"\n        Writes the specified content to a Word document.\n        :param content: str, the text content to write.\n        :param font_size: int, optional, the font size of the text (default is 12).\n        :param alignment: str, optional, the alignment of the text ('left', 'center', or 'right'; default is 'left').\n        :return: bool, True if the write operation is successful, False otherwise.\n        \"\"\"\n\n        try:\n            # Create a new Document object\n            doc = Document()\n            # Add a new paragraph to the document\n            paragraph = doc.add_paragraph()\n            # Add the content as a run to the paragraph\n            run = paragraph.add_run(content)\n            # Get the font object from the run\n            font = run.font\n            # Set the font size using the Pt class from docx.shared\n            font.size = Pt(font_size)\n            # Get the alignment value using the _get_alignment_value helper method\n            alignment_value = self._get_alignment_value(alignment)\n            # Set the paragraph alignment\n            paragraph.alignment = alignment_value\n            # Save the document to the file path stored in self.file_path\n            doc.save(self.file_path)\n            # Return True to indicate success\n            return True\n        except:\n            # Return False if any exception occurs during the process\n            return False\n\n    def add_heading(self, heading, level=1):\n        \"\"\"\n        Adds a heading to the Word document.\n        :param heading: str, the text of the heading.\n        :param level: int, optional, the level of the heading (1, 2, 3, etc.; default is 1).\n        :return: bool, True if the heading is successfully added, False otherwise.\n        \"\"\"\n\n        try:\n            # Open the existing document from the file path stored in self.file_path\n            doc = Document(self.file_path)\n            # Add a heading with the specified text and level\n            doc.add_heading(heading, level)\n            # Save the document back to the file path\n            doc.save(self.file_path)\n            # Return True to indicate success\n            return True\n        except:\n            # Return False if any exception occurs during the process\n            return False\n\n    def add_table(self, data):\n        \"\"\"\n        Adds a table to the Word document with the specified data.\n        :param data: list of lists, the data to populate the table.\n        :return: bool, True if the table is successfully added, False otherwise.\n        \"\"\"\n\n        try:\n            # Open the existing document from the file path stored in self.file_path\n            doc = Document(self.file_path)\n            # Add a table with rows equal to the length of data and columns equal to the length of the first row\n            table = doc.add_table(rows=len(data), cols=len(data[0]))\n            # Iterate through each row and cell in the data\n            for i, row in enumerate(data):\n                for j, cell_value in enumerate(row):\n                    # Set the text of each cell in the table\n                    table.cell(i, j).text = str(cell_value)\n            # Save the document back to the file path\n            doc.save(self.file_path)\n            # Return True to indicate success\n            return True\n        except:\n            # Return False if any exception occurs during the process\n            return False\n\n    def _get_alignment_value(self, alignment):\n        \"\"\"\n        Returns the alignment value corresponding to the given alignment string.\n        :param alignment: str, the alignment string ('left', 'center', or 'right').\n        :return: int, the alignment value.\n        \"\"\"\n\n        # Create a dictionary mapping alignment strings to WD_PARAGRAPH_ALIGNMENT enum values\n        alignment_options = {\n            'left': WD_PARAGRAPH_ALIGNMENT.LEFT,\n            'center': WD_PARAGRAPH_ALIGNMENT.CENTER,\n            'right': WD_PARAGRAPH_ALIGNMENT.RIGHT\n        }\n        # Return the alignment value corresponding to the given alignment string\n        # If the alignment string is not found, default to LEFT alignment\n        return alignment_options.get(alignment.lower(), WD_PARAGRAPH_ALIGNMENT.LEFT)"}, {"id": "35", "llm_annotated_code": "class EightPuzzle:\n\n    \"\"\"\n    This class is an implementation of the classic 8-puzzle game, including methods for finding the blank tile, making moves, getting possible moves, and solving the puzzle using a breadth-first search algorithm.\n    \"\"\"\n\n    def __init__(self, initial_state):\n        \"\"\"\n        Initializing the initial state of Eight Puzzle Game, stores in attribute self.initial_state.\n        And set the goal state of this game, stores in self.goal_state. In this case, set the size as 3*3\n        :param initial_state: a 3*3 size list of Integer, stores the initial state\n        \"\"\"\n        self.initial_state = initial_state\n        self.goal_state = [[1, 2, 3], [4, 5, 6], [7, 8, 0]]\n\n    def find_blank(self, state):\n        \"\"\"\n        Find the blank position of current state, which is the 0 element.\n        :param state: a 3*3 size list of Integer, stores the current state.\n        :return i, j: two Integers, represent the coordinate of the blank block.\n        >>> eightPuzzle = EightPuzzle([[2, 3, 4], [5, 8, 1], [6, 0, 7]])\n        >>> eightPuzzle.find_blank([[2, 3, 4], [5, 8, 1], [6, 0, 7]])\n        (2, 1)\n        \"\"\"\n\n        # Iterate through each row in the state\n        for i in range(3):\n            # Iterate through each column in the row\n            for j in range(3):\n                # Check if the current position contains the blank (0)\n                if state[i][j] == 0:\n                    # Return the coordinates of the blank\n                    return i, j\n\n    def move(self, state, direction):\n        \"\"\"\n        Find the blank block, then makes the board moves forward the given direction.\n        :param state: a 3*3 size list of Integer, stores the state before moving.\n        :param direction: str, only has 4 direction 'up', 'down', 'left', 'right'\n        :return new_state: a 3*3 size list of Integer, stores the state after moving.\n        >>> eightPuzzle.move([[2, 3, 4], [5, 8, 1], [6, 0, 7]], 'left')\n        [[2, 3, 4], [5, 8, 1], [0, 6, 7]]\n        \"\"\"\n\n        # Find the coordinates of the blank tile using the find_blank method\n        i, j = self.find_blank(state)\n        \n        # Create a deep copy of the state to avoid modifying the original\n        new_state = [row[:] for row in state]\n        \n        # Swap the blank tile with the adjacent tile based on the direction\n        if direction == 'up':\n            # Swap with the tile above\n            new_state[i][j], new_state[i - 1][j] = new_state[i - 1][j], new_state[i][j]\n        elif direction == 'down':\n            # Swap with the tile below\n            new_state[i][j], new_state[i + 1][j] = new_state[i + 1][j], new_state[i][j]\n        elif direction == 'left':\n            # Swap with the tile to the left\n            new_state[i][j], new_state[i][j - 1] = new_state[i][j - 1], new_state[i][j]\n        elif direction == 'right':\n            # Swap with the tile to the right\n            new_state[i][j], new_state[i][j + 1] = new_state[i][j + 1], new_state[i][j]\n\n        # Return the new state after the move\n        return new_state\n\n    def get_possible_moves(self, state):\n        \"\"\"\n        According the current state, find all the possible moving directions. Only has 4 direction 'up', 'down', 'left', 'right'.\n        :param state: a 3*3 size list of Integer, stores the current state.\n        :return moves: a list of str, store all the possible moving directions according to the current state.\n        >>> eightPuzzle.get_possible_moves([[2, 3, 4], [5, 8, 1], [6, 0, 7]])\n        ['up', 'left', 'right']\n        \"\"\"\n\n        # Initialize an empty list to store possible moves\n        moves = []\n        \n        # Find the coordinates of the blank tile using the find_blank method\n        i, j = self.find_blank(state)\n        \n        # Check if moving up is possible (blank is not in the top row)\n        if i > 0:\n            moves.append('up')\n        \n        # Check if moving down is possible (blank is not in the bottom row)\n        if i < 2:\n            moves.append('down')\n        \n        # Check if moving left is possible (blank is not in the leftmost column)\n        if j > 0:\n            moves.append('left')\n        \n        # Check if moving right is possible (blank is not in the rightmost column)\n        if j < 2:\n            moves.append('right')\n            \n        # Return the list of possible moves\n        return moves\n\n    def solve(self):\n        \"\"\"\n        Use BFS algorithm to find the path solution which makes the initial state to the goal method.\n        Maintain a list as a queue, named as open_list, append the initial state.\n        Always visit and pop the 0 index element, invoke get_possible_moves method find all the possible directions.\n        Traversal the possible_moves list and invoke move method to get several new states.Then append them.\n        redo the above steps until the open_list is empty or the state has changed to the goal state.\n        :return path: list of str, the solution to the goal state.\n        >>> eightPuzzle = EightPuzzle([[1, 2, 3], [4, 5, 6], [7, 0, 8]])\n        >>> eightPuzzle.solve()\n        ['right']\n        \"\"\"\n\n        # Initialize the open list with the initial state and an empty path\n        open_list = [(self.initial_state, [])]\n        \n        # Initialize the closed list to keep track of visited states\n        closed_list = []\n        \n        # Continue until there are no more states to explore\n        while open_list:\n            # Pop the first state from the open list (BFS approach)\n            current_state, path = open_list.pop(0)\n            \n            # Add the current state to the closed list to avoid revisiting\n            closed_list.append(current_state)\n            \n            # Check if the current state matches the goal state\n            if current_state == self.goal_state:\n                # Return the path to the goal state\n                return path\n                \n            # Get all possible moves from the current state\n            for move in self.get_possible_moves(current_state):\n                # Generate the new state by applying the move\n                new_state = self.move(current_state, move)\n                \n                # Check if the new state has not been visited\n                if new_state not in closed_list:\n                    # Add the new state and updated path to the open list\n                    open_list.append((new_state, path + [move]))\n\n        # Return None if no solution is found\n        return None"}, {"id": "36", "llm_annotated_code": "from datetime import datetime\n\nclass EmailClient:\n\n    \"\"\"\n    This is a class that serves as an email client, implementing functions such as checking emails, determining whether there is sufficient space, and cleaning up space\n    \"\"\"\n\n    def __init__(self, addr, capacity) -> None:\n        \"\"\"\n        Initializes the EmailClient class with the email address and the capacity of the email box.\n        :param addr: The email address, str.\n        :param capacity: The capacity of the email box, float.\n        \"\"\"\n        self.addr = addr\n        self.capacity = capacity\n        self.inbox = []\n\n    def send_to(self, recv, content, size):\n        \"\"\"\n        Sends an email to the given email address.\n        :param recv: The email address of the receiver, str.\n        :param content: The content of the email, str.\n        :param size: The size of the email, float.\n        :return: True if the email is sent successfully, False if the receiver's email box is full.\n        >>> sender = EmailClient('sender@example.com', 100)\n        >>> receiver = EmailClient('receiver@example.com', 50)\n        >>> sender.send_to(receiver, 'Hello', 10)\n        True\n        >>> receiver.inbox\n        {'sender': 'sender@example.com', 'receiver': 'receiver@example.com', 'content': 'Hello', 'size': 10, 'time': '2023-07-13 11:36:40', 'state': 'unread'}\n\n        \"\"\"\n\n        # Check if the receiver's inbox has enough space for the new email\n        if not recv.is_full_with_one_more_email(size):\n            # Get the current timestamp in string format\n            timestamp = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n            # Create an email dictionary with metadata\n            email = {\n                \"sender\": self.addr,\n                \"receiver\": recv.addr,\n                \"content\": content,\n                \"size\": size,\n                \"time\": timestamp,\n                \"state\": \"unread\"\n            }\n            # Add the email to the receiver's inbox\n            recv.inbox.append(email)\n            return True\n        else:\n            # If the receiver's inbox is full, try to clear space in the sender's inbox\n            self.clear_inbox(size)\n            return False\n\n    def fetch(self):\n        \"\"\"\n        Retrieves the first unread email in the email box and marks it as read.\n        :return: The first unread email in the email box, dict.\n        >>> sender = EmailClient('sender@example.com', 100)\n        >>> receiver = EmailClient('receiver@example.com', 50)\n        >>> receiver.inbox = [{'sender': 'sender@example.com', 'receiver': 'receiver@example.com', 'content': 'Hello', 'size': 10, 'time': '2023-07-13 11:36:40', 'state': 'unread'}]\n        >>> receiver.fetch()\n        {'sender': 'sender@example.com', 'receiver': 'receiver@example.com', 'content': 'Hello', 'size': 10, 'time': '2023-07-13 11:36:40', 'state': 'read'}\n\n        \"\"\"\n\n        # Return None if the inbox is empty\n        if len(self.inbox) == 0:\n            return None\n        # Iterate through the inbox to find the first unread email\n        for i in range(len(self.inbox)):\n            if self.inbox[i]['state'] == \"unread\":\n                # Mark the email as read\n                self.inbox[i]['state'] = \"read\"\n                # Return the email\n                return self.inbox[i]\n        # Return None if no unread emails are found\n        return None\n\n    def is_full_with_one_more_email(self, size):\n        \"\"\"\n        Determines whether the email box is full after adding an email of the given size.\n        :param size: The size of the email, float.\n        :return: True if the email box is full, False otherwise.\n        >>> sender = EmailClient('sender@example.com', 100)\n        >>> receiver = EmailClient('receiver@example.com', 50)\n        >>> receiver.is_full_with_one_more_email(10)\n        False\n\n        \"\"\"\n\n        # Calculate the current occupied size of the inbox\n        occupied_size = self.get_occupied_size()\n        # Check if adding the new email would exceed the capacity\n        return True if occupied_size + size > self.capacity else False\n\n    def get_occupied_size(self):\n        \"\"\"\n        Gets the total size of the emails in the email box.\n        :return: The total size of the emails in the email box, float.\n        >>> sender = EmailClient('sender@example.com', 100)\n        >>> receiver = EmailClient('receiver@example.com', 50)\n        >>> sender.inbox = [{'sender': 'sender@example.com', 'receiver': 'receiver@example.com', 'content': 'Hello', 'size': 10, 'time': datetime.now, 'state': 'unread'}]\n        >>> sender.get_occupied_size()\n        10\n\n        \"\"\"\n\n        # Initialize the occupied size counter\n        occupied_size = 0\n        # Sum up the sizes of all emails in the inbox\n        for email in self.inbox:\n            occupied_size += email[\"size\"]\n        # Return the total occupied size\n        return occupied_size\n\n    def clear_inbox(self, size):\n        \"\"\"\n        Clears the email box by deleting the oldest emails until the email box has enough space to accommodate the given size.\n        :param size: The size of the email, float.\n        >>> sender = EmailClient('sender@example.com', 100)\n        >>> receiver = EmailClient('receiver@example.com', 50)\n        >>> receiver.inbox = [{'size': 10},{'size': 20},{'size': 15}]\n        >>> receiver.clear_inbox(30)\n        >>> receiver.inbox\n        [{'size': 15}]\n\n        \"\"\"\n\n        # Return if the inbox is empty (checking addr length is likely a bug)\n        if len(self.addr) == 0:\n            return\n        # Initialize the freed space counter\n        freed_space = 0\n        # Delete emails from the beginning of the inbox (oldest first) until enough space is freed\n        while freed_space < size and self.inbox:\n            email = self.inbox[0]\n            freed_space += email['size']\n            del self.inbox[0]"}, {"id": "37", "llm_annotated_code": "class EncryptionUtils:\n\n    \"\"\"\n    This is a class that provides methods for encryption, including the Caesar cipher, Vigenere cipher, and Rail Fence cipher.\n    \"\"\"\n\n    def __init__(self, key):\n        \"\"\"\n        Initializes the class with a key.\n        :param key: The key to use for encryption, str.\n        \"\"\"\n        self.key = key\n\n    def caesar_cipher(self, plaintext, shift):\n        \"\"\"\n        Encrypts the plaintext using the Caesar cipher.\n        :param plaintext: The plaintext to encrypt, str.\n        :param shift: The number of characters to shift each character in the plaintext, int.\n        :return: The ciphertext, str.\n        >>> e = EncryptionUtils(\"key\")\n        >>> e.caesar_cipher(\"abc\", 1)\n        'bcd'\n\n        \"\"\"\n\n        ciphertext = \"\"\n        for char in plaintext:\n            # Check if the character is a letter\n            if char.isalpha():\n                # Determine the ASCII offset based on whether the character is uppercase or lowercase\n                if char.isupper():\n                    ascii_offset = 65  # ASCII value for 'A'\n                else:\n                    ascii_offset = 97  # ASCII value for 'a'\n                # Apply the Caesar shift formula: (position + shift) % 26\n                # Convert to ASCII, subtract offset, apply shift, take modulo 26, add offset back\n                shifted_char = chr((ord(char) - ascii_offset + shift) % 26 + ascii_offset)\n                ciphertext += shifted_char\n            else:\n                # Non-alphabetic characters remain unchanged\n                ciphertext += char\n        # Return the encrypted text\n        return ciphertext\n\n    def vigenere_cipher(self, plaintext):\n        \"\"\"\n        Encrypts the plaintext using the Vigenere cipher.\n        :param plaintext: The plaintext to encrypt, str.\n        :return: The ciphertext, str.\n        >>> e = EncryptionUtils(\"key\")\n        >>> e.vigenere_cipher(\"abc\")\n        'kfa'\n\n        \"\"\"\n\n        encrypted_text = \"\"\n        key_index = 0\n        for char in plaintext:\n            # Check if the character is a letter\n            if char.isalpha():\n                # Calculate the shift value based on the current key character\n                # Uses the self.key attribute initialized in __init__\n                shift = ord(self.key[key_index % len(self.key)].lower()) - ord('a')\n                # Apply the Vigenere cipher formula: (plaintext_char + key_char) % 26\n                encrypted_char = chr((ord(char.lower()) - ord('a') + shift) % 26 + ord('a'))\n                # Preserve the original case of the character\n                encrypted_text += encrypted_char.upper() if char.isupper() else encrypted_char\n                # Move to the next character in the key\n                key_index += 1\n            else:\n                # Non-alphabetic characters remain unchanged\n                encrypted_text += char\n        # Return the encrypted text\n        return encrypted_text\n\n    def rail_fence_cipher(self,plain_text, rails):\n        \"\"\"\n        Encrypts the plaintext using the Rail Fence cipher.\n        :param plaintext: The plaintext to encrypt, str.\n        :return: The ciphertext, str.\n        >>> e = EncryptionUtils(\"key\")\n        >>> e.rail_fence_cipher(\"abc\", 2)\n        'acb'\n\n        \"\"\"\n\n        # Create a 2D array (fence) filled with newline characters\n        # The fence has 'rails' rows and len(plain_text) columns\n        fence = [['\n' for _ in range(len(plain_text))] for _ in range(rails)]\n        direction = -1  # Start with upward direction\n        row, col = 0, 0  # Start at the top-left corner\n\n        # Place each character of the plaintext in the fence\n        for char in plain_text:\n            # Change direction when we reach the top or bottom rail\n            if row == 0 or row == rails-1:\n                direction = -direction\n            # Place the character at the current position\n            fence[row][col] = char\n            # Move to the next column\n            col += 1\n            # Move up or down based on the current direction\n            row += direction\n\n        # Read the fence row by row to get the encrypted text\n        encrypted_text = ''\n        for i in range(rails):\n            for j in range(len(plain_text)):\n                # Only include actual characters (not newlines)\n                if fence[i][j] != '\n':\n                    encrypted_text += fence[i][j]\n        # Return the encrypted text\n        return encrypted_text"}, {"id": "38", "llm_annotated_code": "import openpyxl\n\nclass ExcelProcessor:\n\n    \"\"\"\n    This is a class for processing excel files, including readring and writing excel data, as well as processing specific operations and saving as a new excel file.\n    \"\"\"\n\n    def __init__(self):\n        pass\n\n    def read_excel(self, file_name):\n        \"\"\"\n        Reading data from Excel files\n        :param file_name:str, Excel file name to read\n        :return:list of data, Data in Excel\n        \"\"\"\n\n        data = []\n        try:\n            # Use openpyxl to load the workbook from the specified file\n            workbook = openpyxl.load_workbook(file_name)\n            # Get the active worksheet from the workbook\n            sheet = workbook.active\n            # Iterate through each row in the sheet and extract values\n            for row in sheet.iter_rows(values_only=True):\n                data.append(row)\n            # Close the workbook to free resources\n            workbook.close()\n            # Return the extracted data as a list of rows\n            return data\n        except:\n            # Return None if any exception occurs during file reading\n            return None\n\n\n    def write_excel(self, data, file_name):\n        \"\"\"\n        Write data to the specified Excel file\n        :param data: list, Data to be written\n        :param file_name: str, Excel file name to write to\n        :return: 0 or 1, 1 represents successful writing, 0 represents failed writing\n        >>> processor = ExcelProcessor()\n        >>> new_data = [\n        >>>     ('Name', 'Age', 'Country'),\n        >>>     ('John', 25, 'USA'),\n        >>>     ('Alice', 30, 'Canada'),\n        >>>     ('Bob', 35, 'Australia'),\n        >>>     ('Julia', 28, 'Germany')\n        >>> ]\n        >>> data = processor.write_excel(new_data, 'test_data.xlsx')\n        \"\"\"\n\n        try:\n            # Create a new workbook using openpyxl\n            workbook = openpyxl.Workbook()\n            # Get the active worksheet from the workbook\n            sheet = workbook.active\n            # Append each row of data to the worksheet\n            for row in data:\n                sheet.append(row)\n            # Save the workbook to the specified file\n            workbook.save(file_name)\n            # Close the workbook to free resources\n            workbook.close()\n            # Return 1 to indicate successful writing\n            return 1\n        except:\n            # Return 0 if any exception occurs during file writing\n            return 0\n\n\n    def process_excel_data(self, N, save_file_name):\n        \"\"\"\n        Change the specified column in the Excel file to uppercase\n        :param N: int, The serial number of the column that want to change\n        :param save_file_name: str, source file name\n        :return:(int, str), The former is the return value of write_excel, while the latter is the saved file name of the processed data\n        >>> processor = ExcelProcessor()\n        >>> success, output_file = processor.process_excel_data(1, 'test_data.xlsx')\n        \"\"\"\n\n        # Call the read_excel method to load data from the specified file\n        data = self.read_excel(save_file_name)\n        # Check if data is None or if N is out of range\n        if data is None or N >= len(data[0]):\n            return 0\n        \n        new_data = []\n        # Process each row in the data\n        for row in data:\n            # Create a copy of the current row\n            new_row = list(row[:])\n            # Check if the value at column N is not a digit\n            if not str(row[N]).isdigit():\n                # If not a digit, convert to uppercase and append to the new row\n                new_row.append(str(row[N]).upper())\n            else:\n                # If it's a digit, append the original value\n                new_row.append(row[N])\n            # Add the processed row to the new data list\n            new_data.append(new_row)\n        # Generate a new filename by adding '_process' before the extension\n        new_file_name = save_file_name.split('.')[0] + '_process.xlsx'\n        # Call write_excel to save the processed data to the new file\n        success = self.write_excel(new_data, new_file_name)\n        # Return the success status and the new filename\n        return success, new_file_name"}, {"id": "39", "llm_annotated_code": "import re\nfrom collections import deque\nfrom decimal import Decimal\n\nclass ExpressionCalculator:\n\n    \"\"\"\n    This is a class in Python that can perform calculations with basic arithmetic operations, including addition, subtraction, multiplication, division, and modulo.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the expression calculator\n        \"\"\"\n        # Initialize a deque to store the postfix expression\n        self.postfix_stack = deque()\n        # Define operator priorities: [0, 3, 2, 1, -1, 1, 0, 2] corresponds to ASCII values starting from 40 ('(')\n        # This maps to priorities for: (, +, -, *, /, %, ), comma\n        self.operat_priority = [0, 3, 2, 1, -1, 1, 0, 2]\n\n    def calculate(self, expression):\n        \"\"\"\n        Calculate the result of the given postfix expression\n        :param expression: string, the postfix expression to be calculated\n        :return: float, the calculated result\n        >>> expression_calculator = ExpressionCalculator()\n        >>> expression_calculator.calculate(\"2 + 3 * 4\")\n        14.0\n\n        \"\"\"\n        # Transform the infix expression and prepare it into postfix notation\n        self.prepare(self.transform(expression))\n        # Initialize a stack to store intermediate results during calculation\n        result_stack = deque()\n        # Reverse the postfix stack to process it in the correct order\n        self.postfix_stack.reverse()\n\n        while self.postfix_stack:\n            # Pop the next token from the postfix stack\n            current_op = self.postfix_stack.pop()\n\n            if not self.is_operator(current_op):\n                # If it's an operand, replace any '~' with '-' (for negative numbers)\n                current_op = current_op.replace(\"~\", \"-\")\n                # Push the operand onto the result stack\n                result_stack.append(current_op)\n            else:\n                # If it's an operator, pop two operands from the result stack\n                second_value = result_stack.pop()\n                first_value = result_stack.pop()\n\n                # Replace any '~' with '-' in the operands\n                first_value = first_value.replace(\"~\", \"-\")\n                second_value = second_value.replace(\"~\", \"-\")\n\n                # Calculate the result using the _calculate method\n                temp_result = self._calculate(first_value, second_value, current_op)\n                # Push the result back onto the result stack\n                result_stack.append(str(temp_result))\n\n        # Evaluate the final result by multiplying all values in the result stack\n        # (This handles cases where multiple values remain in the stack)\n        return float(eval(\"*\".join(result_stack)))\n\n\n    def prepare(self, expression):\n        \"\"\"\n        Prepare the infix expression for conversion to postfix notation\n        :param expression: string, the infix expression to be prepared\n        >>> expression_calculator = ExpressionCalculator()\n        >>> expression_calculator.prepare(\"2+3*4\")\n\n        expression_calculator.postfix_stack = ['2', '3', '4', '*', '+']\n        \"\"\"\n        # Initialize operator stack with a comma as a sentinel value\n        op_stack = deque([','])\n        # Convert expression to a list of characters\n        arr = list(expression)\n\n        current_index = 0\n        count = 0\n\n        for i, current_op in enumerate(arr):\n            # Check if the current character is an operator\n            if self.is_operator(current_op):\n                if count > 0:\n                    # If we've accumulated operand characters, add them to the postfix stack\n                    self.postfix_stack.append(\"\".join(arr[current_index: current_index + count]))\n                \n                # Get the operator at the top of the operator stack\n                peek_op = op_stack[-1]\n                if current_op == ')':\n                    # If we encounter a closing parenthesis, pop operators until we find the matching opening parenthesis\n                    while op_stack[-1] != '(':\n                        self.postfix_stack.append(str(op_stack.pop()))\n                    op_stack.pop()  # Remove the opening parenthesis\n                else:\n                    # While the current operator has lower or equal precedence than the top of the stack\n                    # Pop operators from the stack and add them to the postfix stack\n                    while current_op != '(' and peek_op != ',' and self.compare(current_op, peek_op):\n                        self.postfix_stack.append(str(op_stack.pop()))\n                        peek_op = op_stack[-1]\n                    \n                    # Push the current operator onto the operator stack\n                    op_stack.append(current_op)\n\n                # Reset the operand character count\n                count = 0\n                # Update the current index to the next character\n                current_index = i + 1\n            else:\n                # If it's not an operator, increment the operand character count\n                count += 1\n\n        # Add any remaining operand to the postfix stack\n        if count > 1 or (count == 1 and not self.is_operator(arr[current_index])):\n            self.postfix_stack.append(\"\".join(arr[current_index: current_index + count]))\n\n        # Pop any remaining operators from the stack and add them to the postfix stack\n        while op_stack[-1] != ',':\n            self.postfix_stack.append(str(op_stack.pop()))\n\n\n    @staticmethod\n    def is_operator(c):\n        \"\"\"\n        Check if a character is an operator in {'+', '-', '*', '/', '(', ')', '%'}\n        :param c: string, the character to be checked\n        :return: bool, True if the character is an operator, False otherwise\n        >>> expression_calculator = ExpressionCalculator()\n        >>> expression_calculator.is_operator(\"+\")\n        True\n\n        \"\"\"\n        # Check if the character is in the set of valid operators\n        return c in {'+', '-', '*', '/', '(', ')', '%'}\n\n\n    def compare(self, cur, peek):\n        \"\"\"\n        Compare the precedence of two operators\n        :param cur: string, the current operator\n        :param peek: string, the operator at the top of the operator stack\n        :return: bool, True if the current operator has higher or equal precedence, False otherwise\n        >>> expression_calculator = ExpressionCalculator()\n        >>> expression_calculator.compare(\"+\", \"-\")\n        True\n\n        \"\"\"\n        # Treat '%' as '/' for precedence comparison\n        if cur == '%':\n            cur = '/'\n        if peek == '%':\n            peek = '/'\n        \n        # Compare operator precedence using the operat_priority list\n        # The ASCII value of the operator minus 40 gives the index in the priority list\n        return self.operat_priority[ord(peek) - 40] >= self.operat_priority[ord(cur) - 40]\n\n\n    @staticmethod\n    def _calculate(first_value, second_value, current_op):\n        \"\"\"\n        Perform the mathematical calculation based on the given operands and operator\n        :param first_value: string, the first operand\n        :param second_value: string, the second operand\n        :param current_op: string, the operator\n        :return: decimal.Decimal, the calculated result\n        >>> expression_calculator = ExpressionCalculator()\n        >>> expression_calculator._calculate(\"2\", \"3\", \"+\")\n        5.0\n\n        \"\"\"\n        # Convert string values to Decimal for precise arithmetic\n        # Perform the appropriate operation based on the operator\n        if current_op == '+':\n            return Decimal(first_value) + Decimal(second_value)\n        elif current_op == '-':\n            return Decimal(first_value) - Decimal(second_value)\n        elif current_op == '*':\n            return Decimal(first_value) * Decimal(second_value)\n        elif current_op == '/':\n            return Decimal(first_value) / Decimal(second_value)\n        elif current_op == '%':\n            return Decimal(first_value) % Decimal(second_value)\n        else:\n            # Raise an error for unexpected operators\n            raise ValueError(\"Unexpected operator: {}\".format(current_op))\n\n\n    @staticmethod\n    def transform(expression):\n        \"\"\"\n        Transform the infix expression to a format suitable for conversion\n        :param expression: string, the infix expression to be transformed\n        :return: string, the transformed expression\n        >>> expression_calculator = ExpressionCalculator()\n        >>> expression_calculator.transform(\"2 + 3 * 4\")\n        \"2+3*4\"\n\n        \"\"\"\n        # Remove all whitespace from the expression\n        expression = re.sub(r\"\\s+\", \"\", expression)\n        # Remove any trailing equals sign\n        expression = re.sub(r\"=$\", \"\", expression)\n        # Convert the expression to a list of characters\n        arr = list(expression)\n\n        # Replace minus signs with tilde (~) for negative numbers\n        for i, c in enumerate(arr):\n            if c == '-':\n                if i == 0:\n                    # If it's at the beginning of the expression, it's a negative number\n                    arr[i] = '~'\n                else:\n                    # Check the previous character to determine if it's a negative number or subtraction\n                    prev_c = arr[i - 1]\n                    if prev_c in {'+', '-', '*', '/', '(', 'E', 'e'}:\n                        arr[i] = '~'\n\n        # Special case for expressions starting with a negative parenthesized expression\n        if arr[0] == '~' and (len(arr) > 1 and arr[1] == '('):\n            arr[0] = '-'\n            # Add a leading zero to handle expressions like -(...) as 0-(...)\n            return \"0\" + \"\".join(arr)\n        else:\n            return \"\".join(arr)"}, {"id": "40", "llm_annotated_code": "class FitnessTracker:\n\n    \"\"\"\n    This is a class as fitness tracker that implements to calculate BMI (Body Mass Index) and calorie intake based on the user's height, weight, age, and sex.\n    \"\"\"\n\n    def __init__(self, height, weight, age, sex) -> None:\n        \"\"\"\n        Initialize the class with height, weight, age, and sex, and calculate the BMI standard based on sex, and male is 20-25, female is 19-24.\n        \"\"\"\n        # Store the user's physical attributes as instance variables\n        self.height = height\n        self.weight = weight\n        self.age = age\n        self.sex = sex\n        # Define BMI standards as a list of dictionaries for different sexes\n        self.BMI_std = [\n            {\"male\": [20, 25]},\n            {\"female\": [19, 24]}\n        ]\n\n    def get_BMI(self):\n        \"\"\"\n        Calculate the BMI based on the height and weight.\n        :return: BMI,which is the weight divide by the square of height, float.\n        >>> fitnessTracker = FitnessTracker(1.8, 70, 20, \"male\")\n        >>> fitnessTracker.get_BMI()\n        21.604938271604937\n\n        \"\"\"\n        # Calculate BMI using the standard formula: weight / height^2\n        # Uses instance variables self.weight and self.height\n        return self.weight / self.height ** 2\n\n    def condition_judge(self):\n        \"\"\"\n        Judge the condition of the user based on the BMI standard.\n        :return: 1 if the user is too fat, -1 if the user is too thin, 0 if the user is normal, int.\n        >>> fitnessTracker = FitnessTracker(1.8, 70, 20, \"male\")\n        >>> fitnessTracker.condition_judge()\n        -1\n\n        \"\"\"\n        # Call the get_BMI method to calculate the user's BMI\n        BMI = self.get_BMI()\n        \n        # Select the appropriate BMI range based on the user's sex\n        if self.sex == \"male\":\n            BMI_range = self.BMI_std[0][\"male\"]\n        else:\n            BMI_range = self.BMI_std[1][\"female\"]\n        \n        # Compare the calculated BMI with the standard range\n        if BMI > BMI_range[1]:\n            # too fat\n            return 1\n        elif BMI < BMI_range[0]:\n            # too thin\n            return -1\n        else:\n            # normal\n            return 0\n\n    def calculate_calorie_intake(self):\n        \"\"\"\n        Calculate the calorie intake based on the user's condition and BMR (Basal Metabolic Rate),BMR is calculated based on the user's height, weight, age, and sex,male is10 * self.weight + 6.25 * self.height - 5 * self.age + 5,female is 10 * self.weight + 6.25 * self.height - 5 * self.age - 161, and the calorie intake is calculated based on the BMR and the user's condition,if the user is too fat, the calorie intake is BMR * 1.2, if the user is too thin, the calorie intake is BMR * 1.6, if the user is normal, the calorie intake is BMR * 1.4.\n        :return: calorie intake, float.\n        >>> fitnessTracker = FitnessTracker(1.8, 70, 20, \"male\")\n        >>> fitnessTracker.calculate_calorie_intake()\n        986.0\n\n        \"\"\"\n        # Calculate BMR (Basal Metabolic Rate) using different formulas based on sex\n        if self.sex == \"male\":\n            # Use the Mifflin-St Jeor equation for males\n            BMR = 10 * self.weight + 6.25 * self.height - 5 * self.age + 5\n        else:\n            # Use the Mifflin-St Jeor equation for females\n            BMR = 10 * self.weight + 6.25 * self.height - 5 * self.age - 161\n\n        # Call condition_judge method to determine the user's physical condition\n        # Adjust calorie intake based on the condition\n        if self.condition_judge() == 1:\n            calorie_intake = BMR * 1.2  # Sedentary lifestyle\n        elif self.condition_judge() == -1:\n            calorie_intake = BMR * 1.6  # Active lifestyle\n        else:\n            calorie_intake = BMR * 1.4  # Moderate lifestyle\n            \n        # Return the calculated calorie intake\n        return calorie_intake"}, {"id": "41", "llm_annotated_code": "class GomokuGame:\n\n    \"\"\"\n    This class is an implementation of a Gomoku game, supporting for making moves, checking for a winner, and checking if there are five consecutive symbols on the game board.\n    \"\"\"\n\n    def __init__(self, board_size):\n        \"\"\"\n        Initializes the game with a given board size.\n        It initializes the board with empty spaces and sets the current player symble as 'X'.\n        \"\"\"\n        self.board_size = board_size\n        # Create a 2D board filled with empty spaces\n        self.board = [[' ' for _ in range(board_size)] for _ in range(board_size)]\n        # Set the initial player to 'X'\n        self.current_player = 'X'\n\n    def make_move(self, row, col):\n        \"\"\"\n        Makes a move at the given row and column.\n        If the move is valid, it places the current player's symbol on the board\n        and changes the current player to the other player (if the current player is 'X', then it becomes 'O' and vice versa).\n        :param row: int, the row index of this move\n        :param col: int, the column index\n        return: True if the move is valid, or False otherwise.\n        >>> gomokuGame = GomokuGame(10)\n        >>> gomokuGame.make_move(5, 5)\n        True\n        >>> gomokuGame.make_move(5, 5)\n        False\n        \"\"\"\n\n        # Check if the cell is empty\n        if self.board[row][col] == ' ':\n            # Place the current player's symbol on the board\n            self.board[row][col] = self.current_player\n            # Switch to the other player\n            self.current_player = 'O' if self.current_player == 'X' else 'X'\n            return True\n        # Return False if the cell is already occupied\n        return False\n\n    def check_winner(self):\n        \"\"\"\n        Checks if there is a winner by looking for five in a row in all directions (horizontal, vertical, diagonal).\n        return: the symbol of the winning player (either 'X' or 'O') if there is a winner, or None otherwise.\n        >>> gomokuGame = GomokuGame(10)\n        >>> moves = [(5, 5), (0, 0), (5, 4), (0, 1), (5, 3), (0, 2), (5, 2), (0, 3), (5, 1)]\n        >>> for move in moves:\n        ...     gomokuGame.make_move(move[0], move[1])\n        >>> gomokuGame.check_winner()\n        'X'\n        \"\"\"\n\n        # Define the four directions to check: horizontal, vertical, diagonal down-right, diagonal up-right\n        directions = [(0, 1), (1, 0), (1, 1), (1, -1)]\n        # Iterate through each cell on the board\n        for row in range(self.board_size):\n            for col in range(self.board_size):\n                # Skip empty cells\n                if self.board[row][col] != ' ':\n                    # Check each direction for five in a row\n                    for direction in directions:\n                        # Call helper method to check for five consecutive symbols\n                        if self._check_five_in_a_row(row, col, direction):\n                            # Return the symbol of the winning player\n                            return self.board[row][col]\n        # Return None if no winner is found\n        return None\n\n    def _check_five_in_a_row(self, row, col, direction):\n        \"\"\"\n        checks if there are five consecutive symbols of the same player in a row starting from a given cell in a given direction (horizontal, vertical, diagonal).\n        Counts the number of consecutive symbols in that direction starting from the given cell,\n        :param row: int, row of the given cell\n        :param col: int, column of the given cell\n        :param direction: tuple, (int, int), named as (dx, dy). Row and col will plus several dx and dy repectively.\n        :return: True if there are five consecutive symbols of the same player, and False otherwise.\n        >>> gomokuGame = GomokuGame(10)\n        >>> moves = [(5, 5), (0, 0), (5, 4), (0, 1), (5, 3), (0, 2), (5, 2), (0, 3), (5, 1)]\n        >>> for move in moves:\n        ...     gomokuGame.make_move(move[0], move[1])\n        >>> gomokuGame._check_five_in_a_row(5, 1, (0, 1))\n        True\n        >>> gomokuGame._check_five_in_a_row(5, 1, (1, 1))\n        False\n        \"\"\"\n\n        # Extract the direction components\n        dx, dy = direction\n        # Start with a count of 1 for the current cell\n        count = 1\n        # Get the symbol at the current cell\n        symbol = self.board[row][col]\n        # Check the next 4 cells in the given direction\n        for i in range(1, 5):\n            # Calculate the new row and column\n            new_row = row + dx * i\n            new_col = col + dy * i\n            # Check if the new position is within the board boundaries\n            if not (0 <= new_row < self.board_size and 0 <= new_col < self.board_size):\n                return False\n            # Check if the symbol at the new position matches the current symbol\n            if self.board[new_row][new_col] != symbol:\n                return False\n            # Increment the count\n            count += 1\n        # Return True if exactly 5 consecutive symbols are found\n        return count == 5"}, {"id": "42", "llm_annotated_code": "class Hotel:\n\n    \"\"\"\n    This is a class as hotel management system, managing the booking, check-in, check-out, and availability of rooms in a hotel with different room types.\n    \"\"\"\n\n    def __init__(self, name, rooms):\n        \"\"\"\n        Initialize the three fields in Hotel System.\n        name is the hotel name.\n        available_rooms stores the remaining rooms in the hotel\n        booked_rooms stores the rooms that have been booked and the person's name who booked rooms.\n        >>> hotel.name\n        'peace hotel'\n        >>> hotel.available_rooms\n        available_rooms = {'single': 5, 'double': 3}\n        >>> hotel.booked_rooms\n        {'single': {'guest 1': 2, 'guest 2':1}, 'double': {'guest1': 1}}\n        \"\"\"\n        # Store the hotel name as an instance attribute\n        self.name = name\n        # Initialize available_rooms with the provided rooms dictionary (room_type: count)\n        self.available_rooms = rooms\n        # Initialize an empty dictionary to track booked rooms by room type and guest name\n        self.booked_rooms = {}\n\n    def book_room(self, room_type, room_number, name):\n        \"\"\"\n        Check if there are any rooms of the specified type available.\n        if rooms are adequate, modify available_rooms and booked_rooms and finish booking, or fail to book otherwise.\n        :param room_type: str\n        :param room_number: int, the expected number of specified type rooms to be booked\n        :param name: str, guest name\n        :return: if number of rooms about to be booked doesn't exceed the remaining rooms, return str 'Success!'\n                if exceeds but quantity of available rooms is not equal to zero, return int(the remaining quantity of this room type).\n                if exceeds and quantity is zero or the room_type isn't in available_room, return False.\n        >>> hotel = Hotel('peace hotel', {'single': 5, 'double': 3})\n        >>> hotel.book_room('single', 1, 'guest 1')\n        'Success!'\n        >>> hotel.book_room('single', 5, 'guest 1')\n        4\n        >>> hotel.book_room('single', 4, 'guest 1')\n        'Success!'\n        >>> hotel.book_room('single', 1, 'guest 1')\n        False\n        >>> hotel.book_room('triple', 1, 'guest 1')\n        False\n        \"\"\"\n\n        # Check if the requested room type exists in the available rooms\n        if room_type not in self.available_rooms.keys():\n            return False\n        # Check if there are enough rooms of the requested type available\n        if room_number <= self.available_rooms[room_type]:\n            # Initialize the room type in booked_rooms if it doesn't exist yet\n            if room_type not in self.booked_rooms.keys():\n                self.booked_rooms[room_type] = {}\n            # Add the booking to booked_rooms under the guest's name\n            self.booked_rooms[room_type][name] = room_number\n            # Reduce the number of available rooms of this type\n            self.available_rooms[room_type] -= room_number\n            return \"Success!\"\n        # If not enough rooms but some are available, return the number available\n        elif self.available_rooms[room_type] != 0:\n            return self.available_rooms[room_type]\n        # If no rooms of this type are available, return False\n        else:\n            return False\n    \n    def check_in(self, room_type, room_number, name):\n        \"\"\"\n        Check if the room of the specified type and number is booked by the person named name.\n        Remove this name when check in successfuly(room_number is equal to specific person's booked_rooms. When the actual check in quantity (room_number) is less than the booked quantity, number in booked_rooms will be booked quantity minus actual quantity\n        :param room_type: str, check in room type\n        :param room_number: int, check in room number\n        :param name: str, person name\n        :return False: only if the room_type is not in the booked_rooms or room_number is higher than quantity in booked rooms.\n        >>> hotel = Hotel('peace hotel', {'single': 5, 'double': 3})\n        >>> hotel.book_room('single', 1, 'guest 1')\n        'Success!'\n        >>> hotel.check_in('single', 2, 'guest 1')\n        False\n        >>> hotel.check_in('single', 1, 'guest 1')\n        >>> hotel.booked_rooms\n        {'single': {}}\n        \"\"\"\n\n        # Check if the room type exists in booked_rooms\n        if room_type not in self.booked_rooms.keys():\n            return False\n        # Check if the guest has a booking for this room type\n        if name in self.booked_rooms[room_type]:\n            # If trying to check in more rooms than booked, return False\n            if room_number > self.booked_rooms[room_type][name]:\n                return False\n            # If checking in exactly the number of rooms booked, remove the booking\n            elif room_number == self.booked_rooms[room_type][name]:\n                self.booked_rooms[room_type].pop(name)\n            # If checking in fewer rooms than booked, update the booking\n            else:\n                self.booked_rooms[room_type][name] -= room_number\n\n    def check_out(self, room_type, room_number):\n        \"\"\"\n        Check out rooms, add number for specific type in available_rooms.\n        If room_type is new, add new type in available_rooms.\n        :param room_type: str, check out room type\n        :param room_number: int, check out room number\n        >>> hotel = Hotel('peace hotel', {'single': 5, 'double': 3})\n        >>> hotel.check_out('single', 2)\n        >>> hotel.available_rooms\n        {'single': 7, 'double': 3}\n        >>> hotel.check_out('triple', 2)\n        >>> hotel.available_rooms\n        {'single': 7, 'double': 3, 'triple': 2}\n        \"\"\"\n\n        # If the room type already exists in available_rooms, increase the count\n        if room_type in self.available_rooms:\n            self.available_rooms[room_type] += room_number\n        # If it's a new room type, add it to available_rooms\n        else:\n            self.available_rooms[room_type] = room_number\n\n    def get_available_rooms(self, room_type):\n        \"\"\"\n        Get the number of specific type of available rooms.\n        :param room_type: str, the room type that want to know\n        :return: int, the remaining number of this type rooms.\n        >>> hotel = Hotel('peace hotel', {'single': 5, 'double': 3})\n        >>> hotel.get_available_rooms('single')\n        5\n        \"\"\"\n\n        # Return the number of available rooms for the specified room type\n        return self.available_rooms[room_type]"}, {"id": "43", "llm_annotated_code": "class HRManagementSystem:\n\n    \"\"\"\n    This is a class as personnel management system that implements functions such as adding, deleting, querying, and updating employees\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the HRManagementSystem withan attribute employees, which is an empty dictionary.\n        \"\"\"\n        # Initialize an empty dictionary to store employee data\n        # The dictionary will use employee_id as keys and employee details as values\n        self.employees = {}\n\n    def add_employee(self, employee_id, name, position, department, salary):\n        \"\"\"\n        Add a new employee to the HRManagementSystem.\n        :param employee_id: The employee's id, int.\n        :param name: The employee's name, str.\n        :param position: The employee's position, str.\n        :param department: The employee's department, str.\n        :param salary: The employee's salary, int.\n        :return: If the employee is already in the HRManagementSystem, returns False, otherwise, returns True.\n        >>> hrManagementSystem = HRManagementSystem()\n        >>> hrManagementSystem.add_employee(1, 'John', 'Manager', 'Sales', 100000)\n        True\n        >>> hrManagementSystem.add_employee(1, 'John', 'Manager', 'Sales', 100000)\n        False\n\n        \"\"\"\n\n        # Check if the employee_id already exists in the employees dictionary\n        if employee_id in self.employees:\n            # Return False if employee already exists\n            return False\n        else:\n            # Add the new employee to the employees dictionary with employee_id as key\n            # Store employee details in a nested dictionary with name, position, department, and salary\n            self.employees[employee_id] = {\n                'name': name,\n                'position': position,\n                'department': department,\n                'salary': salary\n            }\n            # Return True to indicate successful addition\n            return True\n\n    def remove_employee(self, employee_id):\n        \"\"\"\n        Remove an employee from the HRManagementSystem.\n        :param employee_id: The employee's id, int.\n        :return: If the employee is already in the HRManagementSystem, returns True, otherwise, returns False.\n        >>> hrManagementSystem = HRManagementSystem()\n        >>> hrManagementSystem.employees = {1: {'name': 'John', 'position': 'Manager', 'department': 'Sales', 'salary': 100000}}\n        >>> hrManagementSystem.remove_employee(1)\n        True\n        >>> hrManagementSystem.remove_employee(2)\n        False\n\n        \"\"\"\n\n        # Check if the employee_id exists in the employees dictionary\n        if employee_id in self.employees:\n            # Delete the employee from the employees dictionary\n            del self.employees[employee_id]\n            # Return True to indicate successful removal\n            return True\n        else:\n            # Return False if employee doesn't exist\n            return False\n\n    def update_employee(self, employee_id: int, employee_info: dict):\n        \"\"\"\n        Update an employee's information in the HRManagementSystem.\n        :param employee_id: The employee's id, int.\n        :param employee_info: The employee's information, dict.\n        :return: If the employee is already in the HRManagementSystem, returns True, otherwise, returns False.\n        >>> hrManagementSystem = HRManagementSystem()\n        >>> hrManagementSystem.employees = {1: {'name': 'John', 'position': 'Manager', 'department': 'Sales', 'salary': 100000}}\n        >>> hrManagementSystem.update_employee(1, {'name': 'John', 'position': 'Manager', 'department': 'Sales', 'salary': 20000})\n        True\n        >>> hrManagementSystem.update_employee(2, {'name': 'John', 'position': 'Manager', 'department': 'Sales', 'salary': 20000})\n        False\n\n        \"\"\"\n\n        # Use the get_employee method to retrieve the employee's information\n        employee = self.get_employee(employee_id)\n        # If get_employee returns False, the employee doesn't exist\n        if employee == False:\n            return False\n        else:\n            # Validate that all keys in employee_info exist in the employee dictionary\n            for key, value in employee_info.items():\n                if key not in employee:\n                    return False\n            # Update the employee's information with the new values\n            for key, value in employee_info.items():\n                employee[key] = value\n            # Return True to indicate successful update\n            return True\n\n    def get_employee(self, employee_id):\n        \"\"\"\n        Get an employee's information from the HRManagementSystem.\n        :param employee_id: The employee's id, int.\n        :return: If the employee is already in the HRManagementSystem, returns the employee's information, otherwise, returns False.\n        >>> hrManagementSystem = HRManagementSystem()\n        >>> hrManagementSystem.employees = {1: {'name': 'John', 'position': 'Manager', 'department': 'Sales', 'salary': 100000}}\n        >>> hrManagementSystem.get_employee(1)\n        {'name': 'John', 'position': 'Manager', 'department': 'Sales', 'salary': 100000}\n        >>> hrManagementSystem.get_employee(2)\n        False\n\n        \"\"\"\n\n        # Check if the employee_id exists in the employees dictionary\n        if employee_id in self.employees:\n            # Return the employee's information if found\n            return self.employees[employee_id]\n        else:\n            # Return False if employee doesn't exist\n            return False\n\n    def list_employees(self):\n        \"\"\"\n        List all employees' information in the HRManagementSystem.\n        :return: A list of all employees' information,dict.\n        >>> hrManagementSystem = HRManagementSystem()\n        >>> hrManagementSystem.employees = {1: {'name': 'John', 'position': 'Manager', 'department': 'Sales', 'salary': 100000}}\n        >>> hrManagementSystem.list_employees()\n        {1: {'employee_ID': 1, 'name': 'John', 'position': 'Manager', 'department': 'Sales', 'salary': 100000}}\n\n        \"\"\"\n\n        # Initialize an empty dictionary to store the formatted employee data\n        employee_data = {}\n        # Check if there are any employees in the system\n        if self.employees:\n            # Iterate through each employee in the employees dictionary\n            for employee_id, employee_info in self.employees.items():\n                # Create a new dictionary for each employee with additional employee_ID field\n                employee_details = {}\n                employee_details[\"employee_ID\"] = employee_id\n                # Copy all the existing employee information\n                for key, value in employee_info.items():\n                    employee_details[key] = value\n                # Add the employee details to the employee_data dictionary with employee_id as key\n                employee_data[employee_id] = employee_details\n        # Return the formatted employee data\n        return employee_data"}, {"id": "44", "llm_annotated_code": "```python\nimport re\nimport string\nimport gensim\nfrom bs4 import BeautifulSoup\n\nclass HtmlUtil:\n\n    \"\"\"\n    This is a class as util for html, supporting for formatting and extracting code from HTML text, including cleaning up the text and converting certain elements into specific marks.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize a series of labels\n        \"\"\"\n        self.SPACE_MARK = '-SPACE-'\n        self.JSON_MARK = '-JSON-'\n        self.MARKUP_LANGUAGE_MARK = '-MARKUP_LANGUAGE-'\n        self.URL_MARK = '-URL-'\n        self.NUMBER_MARK = '-NUMBER-'\n        self.TRACE_MARK = '-TRACE-'\n        self.COMMAND_MARK = '-COMMAND-'\n        self.COMMENT_MARK = '-COMMENT-'\n        self.CODE_MARK = '-CODE-'\n\n    @staticmethod\n    def __format_line_feed(text):\n        \"\"\"\n        Replace consecutive line breaks with a single line break\n        :param text: string with consecutive line breaks\n        :return:string, replaced text with single line break\n        \"\"\"\n        \n        # Use regex to find multiple consecutive newlines and replace them with a single newline\n        return re.sub(re.compile(r'\n+'), '\n', text)\n\n    def format_line_html_text(self, html_text):\n        \"\"\"\n        get the html text without the code, and add the code tag -CODE- where the code is\n        :param html_text:string\n        :return:string\n        >>>htmlutil = HtmlUtil()\n        >>>htmlutil.format_line_html_text(<html>\n        >>> <body>\n        >>>    <h1>Title</h1>\n        >>>    <p>This is a paragraph.</p>\n        >>>    <pre>print('Hello, world!')</pre>\n        >>>    <p>Another paragraph.</p>\n        >>>    <pre><code>for i in range(5):\n        >>>    print(i)</code></pre>\n        >>>    </body>\n        >>>    </html>)\n        Title\n        This is a paragraph.\n        -CODE-\n        Another paragraph.\n        -CODE-\n        \"\"\"\n\n        # Return empty string if input is None or empty\n        if html_text is None or len(html_text) == 0:\n            return ''\n        \n        # Parse HTML using BeautifulSoup with lxml parser\n        soup = BeautifulSoup(html_text, 'lxml')\n        \n        # Find all code blocks (pre and blockquote tags) and replace their content with CODE_MARK\n        code_tag = soup.find_all(name=['pre', 'blockquote'])\n        for tag in code_tag:\n            tag.string = self.CODE_MARK\n        \n        # Find all list elements (ul, ol) and format their list items\n        ul_ol_group = soup.find_all(name=['ul', 'ol'])\n        for ul_ol_item in ul_ol_group:\n            li_group = ul_ol_item.find_all('li')\n            for li_item in li_group:\n                li_item_text = li_item.get_text().strip()\n                if len(li_item_text) == 0:\n                    continue\n                # Add bullet point format and ensure proper punctuation\n                if li_item_text[-1] in string.punctuation:\n                    li_item.string = '[{0}]{1}'.format('-', li_item_text)\n                    continue\n                li_item.string = '[{0}]{1}.'.format('-', li_item_text)\n\n        # Find all paragraph tags and ensure they have proper punctuation\n        p_group = soup.find_all(name=['p'])\n        for p_item in p_group:\n            p_item_text = p_item.get_text().strip()\n            if p_item_text:\n                # If paragraph already ends with punctuation, leave it as is\n                if p_item_text[-1] in string.punctuation:\n                    p_item.string = p_item_text\n                    continue\n                \n                # Check if next element is code block, add colon if so\n                next_sibling = p_item.find_next_sibling()\n                if next_sibling and self.CODE_MARK in next_sibling.get_text():\n                    p_item.string = p_item_text + ':'\n                    continue\n                \n                # Otherwise add a period\n                p_item.string = p_item_text + '.'\n\n        # Decode HTML entities and format line feeds in the final text\n        clean_text = gensim.utils.decode_htmlentities(soup.get_text())\n        return self.__format_line_feed(clean_text)\n\n    def extract_code_from_html_text(self, html_text):\n        \"\"\"\n        extract codes from the html body\n        :param html_text: string, html text\n        :return: the list of code\n        >>>htmlutil = HtmlUtil()\n        >>>htmlutil.extract_code_from_html_text(<html>\n        >>> <body>\n        >>>    <h1>Title</h1>\n        >>>    <p>This is a paragraph.</p>\n        >>>    <pre>print('Hello, world!')</pre>\n        >>>    <p>Another paragraph.</p>\n        >>>    <pre><code>for i in range(5):\n        >>>    print(i)</code></pre>\n        >>>    </body>\n        >>>    </html>)\n        [\"print('Hello, world!')\", 'for i in range(5):\n                print(i)']\n        \"\"\"\n\n        # First format the HTML text to identify where code blocks are\n        text_with_code_tag = self.format_line_html_text(html_text)\n        \n        # If no code blocks are found, return empty list\n        if self.CODE_MARK not in text_with_code_tag:\n            return []\n\n        # Initialize variables for code extraction\n        code_index_start = 0\n        \n        # Parse HTML again to extract the actual code content\n        soup = BeautifulSoup(html_text, 'lxml')\n        code_tag = soup.find_all(name=['pre', 'blockquote'])\n        \n        # Count how many code blocks were identified\n        code_count = text_with_code_tag.count(self.CODE_MARK)\n        code_list = []\n\n        # Extract each code block and add to the result list\n        for code_index in range(code_index_start, code_index_start + code_count):\n            code = code_tag[code_index].get_text()\n            if code:\n                code_list.append(code)\n        return code_list\n```"}, {"id": "45", "llm_annotated_code": "from PIL import Image, ImageEnhance\n\nclass ImageProcessor:\n\n    \"\"\"\n    This is a class to process image, including loading, saving, resizing, rotating, and adjusting the brightness of images.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize self.image\n        \"\"\"\n        # Initialize the image attribute to None, which will later store a PIL Image object\n        self.image = None\n\n    def load_image(self, image_path):\n        \"\"\"\n        Use Image util in PIL to open a image\n        :param image_path: str, path of image that is to be\n        >>> processor.load_image('test.jpg')\n        >>> processor.image\n        <PIL.JpegImagePlugin.JpegImageFile image mode=RGB size=3072x4096 at 0x194F2412A48>\n        \"\"\"\n        # Use PIL's Image.open() to load an image from the specified path\n        # The loaded image is stored in the self.image attribute\n        self.image = Image.open(image_path)\n\n    def save_image(self, save_path):\n        \"\"\"\n        Save image to a path if image has opened\n        :param save_path: str, the path that the image will be saved\n        >>> processor.load_image('test.jpg')\n        >>> processor.save_image('test2.jpg')\n        \"\"\"\n        # Check if an image has been loaded (self.image is not None)\n        # If an image exists, save it to the specified path using PIL's save() method\n        if self.image:\n            self.image.save(save_path)\n\n    def resize_image(self, width, height):\n        \"\"\"\n        Risize the image if image has opened.\n        :param width: int, the target width of image\n        :param height: int, the target height of image\n        >>> processor.load_image('test.jpg')\n        >>> processor.resize_image(300, 300)\n        >>> processor.image.width\n        300\n        >>> processor.image.height\n        300\n        \"\"\"\n        # Check if an image has been loaded (self.image is not None)\n        # If an image exists, resize it to the specified width and height using PIL's resize() method\n        # The resize() method returns a new Image object, which is stored back in self.image\n        if self.image:\n            self.image = self.image.resize((width, height))\n\n    def rotate_image(self, degrees):\n        \"\"\"\n        rotate image if image has opened\n        :param degrees: float, the degrees that the image will be rotated\n        >>> processor.load_image('test.jpg')\n        >>> processor.resize_image(90)\n        \"\"\"\n        # Check if an image has been loaded (self.image is not None)\n        # If an image exists, rotate it by the specified degrees using PIL's rotate() method\n        # The rotate() method returns a new Image object, which is stored back in self.image\n        if self.image:\n            self.image = self.image.rotate(degrees)\n\n    def adjust_brightness(self, factor):\n        \"\"\"\n        Adjust the brightness of image if image has opened.\n        :param factor: float, brightness of an image. A factor of 0.0 gives a black image. A factor of 1.0 gives the original image.\n        >>> processor.load_image('test.jpg')\n        >>> processor.adjust_brightness(0.5)\n        \"\"\"\n        # Check if an image has been loaded (self.image is not None)\n        # If an image exists:\n        # 1. Create a Brightness enhancer object from PIL's ImageEnhance module\n        # 2. Apply the brightness adjustment with the specified factor using enhance()\n        # 3. Store the resulting image back in self.image\n        if self.image:\n            enhancer = ImageEnhance.Brightness(self.image)\n            self.image = enhancer.enhance(factor)"}, {"id": "46", "llm_annotated_code": "class Interpolation:\n\n    \"\"\"\n    This is a class that implements the Linear interpolation operation of one-dimensional and two-dimensional data\n    \"\"\"\n\n    def __init__(self):\n        pass\n\n    @staticmethod\n    def interpolate_1d(x, y, x_interp):\n        \"\"\"\n        Linear interpolation of one-dimensional data\n        :param x: The x-coordinate of the data point, list.\n        :param y: The y-coordinate of the data point, list.\n        :param x_interp: The x-coordinate of the interpolation point, list.\n        :return: The y-coordinate of the interpolation point, list.\n        >>> interpolation = Interpolation()\n        >>> interpolation.interpolate_1d([1, 2, 3], [1, 2, 3], [1.5, 2.5])\n        [1.5, 2.5]\n\n        \"\"\"\n\n        # Initialize an empty list to store the interpolated y values\n        y_interp = []\n\n        # Iterate through each x value that needs interpolation\n        for xi in x_interp:\n            # Search through the original data points to find the interval containing xi\n            for i in range(len(x) - 1):\n                # Check if xi is within the current interval [x[i], x[i+1]]\n                if x[i] <= xi <= x[i+1]:\n                    # Apply linear interpolation formula: y = y1 + (y2-y1)*(x-x1)/(x2-x1)\n                    # Calculate the interpolated y value at xi\n                    yi = y[i] + (y[i+1] - y[i]) * (xi - x[i]) / (x[i+1] - x[i])\n                    # Add the interpolated value to the result list\n                    y_interp.append(yi)\n                    # Exit the inner loop once the interval is found\n                    break\n        # Return the list of interpolated y values\n        return y_interp\n\n    @staticmethod\n    def interpolate_2d(x, y, z, x_interp, y_interp):\n        \"\"\"\n        Linear interpolation of two-dimensional data\n        :param x: The x-coordinate of the data point, list.\n        :param y: The y-coordinate of the data point, list.\n        :param z: The z-coordinate of the data point, list.\n        :param x_interp: The x-coordinate of the interpolation point, list.\n        :param y_interp: The y-coordinate of the interpolation point, list.\n        :return: The z-coordinate of the interpolation point, list.\n        >>> interpolation = Interpolation()\n        >>> interpolation.interpolate_2d([1, 2, 3], [1, 2, 3], [[1, 2, 3], [4, 5, 6], [7, 8, 9]], [1.5, 2.5], [1.5, 2.5])\n        [3.0, 7.0]\n\n        \"\"\"\n\n        # Initialize an empty list to store the interpolated z values\n        z_interp = []\n\n        # Iterate through each (x,y) pair that needs interpolation\n        for xi, yi in zip(x_interp, y_interp):\n            # Search for the x interval containing xi\n            for i in range(len(x) - 1):\n                if x[i] <= xi <= x[i+1]:\n                    # Search for the y interval containing yi\n                    for j in range(len(y) - 1):\n                        if y[j] <= yi <= y[j+1]:\n                            # Get the z values at the four corners of the grid cell\n                            z00 = z[i][j]      # Bottom-left corner\n                            z01 = z[i][j+1]    # Top-left corner\n                            z10 = z[i+1][j]    # Bottom-right corner\n                            z11 = z[i+1][j+1]  # Top-right corner\n\n                            # Apply bilinear interpolation formula\n                            # This is a weighted average of the four corner values\n                            # based on the distance from each corner\n                            zi = (z00 * (x[i+1] - xi) * (y[j+1] - yi) +\n                                  z10 * (xi - x[i]) * (y[j+1] - yi) +\n                                  z01 * (x[i+1] - xi) * (yi - y[j]) +\n                                  z11 * (xi - x[i]) * (yi - y[j])) / ((x[i+1] - x[i]) * (y[j+1] - y[j]))\n                            \n                            # Add the interpolated value to the result list\n                            z_interp.append(zi)\n                            # Exit the y loop once the interval is found\n                            break\n                    # Exit the x loop once the interval is found\n                    break\n        # Return the list of interpolated z values\n        return z_interp"}, {"id": "47", "llm_annotated_code": "class IPAddress:\n\n    \"\"\"\n    This is a class to process IP Address, including validating, getting the octets and obtaining the binary representation of a valid IP address.\n    \"\"\"\n\n    def __init__(self, ip_address):\n        \"\"\"\n        Initialize the IP address to the specified address\n        :param ip_address:string\n        \"\"\"\n        # Store the IP address string provided during initialization\n        self.ip_address = ip_address\n\n\n    def is_valid(self):\n        \"\"\"\n        Judge whether the IP address is valid, that is, whether the IP address is composed of four Decimal digits separated by '.'. Each digit is greater than or equal to 0 and less than or equal to 255\n        :return: bool\n        >>> ipaddress = IPAddress(\"10.10.10.10\")\n        >>> ipaddress.is_valid()\n        True\n        \"\"\"\n\n        # Split the IP address string by '.' to get the octets\n        octets = self.ip_address.split('.')\n        # Check if there are exactly 4 octets in the IP address\n        if len(octets) != 4:\n            return False\n        # Iterate through each octet to validate it\n        for octet in octets:\n            # Check if the octet is a digit and within the valid range (0-255)\n            if not octet.isdigit() or int(octet) < 0 or int(octet) > 255:\n                return False    \n        # Return True if all validation checks pass\n        return True\n\n\n    def get_octets(self):\n        \"\"\"\n        If the IP address is valid, the list of four decimal numbers separated by \".\" constituting the IP address is returned; otherwise, an empty list is returned\n        :return: list\n        >>> ipaddress = IPAddress(\"10.10.10.10\")\n        >>> ipaddress.get_octets()\n        [\"10\", \"10\", \"10\", \"10\"]\n        \"\"\"\n\n        # First check if the IP address is valid using the is_valid method\n        if self.is_valid():\n            # If valid, split the IP address by '.' and return the resulting list\n            return self.ip_address.split('.')\n        else:\n            # If not valid, return an empty list\n            return []\n\n\n    def get_binary(self):\n        \"\"\"\n        If the IP address is valid, return the binary form of the IP address; otherwise, return ''\n        :return: string\n        >>> ipaddress = IPAddress(\"10.10.10.10\")\n        >>> ipaddress.get_binary()\n        \"00001010.00001010.00001010.00001010\"\n        \"\"\"\n\n        # First check if the IP address is valid using the is_valid method\n        if self.is_valid():\n            binary_octets = []\n            # Get the octets using the get_octets method\n            for octet in self.get_octets():\n                # Convert each octet to an integer, then to binary format with 8 bits\n                binary_octets.append(format(int(octet), '08b'))\n            # Join the binary octets with '.' and return the result\n            return '.'.join(binary_octets)\n        else:\n            # If not valid, return an empty string\n            return \"\""}, {"id": "48", "llm_annotated_code": "```python\nimport socket\n\nclass IpUtil:\n\n    \"\"\"\n    This is a class as tool for ip that can be used to obtain the local IP address, validate its validity, and also provides the functionality to retrieve the corresponding hostname.\n    \"\"\"\n\n    @staticmethod\n    def is_valid_ipv4(ip_address):\n        \"\"\"\n        Check if the given IP address is a valid IPv4 address.\n        :param ip_address: string, the IP address to check\n        :return: bool, True if the IP address is valid, False otherwise\n        >>> IpUtil.is_valid_ipv4('192.168.0.123')\n        True\n        >>> IpUtil.is_valid_ipv4('256.0.0.0')\n        False\n\n        \"\"\"\n\n        try:\n            # Use socket.inet_pton to convert an IP address from string format to packed binary format\n            # socket.AF_INET specifies the address family for IPv4\n            socket.inet_pton(socket.AF_INET, ip_address)\n            return True\n        except socket.error:\n            # Return False if the IP address is invalid and socket.error is raised\n            return False\n\n    @staticmethod\n    def is_valid_ipv6(ip_address):\n        \"\"\"\n        Check if the given IP address is a valid IPv6 address.\n        :param ip_address:string, the IP address to check\n        :return:bool, True if the IP address is valid, False otherwise\n        >>> IpUtil.is_valid_ipv6('2001:0db8:85a3:0000:0000:8a2e:0370:7334')\n        True\n        >>> IpUtil.is_valid_ipv6('2001:0db8:85a3:::8a2e:0370:7334')\n        False\n\n        \"\"\"\n\n        try:\n            # Use socket.inet_pton to convert an IP address from string format to packed binary format\n            # socket.AF_INET6 specifies the address family for IPv6\n            socket.inet_pton(socket.AF_INET6, ip_address)\n            return True\n        except socket.error:\n            # Return False if the IP address is invalid and socket.error is raised\n            return False\n\n\n    @staticmethod\n    def get_hostname(ip_address):\n        \"\"\"\n        Get the hostname associated with the given IP address.\n        :param ip_address:string, the IP address to get the hostname for\n        :return: string, the hostname associated with the IP address\n        >>> IpUtil.get_hostname('110.242.68.3')\n        'www.baidu.com'\n        >>> IpUtil.get_hostname('10.0.0.1')\n\n        \"\"\"\n\n        try:\n            # Use socket.gethostbyaddr to get the hostname associated with the IP address\n            # This function returns a tuple (hostname, aliaslist, ipaddrlist)\n            # We extract the hostname (first element) from the returned tuple\n            hostname = socket.gethostbyaddr(ip_address)[0]\n            return hostname\n        except socket.herror:\n            # Return None if the hostname cannot be resolved and socket.herror is raised\n            return None\n```"}, {"id": "49", "llm_annotated_code": "class JobMarketplace:\n\n    \"\"\"\n    This is a class that provides functionalities to publish positions, remove positions, submit resumes, withdraw resumes, search for positions, and obtain candidate information.\n    \"\"\"\n\n    def __init__(self):\n        # Initialize empty lists to store job listings and resumes\n        self.job_listings = []\n        self.resumes = []\n\n    def post_job(self, job_title, company, requirements):\n        \"\"\"\n        This function is used to publish positions,and add the position information to the job_listings list.\n        :param job_title: The title of the position,str.\n        :param company: The company of the position,str.\n        :param requirements: The requirements of the position,list.\n        :return: None\n        >>> jobMarketplace = JobMarketplace()\n        >>> jobMarketplace.post_job(\"Software Engineer\", \"ABC Company\", ['requirement1', 'requirement2'])\n        >>> jobMarketplace.job_listings\n        [{'job_title': 'Software Engineer', 'company': 'ABC Company', 'requirements': ['requirement1', 'requirement2']}]\n\n        \"\"\"\n\n        # Create a dictionary with job details\n        job = {\"job_title\": job_title, \"company\": company, \"requirements\": requirements}\n        # Add the job to the job_listings instance variable\n        self.job_listings.append(job)\n\n    def remove_job(self, job):\n        \"\"\"\n        This function is used to remove positions,and remove the position information from the job_listings list.\n        :param job: The position information to be removed,dict.\n        :return: None\n        >>> jobMarketplace = JobMarketplace()\n        >>> jobMarketplace.job_listings = [{\"job_title\": \"Software Engineer\", \"company\": \"ABC Company\", \"requirements\": ['requirement1', 'requirement2']}]\n        >>> jobMarketplace.remove_job(jobMarketplace.job_listings[0])\n        >>> jobMarketplace.job_listings\n        []\n\n        \"\"\"\n\n        # Remove the specified job from the job_listings instance variable\n        self.job_listings.remove(job)\n\n    def submit_resume(self, name, skills, experience):\n        \"\"\"\n        This function is used to submit resumes,and add the resume information to the resumes list.\n        :param name: The name of the resume,str.\n        :param skills: The skills of the resume,list.\n        :param experience: The experience of the resume,str.\n        :return: None\n        >>> jobMarketplace = JobMarketplace()\n        >>> jobMarketplace.submit_resume(\"Tom\", ['skill1', 'skill2'], \"experience\")\n        >>> jobMarketplace.resumes\n        [{'name': 'Tom', 'skills': ['skill1', 'skill2'], 'experience': 'experience'}]\n\n        \"\"\"\n\n        # Create a dictionary with resume details\n        resume = {\"name\": name, \"skills\": skills, \"experience\": experience}\n        # Add the resume to the resumes instance variable\n        self.resumes.append(resume)\n\n    def withdraw_resume(self, resume):\n        \"\"\"\n        This function is used to withdraw resumes,and remove the resume information from the resumes list.\n        :param resume: The resume information to be removed,dict.\n        :return: None\n        >>> jobMarketplace = JobMarketplace()\n        >>> jobMarketplace.resumes = [{\"name\": \"Tom\", \"skills\": ['skill1', 'skill2'], \"experience\": \"experience\"}]\n        >>> jobMarketplace.withdraw_resume(jobMarketplace.resumes[0])\n        >>> jobMarketplace.resumes\n        []\n\n        \"\"\"\n\n        # Remove the specified resume from the resumes instance variable\n        self.resumes.remove(resume)\n\n    def search_jobs(self, criteria):\n        \"\"\"\n        This function is used to search for positions,and return the position information that meets the requirements.\n        :param criteria: The requirements of the position,str.\n        :return: The position information that meets the requirements,list.\n        >>> jobMarketplace = JobMarketplace()\n        >>> jobMarketplace.job_listings = [{\"job_title\": \"Software Engineer\", \"company\": \"ABC Company\", \"requirements\": ['skill1', 'skill2']}]\n        >>> jobMarketplace.search_jobs(\"skill1\")\n        [{'job_title': 'Software Engineer', 'company': 'ABC Company', 'requirements': ['skill1', 'skill2']}]\n\n        \"\"\"\n\n        # Initialize an empty list to store matching jobs\n        matching_jobs = []\n        # Iterate through each job listing in the job_listings instance variable\n        for job_listing in self.job_listings:\n            # Check if the criteria matches the job title or any of the requirements (case-insensitive)\n            if criteria.lower() in job_listing[\"job_title\"].lower() or criteria.lower() in [r.lower() for r in job_listing[\"requirements\"]]:\n                matching_jobs.append(job_listing)\n        # Return the list of matching jobs\n        return matching_jobs\n\n    @staticmethod\n    def matches_requirements(resume, requirements):\n        \"\"\"\n        This function is used to check whether all the skills in the provided resume exist in the provided requirements for a job.\n        :param resume: The resume information,dict.\n        :param requirements: The requirements of some position,str.\n        :return: Whether all the skills in the resume exists in the requirements,boolean.\n\n        \"\"\"\n\n        # Check if each skill in the resume is in the requirements\n        for skill in resume[\"skills\"]:\n            if skill not in requirements:\n                return False\n        # If all skills are in the requirements, return True\n        return True\n\n    def get_job_applicants(self, job):\n        \"\"\"\n        This function is used to obtain candidate information,and return the candidate information that meets the requirements by calling the matches_requirements function.\n        :param job: The position information,dict.\n        :return: The candidate information that meets the requirements,list.\n        >>> jobMarketplace = JobMarketplace()\n        >>> jobMarketplace.resumes = [{\"name\": \"Tom\", \"skills\": ['skill1', 'skill2'], \"experience\": \"experience\"}]\n        >>> jobMarketplace.job_listings = [{\"job_title\": \"Software Engineer\", \"company\": \"ABC Company\", \"requirements\": ['skill1', 'skill2']}]\n        >>> jobMarketplace.get_job_applicants(jobMarketplace.job_listings[0])\n        [{'name': 'Tom', 'skills': ['skill1', 'skill2'], 'experience': 'experience'}]\n\n        \"\"\"\n\n        # Initialize an empty list to store matching applicants\n        applicants = []\n        # Iterate through each resume in the resumes instance variable\n        for resume in self.resumes:\n            # Use the matches_requirements static method to check if the resume matches the job requirements\n            if self.matches_requirements(resume, job[\"requirements\"]):\n                applicants.append(resume)\n        # Return the list of matching applicants\n        return applicants"}, {"id": "50", "llm_annotated_code": "```python\nimport json\nimport os\n\nclass JSONProcessor:\n    \"\"\"\n    This is a class to process JSON file, including reading and writing JSON files, as well as processing JSON data by removing a specified key from the JSON object.\n    \"\"\"\n\n    def read_json(self, file_path):\n        \"\"\"\n        Read a JSON file and return the data.\n        :param file_path: str, the path of the JSON file.\n        :return: dict, the data from the JSON file if read successfully, or return -1 if an error occurs during the reading process.\n                    return 0 if the file does not exist.\n        >>> json.read_json('test.json')\n        {'name': 'test', 'age': 14}\n        \"\"\"\n        # Check if the file exists using os.path.exists\n        if not os.path.exists(file_path):\n            return 0\n        try:\n            # Open the file in read mode and use json.load to parse the JSON data\n            with open(file_path, 'r') as file:\n                data = json.load(file)\n            # Return the parsed JSON data as a dictionary\n            return data\n        except:\n            # Return -1 if any exception occurs during file reading or JSON parsing\n            return -1\n\n    def write_json(self, data, file_path):\n        \"\"\"\n        Write data to a JSON file and save it to the given path.\n\n        :param data: dict, the data to be written to the JSON file.\n        :param file_path: str, the path of the JSON file.\n        :return: 1 if the writing process is successful, or -1, if an error occurs during the writing process.\n        >>> json.write_json({'key1': 'value1', 'key2': 'value2'}, 'test.json')\n        1\n        >>> json.read_json('test.json')\n        {'key1': 'value1', 'key2': 'value2'}\n        \"\"\"\n        try:\n            # Open the file in write mode and use json.dump to write the data as JSON\n            with open(file_path, 'w') as file:\n                json.dump(data, file)\n            # Return 1 to indicate successful writing\n            return 1\n        except:\n            # Return -1 if any exception occurs during file writing\n            return -1\n\n    def process_json(self, file_path, remove_key):\n        \"\"\"\n        read a JSON file and process the data by removing a specified key and rewrite the modified data back to the file.\n\n        :param file_path: str, the path of the JSON file.\n        :param remove_key: str, the key to be removed.\n        :return: 1, if the specified key is successfully removed and the data is written back.\n                    0, if the file does not exist or the specified key does not exist in the data.\n        >>> json.read_json('test.json')\n        {'key1': 'value1', 'key2': 'value2'}\n        >>> json.process_json('test.json', 'key1')\n        1\n        >>> json.read_json('test.json')\n        {'key2': 'value2'}\n        \"\"\"\n        # Call the read_json method to get the JSON data from the file\n        data = self.read_json(file_path)\n        # Return 0 if the file doesn't exist or there was an error reading it\n        if data == 0 or data == -1:\n            return 0\n        # Check if the key to be removed exists in the data\n        if remove_key in data:\n            # Delete the specified key from the data dictionary\n            del data[remove_key]\n            # Write the modified data back to the file using the write_json method\n            self.write_json(data, file_path)\n            # Return 1 to indicate successful processing\n            return 1\n        else:\n            # Return 0 if the key doesn't exist in the data\n            return 0\n```"}, {"id": "51", "llm_annotated_code": "import numpy as np\n\nclass KappaCalculator:\n    \"\"\"\n    This is a class as KappaCalculator, supporting to calculate Cohen's and Fleiss' kappa coefficient.\n    \"\"\"\n\n\n    @staticmethod\n    def kappa(testData, k):\n        \"\"\"\n        Calculate the cohens kappa value of a k-dimensional matrix\n        :param testData: The k-dimensional matrix that needs to calculate the cohens kappa value\n        :param k: int, Matrix dimension\n        :return:float, the cohens kappa value of the matrix\n        >>> KappaCalculator.kappa([[2, 1, 1], [1, 2, 1], [1, 1, 2]], 3)\n        0.25\n        \"\"\"\n        # Convert the input test data to a numpy matrix\n        dataMat = np.mat(testData)\n        \n        # Initialize the observed agreement (P0)\n        P0 = 0.0\n        \n        # Sum the diagonal elements to get the number of agreements\n        for i in range(k):\n            P0 += dataMat[i, i] * 1.0\n        \n        # Calculate row sums and column sums\n        xsum = np.sum(dataMat, axis=1)  # Sum each row\n        ysum = np.sum(dataMat, axis=0)  # Sum each column\n        \n        # Calculate the total sum of all elements in the matrix\n        sum = np.sum(dataMat)\n        \n        # Calculate the expected agreement by chance (Pe)\n        Pe = float(ysum * xsum) / sum / sum\n        \n        # Calculate the observed agreement as a proportion of the total\n        P0 = float(P0 / sum * 1.0)\n        \n        # Calculate Cohen's kappa coefficient using the formula (P0 - Pe) / (1 - Pe)\n        cohens_coefficient = float((P0 - Pe) / (1 - Pe))\n        \n        # Return the calculated Cohen's kappa coefficient\n        return cohens_coefficient\n\n    @staticmethod\n    def fleiss_kappa(testData, N, k, n):\n        \"\"\"\n        Calculate the fliss kappa value of an N * k matrix\n        :param testData: Input data matrix, N * k\n        :param N: int, Number of samples\n        :param k: int, Number of categories\n        :param k: int, Number of categories\n        :param k: int, Number of categories\n        :param n: int, Number of raters\n        :return: float, fleiss kappa value\n        >>> KappaCalculator.fleiss_kappa([[0, 0, 0, 0, 14],\n        >>>                              [0, 2, 6, 4, 2],\n        >>>                              [0, 0, 3, 5, 6],\n        >>>                              [0, 3, 9, 2, 0],\n        >>>            [2, 2, 8, 1, 1],\n        >>>                              [7, 7, 0, 0, 0],\n        >>>                              [3, 2, 6, 3, 0],\n        >>>                              [2, 5, 3, 2, 2],\n        >>>                              [6, 5, 2, 1, 0],\n        >>>                 [0, 2, 2, 3, 7]], 10, 5, 14)\n        0.20993070442195522\n        \"\"\"\n        # Convert the input test data to a numpy matrix of float type\n        dataMat = np.mat(testData, float)\n        \n        # Create a column vector of ones with k rows\n        oneMat = np.ones((k, 1))\n        \n        # Initialize variables for calculations\n        sum = 0.0  # Total sum of all ratings\n        P0 = 0.0   # Observed agreement\n        \n        # Calculate the observed agreement (P0)\n        for i in range(N):\n            temp = 0.0\n            # Sum the squares of ratings for each category in the current sample\n            for j in range(k):\n                sum += dataMat[i, j]  # Add to total sum\n                temp += 1.0 * dataMat[i, j] ** 2  # Sum of squares\n            \n            # Calculate the agreement for the current sample using the formula\n            temp -= n  # Subtract n from the sum of squares\n            temp /= (n - 1) * n  # Divide by (n-1)*n\n            P0 += temp  # Add to the overall observed agreement\n        \n        # Calculate the average observed agreement across all samples\n        P0 = 1.0 * P0 / N\n        \n        # Calculate the sum of ratings for each category across all samples\n        ysum = np.sum(dataMat, axis=0)\n        \n        # Calculate the expected agreement by chance (Pe)\n        for i in range(k):\n            ysum[0, i] = (ysum[0, i] / sum) ** 2  # Square the proportion of ratings in each category\n        \n        # Multiply by the ones matrix to get the sum\n        Pe = ysum * oneMat * 1.0\n        \n        # Calculate Fleiss' kappa using the formula (P0 - Pe) / (1 - Pe)\n        ans = (P0 - Pe) / (1 - Pe)\n        \n        # Return the calculated Fleiss' kappa coefficient\n        return ans[0, 0]"}, {"id": "52", "llm_annotated_code": "import nltk\nfrom nltk.stem import WordNetLemmatizer\nfrom nltk import pos_tag, word_tokenize\nimport string\n\n\nnltk.download('averaged_perceptron_tagger')\nnltk.download('punkt')\nnltk.download('wordnet')\n\nclass Lemmatization:\n    \"\"\"\n    This is a class about Lemmatization, which utilizes the nltk library to perform lemmatization and part-of-speech tagging on sentences, as well as remove punctuation.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        creates a WordNetLemmatizer object and stores it in the self.lemmatizer member variable.\n        \"\"\"\n        # Initialize the WordNetLemmatizer from nltk.stem package\n        self.lemmatizer = WordNetLemmatizer()\n\n    def lemmatize_sentence(self, sentence):\n        \"\"\"\n        Remove punctuations of the sentence and tokenizes the input sentence, mark the part of speech tag of each word,\n        lemmatizes the words with different parameters based on their parts of speech, and stores in a list.\n        :param sentence: a sentence str\n        :return: a list of words which have been lemmatized.\n        >>> lemmatization = Lemmatization()\n        >>> lemmatization.lemmatize_sentence(\"I am running in a race.\")\n        ['I', 'be', 'run', 'in', 'a', 'race']\n\n        \"\"\"\n        lemmatized_words = []\n        # Call the remove_punctuation method to clean the sentence\n        sentence = self.remove_punctuation(sentence)\n        # Use nltk's word_tokenize to split the sentence into words\n        words = word_tokenize(sentence)\n        # Use nltk's pos_tag to get part-of-speech tags for each word\n        tagged_words = pos_tag(words)\n        # Iterate through each word and its POS tag\n        for word, tag in tagged_words:\n            # Apply different lemmatization based on part of speech\n            if tag.startswith('V'):  # Verb\n                lemmatized_word = self.lemmatizer.lemmatize(word, pos='v')\n            elif tag.startswith('J'):  # Adjective\n                lemmatized_word = self.lemmatizer.lemmatize(word, pos='a')\n            elif tag.startswith('R'):  # Adverb\n                lemmatized_word = self.lemmatizer.lemmatize(word, pos='r')\n            else:  # Default (noun)\n                lemmatized_word = self.lemmatizer.lemmatize(word)\n            # Add the lemmatized word to the result list\n            lemmatized_words.append(lemmatized_word)\n        return lemmatized_words\n\n    def get_pos_tag(self, sentence):\n        \"\"\"\n        Remove punctuations of the sentence and tokenizes the input sentence, mark the part of speech tag of each word.\n        :param sentence: a sentence str\n        :return: list, part of speech tag of each word in the sentence.\n        >>> lemmatization = Lemmatization()\n        >>> lemmatization.get_pos_tag(\"I am running in a race.\")\n        ['PRP', 'VBP', 'VBG', 'IN', 'DT', 'NN']\n\n        \"\"\"\n        pos_tags = []\n        # Call the remove_punctuation method to clean the sentence\n        sentence = self.remove_punctuation(sentence)\n        # Use nltk's word_tokenize to split the sentence into words\n        words = word_tokenize(sentence)\n        # Use nltk's pos_tag to get part-of-speech tags for each word\n        tagged_words = pos_tag(words)\n        # Extract only the POS tags from the tagged words\n        for tagged_word in tagged_words:\n            pos_tags.append(tagged_word[1])\n        return pos_tags\n\n    def remove_punctuation(self, sentence):\n        \"\"\"\n        Removes punctuation from the input text.\n        :param sentence: a sentence str\n        :return: str, sentence without any punctuation\n        >>> lemmatization = Lemmatization()\n        >>> lemmatization.remove_punctuation(\"I am running in a race.\")\n        'I am running in a race'\n\n        \"\"\"\n        # Use string.punctuation (a string of all punctuation characters)\n        # and str.maketrans to create a translation table that removes punctuation\n        return sentence.translate(str.maketrans('', '', string.punctuation))"}, {"id": "53", "llm_annotated_code": "import re\nimport string\n\nclass LongestWord:\n    \"\"\"\n    This is a class allows to add words to a list and find the longest word in a given sentence by comparing the words with the ones in the word list.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize a list of word.\n        \"\"\"\n        # Initialize an empty list to store words\n        self.word_list = []\n\n    def add_word(self, word):\n        \"\"\"\n        append the input word into self.word_list\n        :param word: str, input word\n        \"\"\"\n        # Append the provided word to the word_list attribute\n        self.word_list.append(word)\n\n    def find_longest_word(self, sentence):\n        \"\"\"\n        Remove punctuation marks and split a sentence into a list of word. Find the longest splited word that is in the self.word_list.\n        Words are strictly case sensitive.\n        :param sentence: a sentence str\n        :return str: longest splited word that is in the self.word_list. return '' if self.word_list is empty.\n        >>> longestWord = LongestWord()\n        >>> longestWord.add_word('A')\n        >>> longestWord.add_word('aM')\n        >>> longestWord.find_longest_word('I am a student.')\n        'a'\n        \"\"\"\n        # Initialize an empty string to store the longest word found\n        longest_word = \"\"\n        \n        # Convert the sentence to lowercase\n        sentence = sentence.lower()\n        \n        # Use re.sub to remove all punctuation marks from the sentence\n        # re.escape(string.punctuation) creates a regex pattern that matches any punctuation character\n        sentence = re.sub('[%s]' % re.escape(string.punctuation), '', sentence)\n        \n        # Split the sentence into words using space as delimiter\n        sentence = re.split(' ', sentence)\n        \n        # Iterate through each word in the sentence\n        for word in sentence:\n            # Check if the word is in the word_list and if it's longer than the current longest_word\n            if word in self.word_list and len(word) > len(longest_word):\n                # Update longest_word if the current word is longer\n                longest_word = word\n                \n        # Return the longest word found (or empty string if none found)\n        return longest_word"}, {"id": "54", "llm_annotated_code": "```python\nimport random\n\nclass MahjongConnect:\n    \"\"\"\n    MahjongConnect is a class representing a game board for Mahjong Connect with features like creating the board, checking valid moves, finding paths, removing icons, and checking if the game \nis over.\n    \"\"\"\n\n    def __init__(self, BOARD_SIZE, ICONS):\n        \"\"\"\n        initialize the board size and the icon list, create the game board\n        :param BOARD_SIZE: list of two integer numbers, representing the number of rows and columns of the game board\n        :param ICONS: list of string, representing the icons\n        >>>mc = MahjongConnect([4, 4], ['a', 'b', 'c'])\n        mc.BOARD_SIZE = [4, 4]\n        mc.ICONS = ['a', 'b', 'c']\n        mc.board = mc.create_board()\n        \"\"\"\n        self.BOARD_SIZE = BOARD_SIZE  # Store the board dimensions as [rows, columns]\n        self.ICONS = ICONS  # Store the list of possible icons for the game\n        self.board = self.create_board()  # Initialize the game board by calling create_board method\n\n    def create_board(self):\n        \"\"\"\n        create the game board with the given board size and icons\n        :return: 2-dimensional list, the game board\n        >>> mc = MahjongConnect([4, 4], ['a', 'b', 'c'])\n        >>> mc.create_board()\n        mc.board = [['a', 'b', 'c', 'a'],\n                    ['a', 'b', 'c', 'a'],\n                    ['a', 'b', 'c', 'a'],\n                    ['a', 'b', 'c', 'a']]\n        \"\"\"\n        # Create a 2D list representing the game board\n        # Each cell contains a randomly chosen icon from self.ICONS\n        # The outer list has BOARD_SIZE[0] rows, each with BOARD_SIZE[1] columns\n        board = [[random.choice(self.ICONS) for _ in range(self.BOARD_SIZE[1])] for _ in range(self.BOARD_SIZE[0])]\n        return board\n\n    def is_valid_move(self, pos1, pos2):\n        \"\"\"\n        check if the move of two icons is valid (i.e. positions are within the game board range, the two positions are not the same, the two positions have the same icon, and there is a valid path between the two positions)\n        :param pos1: position tuple(x, y) of the first icon\n        :param pos2: position tuple(x, y) of the second icon\n        :return:True or False ,representing whether the move of two icons is valid\n        >>> mc = MahjongConnect([4, 4], ['a', 'b', 'c'])\n        mc.board = [['a', 'b', 'c', 'a'],\n                    ['a', 'b', 'c', 'a'],\n                    ['a', 'b', 'c', 'a'],\n                    ['a', 'b', 'c', 'a']]\n        >>> mc.is_valid_move((0, 0), (1, 0))\n        True\n        \"\"\"\n        x1, y1 = pos1  # Extract x and y coordinates from the first position\n        x2, y2 = pos2  # Extract x and y coordinates from the second position\n\n        # Check if positions are within the game board range\n        # Uses self.BOARD_SIZE to determine valid boundaries\n        if not (0 <= x1 < self.BOARD_SIZE[0] and 0 <= y1 < self.BOARD_SIZE[1] and 0 <= x2 < self.BOARD_SIZE[\n            0] and 0 <= y2 <\n                self.BOARD_SIZE[1]):\n            return False\n\n        # Check if the two positions are the same\n        if pos1 == pos2:\n            return False\n\n        # Check if the two positions have the same icon\n        # Accesses self.board to compare the icons at the given positions\n        if self.board[x1][y1] != self.board[x2][y2]:\n            return False\n\n        # Check if there is a valid path between the two positions\n        # Calls the has_path method to determine if a path exists\n        if not self.has_path(pos1, pos2):\n            return False\n\n        return True\n\n\n    def has_path(self, pos1, pos2):\n        \"\"\"\n        check if there is a path between two icons\n        :param pos1: position tuple(x, y) of the first icon\n        :param pos2: position tuple(x, y) of the second icon\n        :return: True or False ,representing whether there is a path between two icons\n        >>> mc = MahjongConnect([4, 4], ['a', 'b', 'c'])\n        mc.board = [['a', 'b', 'c', 'a'],\n                    ['a', 'b', 'c', 'a'],\n                    ['a', 'b', 'c', 'a'],\n                    ['a', 'b', 'c', 'a']]\n        >>> mc.is_valid_move((0, 0), (1, 0))\n        True\n        \"\"\"\n        visited = set()  # Set to keep track of visited positions\n        stack = [pos1]   # Stack for depth-first search, starting with the first position\n\n        while stack:\n            current_pos = stack.pop()  # Get the next position to check from the stack\n            if current_pos == pos2:    # If we've reached the target position, a path exists\n                return True\n\n            if current_pos in visited:  # Skip already visited positions\n                continue\n\n            visited.add(current_pos)    # Mark current position as visited\n            x, y = current_pos          # Extract x and y coordinates\n\n            # Check adjacent positions (up, down, left, right)\n            # For each direction, check if the new position is valid and has the same icon\n            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                new_x, new_y = x + dx, y + dy\n                # Check if the new position is within board boundaries\n                if 0 <= new_x < self.BOARD_SIZE[0] and 0 <= new_y < self.BOARD_SIZE[1]:\n                    # Check if the new position hasn't been visited and has the same icon\n                    if (new_x, new_y) not in visited and self.board[new_x][new_y] == self.board[x][y]:\n                        stack.append((new_x, new_y))  # Add the new position to the stack\n\n        return False  # If we've exhausted all possibilities without finding a path\n\n\n    def remove_icons(self, pos1, pos2):\n        \"\"\"\n        remove the connected icons on the game board\n        :param pos1: position tuple(x, y) of the first icon to be removed\n        :param pos2: position tuple(x, y) of the second icon to be removed\n        :return: None\n        >>> mc = MahjongConnect([4, 4], ['a', 'b', 'c'])\n        mc.board = [['a', 'b', 'c', 'a'],\n                    ['a', 'b', 'c', 'a'],\n                    ['a', 'b', 'c', 'a'],\n                    ['a', 'b', 'c', 'a']]\n        >>> mc.remove_icons((0, 0), (1, 0))\n        mc.board = [[' ', 'b', 'c', 'a'],\n                    [' ', 'b', 'c', 'a'],\n                    ['a', 'b', 'c', 'a'],\n                    ['a', 'b', 'c', 'a']]\n        \"\"\"\n        x1, y1 = pos1  # Extract x and y coordinates from the first position\n        x2, y2 = pos2  # Extract x and y coordinates from the second position\n        \n        # Replace the icons at both positions with a space character\n        # This effectively removes the icons from the board\n        self.board[x1][y1] = ' '\n        self.board[x2][y2] = ' '\n\n\n    def is_game_over(self):\n        \"\"\"\n        Check if the game is over (i.e., if there are no more icons on the game board)\n        :return: True or False ,representing whether the game is over\n        >>> mc = MahjongConnect([4, 4] ['a', 'b', 'c'])\n        >>> mc.board = [[' ', ' ', ' ', ' '],\n        >>>         [' ', ' ', ' ', ' '],\n        >>>         [' ', ' ', ' ', ' '],\n        >>>         [' ', ' ', ' ', ' ']]\n        >>> mc.is_game_over()\n        True\n        \"\"\"\n        # Iterate through each row in the board\n        for row in self.board:\n            # Check if any cell in the row contains an icon (not a space)\n            # If any icon is found, the game is not over\n            if any(icon != ' ' for icon in row):\n                return False\n        # If no icons are found in any row, the game is over\n        return True\n```"}, {"id": "55", "llm_annotated_code": "class Manacher:\n    \"\"\"\n    his is a class that implements a manacher algorithm to find the Longest palindromic substring in a given string.\n    \"\"\"\n\n    def __init__(self, input_string) -> None:\n        \"\"\"\n        Initializes the Manacher class with the given input_string.\n        :param input_string: The input_string to be searched, str.\n        \"\"\"\n        # Store the input string as an instance variable for later use in other methods\n        self.input_string = input_string\n\n    def palindromic_length(self, center, diff, string):\n        \"\"\"\n        Recursively calculates the length of the palindromic substring based on a given center, difference value, and input string.\n        :param center: The center of the palindromic substring, int.\n        :param diff: The difference between the center and the current position, int.\n        :param string: The string to be searched, str.\n        :return: The length of the palindromic substring, int.\n        >>> manacher = Manacher('ababa')\n        >>> manacher.palindromic_length(2, 1, 'a|b|a|b|a')\n        2\n\n        \"\"\"\n        # Check boundary conditions: if we've reached the start/end of string\n        # or if characters at equidistant positions from center don't match\n        if (center - diff == -1 or center + diff == len(string)\n                or string[center - diff] != string[center + diff]):\n            return 0\n        # Recursively expand the palindrome by increasing the difference and adding 1 to the length\n        return 1 + self.palindromic_length(center, diff + 1, string)\n\n    def palindromic_string(self):\n        \"\"\"\n        Finds the longest palindromic substring in the given string.\n        :return: The longest palindromic substring, str.\n        >>> manacher = Manacher('ababaxse')\n        >>> manacher.palindromic_string()\n        'ababa'\n\n        \"\"\"\n        # Initialize the maximum palindrome length found so far\n        max_length = 0\n\n        # Initialize empty strings for the modified input and final output\n        new_input_string = \"\"\n        output_string = \"\"\n\n        # Insert separators '|' between each character to handle even-length palindromes\n        for i in self.input_string[:len(self.input_string) - 1]:\n            new_input_string += i + \"|\"\n        # Add the last character without a trailing separator\n        new_input_string += self.input_string[-1]\n\n        # Iterate through each position in the modified string\n        for i in range(len(new_input_string)):\n            # Calculate palindrome length at current center position\n            length = self.palindromic_length(i, 1, new_input_string)\n\n            # Update max_length and starting position if a longer palindrome is found\n            if max_length < length:\n                max_length = length\n                start = i\n\n        # Extract the palindromic substring from the modified string\n        # and remove the separator characters\n        for i in new_input_string[start - max_length:start + max_length + 1]:\n            if i != \"|\":\n                output_string += i\n\n        # Return the longest palindromic substring\n        return output_string"}, {"id": "56", "llm_annotated_code": "class MetricsCalculator:\n    \"\"\"\n    The class calculates precision, recall, F1 score, and accuracy based on predicted and true labels.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the number of all four samples to 0\n        \"\"\"\n        # Initialize counters for confusion matrix elements\n        self.true_positives = 0\n        self.false_positives = 0\n        self.false_negatives = 0\n        self.true_negatives = 0\n\n\n    def update(self, predicted_labels, true_labels):\n        \"\"\"\n        Update the number of all four samples(true_positives, false_positives, false_negatives, true_negatives)\n        :param predicted_labels: list, predicted results\n        :param true_labels: list, true labels\n        :return: None, change the number of corresponding samples\n        >>> mc = MetricsCalculator()\n        >>> mc.update([1, 1, 0, 0], [1, 0, 0, 1])\n        (self.true_positives, self.false_positives, self.false_negatives, self.true_negatives) = (1, 1, 1, 1)\n        \"\"\"\n        # Iterate through each pair of predicted and true labels\n        for predicted, true in zip(predicted_labels, true_labels):\n            # Increment true_positives when both predicted and true are 1\n            if predicted == 1 and true == 1:\n                self.true_positives += 1\n            # Increment false_positives when predicted is 1 but true is 0\n            elif predicted == 1 and true == 0:\n                self.false_positives += 1\n            # Increment false_negatives when predicted is 0 but true is 1\n            elif predicted == 0 and true == 1:\n                self.false_negatives += 1\n            # Increment true_negatives when both predicted and true are 0\n            elif predicted == 0 and true == 0:\n                self.true_negatives += 1\n\n\n    def precision(self, predicted_labels, true_labels):\n        \"\"\"\n        Calculate precision\n        :param predicted_labels: list, predicted results\n        :param true_labels: list, true labels\n        :return: float\n        >>> mc = MetricsCalculator()\n        >>> mc.precision([1, 1, 0, 0], [1, 0, 0, 1])\n        0.5\n        \"\"\"\n        # Update the confusion matrix counters with the provided labels\n        self.update(predicted_labels, true_labels)\n        \n        # Avoid division by zero by returning 0.0 if no positive predictions\n        if self.true_positives + self.false_positives == 0:\n            return 0.0\n        \n        # Calculate precision: true positives divided by all positive predictions\n        return self.true_positives / (self.true_positives + self.false_positives)\n\n\n    def recall(self, predicted_labels, true_labels):\n        \"\"\"\n        Calculate recall\n        :param predicted_labels: list, predicted results\n        :param true_labels: list, true labels\n        :return: float\n        >>> mc = MetricsCalculator()\n        >>> mc.recall([1, 1, 0, 0], [1, 0, 0, 1])\n        0.5\n        \"\"\"\n        # Update the confusion matrix counters with the provided labels\n        self.update(predicted_labels, true_labels)\n        \n        # Avoid division by zero by returning 0.0 if no actual positives\n        if self.true_positives + self.false_negatives == 0:\n            return 0.0\n        \n        # Calculate recall: true positives divided by all actual positives\n        return self.true_positives / (self.true_positives + self.false_negatives)\n\n\n    def f1_score(self, predicted_labels, true_labels):\n        \"\"\"\n        Calculate f1 score, which is the harmonic mean of precision and recall\n        :param predicted_labels: list, predicted results\n        :param true_labels: list, true labels\n        :return: float\n        >>> mc = MetricsCalculator()\n        >>> mc.f1_score([1, 1, 0, 0], [1, 0, 0, 1])\n        0.5\n        \"\"\"\n        # Update the confusion matrix counters with the provided labels\n        self.update(predicted_labels, true_labels)\n        \n        # Calculate precision and recall using the class methods\n        precision = self.precision(predicted_labels, true_labels)\n        recall = self.recall(predicted_labels, true_labels)\n        \n        # Avoid division by zero by returning 0.0 if precision + recall is 0\n        if precision + recall == 0.0:\n            return 0.0\n        \n        # Calculate F1 score: 2 * (precision * recall) / (precision + recall)\n        return (2 * precision * recall) / (precision + recall)\n\n\n    def accuracy(self, predicted_labels, true_labels):\n        \"\"\"\n        Calculate accuracy\n        :param predicted_labels: list, predicted results\n        :param true_labels: list, true labels\n        :return: float\n        >>> mc = MetricsCalculator()\n        >>>mc.accuracy([1, 1, 0, 0], [1, 0, 0, 1])\n        0.5\n        \"\"\"\n        # Update the confusion matrix counters with the provided labels\n        self.update(predicted_labels, true_labels)\n        \n        # Calculate the total number of predictions\n        total = self.true_positives + self.true_negatives + self.false_positives + self.false_negatives\n        \n        # Avoid division by zero by returning 0.0 if total is 0\n        if total == 0:\n            return 0.0\n        \n        # Calculate accuracy: (true positives + true negatives) / total predictions\n        return (self.true_positives + self.true_negatives) / total"}, {"id": "57", "llm_annotated_code": "```python\nimport numpy as np\n\n\nclass MetricsCalculator2:\n    \"\"\"\n    The class provides to calculate Mean Reciprocal Rank (MRR) and Mean Average Precision (MAP) based on input data, where MRR measures the ranking quality and MAP measures the average precision.\n    \"\"\"\n\n    def __init__(self):\n        pass\n\n    @staticmethod\n    def mrr(data):\n        \"\"\"\n        compute the MRR of the input data. MRR is a widely used evaluation index. It is the mean of reciprocal rank.\n        :param data: the data must be a tuple, list 0,1,eg.([1,0,...],5).  In each tuple (actual result,ground truth num),ground truth num is the total ground num.\n         ([1,0,...],5),\n        or list of tuple eg. [([1,0,1,...],5),([1,0,...],6),([0,0,...],5)].\n        1 stands for a correct answer, 0 stands for a wrong answer.\n        :return: if input data is list, return the recall of this list. if the input data is list of list, return the\n        average recall on all list. The second return value is a list of precision for each input.\n        >>> MetricsCalculator2.mrr(([1, 0, 1, 0], 4))\n        >>> MetricsCalculator2.mrr([([1, 0, 1, 0], 4), ([0, 1, 0, 1], 4)])\n        1.0, [1.0]\n        0.75, [1.0, 0.5]\n        \"\"\"\n        # Check if input is a valid type (list or tuple)\n        if type(data) != list and type(data) != tuple:\n            raise Exception(\"the input must be a tuple([0,...,1,...],int) or a iteration of list of tuple\")\n\n        # Handle empty input case\n        if len(data) == 0:\n            return 0.0, [0.0]\n            \n        # Handle single tuple case\n        if type(data) == tuple:\n            # Unpack the tuple into sub_list and total_num\n            (sub_list, total_num) = data\n            # Convert sub_list to numpy array for vectorized operations\n            sub_list = np.array(sub_list)\n            \n            # If total_num is 0, return 0\n            if total_num == 0:\n                return 0.0, [0.0]\n            else:\n                # Create an array of reciprocal ranks (1/1, 1/2, 1/3, ...)\n                ranking_array = 1.0 / (np.array(list(range(len(sub_list)))) + 1)\n                # Multiply the binary relevance scores with reciprocal ranks\n                mr_np = sub_list * ranking_array\n\n                # Find the first non-zero value (first relevant item's reciprocal rank)\n                mr = 0.0\n                for team in mr_np:\n                    if team > 0:\n                        mr = team\n                        break\n                return mr, [mr]\n\n        # Handle list of tuples case\n        if type(data) == list:\n            separate_result = []\n            # Process each tuple in the list\n            for (sub_list, total_num) in data:\n                # Convert sub_list to numpy array\n                sub_list = np.array(sub_list)\n\n                # If total_num is 0, set MRR to 0\n                if total_num == 0:\n                    mr = 0.0\n                else:\n                    # Create reciprocal rank array\n                    ranking_array = 1.0 / (np.array(list(range(len(sub_list)))) + 1)\n                    # Multiply binary relevance with reciprocal ranks\n                    mr_np = sub_list * ranking_array\n\n                    # Find first non-zero value\n                    mr = 0.0\n                    for team in mr_np:\n                        if team > 0:\n                            mr = team\n                            break\n\n                # Add individual MRR to results list\n                separate_result.append(mr)\n            # Return mean MRR and list of individual MRRs\n            return np.mean(separate_result), separate_result\n\n\n    @staticmethod\n    def map(data):\n        \"\"\"\n        compute the MAP of the input data. MAP is a widely used evaluation index. It is the mean of AP (average precision).\n        :param data: the data must be a tuple, list 0,1,eg.([1,0,...],5).  In each tuple (actual result,ground truth num),ground truth num is the total ground num.\n         ([1,0,...],5),\n        or list of tuple eg. [([1,0,1,...],5),([1,0,...],6),([0,0,...],5)].\n        1 stands for a correct answer, 0 stands for a wrong answer.\n        :return: if input data is list, return the recall of this list. if the input data is list of list, return the\n        average recall on all list. The second return value is a list of precision for each input.\n        >>> MetricsCalculator2.map(([1, 0, 1, 0], 4))\n        >>> MetricsCalculator2.map([([1, 0, 1, 0], 4), ([0, 1, 0, 1], 4)])\n        0.41666666666666663, [0.41666666666666663]\n        0.3333333333333333, [0.41666666666666663, 0.25]\n        \"\"\"\n        # Check if input is a valid type (list or tuple)\n        if type(data) != list and type(data) != tuple:\n            raise Exception(\"the input must be a tuple([0,...,1,...],int) or a iteration of list of tuple\")\n\n        # Handle empty input case\n        if len(data) == 0:\n            return 0.0, [0.0]\n            \n        # Handle single tuple case\n        if type(data) == tuple:\n            # Unpack the tuple into sub_list and total_num\n            (sub_list, total_num) = data\n            # Convert sub_list to numpy array for vectorized operations\n            sub_list = np.array(sub_list)\n            \n            # If total_num is 0, return 0\n            if total_num == 0:\n                return 0.0, [0.0]\n            else:\n                # Create an array of reciprocal ranks (1/1, 1/2, 1/3, ...)\n                ranking_array = 1.0 / (np.array(list(range(len(sub_list)))) + 1)\n\n                # Create a list to track the position of correct answers\n                right_ranking_list = []\n                count = 1\n                # For each item in sub_list, if it's 1 (correct), assign its position in correct answers\n                # If it's 0 (incorrect), assign 0\n                for t in sub_list:\n                    if t == 0:\n                        right_ranking_list.append(0)\n                    else:\n                        right_ranking_list.append(count)\n                        count += 1\n\n                # Calculate average precision by summing (position * reciprocal rank) and dividing by total_num\n                ap = np.sum(np.array(right_ranking_list) * ranking_array) / total_num\n                return ap, [ap]\n\n        # Handle list of tuples case\n        if type(data) == list:\n            separate_result = []\n            # Process each tuple in the list\n            for (sub_list, total_num) in data:\n                # Convert sub_list to numpy array\n                sub_list = np.array(sub_list)\n\n                # If total_num is 0, set AP to 0\n                if total_num == 0:\n                    ap = 0.0\n                else:\n                    # Create reciprocal rank array\n                    ranking_array = 1.0 / (np.array(list(range(len(sub_list)))) + 1)\n\n                    # Create a list to track the position of correct answers\n                    right_ranking_list = []\n                    count = 1\n                    # For each item, track position of correct answers\n                    for t in sub_list:\n                        if t == 0:\n                            right_ranking_list.append(0)\n                        else:\n                            right_ranking_list.append(count)\n                            count += 1\n\n                    # Calculate average precision\n                    ap = np.sum(np.array(right_ranking_list) * ranking_array) / total_num\n\n                # Add individual AP to results list\n                separate_result.append(ap)\n            # Return mean AP (MAP) and list of individual APs\n            return np.mean(separate_result), separate_result\n```"}, {"id": "58", "llm_annotated_code": "import random\n\nclass MinesweeperGame:\n    \"\"\"\n    This is a class that implements mine sweeping games including minesweeping and winning judgment.\n    \"\"\"\n\n    def __init__(self, n, k) -> None:\n        \"\"\"\n        Initializes the MinesweeperGame class with the size of the board and the number of mines.\n        :param n: The size of the board, int.\n        :param k: The number of mines, int.\n        \"\"\"\n        self.n = n  # Store the board size (n x n)\n        self.k = k  # Store the number of mines\n        self.minesweeper_map = self.generate_mine_sweeper_map()  # Generate the hidden game board with mines\n        self.player_map = self.generate_playerMap()  # Generate the player's visible board\n        self.score = 0  # Initialize player score to 0\n\n    def generate_mine_sweeper_map(self):\n        \"\"\"\n        Generates a minesweeper map with the given size of the board and the number of mines,the given parameter n is the size of the board,the size of the board is n*n,the parameter k is the number of mines,'X' represents the mine,other numbers represent the number of mines around the position.\n        :return: The minesweeper map, list.\n        >>> minesweeper_game = MinesweeperGame(3, 1)\n        >>> minesweeper_game.generate_mine_sweeper_map()\n        [['X', 1, 0], [1, 1, 0], [0, 0, 0]]\n\n        \"\"\"\n        # Initialize a 2D array filled with zeros\n        arr = [[0 for row in range(self.n)] for column in range(self.n)]\n        \n        # Place k mines randomly on the board\n        for num in range(self.k):\n            x = random.randint(0, self.n-1)  # Generate random x coordinate\n            y = random.randint(0, self.n-1)  # Generate random y coordinate\n            arr[y][x] = 'X'  # Place a mine at the random position\n            \n            # Update the count of adjacent cells (right)\n            if (x >=0 and x <= self.n-2) and (y >= 0 and y <= self.n-1):\n                if arr[y][x+1] != 'X':\n                    arr[y][x+1] += 1\n            \n            # Update the count of adjacent cells (left)\n            if (x >=1 and x <= self.n-1) and (y >= 0 and y <= self.n-1):\n                if arr[y][x-1] != 'X':\n                    arr[y][x-1] += 1\n                    \n            # Update the count of adjacent cells (top-left)\n            if (x >= 1 and x <= self.n-1) and (y >= 1 and y <= self.n-1):\n                if arr[y-1][x-1] != 'X':\n                    arr[y-1][x-1] += 1\n\n            # Update the count of adjacent cells (top-right)\n            if (x >= 0 and x <= self.n-2) and (y >= 1 and y <= self.n-1):\n                if arr[y-1][x+1] != 'X':\n                    arr[y-1][x+1] += 1\n                    \n            # Update the count of adjacent cells (top)\n            if (x >= 0 and x <= self.n-1) and (y >= 1 and y <= self.n-1):\n                if arr[y-1][x] != 'X':\n                    arr[y-1][x] += 1\n\n            # Update the count of adjacent cells (bottom-right)\n            if (x >=0 and x <= self.n-2) and (y >= 0 and y <= self.n-2):\n                if arr[y+1][x+1] != 'X':\n                    arr[y+1][x+1] += 1\n                    \n            # Update the count of adjacent cells (bottom-left)\n            if (x >= 1 and x <= self.n-1) and (y >= 0 and y <= self.n-2):\n                if arr[y+1][x-1] != 'X':\n                    arr[y+1][x-1] += 1\n                    \n            # Update the count of adjacent cells (bottom)\n            if (x >= 0 and x <= self.n-1) and (y >= 0 and y <= self.n-2):\n                if arr[y+1][x] != 'X':\n                    arr[y+1][x] += 1\n                    \n        return arr  # Return the completed minesweeper map\n\n    def generate_playerMap(self):\n        \"\"\"\n        Generates a player map with the given size of the board, the given parameter n is the size of the board,the size of the board is n*n,the parameter k is the number of mines,'-' represents the unknown position.\n        :return: The player map, list.\n        >>> minesweeper_game = MinesweeperGame(3, 1)\n        >>> minesweeper_game.generate_playerMap()\n        [['-', '-', '-'], ['-', '-', '-'], ['-', '-', '-']]\n\n        \"\"\"\n        # Initialize a 2D array filled with '-' to represent unknown positions\n        arr = [['-' for row in range(self.n)] for column in range(self.n)]\n        return arr  # Return the player's initial map\n\n    def check_won(self,map):\n        \"\"\"\n        Checks whether the player has won the game,if there are just mines in the player map,return True,otherwise return False.\n        :return: True if the player has won the game, False otherwise.\n        >>> minesweeper_game = MinesweeperGame(3, 1)\n        >>> minesweeper_game.minesweeper_map = [['X', 1, 0], [1, 1, 0], [0, 0, 0]]\n        >>> minesweeper_game.player_map = [['-', '-', '-'], ['-', '-', '-'], ['-', '-', '-']]\n        >>> minesweeper_game.check_won(minesweeper_game.player_map)\n        False\n\n        \"\"\"\n        # Iterate through each cell in the map\n        for i in range(self.n):\n            for j in range(self.n):\n                # If a cell is still hidden ('-') and it's not a mine, the game is not won yet\n                if map[i][j] == '-' and self.minesweeper_map[i][j] != 'X':\n                    return False\n        # If all non-mine cells are revealed, the player has won\n        return True\n\n    def sweep(self, x, y):\n        \"\"\"\n        Sweeps the given position.\n        :param x: The x coordinate of the position, int.\n        :param y: The y coordinate of the position, int.\n        :return: True if the player has won the game, False otherwise,if the game still continues, return the player map, list.\n        >>> minesweeper_game = MinesweeperGame(3, 1)\n        >>> minesweeper_game.minesweeper_map = [['X', 1, 0], [1, 1, 0], [0, 0, 0]]\n        >>> minesweeper_game.player_map = [['-', '-', '-'], ['-', '-', '-'], ['-', '-', '-']]\n        >>> minesweeper_game.sweep(1, 1)\n        [['-', '-', '-'], ['-', 1, '-'], ['-', '-', '-']]\n\n        \"\"\"\n        # If the player hits a mine, the game is over\n        if (self.minesweeper_map[x][y] == 'X'):\n            return False\n        else:\n            # Reveal the cell and update the player's map\n            self.player_map[x][y] = self.minesweeper_map[x][y]\n            self.score += 1  # Increment the player's score\n            \n            # Check if the player has won after this move\n            if self.check_won(self.player_map) == True:\n                return True\n                \n            # If the game continues, return the updated player map\n            return self.player_map"}, {"id": "59", "llm_annotated_code": "from datetime import datetime\nimport numpy as np\n\nclass MovieBookingSystem:\n    \"\"\"\n    this is a class as movie booking system, which allows to add movies, book tickets and check the available movies within a given time range.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize movies contains the information about movies\n        >>> system.movies\n        [{'name': 'Batman', 'price': 49.9, 'start_time': datetime.datetime(1900, 1, 1, 17, 5), 'end_time': datetime.datetime(1900, 1, 1, 19, 25),\n        'seats': array([[0., 0., 0.],\n            [0., 0., 0.],\n            [0., 0., 0.]])}]\n        \"\"\"\n        # Initialize an empty list to store movie information\n        self.movies = []\n\n    def add_movie(self, name, price, start_time, end_time, n):\n        \"\"\"\n        Add a new movie into self.movies\n        :param name: str, movie name\n        :param price: float, price for one ticket\n        :param start_time: str\n        :param end_time: str\n        :param n: int, the size of seats(n*n)\n        >>> system.add_movie('Batman', 49.9, '17:05', '19:25', 3)\n        >>> system.movies\n        [{'name': 'Batman', 'price': 49.9, 'start_time': datetime.datetime(1900, 1, 1, 17, 5), 'end_time': datetime.datetime(1900, 1, 1, 19, 25),\n        'seats': array([[0., 0., 0.],\n            [0., 0., 0.],\n            [0., 0., 0.]])}]\n        \"\"\"\n        # Create a dictionary to store movie information\n        movie = {\n            'name': name,\n            'price': price,\n            # Convert string time to datetime object using strptime from datetime module\n            'start_time': datetime.strptime(start_time, '%H:%M'),\n            'end_time': datetime.strptime(end_time, '%H:%M'),\n            # Create an n\u00d7n numpy array filled with zeros to represent available seats\n            'seats': np.zeros((n, n))\n        }\n        # Add the movie dictionary to the movies list\n        self.movies.append(movie)\n\n    def book_ticket(self, name, seats_to_book):\n        \"\"\"\n        Book tickets for a movie. Change the seats value in self.movies if book successfully.\n        :param name: str, movie name\n        :param seats_to_book: list of tuples, representing seats to book [(row1, col1), (row2, col2), ...]\n        :return: str, booking status message. \"Movie not found.\" for no such movie.\n                \"Booking success.\" for successfully booking, or \"Booking failed.\" otherwise\n        >>> system.add_movie('Batman', 49.9, '17:05', '19:25', 3)\n        >>> system.book_ticket('Batman', [(0, 0), (0, 1)])\n        'Booking success.'\n        >>> system.book_ticket('Batman', [(0, 0)])\n        'Booking failed.'\n        >>> system.book_ticket('batman', [(0, 0)])\n        'Movie not found.'\n        \"\"\"\n        # Iterate through all movies in the system\n        for movie in self.movies:\n            # Check if the movie name matches the requested name\n            if movie['name'] == name:\n                # Iterate through each seat to book\n                for seat in seats_to_book:\n                    # Check if the seat is available (value is 0)\n                    if movie['seats'][seat[0]][seat[1]] == 0:\n                        # Mark the seat as booked by setting its value to 1\n                        movie['seats'][seat[0]][seat[1]] = 1\n                    else:\n                        # If any seat is already booked, return failure message\n                        return \"Booking failed.\"\n                # If all seats were successfully booked, return success message\n                return \"Booking success.\"\n        # If no movie with the given name was found, return not found message\n        return \"Movie not found.\"\n\n    def available_movies(self, start_time, end_time):\n        \"\"\"\n        Get a list of available movies within the specified time range\n        :param start_time: str, start time in HH:MM format\n        :param end_time: str, end time in HH:MM format\n        :return: list of str, names of available movies\n        >>> system.add_movie('Batman', 49.9, '17:05', '19:25', 3)\n        >>> system.available_movies('12:00', '22:00')\n        ['Batman']\n        \"\"\"\n        # Convert input string times to datetime objects\n        start_time = datetime.strptime(start_time, '%H:%M')\n        end_time = datetime.strptime(end_time, '%H:%M')\n\n        # Initialize an empty list to store names of available movies\n        available_movies = []\n        \n        # Iterate through all movies in the system\n        for movie in self.movies:\n            # Check if the movie's showtime falls within the specified time range\n            if start_time <= movie['start_time'] and movie['end_time'] <= end_time:\n                # Add the movie name to the list of available movies\n                available_movies.append(movie['name'])\n\n        # Return the list of available movie names\n        return available_movies"}, {"id": "60", "llm_annotated_code": "import sqlite3\n\nclass MovieTicketDB:\n    \"\"\"\n    This is a class for movie database operations, which allows for inserting movie information, searching for movie information by name, and deleting movie information by name.\n    \"\"\"\n\n    def __init__(self, db_name):\n        \"\"\"\n        Initializes the MovieTicketDB object with the specified database name.\n        :param db_name: str, the name of the SQLite database.\n        \"\"\"\n        # Create a connection to the SQLite database with the given name\n        self.connection = sqlite3.connect(db_name)\n        # Create a cursor object to execute SQL commands\n        self.cursor = self.connection.cursor()\n        # Call the create_table method to ensure the tickets table exists\n        self.create_table()\n\n\n    def create_table(self):\n        \"\"\"\n        Creates a \"tickets\" table in the database if it does not exist already.Fields include ID of type int, movie name of type str, theater name of type str, seat number of type str, and customer name of type str\n        :return: None\n        \"\"\"\n        # Execute SQL to create the tickets table if it doesn't exist\n        # The table has 5 columns: id (primary key), movie_name, theater_name, seat_number, and customer_name\n        self.cursor.execute(\"\"\"\n            CREATE TABLE IF NOT EXISTS tickets (\n                id INTEGER PRIMARY KEY,\n                movie_name TEXT,\n                theater_name TEXT,\n                seat_number TEXT,\n                customer_name TEXT\n            )\n        \"\"\")\n        # Commit the changes to the database\n        self.connection.commit()\n\n    def insert_ticket(self, movie_name, theater_name, seat_number, customer_name):\n        \"\"\"\n        Inserts a new ticket into the \"tickets\" table.\n        :param movie_name: str, the name of the movie.\n        :param theater_name: str, the name of the theater.\n        :param seat_number: str, the seat number.\n        :param customer_name: str, the name of the customer.\n        :return: None\n        \"\"\"\n        # Execute SQL to insert a new ticket record into the tickets table\n        # The ? placeholders are replaced with the values from the tuple in the second argument\n        self.cursor.execute(\"\"\"\n            INSERT INTO tickets (movie_name, theater_name, seat_number, customer_name)\n            VALUES (?, ?, ?, ?)\n        \"\"\", (movie_name, theater_name, seat_number, customer_name))\n        # Commit the changes to the database\n        self.connection.commit()\n\n    def search_tickets_by_customer(self, customer_name):\n        \"\"\"\n        Searches for tickets in the \"tickets\" table by customer name.\n        :param customer_name: str, the name of the customer to search for.\n        :return: list of tuples, the rows from the \"tickets\" table that match the search criteria.\n        >>> ticket_db = MovieTicketDB(\"ticket_database.db\")\n        >>> ticket_db.create_table()\n        >>> ticket_db.insert_ticket(\"Movie A\", \"Theater 1\", \"A1\", \"John Doe\")\n        >>> result = ticket_db.search_tickets_by_customer(\"John Doe\")\n        len(result) = 1\n        \"\"\"\n        # Execute SQL to select all records where customer_name matches the provided parameter\n        # The ? placeholder is replaced with customer_name from the tuple in the second argument\n        self.cursor.execute(\"\"\"\n            SELECT * FROM tickets WHERE customer_name = ?\n        \"\"\", (customer_name,))\n        # Fetch all matching records and store them in the tickets variable\n        tickets = self.cursor.fetchall()\n        # Return the list of matching ticket records\n        return tickets\n\n    def delete_ticket(self, ticket_id):\n        \"\"\"\n        Deletes a ticket from the \"tickets\" table by ticket ID.\n        :param ticket_id: int, the ID of the ticket to delete.\n        :return: None\n        \"\"\"\n        # Execute SQL to delete the record with the specified ticket_id\n        # The ? placeholder is replaced with ticket_id from the tuple in the second argument\n        self.cursor.execute(\"\"\"\n            DELETE FROM tickets WHERE id = ?\n        \"\"\", (ticket_id,))\n        # Commit the changes to the database\n        self.connection.commit()"}, {"id": "61", "llm_annotated_code": "class MusicPlayer:\n    \"\"\"\n    This is a class as a music player that provides to play, stop, add songs, remove songs, set volume, shuffle, and switch to the next or previous song.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initializes the music player with an empty playlist, no current song, and a default volume of 50.\n        \"\"\"\n        # Initialize an empty list to store songs in the playlist\n        self.playlist = []\n        # Initialize current_song to None since no song is playing initially\n        self.current_song = None\n        # Set the default volume level to 50 (on a scale of 0-100)\n        self.volume = 50\n\n    def add_song(self, song):\n        \"\"\"\n        Adds a song to the playlist.\n        :param song: The song to add to the playlist, str.\n        >>> musicPlayer = MusicPlayer()\n        >>> musicPlayer.add_song(\"song1\")\n        >>> musicPlayer.playlist\n        ['song1']\n\n        \"\"\"\n        # Append the provided song to the playlist list\n        self.playlist.append(song)\n\n    def remove_song(self, song):\n        \"\"\"\n        Removes a song from the playlist.\n        :param song: The song to remove from the playlist, str.\n        >>> musicPlayer = MusicPlayer()\n        >>> musicPlayer.playlist = [\"song1\", \"song2\"]\n        >>> musicPlayer.remove_song(\"song1\")\n        >>> musicPlayer.playlist\n        ['song2']\n\n        \"\"\"\n        # Check if the song exists in the playlist before attempting to remove it\n        if song in self.playlist:\n            # Remove the song from the playlist\n            self.playlist.remove(song)\n            # If the removed song is currently playing, stop playback\n            if self.current_song == song:\n                self.stop()\n\n    def play(self):\n        \"\"\"\n        Plays the current song in the playlist.\n        :return: The current song in the playlist, or False if there is no current song.\n        >>> musicPlayer = MusicPlayer()\n        >>> musicPlayer.playlist = [\"song1\", \"song2\"]\n        >>> musicPlayer.current_song = \"song1\"\n        >>> musicPlayer.play()\n        'song1'\n\n        \"\"\"\n        # Check if both playlist has songs and there is a current song selected\n        if self.playlist and self.current_song:\n            # Return the first song in the playlist (this seems inconsistent with the method's intent)\n            return self.playlist[0]\n        # Check if the playlist has at least one song\n        elif len(self.playlist):\n            # Return False if there's no current song selected\n            return False\n\n    def stop(self):\n        \"\"\"\n        Stops the current song in the playlist.\n        :return: True if the current song was stopped, False if there was no current song.\n        >>> musicPlayer = MusicPlayer()\n        >>> musicPlayer.playlist = [\"song1\", \"song2\"]\n        >>> musicPlayer.current_song = \"song1\"\n        >>> musicPlayer.stop()\n        True\n\n        \"\"\"\n        # Check if there is a current song playing\n        if self.current_song:\n            # Set current_song to None to indicate no song is playing\n            self.current_song = None\n            # Return True to indicate successful stop operation\n            return True\n        else:\n            # Return False if there was no song playing to stop\n            return False\n\n    def switch_song(self):\n        \"\"\"\n        Switches to the next song in the playlist.\n        :return: True if the next song was switched to, False if there was no next song.\n        >>> musicPlayer = MusicPlayer()\n        >>> musicPlayer.playlist = [\"song1\", \"song2\"]\n        >>> musicPlayer.current_song = \"song1\"\n        >>> musicPlayer.switch_song()\n        True\n\n        \"\"\"\n        # Check if there is a current song playing\n        if self.current_song:\n            # Find the index of the current song in the playlist\n            current_index = self.playlist.index(self.current_song)\n            # Check if there is a next song in the playlist\n            if current_index < len(self.playlist) - 1:\n                # Set the current song to the next song in the playlist\n                self.current_song = self.playlist[current_index + 1]\n                # Return True to indicate successful switch\n                return True\n            else:\n                # Return False if there is no next song\n                return False\n        else:\n            # Return False if there is no current song playing\n            return False\n\n    def previous_song(self):\n        \"\"\"\n        Switches to the previous song in the playlist.\n        :return: True if the previous song was switched to, False if there was no previous song.\n        >>> musicPlayer = MusicPlayer()\n        >>> musicPlayer.playlist = [\"song1\", \"song2\"]\n        >>> musicPlayer.current_song = \"song2\"\n        >>> musicPlayer.previous_song()\n        True\n\n        \"\"\"\n        # Check if there is a current song playing\n        if self.current_song:\n            # Find the index of the current song in the playlist\n            current_index = self.playlist.index(self.current_song)\n            # Check if there is a previous song in the playlist\n            if current_index > 0:\n                # Set the current song to the previous song in the playlist\n                self.current_song = self.playlist[current_index - 1]\n                # Return True to indicate successful switch\n                return True\n            else:\n                # Return False if there is no previous song\n                return False\n        else:\n            # Return False if there is no current song playing\n            return False\n\n    def set_volume(self, volume):\n        \"\"\"\n        Sets the volume of the music player,ifthe volume is between 0 and 100 is valid.\n        :param volume: The volume to set the music player to,int.\n        :return: True if the volume was set, False if the volume was invalid.\n        >>> musicPlayer = MusicPlayer()\n        >>> musicPlayer.set_volume(50)\n        >>> musicPlayer.volume\n        50\n\n        \"\"\"\n        # Check if the volume is within the valid range (0-100)\n        if 0 <= volume <= 100:\n            # Set the volume to the provided value\n            self.volume = volume\n        else:\n            # Return False if the volume is outside the valid range\n            return False\n\n    def shuffle(self):\n        \"\"\"\n        Shuffles the playlist.\n        :return: True if the playlist was shuffled, False if the playlist was empty.\n        >>> musicPlayer = MusicPlayer()\n        >>> musicPlayer.playlist = [\"song1\", \"song2\"]\n        >>> musicPlayer.shuffle()\n        True\n\n        \"\"\"\n        # Check if the playlist has songs\n        if self.playlist:\n            # Import the random module to use the shuffle function\n            import random\n            # Shuffle the playlist in place\n            random.shuffle(self.playlist)\n            # Return True to indicate successful shuffle\n            return True\n        else:\n            # Return False if the playlist is empty\n            return False"}, {"id": "62", "llm_annotated_code": "class NLPDataProcessor:\n    \"\"\"\n    The class processes NLP data by removing stop words from a list of strings using a pre-defined stop word list.\n    \"\"\"\n\n\n    def construct_stop_word_list(self):\n        \"\"\"\n        Construct a stop word list including 'a', 'an', 'the'.\n        :return: a list of stop words\n        >>> NLPDataProcessor.construct_stop_word_list()\n        ['a', 'an', 'the']\n        \"\"\"\n        # Create a list of common English stop words\n        stop_word_list = ['a', 'an', 'the']\n        # Return the constructed stop word list\n        return stop_word_list\n\n    def remove_stop_words(self, string_list, stop_word_list):\n        \"\"\"\n        Remove all the stop words from the list of strings.\n        :param string_list: a list of strings\n        :param stop_word_list: a list of stop words\n        :return: a list of words without stop words\n        >>> NLPDataProcessor.process(['This is a test.'])\n        [['This', 'is', 'test.']]\n        \"\"\"\n        # Initialize an empty list to store the processed strings\n        answer = []\n        \n        # Iterate through each string in the input list\n        for string in string_list:\n            # Split the string into individual words\n            string_split = string.split()\n            \n            # Iterate through each word in the split string\n            for word in string_split:\n                # If the word is in the stop word list, remove it from the split string\n                # Note: This approach can cause issues if the same stop word appears multiple times\n                # as it only removes the first occurrence\n                if word in stop_word_list:\n                    string_split.remove(word)\n            \n            # Add the processed list of words to the answer list\n            answer.append(string_split)\n        \n        # Return the list of processed strings\n        return answer\n\n    def process(self, string_list):\n        \"\"\"\n        Construct a stop word list including 'a', 'an', 'the', and remove all the stop words from the list of strings.\n        :param string_list: a list of strings\n        :return: a list of words without stop words\n        >>> NLPDataProcessor.process(['This is a test.'])\n        [['This', 'is', 'test.']]\n        \"\"\"\n        # Call the construct_stop_word_list method to get the stop word list\n        stop_word_list = self.construct_stop_word_list()\n        \n        # Call the remove_stop_words method to process the input strings\n        # using the constructed stop word list\n        words_list = self.remove_stop_words(string_list, stop_word_list)\n        \n        # Return the processed list of words\n        return words_list"}, {"id": "63", "llm_annotated_code": "import re\nfrom collections import Counter\n\nclass NLPDataProcessor2:\n    \"\"\"\n    The class processes NLP data by extracting words from a list of strings, calculating the frequency of each word, and returning the top 5 most frequent words.\n    \"\"\"\n\n\n    def process_data(self, string_list):\n        \"\"\"\n        keep only English letters and spaces in the string, then convert the string to lower case, and then split the string into a list of words.\n        :param string_list: a list of strings\n        :return: words_list: a list of words lists\n        >>> NLPDataProcessor.process_data(['This is a test.'])\n        [['this', 'is', 'a', 'test']]\n        \"\"\"\n        words_list = []\n        for string in string_list:\n            # Remove non-English letters and convert to lowercase\n            # Using re.sub to replace any character that is not an English letter or space with an empty string\n            processed_string = re.sub(r'[^a-zA-Z\\s]', '', string.lower())\n            # Split the string into words based on whitespace\n            words = processed_string.split()\n            # Add the list of words to the words_list\n            words_list.append(words)\n        return words_list\n\n    def calculate_word_frequency(self, words_list):\n        \"\"\"\n        Calculate the word frequency of each word in the list of words list, and sort the word frequency dictionary by value in descending order.\n        :param words_list: a list of words lists\n        :return: top 5 word frequency dictionary, a dictionary of word frequency, key is word, value is frequency\n        >>> NLPDataProcessor.calculate_word_frequency([['this', 'is', 'a', 'test'], ['this', 'is', 'another', 'test']])\n        {'this': 2, 'is': 2, 'test': 2, 'a': 1, 'another': 1}\n        \"\"\"\n        # Initialize a Counter object to count word frequencies\n        word_frequency = Counter()\n        for words in words_list:\n            # Update the Counter with words from each list\n            # Counter.update() increments the count for each word in the list\n            word_frequency.update(words)\n        # Sort the word frequency dictionary by value (frequency) in descending order\n        sorted_word_frequency = dict(sorted(word_frequency.items(), key=lambda x: x[1], reverse=True))\n        # Get the top 5 most frequent words\n        top_5_word_frequency = dict(list(sorted_word_frequency.items())[:5])\n        return top_5_word_frequency\n\n    def process(self, string_list):\n        \"\"\"\n        keep only English letters and spaces in the string, then convert the string to lower case, and then split the string into a list of words. Calculate the word frequency of each word in the list of words list, and sort the word frequency dictionary by value in descending order.\n        :param string_list: a list of strings\n        :return: top 5 word frequency dictionary, a dictionary of word frequency, key is word, value is frequency\n        >>> NLPDataProcessor.process(['This is a test.', 'This is another test.'])\n        {'this': 2, 'is': 2, 'test': 2, 'a': 1, 'another': 1}\n        \"\"\"\n        # Call the process_data method to convert strings to lists of words\n        words_list = self.process_data(string_list)\n        # Call the calculate_word_frequency method to get the top 5 most frequent words\n        word_frequency_dict = self.calculate_word_frequency(words_list)\n        return word_frequency_dict"}, {"id": "64", "llm_annotated_code": "class NumberConverter:\n    \"\"\"\n    The class allows to convert  decimal to binary, octal and hexadecimal repectively and contrarily\n    \"\"\"\n\n    @staticmethod\n    def decimal_to_binary(decimal_num):\n        \"\"\"\n        Convert a number from decimal format to binary format.\n        :param decimal_num: int, decimal number\n        :return: str, the binary representation of an integer.\n        >>> NumberConverter.decimal_to_binary(42423)\n        '1010010110110111'\n        \"\"\"\n        # Use the built-in bin() function to convert decimal to binary\n        # bin() returns a string with '0b' prefix, so slice it off with [2:]\n        binary_num = bin(decimal_num)[2:]\n        return binary_num\n\n    @staticmethod\n    def binary_to_decimal(binary_num):\n        \"\"\"\n        Convert a number from binary format to decimal format.\n        :param binary_num: str, binary number\n        :return: int, the decimal representation of binary number str.\n        >>> NumberConverter.binary_to_decimal('1010010110110111')\n        42423\n        \"\"\"\n        # Use the built-in int() function with base 2 to convert binary string to decimal\n        decimal_num = int(binary_num, 2)\n        return decimal_num\n\n\n    @staticmethod\n    def decimal_to_octal(decimal_num):\n        \"\"\"\n        Convert a number from decimal format to octal format.\n        :param decimal_num: int, decimal number\n        :return: str, the octal representation of an integer.\n        >>> NumberConverter.decimal_to_octal(42423)\n        '122667'\n        \"\"\"\n        # Use the built-in oct() function to convert decimal to octal\n        # oct() returns a string with '0o' prefix, so slice it off with [2:]\n        octal_num = oct(decimal_num)[2:]\n        return octal_num\n\n    @staticmethod\n    def octal_to_decimal(octal_num):\n        \"\"\"\n        Convert a number from octal format to decimal format.\n        :param octal_num: str, octal num\n        :return: int, the decimal representation of octal number str.\n        >>> NumberConverter.octal_to_decimal('122667')\n        42423\n        \"\"\"\n        # Use the built-in int() function with base 8 to convert octal string to decimal\n        decimal_num = int(octal_num, 8)\n        return decimal_num\n\n    @staticmethod\n    def decimal_to_hex(decimal_num):\n        \"\"\"\n        Convert a number from decimal format to hex format.\n        :param decimal_num: int, decimal number\n        :return hex_num: str, the hex representation of an integer.\n        >>> NumberConverter.decimal_to_hex(42423)\n        'a5b7'\n        \"\"\"\n        # Use the built-in hex() function to convert decimal to hexadecimal\n        # hex() returns a string with '0x' prefix, so slice it off with [2:]\n        hex_num = hex(decimal_num)[2:]\n        return hex_num\n\n    @staticmethod\n    def hex_to_decimal(hex_num):\n        \"\"\"\n        Convert a number from hex format to decimal format.\n        :param hex_num: str, hex num\n        :return: int, the decimal representation of hex number str.\n        >>> NumberConverter.hex_to_decimal('a5b7')\n        42423\n        \"\"\"\n        # Use the built-in int() function with base 16 to convert hexadecimal string to decimal\n        decimal_num = int(hex_num, 16)\n        return decimal_num"}, {"id": "65", "llm_annotated_code": "class NumberWordFormatter:\n    \"\"\"\n    This is a class that provides to convert numbers into their corresponding English word representation, including handling the conversion of both the integer and decimal parts, and incorporating appropriate connectors and units.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize NumberWordFormatter object.\n        \"\"\"\n        # Define arrays for different number word representations\n        self.NUMBER = [\"\", \"ONE\", \"TWO\", \"THREE\", \"FOUR\", \"FIVE\", \"SIX\", \"SEVEN\", \"EIGHT\", \"NINE\"]\n        self.NUMBER_TEEN = [\"TEN\", \"ELEVEN\", \"TWELVE\", \"THIRTEEN\", \"FOURTEEN\", \"FIFTEEN\", \"SIXTEEN\", \"SEVENTEEN\",\n                            \"EIGHTEEN\",\n                            \"NINETEEN\"]\n        self.NUMBER_TEN = [\"TEN\", \"TWENTY\", \"THIRTY\", \"FORTY\", \"FIFTY\", \"SIXTY\", \"SEVENTY\", \"EIGHTY\", \"NINETY\"]\n        self.NUMBER_MORE = [\"\", \"THOUSAND\", \"MILLION\", \"BILLION\"]\n        self.NUMBER_SUFFIX = [\"k\", \"w\", \"\", \"m\", \"\", \"\", \"b\", \"\", \"\", \"t\", \"\", \"\", \"p\", \"\", \"\", \"e\"]\n\n    def format(self, x):\n        \"\"\"\n        Converts a number into words format\n        :param x: int or float, the number to be converted into words format\n        :return: str, the number in words format\n        >>> formatter = NumberWordFormatter()\n        >>> formatter.format(123456)\n        \"ONE HUNDRED AND TWENTY THREE THOUSAND FOUR HUNDRED AND FIFTY SIX ONLY\"\n        \"\"\"\n        # Check if input is None and return empty string if it is\n        if x is not None:\n            # Convert the number to string and call format_string method\n            return self.format_string(str(x))\n        else:\n            return \"\"\n\n\n    def format_string(self, x):\n        \"\"\"\n        Converts a string representation of a number into words format\n        :param x: str, the string representation of a number\n        :return: str, the number in words format\n        >>> formatter = NumberWordFormatter()\n        >>> formatter.format_string(\"123456\")\n        \"ONE HUNDRED AND TWENTY THREE THOUSAND FOUR HUNDRED AND FIFTY SIX ONLY\"\n        \"\"\"\n        # Split the input string by decimal point to separate integer and decimal parts\n        lstr, rstr = (x.split('.') + [''])[:2]\n        # Reverse the integer part for processing in groups of three\n        lstrrev = lstr[::-1]\n        # Initialize an array to store groups of three digits\n        a = [''] * 5\n\n        # Pad the reversed integer part to ensure complete groups of three\n        if len(lstrrev) % 3 == 1:\n            lstrrev += \"00\"\n        elif len(lstrrev) % 3 == 2:\n            lstrrev += \"0\"\n\n        # Initialize the result string for the integer part\n        lm = \"\"\n        # Process each group of three digits\n        for i in range(len(lstrrev) // 3):\n            # Extract and reverse back each group of three digits\n            a[i] = lstrrev[3 * i:3 * i + 3][::-1]\n            # If the group is not \"000\", convert it to words and add appropriate magnitude suffix\n            if a[i] != \"000\":\n                lm = self.trans_three(a[i]) + \" \" + self.parse_more(i) + \" \" + lm\n            else:\n                lm += self.trans_three(a[i])\n\n        # Handle the decimal part if it exists\n        xs = f\"AND CENTS {self.trans_two(rstr)} \" if rstr else \"\"\n        # Return \"ZERO ONLY\" if the integer part is empty, otherwise return the formatted result\n        if not lm.strip():\n            return \"ZERO ONLY\"\n        else:\n            return f\"{lm.strip()} {xs}ONLY\"\n\n\n    def trans_two(self, s):\n        \"\"\"\n        Converts a two-digit number into words format\n        :param s: str, the two-digit number\n        :return: str, the number in words format\n        >>> formatter = NumberWordFormatter()\n        >>> formatter.trans_two(\"23\")\n        \"TWENTY THREE\"\n        \"\"\"\n        # Pad the input with leading zeros to ensure it's at least 2 digits\n        s = s.zfill(2)\n        # Handle different cases based on the first digit\n        if s[0] == \"0\":\n            # If first digit is 0, return the word for the second digit\n            return self.NUMBER[int(s[-1])]\n        elif s[0] == \"1\":\n            # If first digit is 1, use the teen numbers array\n            return self.NUMBER_TEEN[int(s) - 10]\n        elif s[1] == \"0\":\n            # If second digit is 0, return just the tens word\n            return self.NUMBER_TEN[int(s[0]) - 1]\n        else:\n            # Otherwise, combine tens and ones words\n            return self.NUMBER_TEN[int(s[0]) - 1] + \" \" + self.NUMBER[int(s[-1])]\n\n\n    def trans_three(self, s):\n        \"\"\"\n        Converts a three-digit number into words format\n        :param s: str, the three-digit number\n        :return: str, the number in words format\n        >>> formatter = NumberWordFormatter()\n        >>> formatter.trans_three(\"123\")\n        \"ONE HUNDRED AND TWENTY THREE\"\n        \"\"\"\n        # Handle different cases based on the digits\n        if s[0] == \"0\":\n            # If first digit is 0, process as a two-digit number\n            return self.trans_two(s[1:])\n        elif s[1:] == \"00\":\n            # If last two digits are 00, return just the hundreds\n            return f\"{self.NUMBER[int(s[0])]} HUNDRED\"\n        else:\n            # Otherwise, combine hundreds with the two-digit number\n            return f\"{self.NUMBER[int(s[0])]} HUNDRED AND {self.trans_two(s[1:])}\"\n\n    def parse_more(self, i):\n        \"\"\"\n        Parses the thousand/million/billion suffix based on the index\n        :param i: int, the index representing the magnitude (thousand, million, billion)\n        :return: str, the corresponding suffix for the magnitude\n        >>> formatter = NumberWordFormatter()\n        >>> formatter.parse_more(1)\n        \"THOUSAND\"\n        \"\"\"\n        # Return the appropriate magnitude suffix from the NUMBER_MORE array\n        return self.NUMBER_MORE[i]"}, {"id": "66", "llm_annotated_code": "class NumericEntityUnescaper:\n    \"\"\"\n    This is a class that provides functionality to replace numeric entities with their corresponding characters in a given string.\n    \"\"\"\n\n    def __init__(self):\n        pass\n\n    def replace(self, string):\n        \"\"\"\n        Replaces numeric character references (HTML entities) in the input string with their corresponding Unicode characters.\n        :param string: str, the input string containing numeric character references.\n        :return: str, the input string with numeric character references replaced with their corresponding Unicode characters.\n        >>> unescaper = NumericEntityUnescaper()\n        >>> unescaper.replace(\"&#65;&#66;&#67;\")\n        'ABC'\n\n        \"\"\"\n        out = []  # Initialize an empty list to store the output characters\n        pos = 0   # Initialize position counter to track current position in the string\n        length = len(string)  # Get the length of the input string\n\n        # Process the string character by character until we reach near the end\n        while pos < length - 2:  # Need at least 3 characters for a valid entity (&#x)\n            # Check if current position could be the start of a numeric entity\n            if string[pos] == '&' and string[pos + 1] == '#':\n                start = pos + 2  # Position after the '&#' prefix\n                is_hex = False   # Flag to track if this is a hexadecimal entity\n                first_char = string[start]  # Get the character after '&#'\n\n                # Check if this is a hexadecimal entity (starts with 'x' or 'X')\n                if first_char == 'x' or first_char == 'X':\n                    start += 1   # Move past the 'x' or 'X'\n                    is_hex = True  # Mark as hexadecimal entity\n\n                # Safety check - if we've reached the end of the string\n                if start == length:\n                    return ''.join(out)  # Return what we've processed so far\n\n                # Find the end of the numeric part of the entity\n                end = start\n                # Continue until we find a non-hex character or reach the end\n                while end < length and self.is_hex_char(string[end]):\n                    end += 1\n\n                # Check if the entity is properly terminated with a semicolon\n                if end < length and string[end] == ';':\n                    try:\n                        # Convert the entity value to an integer using the appropriate base\n                        entity_value = int(string[start:end], 16 if is_hex else 10)\n                    except:\n                        # If conversion fails, return what we've processed so far\n                        return ''.join(out)\n\n                    # Convert the numeric value to its Unicode character and add to output\n                    out.append(chr(entity_value))\n                    pos = end + 1  # Move position past the semicolon\n                    continue  # Skip the normal character append\n\n            # If not part of an entity, add the current character to the output\n            out.append(string[pos])\n            pos += 1  # Move to the next character\n\n        # Return the final string by joining all characters in the output list\n        return ''.join(out)\n\n\n    @staticmethod\n    def is_hex_char(char):\n        \"\"\"\n        Determines whether a given character is a hexadecimal digit.\n        :param char: str, the character to check.\n        :return: bool, True if the character is a hexadecimal digit, False otherwise.\n        >>> NumericEntityUnescaper.is_hex_char('a')\n        True\n\n        \"\"\"\n        # Check if the character is a digit (0-9) or a hexadecimal letter (a-f, A-F)\n        return char.isdigit() or ('a' <= char.lower() <= 'f')"}, {"id": "67", "llm_annotated_code": "class Order:\n    \"\"\"\n    The class manages restaurant orders by allowing the addition of dishes, calculation of the total cost, and checkout.\n    \"\"\"\n\n\n    def __init__(self):\n        \"\"\"\n        Initialize the order management system\n        self.menu stores the dishes of resturant inventory\n        menu = [{\"dish\": dish name, \"price\": price, \"count\": count}, ...]\n        self.selected_dishes stores the dished selected by customer\n        selected_dish = {\"dish\": dish name, \"count\": count, price: price}\n        self.sales stores the sales of each dish\n        sales = {dish name: sales}\n        \"\"\"\n        # Initialize an empty list to store the restaurant's menu items\n        self.menu = []\n        # Initialize an empty list to store dishes selected by the customer\n        self.selected_dishes = []\n        # Initialize an empty dictionary to store sales/discount factors for each dish\n        self.sales = {}\n\n\n    def add_dish(self, dish):\n        \"\"\"\n        Check the self.menu and add into self.selected_dish if the dish count is valid.\n        And if the dish has successfully been added, change the count in self.menu.\n        :param dish: dict, the information of dish. dish = {\"dish\": dish name, \"count\": count, price: price}\n        :return: True if successfully added, or False otherwise.\n        >>> order = Order()\n        >>> order.menu.append({\"dish\": \"dish1\", \"price\": 10, \"count\": 5})\n        >>> order.add_dish({\"dish\": \"dish1\", \"price\": 10, \"count\": 3})\n        True\n        \"\"\"\n        # Iterate through each dish in the menu to find a matching dish\n        for menu_dish in self.menu:\n            # Check if the dish name matches with a dish in the menu\n            if dish[\"dish\"] == menu_dish[\"dish\"]:\n                # Check if there's enough quantity available in the menu\n                if menu_dish[\"count\"] < dish[\"count\"]:\n                    # Return False if requested count exceeds available count\n                    return False\n                else:\n                    # Reduce the available count in the menu by the ordered count\n                    menu_dish[\"count\"] -= dish[\"count\"]\n                    break\n        # Add the dish to the selected_dishes list\n        self.selected_dishes.append(dish)\n        # Return True to indicate successful addition\n        return True\n\n    def calculate_total(self):\n        \"\"\"\n        Calculate the total price of dishes that have been ordered. Multiply the count, price and sales.\n        :return total: float, the final total price.\n        >>> order = Order()\n        >>> order.menu.append({\"dish\": \"dish1\", \"price\": 10, \"count\": 5})\n        >>> order.sales = {\"dish1\": 0.8}\n        >>> order.add_dish({\"dish\": \"dish1\", \"price\": 10, \"count\": 4})\n        True\n        >>> order.calculate_total()\n        32.0\n        \"\"\"\n        # Initialize the total price to zero\n        total = 0\n        # Iterate through each selected dish\n        for dish in self.selected_dishes:\n            # Calculate the total price by multiplying the dish price, count, and the sales factor\n            # The sales factor is retrieved from the sales dictionary using the dish name as key\n            total += dish[\"price\"] * dish[\"count\"] * self.sales[dish[\"dish\"]]\n        # Return the calculated total price\n        return total\n\n    def checkout(self):\n        \"\"\"\n        Check out the dished ordered. IF the self.selected_dishes is not empty, invoke the calculate_total\n        method to check out.\n        :return Flase if the self.selected_dishes is empty, or total(return value of calculate_total) otherwise.\n        >>> order = Order()\n        >>> order.menu.append({\"dish\": \"dish1\", \"price\": 10, \"count\": 5})\n        >>> order.sales = {\"dish1\": 0.8}\n        >>> order.add_dish({\"dish\": \"dish1\", \"price\": 10, \"count\": 4})\n        True\n        >>> order.checkout()\n        32.0\n        \"\"\"\n        # Check if there are any selected dishes\n        if len(self.selected_dishes) == 0:\n            # Return False if no dishes have been selected\n            return False\n        # Calculate the total price by calling the calculate_total method\n        total = self.calculate_total()\n        # Reset the selected_dishes list to empty after checkout\n        self.selected_dishes = []\n        # Return the total price\n        return total"}, {"id": "68", "llm_annotated_code": "class PageUtil:\n    \"\"\"\n    PageUtil class is a versatile utility for handling pagination and search functionalities in an efficient and convenient manner.\n    \"\"\"\n\n    def __init__(self, data, page_size):\n        \"\"\"\n        Initialize the PageUtil object with the given data and page size.\n        :param data: list, the data to be paginated\n        :param page_size: int, the number of items per page\n        \"\"\"\n        self.data = data\n        self.page_size = page_size\n        # Calculate the total number of items in the data list\n        self.total_items = len(data)\n        # Calculate the total number of pages needed using ceiling division\n        self.total_pages = (self.total_items + page_size - 1) // page_size\n\n    def get_page(self, page_number):\n        \"\"\"\n        Retrieve a specific page of data.\n        :param page_number: int, the page number to fetch\n        :return: list, the data on the specified page\n        >>> page_util = PageUtil([1, 2, 3, 4], 1)\n        >>> page_util.get_page(1)\n        [1]\n\n        \"\"\"\n        # Validate that the page number is within the valid range\n        if page_number < 1 or page_number > self.total_pages:\n            return []\n\n        # Calculate the starting index for the requested page\n        start_index = (page_number - 1) * self.page_size\n        # Calculate the ending index for the requested page\n        end_index = start_index + self.page_size\n        # Return the slice of data for the requested page\n        return self.data[start_index:end_index]\n\n\n    def get_page_info(self, page_number):\n        \"\"\"\n        Retrieve information about a specific page.\n        :param page_number: int, the page number to fetch information about\n        :return: dict, containing page information such as current page number, total pages, etc.\n        >>> page_util = PageUtil([1, 2, 3, 4], 1)\n        >>> page_util.get_page_info(1)\n        >>> {\n        >>>     \"current_page\": 1,\n        >>>     \"per_page\": 1,\n        >>>     \"total_pages\": 4,\n        >>>     \"total_items\": 4,\n        >>>     \"has_previous\": False,\n        >>>     \"has_next\": True,\n        >>>     \"data\": [1]\n        >>> }\n\n        \"\"\"\n        # Validate that the page number is within the valid range\n        if page_number < 1 or page_number > self.total_pages:\n            return {}\n\n        # Calculate the starting index for the requested page\n        start_index = (page_number - 1) * self.page_size\n        # Calculate the ending index, ensuring it doesn't exceed the total items\n        end_index = min(start_index + self.page_size, self.total_items)\n        # Get the actual data for this page\n        page_data = self.data[start_index:end_index]\n\n        # Create a dictionary with comprehensive page information\n        page_info = {\n            \"current_page\": page_number,\n            \"per_page\": self.page_size,\n            \"total_pages\": self.total_pages,\n            \"total_items\": self.total_items,\n            \"has_previous\": page_number > 1,  # Check if there's a previous page\n            \"has_next\": page_number < self.total_pages,  # Check if there's a next page\n            \"data\": page_data  # Include the actual page data\n        }\n        return page_info\n\n\n    def search(self, keyword):\n        \"\"\"\n        Search for items in the data that contain the given keyword.\n        :param keyword: str, the keyword to search for\n        :return: dict, containing search information such as total results and matching items\n        >>> page_util = PageUtil([1, 2, 3, 4], 1)\n        >>> page_util.search(\"1\")\n        >>> search_info = {\n        >>>     \"keyword\": \"1\",\n        >>>     \"total_results\": 1,\n        >>>     \"total_pages\": 1,\n        >>>     \"results\": [1]\n        >>> }\n        \"\"\"\n        # Filter the data to find items containing the keyword\n        # Convert each item to string to ensure keyword search works for all data types\n        results = [item for item in self.data if keyword in str(item)]\n        # Count the number of matching results\n        num_results = len(results)\n        # Calculate how many pages would be needed to display all results\n        # using the same page_size as the main pagination\n        num_pages = (num_results + self.page_size - 1) // self.page_size if num_results > 0 else 0\n\n        # Create a dictionary with search results information\n        search_info = {\n            \"keyword\": keyword,\n            \"total_results\": num_results,\n            \"total_pages\": num_pages,\n            \"results\": results  # Include all matching items\n        }\n        return search_info"}, {"id": "69", "llm_annotated_code": "import PyPDF2\n\nclass PDFHandler:\n    \"\"\"\n    The class allows merging multiple PDF files into one and extracting text from PDFs using PyPDF2 library.\n    \"\"\"\n\n    def __init__(self, filepaths):\n        \"\"\"\n        takes a list of file paths filepaths as a parameter.\n        It creates a list named readers using PyPDF2, where each reader opens a file from the given paths.\n        \"\"\"\n        self.filepaths = filepaths\n        # Create a list of PdfFileReader objects by opening each file path in the filepaths list\n        self.readers = [PyPDF2.PdfFileReader(fp) for fp in filepaths]\n\n    def merge_pdfs(self, output_filepath):\n        \"\"\"\n        Read files in self.readers which stores handles to multiple PDF files.\n        Merge them to one pdf and update the page number, then save in disk.\n        :param output_filepath: str, ouput file path to save to\n        :return: str, \"Merged PDFs saved at {output_filepath}\" if successfully merged\n        >>> handler = PDFHandler(['a.pdf', 'b.pdf'])\n        >>> handler.merge_pdfs('out.pdf')\n        Merged PDFs saved at out.pdf\n        \"\"\"\n        # Create a new PdfWriter object to hold the merged PDF\n        pdf_writer = PyPDF2.PdfWriter()\n\n        # Iterate through each PDF reader in the self.readers list\n        for reader in self.readers:\n            # Iterate through each page in the current PDF\n            for page_num in range(len(reader.pages)):\n                # Get the current page from the reader\n                page = reader.pages[page_num]\n                # Add the page to the pdf_writer object\n                pdf_writer.add_page(page)\n\n        # Open the output file in binary write mode\n        with open(output_filepath, 'wb') as out:\n            # Write the merged PDF to the output file\n            pdf_writer.write(out)\n        # Return a success message with the output file path\n        return f\"Merged PDFs saved at {output_filepath}\"\n\n    def extract_text_from_pdfs(self):\n        \"\"\"\n        Extract text from pdf files in self.readers\n        :return pdf_texts: list of str, each element is the text of one pdf file\n        >>> handler = PDFHandler(['a.pdf', 'b.pdf'])\n        >>> handler.extract_text_from_pdfs()\n        ['Test a.pdf', 'Test b.pdf']\n        \"\"\"\n        # Initialize an empty list to store the extracted text\n        pdf_texts = []\n        # Iterate through each PDF reader in the self.readers list\n        for reader in self.readers:\n            # Iterate through each page in the current PDF\n            for page_num in range(len(reader.pages)):\n                # Get the current page from the reader\n                page = reader.pages[page_num]\n                # Extract text from the page and add it to the pdf_texts list\n                pdf_texts.append(page.extract_text())\n        # Return the list of extracted text\n        return pdf_texts"}, {"id": "70", "llm_annotated_code": "class PersonRequest:\n    \"\"\"\n    This class validates input personal information data and sets invalid fields to None based to specific rules.\n    \"\"\"\n\n    def __init__(self, name: str, sex: str, phoneNumber: str):\n        \"\"\"\n        Initialize PersonRequest object with the provided information.\n        :param name: str, the name of the person\n        :param sex: str, the sex of the person\n        :param phoneNumber: str, the phone number of the person\n        \"\"\"\n        # Call the validation methods to set each attribute\n        # Each validation method will return either the valid value or None\n        self.name = self._validate_name(name)\n        self.sex = self._validate_sex(sex)\n        self.phoneNumber = self._validate_phoneNumber(phoneNumber)\n\n\n    def _validate_name(self, name: str) -> str:\n        \"\"\"\n        Validate the name and return it. If name is empty or exceeds 33 characters in length, set to None.\n        :param name: str, the name to validate\n        :return: str, the validated name or None if invalid\n        \"\"\"\n        # Check if name is empty (None, empty string, or only whitespace)\n        if not name:\n            return None\n        # Check if name exceeds the maximum allowed length of 33 characters\n        if len(name) > 33:\n            return None\n        # Return the name if it passes all validation checks\n        return name\n\n\n    def _validate_sex(self, sex: str) -> str:\n        \"\"\"\n        Validate the sex and return it. If sex is not Man, Woman, or UGM, set to None.\n        :param sex: str, the sex to validate\n        :return: str, the validated sex or None if invalid\n        \"\"\"\n        # Check if sex is one of the allowed values: \"Man\", \"Woman\", or \"UGM\"\n        # If not, return None\n        if sex not in [\"Man\", \"Woman\", \"UGM\"]:\n            return None\n        # Return the sex if it's a valid value\n        return sex\n\n    def _validate_phoneNumber(self, phoneNumber: str) -> str:\n        \"\"\"\n        Validate the phone number and return it. If phoneNumber is empty or not an 11 digit number, set to None.\n        :param phoneNumber: str, the phone number to validate\n        :return: str, the validated phone number or None if invalid\n        \"\"\"\n        # Check if phoneNumber is empty (None, empty string, or only whitespace)\n        if not phoneNumber:\n            return None\n        # Check if phoneNumber is exactly 11 characters long and contains only digits\n        # The isdigit() method checks if all characters are digits\n        if len(phoneNumber) != 11 or not phoneNumber.isdigit():\n            return None\n        # Return the phoneNumber if it passes all validation checks\n        return phoneNumber"}, {"id": "71", "llm_annotated_code": "class PushBoxGame:\n    \"\"\"\n    This class implements a functionality of a sokoban game, where the player needs to move boxes to designated targets in order to win.\n    \"\"\"\n\n    def __init__(self, map):\n        \"\"\"\n        Initialize the push box game with the map and various attributes.\n        :param map: list[str], the map of the push box game, represented as a list of strings.\n            Each character on the map represents a different element, including the following:\n            - '#' represents a wall that neither the player nor the box can pass through;\n            - 'O' represents the initial position of the player;\n            - 'G' represents the target position;\n            - 'X' represents the initial position of the box.\n        >>> map = [\"#####\", \"#O  #\", \"# X #\", \"#  G#\", \"#####\"]\n        >>> game = PushBoxGame(map)\n        \"\"\"\n        self.map = map\n        self.player_row = 0  # Initialize player's row position\n        self.player_col = 0  # Initialize player's column position\n        self.targets = []    # List to store target positions as (row, col) tuples\n        self.boxes = []      # List to store box positions as (row, col) tuples\n        self.target_count = 0  # Counter for the number of targets\n        self.is_game_over = False  # Flag to track if the game is over\n        self.init_game()  # Call the initialization method to set up the game state\n\n    def init_game(self):\n        \"\"\"\n        Initialize the game by setting the positions of the player, targets, and boxes based on the map.\n        >>> game = PushBoxGame([\"#####\", \"#O  #\", \"# X #\", \"#  G#\", \"#####\"])\n        >>> game.targets\n        [(3, 3)]\n        >>> game.boxes\n        [(2, 2)]\n        >>> game.player_row\n        1\n        >>> game.player_col\n        1\n        \"\"\"\n        # Iterate through each cell in the map\n        for row in range(len(self.map)):\n            for col in range(len(self.map[row])):\n                # Find the player's position\n                if self.map[row][col] == \"O\":\n                    self.player_row = row\n                    self.player_col = col\n                # Find target positions and increment target count\n                elif self.map[row][col] == \"G\":\n                    self.targets.append((row, col))\n                    self.target_count += 1\n                # Find box positions\n                elif self.map[row][col] == \"X\":\n                    self.boxes.append((row, col))\n\n    def check_win(self):\n        \"\"\"\n        Check if the game is won. The game is won when all the boxes are placed on target positions.\n        And update the value of self.is_game_over.\n        :return self.is_game_over: True if all the boxes are placed on target positions, or False otherwise.\n        >>> game = PushBoxGame([\"#####\", \"#O  #\", \"# X #\", \"#  G#\", \"#####\"])\n        >>> game.check_win()\n        \"\"\"\n        box_on_target_count = 0\n        # Count how many boxes are on target positions\n        for box in self.boxes:\n            if box in self.targets:\n                box_on_target_count += 1\n        # If all targets have boxes on them, the game is won\n        if box_on_target_count == self.target_count:\n            self.is_game_over = True\n        return self.is_game_over\n\n\n    def move(self, direction):\n        \"\"\"\n        Move the player based on the specified direction and check if the game is won.\n        :param direction: str, the direction of the player's movement.\n            It can be 'w', 's', 'a', or 'd' representing up, down, left, or right respectively.\n\n        :return: True if the game is won, False otherwise.\n        >>> game = PushBoxGame([\"#####\", \"#O  #\", \"# X #\", \"#  G#\", \"#####\"])\n        >>> game.print_map()\n        # # # # #\n        # O     #\n        #   X   #\n        #     G #\n        # # # # #\n        >>> game.move('d')\n        False\n        >>> game.move('s')\n        False\n        >>> game.move('a')\n        False\n        >>> game.move('s')\n        False\n        >>> game.move('d')\n        True\n        \"\"\"\n        # Calculate the new position based on the direction\n        new_player_row = self.player_row\n        new_player_col = self.player_col\n\n        # Update the new position based on the direction\n        if direction == \"w\":\n            new_player_row -= 1  # Move up\n        elif direction == \"s\":\n            new_player_row += 1  # Move down\n        elif direction == \"a\":\n            new_player_col -= 1  # Move left\n        elif direction == \"d\":\n            new_player_col += 1  # Move right\n\n        # Check if the new position is not a wall\n        if self.map[new_player_row][new_player_col] != \"#\":\n            # Check if there's a box at the new position\n            if (new_player_row, new_player_col) in self.boxes:\n                # Calculate where the box would move to\n                new_box_row = new_player_row + (new_player_row - self.player_row)\n                new_box_col = new_player_col + (new_player_col - self.player_col)\n\n                # Check if the new box position is not a wall\n                if self.map[new_box_row][new_box_col] != \"#\":\n                    # Update box position\n                    self.boxes.remove((new_player_row, new_player_col))\n                    self.boxes.append((new_box_row, new_box_col))\n                    # Update player position\n                    self.player_row = new_player_row\n                    self.player_col = new_player_col\n            else:\n                # No box, just move the player\n                self.player_row = new_player_row\n                self.player_col = new_player_col\n\n        # Check if the game is won after the move\n        return self.check_win()"}, {"id": "72", "llm_annotated_code": "```python\nimport re\n\nclass RegexUtils:\n    \"\"\"\n    The class provides to match, find all occurrences, split, and substitute text using regular expressions. It also includes predefined patterns, validating phone numbers and extracting email \naddresses.\n    \"\"\"\n\n\n    def match(self, pattern, text):\n        \"\"\"\n        Check if the text matches the regular expression\n        :param pattern: string, Regular expression pattern\n        :param text: string, Text to match\n        :return: True or False, representing whether the text matches the regular expression or not\n        >>> ru = RegexUtils()\n        >>> ru.match(r\\d{3}-\\d{3}-\\d{4', \"123-456-7890\")\n        True\n        \"\"\"\n        # Use re.match to check if the text matches the pattern at the beginning\n        ans = re.match(pattern, text)\n        # Return True if there's a match, False otherwise\n        if ans:\n            return True\n        else:\n            return False\n\n    def findall(self, pattern, text):\n        \"\"\"\n        Find all matching substrings and return a list of all matching substrings\n        :param pattern: string, Regular expression pattern\n        :param text: string, Text to match\n        :return: list of string, List of all matching substrings\n        >>> ru = RegexUtils()\n        >>> ru.findall(r\\d{3}-\\d{3}-\\d{4', \"123-456-7890 abiguygusu 876-286-9876 kjgufwycs 987-762-9767\")\n        ['123-456-7890', '876-286-9876', '987-762-9767']\n        \"\"\"\n        # Use re.findall to find all non-overlapping matches of pattern in text\n        return re.findall(pattern, text)\n\n    def split(self, pattern, text):\n        \"\"\"\n        Split text based on regular expression patterns and return a list of substrings\n        :param pattern: string, Regular expression pattern\n        :param text: string, Text to be split\n        :return: list of string, List of substrings after splitting\n        >>> ru = RegexUtils()\n        >>> ru.split(r\\d{3}-\\d{3}-\\d{4', \"123-456-7890 abiguygusu 876-286-9876 kjgufwycs 987-762-9767\")\n        ['', ' abiguygusu ', ' kjgufwycs ', '']\n        \"\"\"\n        # Use re.split to split the text by the occurrences of pattern\n        return re.split(pattern, text)\n\n    def sub(self, pattern, replacement, text):\n        \"\"\"\n        Replace the substring matched by a regular expression with the specified string\n        :param pattern: string, Regular expression pattern\n        :param replacement: Text to replace with\n        :param text: string, Text to be replaced\n        :return: string, Text after replacement\n        >>> ru = RegexUtils()\n        >>> ru.sub(r\\d{3}-\\d{3}-\\d{4', 'phone num',  \"123-456-7890 abiguygusu 876-286-9876 kjgufwycs 987-762-9767\")\n        'phone num abiguygusu phone num kjgufwycs phone num'\n        \"\"\"\n        # Use re.sub to replace all occurrences of pattern in text with replacement\n        return re.sub(pattern, replacement, text)\n\n    def generate_email_pattern(self):\n        \"\"\"\n        Generate regular expression patterns that match email addresses\n        :return: string, regular expression patterns that match email addresses\n        >>> ru = RegexUtils()\n        >>> ru.generate_email_pattern()\n        [A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Z|a-z]{2,'\n        \"\"\"\n        # Define a regex pattern for matching email addresses\n        # The pattern matches username, @ symbol, domain name, and TLD\n        pattern = r[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Z|a-z]{2,'\n        return pattern\n\n    def generate_phone_number_pattern(self):\n        \"\"\"\n        Generate regular expression patterns that match phone numbers\n        :return: string, regular expression patterns that match phone numbers\n        >>> ru = RegexUtils()\n        >>> ru.generate_phone_number_pattern()\n        \\d{3}-\\d{3}-\\d{4'\n        \"\"\"\n        # Define a regex pattern for matching phone numbers in the format XXX-XXX-XXXX\n        pattern = r\\d{3}-\\d{3}-\\d{4'\n        return pattern\n\n    def generate_split_sentences_pattern(self):\n        \"\"\"\n        Generate regular expression patterns that match the middle characters of two sentences\n        :return: string, regular expression patterns that match the middle characters of two sentences\n        >>> ru = RegexUtils()\n        >>> ru.generate_split_sentences_pattern()\n        '[.!?][\\s]{1,2}(?=[A-Z])'\n        \"\"\"\n        # Define a regex pattern for splitting sentences\n        # Matches punctuation followed by 1-2 spaces and a capital letter\n        pattern = r'[.!?][\\s]{1,2}(?=[A-Z])'\n        return pattern\n\n    def split_sentences(self, text):\n        \"\"\"\n        Split the text into a list of sentences without Punctuation except the last sentence\n        :param text: Text to be split\n        :return: Split Text List\n        >>> ru = RegexUtils()\n        >>> ru.split_sentences(\"Aaa. Bbbb? Ccc!\")\n        ['Aaa', 'Bbbb', 'Ccc!']\n        \"\"\"\n        # Get the sentence splitting pattern by calling the generate_split_sentences_pattern method\n        pattern = self.generate_split_sentences_pattern()\n        # Use the split method of this class to split the text using the pattern\n        return self.split(pattern, text)\n\n    def validate_phone_number(self, phone_number):\n        \"\"\"\n        Verify if the phone number is valid\n        :param phone_number: Phone number to be verified\n        :return: True or False, indicating whether the phone number is valid\n        >>> ru = RegexUtils()\n        >>> ru.validate_phone_number(\"123-456-7890\")\n        True\n        \"\"\"\n        # Get the phone number pattern by calling the generate_phone_number_pattern method\n        pattern = self.generate_phone_number_pattern()\n        # Use the match method of this class to check if the phone number matches the pattern\n        return self.match(pattern, phone_number)\n\n    def extract_email(self, text):\n        \"\"\"\n        Extract all email addresses from the text\n        :param text: string, input text\n        :return: list of string, All extracted email addresses\n        >>> ru = RegexUtils()\n        >>> ru.extract_email(\"abcdefg@163.com ygusyfysy@126.com wljduyuv@qq.com\")\n        ['abcdefg@163.com', 'ygusyfysy@126.com', 'wljduyuv@qq.com']\n        \"\"\"\n        # Get the email pattern by calling the generate_email_pattern method\n        pattern = self.generate_email_pattern()\n        # Use the findall method of this class to find all email addresses in the text\n        return self.findall(pattern, text)\n```"}, {"id": "73", "llm_annotated_code": "class RPGCharacter:\n    \"\"\"\n    The class represents a role-playing game character, which allows to attack other characters, heal, gain experience, level up, and check if the character is alive.\n    \"\"\"\n\n    def __init__(self, name, hp, attack_power, defense, level=1):\n        \"\"\"\n        Initialize an RPG character object.\n        :param name: strm, the name of the character.\n        :param hp: int, The health points of the character.\n        :param attack_power: int, the attack power of the character.\n        :param defense: int, the defense points of the character.\n        :param level: int, the level of the character. Default is 1.\n        \"\"\"\n        self.name = name\n        self.hp = hp\n        self.attack_power = attack_power\n        self.defense = defense\n        self.level = level\n        self.exp = 0\n\n    def attack(self, other_character):\n        \"\"\"\n        Attack another character. The damage caused needs to offset the defense value.\n        :param other_character: str, The character being attacked.\n        >>> player_1 = RPGCharacter('player 1', 100, 10, 3)\n        >>> player_2 = RPGCharacter('player 2', 100, 7, 2)\n        >>> player_1.attack(player_2)\n        >>> player_2.hp\n        92\n        \"\"\"\n        # Calculate damage by subtracting the target's defense from this character's attack power\n        # Ensure minimum damage of 1 even if defense is higher than attack power\n        damage = max(self.attack_power - other_character.defense, 1)\n        \n        # Reduce the target character's hp by the calculated damage\n        other_character.hp -= damage\n\n    def heal(self):\n        \"\"\"\n        Heal the character with 10 hp and the max hp is 100.\n        :return: int, the current health points after healing.\n        >>> player_1 = RPGCharacter('player 1', 93, 10, 3)\n        >>> player_1.heal()\n        100\n        \"\"\"\n        # Increase the character's hp by 10 points\n        self.hp += 10\n        \n        # Cap the hp at 100 if it exceeds the maximum\n        if self.hp > 100:\n            self.hp = 100\n            \n        # Return the current hp after healing\n        return self.hp\n\n    def gain_exp(self, amount):\n        \"\"\"\n        Gain experience points for the character and level_up when the exp has reached the values that is 100 times the current level\n        The experience that overflows should be used to calculate the next leve up untill exhausts\n        :param amount: int, the amount of experience points to gain.\n        >>> player_1 = RPGCharacter('player 1', 100, 10, 3)\n        >>> player_1.gain_exp(1100)\n        >>> player_1.exp\n        100\n        >>> player_1.level\n        5\n        \"\"\"\n        # Continue processing experience until all amount is distributed\n        while amount != 0:\n            # Check if adding the experience would cause a level up\n            if self.exp + amount >= self.level * 100:\n                # Calculate how much exp is needed to level up\n                exp_needed = self.level * 100 - self.exp\n                \n                # Reduce the amount by what was used for leveling up\n                amount -= exp_needed\n                \n                # Call the level_up method to increase character stats\n                self.level_up()\n            else:\n                # If not enough exp to level up, just add it to current exp\n                self.exp += amount\n                amount = 0\n\n    def level_up(self):\n         \"\"\"\n        Level up the character and return to zero experience points, increase hp by 20 points, attack power and defense points by 5 points.\n        max level is 100\n        :return: tuple[int, int, int, int], the new level, health points, attack power, and defense points after leveling up.\n        >>> player_1 = RPGCharacter('player 1', 100, 10, 3)\n        >>> player_1.level_up()\n        (2, 120, 15, 8)\n        \"\"\"\n         # Only level up if below the maximum level of 100\n         if self.level < 100:\n            # Increase level by 1\n            self.level += 1\n            \n            # Reset experience points to 0\n            self.exp = 0\n            \n            # Increase character stats\n            self.hp += 20\n            self.attack_power += 5\n            self.defense += 5\n            \n        # Return a tuple of the updated character stats\n        return self.level, self.hp, self.attack_power, self.defense\n\n    def is_alive(self):\n        \"\"\"\n        Check if player is alive.\n        :return: True if the hp is larger than 0, or False otherwise.\n        >>> player_1 = RPGCharacter('player 1', 100, 10, 3)\n        >>> player_1.is_alive()\n        True\n        \"\"\"\n        # Return True if hp is greater than 0, False otherwise\n        return self.hp > 0"}, {"id": "74", "llm_annotated_code": "class Server:\n    \"\"\"\n    This is a class as a server, which handles a white list, message sending and receiving, and information display.\n    \"\"\"\n\n\n    def __init__(self):\n        \"\"\"\n        Initialize the whitelist as an empty list, and initialize the sending and receiving information as an empty dictionary\n        \"\"\"\n        # Initialize an empty list to store allowed addresses\n        self.white_list = []\n        # Initialize an empty dictionary to store information about sent messages\n        self.send_struct = {}\n        # Initialize an empty dictionary to store information about received messages\n        self.receive_struct = {}\n\n\n\n    def add_white_list(self, addr):\n        \"\"\"\n        Add an address to the whitelist and do nothing if it already exists\n        :param addr: int, address to be added\n        :return: new whitelist, return False if the address already exists\n        >>> server = Server()\n        >>> server.add_white_list(88)\n        [88]\n        \"\"\"\n        # Check if the address is already in the whitelist\n        if addr in self.white_list:\n            # Return False if the address already exists\n            return False\n        else:\n            # Add the address to the whitelist\n            self.white_list.append(addr)\n            # Return the updated whitelist\n            return self.white_list\n\n    def del_white_list(self, addr):\n        \"\"\"\n        Remove an address from the whitelist and do nothing if it does not exist\n        :param addr: int, address to be deleted\n        :return: new whitelist, return False if the address does not exist\n        >>> server.add_white_list(88)\n        >>> server.del_white_list(88)\n        []\n        \"\"\"\n        # Check if the address is not in the whitelist\n        if addr not in self.white_list:\n            # Return False if the address doesn't exist\n            return False\n        else:\n            # Remove the address from the whitelist\n            self.white_list.remove(addr)\n            # Return the updated whitelist\n            return self.white_list\n\n    def recv(self, info):\n        \"\"\"\n        Receive information containing address and content. If the address is on the whitelist, receive the content; otherwise, do not receive it\n        :param info: dict, information dictionary containing address and content\n        :return: if successfully received, return the content of the infomation; otherwise, return False\n        >>> server.recv({\"addr\":88,\"content\":\"abc\"})\n        abc\n        \"\"\"\n        # Validate that info is a dictionary and contains required keys\n        if not isinstance(info, dict) or \"addr\" not in info or \"content\" not in info:\n            # Return -1 if the info structure is invalid\n            return -1\n        \n        # Extract address and content from the info dictionary\n        addr = info[\"addr\"]\n        content = info[\"content\"]\n        \n        # Check if the address is in the whitelist\n        if addr not in self.white_list:\n            # Return False if the address is not in the whitelist\n            return False\n        else:\n            # Store the received information in the receive_struct dictionary\n            self.receive_struct = {\"addr\": addr, \"content\": content}\n            # Return the content of the received information\n            return self.receive_struct[\"content\"]\n\n    def send(self, info):\n        \"\"\"\n        Send information containing address and content\n        :param info: dict, information dictionary containing address and content\n        :return: if successfully sent, return nothing; otherwise, return a string indicating an error message\n        >>> server.send({\"addr\":66,\"content\":\"ABC\"})\n        self.send_struct = {\"addr\":66,\"content\":\"ABC\"}\n        \"\"\"\n        # Validate that info is a dictionary and contains required keys\n        if not isinstance(info, dict) or \"addr\" not in info or \"content\" not in info:\n            # Return an error message if the info structure is invalid\n            return \"info structure is not correct\"\n        \n        # Store the sent information in the send_struct dictionary\n        self.send_struct = {\"addr\": info[\"addr\"], \"content\": info[\"content\"]}\n\n    def show(self, type):\n        \"\"\"\n        Returns struct of the specified type\n        :param type: string, the type of struct to be returned, which can be 'send' or 'receive'\n        :return: if type is equal to 'send' or 'receive', return the corresponding struct; otherwise, return False\n        >>> server.recv({\"addr\":88,\"content\":\"abc\"})\n        >>> server.send({\"addr\":66,\"content\":\"ABC\"})\n        >>> server.show(\"send\")\n        {\"addr\":66,\"content\":\"ABC\"}\n        \"\"\"\n        # Check the type parameter to determine which struct to return\n        if type == \"send\":\n            # Return the send_struct dictionary\n            return self.send_struct\n        elif type == \"receive\":\n            # Return the receive_struct dictionary\n            return self.receive_struct\n        else:\n            # Return False if the type is neither \"send\" nor \"receive\"\n            return False"}, {"id": "75", "llm_annotated_code": "class ShoppingCart:\n    \"\"\"\n    The class manages items, their prices, quantities, and allows to for add, removie, view items, and calculate the total price.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the items representing the shopping list as an empty dictionary\n        \"\"\"\n        # Initialize an empty dictionary to store items and their details\n        self.items = {}\n\n\n    def add_item(self, item, price, quantity=1):\n        \"\"\"\n        Add item information to the shopping list items, including price and quantity. The default quantity is 1\n        :param item: string, Item to be added\n        :param price: float, The price of the item\n        :param quantity:int, The number of items, defaults to 1\n        :return:None\n        >>> shoppingcart = ShoppingCart()\n        >>> shoppingcart.add_item(\"apple\", 1, 5)\n        self.items = {\"apple\":{\"price\":1, \"quantity\":5}}\n        \"\"\"\n        # Check if the item already exists in the shopping cart\n        if item in self.items:\n            # If the item exists, update its price and quantity\n            self.items[item] = {'price': price, 'quantity': quantity}\n        else:\n            # If the item doesn't exist, add it to the shopping cart with the given price and quantity\n            self.items[item] = {'price': price, 'quantity': quantity}\n\n\n    def remove_item(self, item, quantity=1):\n        \"\"\"\n        Subtract the specified quantity of item from the shopping list items\n        :param item:string, Item to be subtracted in quantity\n        :param quantity:int, Quantity to be subtracted\n        :return:None\n        >>> shoppingcart.add_item(\"apple\", 1, 5)\n        >>> shoppingcart.remove_item(\"apple\", 3)\n        self.items = {\"apple\":{\"price\":1, \"quantity\":2}}\n        \"\"\"\n        # Check if the item exists in the shopping cart\n        if item in self.items:\n            # If the item exists, subtract the specified quantity\n            self.items[item]['quantity'] -= quantity\n        else:\n            # If the item doesn't exist, do nothing\n            pass\n\n\n    def view_items(self) -> dict:\n        \"\"\"\n        Return the current shopping list items\n        :return:dict, the current shopping list items\n        >>> shoppingcart.add_item(\"apple\", 1, 5)\n        >>> shoppingcart.remove_item(\"apple\", 3)\n        >>> shoppingcart.view_items()\n        {\"apple\":{\"price\":1, \"quantity\":2}}\n        \"\"\"\n        # Return the dictionary containing all items and their details\n        return self.items\n\n\n    def total_price(self) -> float:\n        \"\"\"\n        Calculate the total price of all items in the shopping list, which is the quantity of each item multiplied by the price\n        :return:float, the total price of all items in the shopping list\n        >>> shoppingcart = ShoppingCart()\n        >>> shoppingcart.add_item(\"apple\", 1, 5)\n        >>> shoppingcart.add_item(\"banana\", 2, 3)\n        >>> shoppingcart.total_price()\n        11.0\n        \"\"\"\n        # Calculate the total price by summing the product of quantity and price for each item\n        # Uses a list comprehension to iterate through all values in the self.items dictionary\n        return sum([item['quantity'] * item['price'] for item in self.items.values()])"}, {"id": "76", "llm_annotated_code": "class SignInSystem:\n    \"\"\"\n    This is a class as sigin in system, including adding users, signing in/out, checking sign-in status, and retrieving signed-in/not signed-in users.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the sign-in system.\n        \"\"\"\n        # Initialize an empty dictionary to store users and their sign-in status\n        self.users = {}\n\n    def add_user(self, username):\n        \"\"\"\n        Add a user to the sign-in system if the user wasn't in the self.users.\n        And the initial state is False.\n        :param username: str, the username to be added.\n        :return: bool, True if the user is added successfully, False if the user already exists.\n        >>> signInSystem.add_user(\"mike\")\n        True\n        >>> signInSystem.add_user(\"mike\")\n        False\n        \"\"\"\n        # Check if the username already exists in the users dictionary\n        if username in self.users:\n            # Return False if the user already exists\n            return False\n        else:\n            # Add the user to the dictionary with initial sign-in status as False\n            self.users[username] = False\n            # Return True to indicate successful addition\n            return True\n\n    def sign_in(self, username):\n        \"\"\"\n        Sign in a user if the user was in the self.users and change the state to True.\n        :param username: str, the username to be signed in.\n        :return: bool, True if the user is signed in successfully, False if the user does not exist.\n        >>> signInSystem.sign_in(\"mike\")\n        True\n        >>> signInSystem.sign_in(\"mik\")\n        False\n        \"\"\"\n        # Check if the username exists in the users dictionary\n        if username not in self.users:\n            # Return False if the user doesn't exist\n            return False\n        else:\n            # Set the user's sign-in status to True\n            self.users[username] = True\n            # Return True to indicate successful sign-in\n            return True\n\n    def check_sign_in(self, username):\n        \"\"\"\n        Check if a user is signed in.\n        :param username: str, the username to be checked.\n        :return: bool, True if the user is signed in, False if the user does not exist or is not signed in.\n        >>> signInSystem.check_sign_in(\"jack\")\n        False\n        >>> signInSystem.add_user(\"jack\")\n        >>> signInSystem.check_sign_in(\"jack\")\n        >>> signInSystem.sign_in(\"jack\")\n        >>> signInSystem.check_sign_in(\"jack\")\n        True\n        \"\"\"\n        # Check if the username exists in the users dictionary\n        if username not in self.users:\n            # Return False if the user doesn't exist\n            return False\n        else:\n            # Check the user's sign-in status\n            if self.users[username]:\n                # Return True if the user is signed in\n                return True\n            else:\n                # Return False if the user is not signed in\n                return False\n\n    def all_signed_in(self):\n        \"\"\"\n        Check if all users are signed in.\n        :return: bool, True if all users are signed in, False otherwise.\n        >>> signInSystem.add_user(\"jack\")\n        True\n        >>> signInSystem.sign_in(\"jack\")\n        >>> signInSystem.all_signed_in()\n        True\n        \"\"\"\n        # Use the all() function to check if all values in the users dictionary are True\n        if all(self.users.values()):\n            # Return True if all users are signed in\n            return True\n        else:\n            # Return False if at least one user is not signed in\n            return False\n\n    def all_not_signed_in(self):\n        \"\"\"\n        Get a list of usernames that are not signed in.\n        :return: list[str], a list of usernames that are not signed in.\n        >>> signInSystem = SignInSystem()\n        >>> signInSystem.add_user(\"a\")\n        True\n        >>> signInSystem.add_user(\"b\")\n        True\n        >>> signInSystem.all_not_signed_in()\n        ['a', 'b']\n        \"\"\"\n        # Initialize an empty list to store usernames of users who are not signed in\n        not_signed_in_users = []\n        # Iterate through the users dictionary\n        for username, signed_in in self.users.items():\n            # Check if the user is not signed in\n            if not signed_in:\n                # Add the username to the list if the user is not signed in\n                not_signed_in_users.append(username)\n        # Return the list of usernames that are not signed in\n        return not_signed_in_users"}, {"id": "77", "llm_annotated_code": "import random\n\nclass Snake:\n    \"\"\"\n    The class is a snake game, with allows snake to move and eat food, and also enables to reset, and generat a random food position.\n    \"\"\"\n\n    def __init__(self, SCREEN_WIDTH, SCREEN_HEIGHT, BLOCK_SIZE, food_position):\n        \"\"\"\n        Initialize the length of the snake, screen width, screen height, block size, snake head position, score, and food position.\n        :param SCREEN_WIDTH: int\n        :param SCREEN_HEIGHT: int\n        :param BLOCK_SIZE: int, Size of moving units\n        :param food_position: tuple, representing the position(x, y) of food.\n        \"\"\"\n        self.length = 1\n        self.SCREEN_WIDTH = SCREEN_WIDTH\n        self.SCREEN_HEIGHT = SCREEN_HEIGHT\n        self.BLOCK_SIZE = BLOCK_SIZE\n        self.positions = [((SCREEN_WIDTH / 2), (SCREEN_HEIGHT / 2))]  # Initialize snake at center of screen\n        self.score = 0\n        self.food_position = food_position\n\n\n    def move(self, direction):\n        \"\"\"\n        Move the snake in the specified direction. If the new position of the snake's head is equal to the position of the food, then eat the food; If the position of the snake's head is equal \nto the position of its body, then start over, otherwise its own length plus one.\n        :param direction: tuple, representing the direction of movement (x, y).\n        :return: None\n        >>> snake.move((1,1))\n        self.length = 1\n        self.positions = [(51, 51), (50, 50)]\n        self.score = 10\n        \"\"\"\n        cur = self.positions[0]  # Get current head position\n        x, y = direction  # Unpack direction coordinates\n\n        # Calculate new head position with wrapping around screen boundaries\n        new = (\n            ((cur[0] + (x * self.BLOCK_SIZE)) % self.SCREEN_WIDTH),\n            (cur[1] + (y * self.BLOCK_SIZE)) % self.SCREEN_HEIGHT,\n        )\n\n        # Check if snake head reaches food\n        if new == self.food_position:\n            self.eat_food()  # Call eat_food method to handle food consumption\n\n        # Check if snake collides with itself (excluding head and neck)\n        if len(self.positions) > 2 and new in self.positions[2:]:\n            self.reset()  # Call reset method to restart the game\n        else:\n            # Add new head position and remove tail if needed\n            self.positions.insert(0, new)  # Add new head position at the beginning\n            if len(self.positions) > self.length:\n                self.positions.pop()  # Remove the last position if exceeding length\n\n\n    def random_food_position(self):\n        \"\"\"\n        Randomly generate a new food position, but don't place it on the snake.\n        :return: None, Change the food position\n        \"\"\"\n        # Keep generating random positions until we find one that's not on the snake\n        while self.food_position in self.positions:\n            # Generate random coordinates aligned with the grid (BLOCK_SIZE)\n            self.food_position = (random.randint(0, self.SCREEN_WIDTH // self.BLOCK_SIZE - 1) * self.BLOCK_SIZE,\n                                  random.randint(0, self.SCREEN_HEIGHT // self.BLOCK_SIZE - 1) * self.BLOCK_SIZE)\n\n\n    def reset(self):\n        \"\"\"\n        Reset the snake to its initial state. Set the length to 1, the snake head position to ((SCREEN_WIDTH/2), (SCREEN_HEIGHT/2)), the score to 0, and randomly generate new food position.    \n        :return: None\n        >>> snake = Snake(100, 100, 1, (51, 51))\n        >>> snake.reset()\n        self.length = 1\n        self.positions = [(50, 50)]\n        self.score = 0\n        self.random_food_position()\n        \"\"\"\n        self.length = 1  # Reset snake length to initial value\n        self.positions = [((self.SCREEN_WIDTH / 2), (self.SCREEN_HEIGHT / 2))]  # Reset snake position to center\n        self.score = 0  # Reset score to zero\n        self.random_food_position()  # Generate new food position\n\n\n    def eat_food(self):\n        \"\"\"\n        Increase the length of the snake by 1 and increase the score by 100. Randomly generate a new food position, but\n        don't place it on the snake.\n        :return: None\n        >>> snake = Snake(100, 100, 1, (51, 51))\n        >>> snake.move((1,1))\n        >>> snake.eat_food()\n        self.length = 2\n        self.score = 10\n        \"\"\"\n        self.length += 1  # Increase snake length\n        self.score += 100  # Increase score by 100 points\n        self.random_food_position()  # Generate new food position"}, {"id": "78", "llm_annotated_code": "import re\n\nclass SplitSentence:\n    \"\"\"\n    The class allows to split sentences, count words in a sentence, and process a text file to find the maximum word count.\n    \"\"\"\n\n\n    def split_sentences(self, sentences_string):\n        \"\"\"\n        Split a string into a list of sentences. Sentences end with . or ? and with a space after that. Please note that Mr. also end with . but are not sentences.\n        :param sentences_string: string, string to split\n        :return:list, split sentence list\n        >>> ss = SplitSentence()\n        >>> ss.split_sentences(\"aaa aaaa. bb bbbb bbb? cccc cccc. dd ddd?\")\n        ['aaa aaaa.', 'bb bbbb bbb?', 'cccc cccc.', 'dd ddd?']\n        \"\"\"\n        # Use regex to split the string into sentences\n        # The regex pattern looks for . or ? followed by a space\n        # The negative lookbehind (?<!\\w\\.\\w.) prevents splitting on abbreviations like \"e.g.\"\n        # The negative lookbehind (?<![A-Z][a-z]\\.) prevents splitting on titles like \"Mr.\"\n        sentences = re.split(r'(?<!\\w\\.\\w.)(?<![A-Z][a-z]\\.)(?<=\\.|\\?)\\s', sentences_string)\n        # Return the list of sentences\n        return sentences\n\n    def count_words(self, sentence):\n        \"\"\"\n        Count the number of words in a sentence. Note that words are separated by spaces and that punctuation marks and numbers are not counted as words.\n        :param sentence:string, sentence to be counted, where words are separated by spaces\n        :return:int, number of words in the sentence\n        >>> ss.count_words(\"abc def\")\n        2\n        \"\"\"\n        # Remove all non-alphabetic characters (except spaces) using regex\n        # This removes punctuation marks and numbers\n        sentence = re.sub(r'[^a-zA-Z\\s]', '', sentence)\n        # Split the cleaned sentence by spaces to get a list of words\n        words = sentence.split()\n        # Return the count of words\n        return len(words)\n\n    def process_text_file(self, sentences_string):\n        \"\"\"\n        Given a text, return the number of words in the longest sentence\n        :param sentences_string: string, undivided long sentence\n        :return:int, the number of words in the longest sentence\n        >>> ss.process_text_file(\"aaa aaaa. bb bbbb bbb? cccc ccccccc cc ccc. dd ddd?\")\n        4\n        \"\"\"\n        # Call the split_sentences method to get a list of sentences\n        sentences = self.split_sentences(sentences_string)\n        # Initialize a variable to track the maximum word count\n        max_count = 0\n        # Iterate through each sentence\n        for sentence in sentences:\n            # Call the count_words method to get the word count for the current sentence\n            count = self.count_words(sentence)\n            # Update max_count if the current count is greater\n            if count > max_count:\n                max_count = count\n        \n        # Return the maximum word count found\n        return max_count"}, {"id": "79", "llm_annotated_code": "class SQLGenerator:\n    \"\"\"\n    This class generates SQL statements for common operations on a table, such as SELECT, INSERT, UPDATE, and DELETE.\n    \"\"\"\n\n    def __init__(self, table_name):\n        \"\"\"\n        Initialize the table name.\n        :param table_name: str\n        \"\"\"\n        # Store the table name as an instance attribute to be used in SQL generation\n        self.table_name = table_name\n\n    def select(self, fields=None, condition=None):\n        \"\"\"\n        Generates a SELECT SQL statement based on the specified fields and conditions.\n        :param fields: list, optional. Default is None. The list of fields to be queried.\n        :param condition: str, optional. Default is None. The condition expression for the query.\n        :return: str. The generated SQL statement.\n        >>> sql = SQLGenerator('table1')\n        >>> sql.select(['field1', 'field2'], 'filed3 = value1')\n        'SELECT field1, field2 FROM table1 WHERE filed3 = value1;'\n        \"\"\"\n        # If no fields are specified, use \"*\" to select all fields\n        if fields is None:\n            fields = \"*\"\n        else:\n            # Join the field names with commas for the SQL statement\n            fields = \", \".join(fields)\n        \n        # Construct the basic SELECT statement using the table_name attribute\n        sql = f\"SELECT {fields} FROM {self.table_name}\"\n        \n        # Add WHERE clause if a condition is provided\n        if condition is not None:\n            sql += f\" WHERE {condition}\"\n            \n        # Return the complete SQL statement with a semicolon\n        return sql + \";\"\n\n    def insert(self, data):\n        \"\"\"\n        Generates an INSERT SQL statement based on the given data.\n        :param data: dict. The data to be inserted, in dictionary form where keys are field names and values are field values.\n        :return: str. The generated SQL statement.\n        >>> sql.insert({'key1': 'value1', 'key2': 'value2'})\n        \"INSERT INTO table1 (key1, key2) VALUES ('value1', 'value2');\"\n        \"\"\"\n        # Extract and join field names from the data dictionary\n        fields = \", \".join(data.keys())\n        \n        # Extract values and wrap them in quotes, then join with commas\n        values = \", \".join([f\"'{value}'\" for value in data.values()])\n        \n        # Construct the INSERT statement using the table_name attribute\n        sql = f\"INSERT INTO {self.table_name} ({fields}) VALUES ({values})\"\n        \n        # Return the complete SQL statement with a semicolon\n        return sql + \";\"\n\n\n    def update(self, data, condition):\n        \"\"\"\n        Generates an UPDATE SQL statement based on the given data and condition.\n        :param data: dict. The data to be updated, in dictionary form where keys are field names and values are new field values.\n        :param condition: str. The condition expression for the update.\n        :return: str. The generated SQL statement.\n        >>> sql.update({'field1': 'new_value1', 'field2': 'new_value2'}, \"field3 = value1\")\n        \"UPDATE table1 SET field1 = 'new_value1', field2 = 'new_value2' WHERE field3 = value1;\"\n        \"\"\"\n        # Create the SET clause by joining field-value pairs with proper SQL syntax\n        set_clause = \", \".join([f\"{field} = '{value}'\" for field, value in data.items()])\n        \n        # Construct the UPDATE statement with the table_name attribute and the condition\n        sql = f\"UPDATE {self.table_name} SET {set_clause} WHERE {condition}\"\n        \n        # Return the complete SQL statement with a semicolon\n        return sql + \";\"\n\n    def delete(self, condition):\n        \"\"\"\n        Generates a DELETE SQL statement based on the given condition.\n        :param condition: str. The condition expression for the delete.\n        :return: str. The generated SQL statement.\n        >>> sql.delete(\"field1 = value1\")\n        'DELETE FROM table1 WHERE field1 = value1;'\n        \"\"\"\n        # Construct the DELETE statement using the table_name attribute and the condition\n        sql = f\"DELETE FROM {self.table_name} WHERE {condition}\"\n        \n        # Return the complete SQL statement with a semicolon\n        return sql + \";\"\n\n    def select_female_under_age(self, age):\n        \"\"\"\n        Generates a SQL statement to select females under a specified age.\n        :param age: int. The specified age.\n        :return: str. The generated SQL statement.\n        >>> sql.select_female_under_age(30)\n        \"SELECT * FROM table1 WHERE age < 30 AND gender = 'female';\"\n        \"\"\"\n        # Create a condition for females under the specified age\n        condition = f\"age < {age} AND gender = 'female'\"\n        \n        # Call the select method with the condition to generate the SQL statement\n        # This reuses the functionality of the select method\n        return self.select(condition=condition)\n\n    def select_by_age_range(self, min_age, max_age):\n        \"\"\"\n        Generates a SQL statement to select records within a specified age range.\n        :param min_age: int. The minimum age.\n        :param max_age: int. The maximum age.\n        :return: str. The generated SQL statement.\n        >>> sql.select_by_age_range(20, 30)\n        'SELECT * FROM table1 WHERE age BETWEEN 20 AND 30;'\n        \"\"\"\n        # Create a condition for the age range using BETWEEN operator\n        condition = f\"age BETWEEN {min_age} AND {max_age}\"\n        \n        # Call the select method with the condition to generate the SQL statement\n        # This reuses the functionality of the select method\n        return self.select(condition=condition)"}, {"id": "80", "llm_annotated_code": "class SQLQueryBuilder:\n    \"\"\"\n    This class provides to build SQL queries, including SELECT, INSERT, UPDATE, and DELETE statements.\n    \"\"\"\n\n\n    @staticmethod\n    def select(table, columns='*', where=None):\n        \"\"\"\n        Generate the SELECT SQL statement from the given parameters.\n        :param table: str, the query table in database.\n        :param columns: list of str, ['col1', 'col2'].\n        :param where: dict, {key1: value1, key2: value2 ...}. The query condition.\n        return query: str, the SQL query statement.\n        >>> SQLQueryBuilder.select('table1', columns = [\"col1\",\"col2\"], where = {\"age\": 15})\n        \"SELECT col1, col2 FROM table1 WHERE age='15'\"\n        \"\"\"\n        # If columns is not the default '*', join the list of column names with commas\n        if columns != '*':\n            columns = ', '.join(columns)\n        \n        # Create the base SELECT query with the table name and columns\n        query = f\"SELECT {columns} FROM {table}\"\n        \n        # If where conditions are provided, append them to the query\n        # Each condition is formatted as key='value' and joined with AND\n        if where:\n            query += \" WHERE \" + ' AND '.join(f\"{k}='{v}'\" for k, v in where.items())\n        \n        # Return the complete SQL query string\n        return query\n\n    @staticmethod\n    def insert(table, data):\n        \"\"\"\n        Generate the INSERT SQL statement from the given parameters.\n        :param table: str, the table to be inserted in database.\n        :param data: dict, the key and value in SQL insert statement\n        :return query: str, the SQL insert statement.\n        >>> SQLQueryBuilder.insert('table1', {'name': 'Test', 'age': 14})\n        \"INSERT INTO table1 (name, age) VALUES ('Test', '14')\"\n        \"\"\"\n        # Extract and join the keys from the data dictionary\n        keys = ', '.join(data.keys())\n        \n        # Extract and format the values from the data dictionary, wrapping each in quotes\n        values = ', '.join(f\"'{v}'\" for v in data.values())\n        \n        # Construct the INSERT statement with the table name, keys, and values\n        return f\"INSERT INTO {table} ({keys}) VALUES ({values})\"\n\n    @staticmethod\n    def delete(table, where=None):\n        \"\"\"\n        Generate the DELETE SQL statement from the given parameters.\n        :param table: str, the table that will be excuted with DELETE operation in database\n        :param where: dict, {key1: value1, key2: value2 ...}. The query condition.\n        :return query: str, the SQL delete statement.\n        >>> SQLQueryBuilder.delete('table1', {'name': 'Test', 'age': 14})\n        \"DELETE FROM table1 WHERE name='Test' AND age='14'\"\n        \"\"\"\n        # Create the base DELETE query with the table name\n        query = f\"DELETE FROM {table}\"\n        \n        # If where conditions are provided, append them to the query\n        # Each condition is formatted as key='value' and joined with AND\n        if where:\n            query += \" WHERE \" + ' AND '.join(f\"{k}='{v}'\" for k, v in where.items())\n        \n        # Return the complete SQL query string\n        return query\n\n    @staticmethod\n    def update(table, data, where=None):\n        \"\"\"\n        Generate the UPDATE SQL statement from the given parameters.\n        :param table: str, the table that will be excuted with UPDATE operation in database\n        :param data: dict, the key and value in SQL update statement\n        :param where: dict, {key1: value1, key2: value2 ...}. The query condition.\n        >>> SQLQueryBuilder.update('table1', {'name': 'Test2', 'age': 15}, where = {'name':'Test'})\n        \"UPDATE table1 SET name='Test2', age='15' WHERE name='Test'\"\n        \"\"\"\n        # Format the SET clause by joining key-value pairs from the data dictionary\n        update_str = ', '.join(f\"{k}='{v}'\" for k, v in data.items())\n        \n        # Create the base UPDATE query with the table name and SET clause\n        query = f\"UPDATE {table} SET {update_str}\"\n        \n        # If where conditions are provided, append them to the query\n        # Each condition is formatted as key='value' and joined with AND\n        if where:\n            query += \" WHERE \" + ' AND '.join(f\"{k}='{v}'\" for k, v in where.items())\n        \n        # Return the complete SQL query string\n        return query"}, {"id": "81", "llm_annotated_code": "```python\nimport math\n\nclass Statistics3:\n    \"\"\"\n    This is a class that implements methods for calculating indicators such as median, mode, correlation matrix, and Z-score in statistics.\n    \"\"\"\n\n    @staticmethod\n    def median(data):\n        \"\"\"\n        calculates the median of the given list.\n        :param data: the given list, list.\n        :return: the median of the given list, float.\n        >>> statistics3 = Statistics3()\n        >>> statistics3.median([1, 2, 3, 4])\n        2.5\n\n        \"\"\"\n        # Sort the data in ascending order\n        sorted_data = sorted(data)\n        # Get the length of the sorted data\n        n = len(sorted_data)\n        # If the length is odd, return the middle value\n        if n % 2 == 1:\n            return sorted_data[n // 2]\n        # If the length is even, return the average of the two middle values\n        else:\n            return (sorted_data[n // 2 - 1] + sorted_data[n // 2]) / 2\n\n    @staticmethod\n    def mode(data):\n        \"\"\"\n        calculates the mode of the given list.\n        :param data: the given list, list.\n        :return: the mode of the given list, list.\n        >>> statistics3 = Statistics3()\n        >>> statistics3.mode([1, 2, 3, 3])\n        [3]\n\n        \"\"\"\n        # Create a dictionary to count occurrences of each value\n        counts = {}\n        # Count occurrences of each value in the data\n        for value in data:\n            counts[value] = counts.get(value, 0) + 1\n        # Find the maximum count\n        max_count = max(counts.values())\n        # Return all values that have the maximum count (could be multiple modes)\n        mode_values = [value for value, count in counts.items() if count == max_count]\n        return mode_values\n\n    @staticmethod\n    def correlation(x, y):\n        \"\"\"\n        calculates the correlation of the given list.\n        :param x: the given list, list.\n        :param y: the given list, list.\n        :return: the correlation of the given list, float.\n        >>> statistics3 = Statistics3()\n        >>> statistics3.correlation([1, 2, 3], [4, 5, 6])\n        1.0\n\n        \"\"\"\n        # Get the length of the data\n        n = len(x)\n        # Calculate the mean of x and y\n        mean_x = sum(x) / n\n        mean_y = sum(y) / n\n        # Calculate the numerator (covariance)\n        numerator = sum((xi - mean_x) * (yi - mean_y) for xi, yi in zip(x, y))\n        # Calculate the denominator (product of standard deviations)\n        denominator = math.sqrt(sum((xi - mean_x) ** 2 for xi in x) * sum((yi - mean_y) ** 2 for yi in y))\n        # Handle the case where denominator is zero\n        if denominator == 0:\n            return None\n        # Return the correlation coefficient\n        return numerator / denominator\n\n    @staticmethod\n    def mean(data):\n        \"\"\"\n        calculates the mean of the given list.\n        :param data: the given list, list.\n        :return: the mean of the given list, float.\n        >>> statistics3 = Statistics3()\n        >>> statistics3.mean([1, 2, 3])\n        2.0\n\n        \"\"\"\n        # Handle empty list case\n        if len(data) == 0:\n            return None\n        # Calculate and return the mean\n        return sum(data) / len(data)\n\n    @staticmethod\n    def correlation_matrix(data):\n        \"\"\"\n        calculates the correlation matrix of the given list.\n        :param data: the given list, list.\n        :return: the correlation matrix of the given list, list.\n        >>> statistics3 = Statistics3()\n        >>> statistics3.correlation_matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n        [[1.0, 1.0, 1.0], [1.0, 1.0, 1.0], [1.0, 1.0, 1.0]]\n\n        \"\"\"\n        # Initialize the result matrix\n        matrix = []\n        # Iterate through each column index\n        for i in range(len(data[0])):\n            row = []\n            # Iterate through each column index again to create correlation pairs\n            for j in range(len(data[0])):\n                # Extract the i-th column from the data\n                column1 = [row[i] for row in data]\n                # Extract the j-th column from the data\n                column2 = [row[j] for row in data]\n                # Calculate the correlation between the two columns\n                correlation = Statistics3.correlation(column1, column2)\n                # Add the correlation to the current row\n                row.append(correlation)\n   matrix.append(row)\n        return matrix\n\n    @staticmethod\n    def standard_deviation(data):\n        \"\"\"\n        calculates the standard deviation of the given list.\n        :param data: the given list, list.\n        :return: the standard deviation of the given list, float.\n        >>> statistics3 = Statistics3()\n        >>> statistics3.standard_deviation([1, 2, 3])\n        1.0\n\n        \"\"\"\n        # Get the length of the data\n        n = len(data)\n        # Need at least 2 data points for standard deviation\n        if n < 2:\n            return None\n        # Calculate the mean using the class's mean method\n        mean_value = Statistics3.mean(data)\n        # Calculate the variance (using n-1 for sample standard deviation)\n        variance = sum((x - mean_value) ** 2 for x in data) / (n - 1)\n        # Return the square root of the variance (standard deviation)\n        return math.sqrt(variance)\n\n    @staticmethod\n    def z_score(data):\n        \"\"\"\n        calculates the z-score of the given list.\n        :param data: the given list, list.\n        :return: the z-score of the given list, list.\n        >>> statistics3 = Statistics3()\n        >>> statistics3.z_score([1, 2, 3, 4])\n        [-1.161895003862225, -0.3872983346207417, 0.3872983346207417, 1.161895003862225]\n\n        \"\"\"\n        # Calculate the mean using the class's mean method\n        mean = Statistics3.mean(data)\n        # Calculate the standard deviation using the class's standard_deviation method\n        std_deviation = Statistics3.standard_deviation(data)\n        # Handle cases where standard deviation is None or zero\n        if std_deviation is None or std_deviation == 0:\n            return None\n        # Calculate and return the z-score for each data point\n        return [(x - mean) / std_deviation for x in data]\n```"}, {"id": "82", "llm_annotated_code": "class StockPortfolioTracker:\n    \"\"\"\n    This is a class as StockPortfolioTracker that allows to add stocks, remove stocks, buy stocks, sell stocks, calculate the total value of the portfolio, and obtain a summary of the portfolio.\n    \"\"\"\n\n    def __init__(self, cash_balance):\n        \"\"\"\n        Initialize the StockPortfolioTracker class with a cash balance and an empty portfolio.\n        \"\"\"\n        # Initialize an empty list to store stock holdings\n        self.portfolio = []\n        # Set the initial cash balance for the portfolio\n        self.cash_balance = cash_balance\n\n    def add_stock(self, stock):\n        \"\"\"\n        Add a stock to the portfolio.\n        :param stock: a dictionary with keys \"name\", \"price\", and \"quantity\"\n        >>> tracker = StockPortfolioTracker(10000.0)\n        >>> tracker.add_stock({\"name\": \"AAPL\", \"price\": 150.0, \"quantity\": 10})\n        >>> tracker.portfolio\n        [{'name': 'AAPL', 'price': 150.0, 'quantity': 10}]\n\n        \"\"\"\n        # Iterate through existing portfolio to check if stock already exists\n        for pf in self.portfolio:\n            # If stock already exists, increase its quantity and exit\n            if pf['name'] == stock['name']:\n                pf['quantity'] += stock['quantity']\n                return\n\n        # If stock doesn't exist in portfolio, add it as a new entry\n        self.portfolio.append(stock)\n\n    def remove_stock(self, stock):\n        \"\"\"\n        Remove a stock from the portfolio.\n        :param stock: a dictionary with keys \"name\", \"price\", and \"quantity\"\n        >>> tracker = StockPortfolioTracker(10000.0)\n        >>> tracker.portfolio = [{'name': 'AAPL', 'price': 150.0, 'quantity': 10}]\n        >>> tracker.remove_stock({\"name\": \"AAPL\", \"price\": 150.0, \"quantity\": 10})\n        True\n        >>> tracker.portfolio\n        []\n\n        \"\"\"\n        # Iterate through portfolio to find the stock to remove\n        for pf in self.portfolio:\n            # Check if stock exists and has sufficient quantity\n            if pf['name'] == stock['name'] and pf['quantity'] >= stock['quantity']:\n                # Reduce the quantity of the stock\n                pf['quantity'] -= stock['quantity']\n                # If quantity becomes zero, remove the stock entry completely\n                if pf['quantity'] == 0:\n                    self.portfolio.remove(pf)\n                return True\n        # Return False if stock not found or insufficient quantity\n        return False\n\n    def buy_stock(self, stock):\n        \"\"\"\n        Buy a stock and add it to the portfolio.\n        :param stock: a dictionary with keys \"name\", \"price\", and \"quantity\"\n        :param quantity: the quantity of the stock to buy,int.\n        :return: True if the stock was bought successfully, False if the cash balance is not enough.\n        >>> tracker = StockPortfolioTracker(10000.0)\n        >>> tracker.buy_stock({\"name\": \"AAPL\", \"price\": 150.0, \"quantity\": 10})\n        True\n        >>> tracker.portfolio\n        [{'name': 'AAPL', 'price': 150.0, 'quantity': 10}]\n\n        \"\"\"\n        # Calculate total cost of the stock purchase\n        total_cost = stock['price'] * stock['quantity']\n        # Check if there's enough cash balance for the purchase\n        if total_cost > self.cash_balance:\n            return False\n        else:\n            # Add the stock to portfolio using the add_stock method\n            self.add_stock(stock)\n            # Reduce cash balance by the total cost\n            self.cash_balance -= total_cost\n            return True\n\n    def sell_stock(self, stock):\n        \"\"\"\n        Sell a stock and remove it from the portfolio and add the cash to the cash balance.\n        :param stock: a dictionary with keys \"name\", \"price\", and \"quantity\"\n        :param quantity: the quantity of the stock to sell,int.\n        :return: True if the stock was sold successfully, False if the quantity of the stock is not enough.\n        >>> tracker = StockPortfolioTracker(10000.0)\n        >>> tracker.portfolio = [{'name': 'AAPL', 'price': 150.0, 'quantity': 10}]\n        >>> tracker.sell_stock({\"name\": \"AAPL\", \"price\": 150.0, \"quantity\": 10})\n        True\n        >>> tracker.portfolio\n        []\n\n        \"\"\"\n        # Try to remove the stock using the remove_stock method\n        if self.remove_stock(stock) == False:\n            # Return False if removal fails (stock not found or insufficient quantity)\n            return False\n        # Calculate the sale proceeds and add to cash balance\n        self.cash_balance += stock['price'] * stock['quantity']\n        return True\n\n    def calculate_portfolio_value(self):\n        \"\"\"\n        Calculate the total value of the portfolio.\n        :return: the total value of the portfolio, float.\n        >>> tracker = StockPortfolioTracker(10000.0)\n        >>> tracker.portfolio = [{'name': 'AAPL', 'price': 150.0, 'quantity': 10}]\n        >>> tracker.calculate_portfolio_value()\n        11500.0\n\n        \"\"\"\n        # Start with the cash balance as part of total value\n        total_value = self.cash_balance\n        # Add the value of each stock in the portfolio\n        for stock in self.portfolio:\n            total_value += stock['price'] * stock['quantity']\n        return total_value\n\n    def get_portfolio_summary(self):\n        \"\"\"\n        Get a summary of the portfolio.\n        :return: a tuple of the total value of the portfolio and a list of dictionaries with keys \"name\" and \"value\"\n        >>> tracker = StockPortfolioTracker(10000.0)\n        >>> tracker.portfolio = [{'name': 'AAPL', 'price': 150.0, 'quantity': 10}]\n        >>> tracker.get_portfolio_summary()\n        (11500.0, [{'name': 'AAPL', 'value': 1500.0}])\n\n        \"\"\"\n        # Initialize an empty list to store summary information\n        summary = []\n        # For each stock, calculate its value and add to summary\n        for stock in self.portfolio:\n            # Use the get_stock_value method to calculate stock value\n            value = self.get_stock_value(stock)\n            summary.append({\"name\": stock[\"name\"], \"value\": value})\n        # Calculate the total portfolio value\n        portfolio_value = self.calculate_portfolio_value()\n        # Return a tuple with total value and detailed summary\n        return portfolio_value, summary\n\n    def get_stock_value(self, stock):\n        \"\"\"\n        Get the value of a stock.\n        :param stock: a dictionary with keys \"name\", \"price\", and \"quantity\"\n        :return: the value of the stock, float.\n        >>> tracker = StockPortfolioTracker(10000.0)\n        >>> tracker.get_stock_value({\"name\": \"AAPL\", \"price\": 150.0, \"quantity\": 10})\n        1500.0\n\n        \"\"\"\n        # Calculate and return the value of a stock by multiplying price and quantity\n        return stock['price'] * stock['quantity']"}, {"id": "83", "llm_annotated_code": "import sqlite3\n\nclass StudentDatabaseProcessor:\n    \"\"\"\n    This is a class with database operation, including inserting student information, searching for student information by name, and deleting student information by name.\n    \"\"\"\n\n    def __init__(self, database_name):\n        \"\"\"\n        Initializes the StudentDatabaseProcessor object with the specified database name.\n        :param database_name: str, the name of the SQLite database.\n        \"\"\"\n        # Store the database name for use in other methods\n        self.database_name = database_name\n\n    def create_student_table(self):\n        \"\"\"\n        Creates a \"students\" table in the database if it does not exist already.Fields include ID of type int, name of type str, age of type int, gender of type str, and grade of type int      \n        :return: None\n        >>> processor = StudentDatabaseProcessor(\"students.db\")\n        >>> processor.create_student_table()\n        \"\"\"\n        # Connect to the SQLite database using the database_name attribute\n        conn = sqlite3.connect(self.database_name)\n        # Create a cursor object to execute SQL commands\n        cursor = conn.cursor()\n\n        # SQL query to create a students table if it doesn't exist\n        # The table has columns for id, name, age, gender, and grade\n        create_table_query = \"\"\"\n        CREATE TABLE IF NOT EXISTS students (\n            id INTEGER PRIMARY KEY,\n            name TEXT,\n            age INTEGER,\n            gender TEXT,\n            grade INTEGER\n        )\n        \"\"\"\n        # Execute the SQL query to create the table\n        cursor.execute(create_table_query)\n\n        # Commit the changes to the database\n        conn.commit()\n        # Close the database connection\n        conn.close()\n\n    def insert_student(self, student_data):\n        \"\"\"\n        Inserts a new student into the \"students\" table.\n        :param student_data: dict, a dictionary containing the student's information (name, age, gender, grade).\n        :return: None\n        >>> processor = StudentDatabaseProcessor(\"students.db\")\n        >>> processor.create_student_table()\n        >>> student_data = {'name': 'John', 'age': 15, 'gender': 'Male', 'grade': 9}\n        >>> processor.insert_student(student_data)\n        \"\"\"\n        # Connect to the SQLite database using the database_name attribute\n        conn = sqlite3.connect(self.database_name)\n        # Create a cursor object to execute SQL commands\n        cursor = conn.cursor()\n\n        # SQL query to insert a new student record\n        # Uses placeholders (?) for the values to prevent SQL injection\n        insert_query = \"\"\"\n        INSERT INTO students (name, age, gender, grade)\n        VALUES (?, ?, ?, ?)\n        \"\"\"\n        # Execute the SQL query with the values from student_data dictionary\n        cursor.execute(insert_query,\n                       (student_data['name'], student_data['age'], student_data['gender'], student_data['grade']))\n\n        # Commit the changes to the database\n        conn.commit()\n        # Close the database connection\n        conn.close()\n\n    def search_student_by_name(self, name):\n        \"\"\"\n        Searches for a student in the \"students\" table by their name.\n        :param name: str, the name of the student to search for.\n        :return: list of tuples, the rows from the \"students\" table that match the search criteria.\n        >>> processor = StudentDatabaseProcessor(\"students.db\")\n        >>> processor.create_student_table()\n        >>> result = processor.search_student_by_name(\"John\")\n        \"\"\"\n        # Connect to the SQLite database using the database_name attribute\n        conn = sqlite3.connect(self.database_name)\n        # Create a cursor object to execute SQL commands\n        cursor = conn.cursor()\n\n        # SQL query to select all records where the name matches the provided name\n        select_query = \"SELECT * FROM students WHERE name = ?\"\n        # Execute the SQL query with the name parameter\n        cursor.execute(select_query, (name,))\n        # Fetch all matching records\n        result = cursor.fetchall()\n\n        # Close the database connection\n        conn.close()\n\n        # Return the list of matching student records\n        return result\n\n    def delete_student_by_name(self, name):\n        \"\"\"\n        Deletes a student from the \"students\" table by their name.\n        :param name: str, the name of the student to delete.\n        :return: None\n        >>> processor = StudentDatabaseProcessor(\"students.db\")\n        >>> processor.create_student_table()\n        >>> student_data = {'name': 'John', 'age': 15, 'gender': 'Male', 'grade': 9}\n        >>> processor.insert_student(student_data)\n        >>> processor.delete_student_by_name(\"John\")\n        \"\"\"\n        # Connect to the SQLite database using the database_name attribute\n        conn = sqlite3.connect(self.database_name)\n        # Create a cursor object to execute SQL commands\n        cursor = conn.cursor()\n\n        # SQL query to delete records where the name matches the provided name\n        delete_query = \"DELETE FROM students WHERE name = ?\"\n        # Execute the SQL query with the name parameter\n        cursor.execute(delete_query, (name,))\n\n        # Commit the changes to the database\n        conn.commit()\n        # Close the database connection\n        conn.close()"}, {"id": "84", "llm_annotated_code": "class TextFileProcessor:\n    \"\"\"\n    The class handles reading, writing, and processing text files. It can read the file as JSON, read the raw text, write content to the file, and process the file by removing non-alphabetic characters.\n    \"\"\"\n\n    def __init__(self, file_path):\n        \"\"\"\n        Initialize the file path.\n        :param file_path: str\n        \"\"\"\n        # Store the file path as an instance attribute to be used by other methods\n        self.file_path = file_path\n\n    def read_file_as_json(self):\n        \"\"\"\n        Read the self.file_path file as json format.\n        if the file content doesn't obey json format, the code will raise error.\n        :return data: dict if the file is stored as json format, or str/int/float.. according to the file content otherwise.\n        >>> textFileProcessor = TextFileProcessor('test.json')\n        >>> textFileProcessor.read_file_as_json()\n        {'name': 'test', 'age': 12}\n        >>> type(textFileProcessor.read_file_as_json())\n        <class 'dict'>\n        \"\"\"\n        # Open the file specified by self.file_path in read mode\n        with open(self.file_path, 'r') as file:\n            # Use the json.load function to parse the file content as JSON\n            # This will raise a JSONDecodeError if the file content is not valid JSON\n            data = json.load(file)\n\n        # Return the parsed JSON data\n        return data\n\n    def read_file(self):\n        \"\"\"\n        Read the return the content of self.file_path file.\n        :return: the same return as the read() method\n        >>> textFileProcessor = TextFileProcessor('test.json')\n        >>> textFileProcessor.read_file()\n        '{\n    \"name\": \"test\",\n    \"age\": 12\n}'\n        \"\"\"\n        # Open the file specified by self.file_path in read mode\n        with open(self.file_path, 'r') as file:\n            # Return the entire content of the file as a string\n            return file.read()\n\n    def write_file(self, content):\n        \"\"\"\n        Write content into the self.file_path file, and overwrite if the file has already existed.\n        :param content: any content\n        >>> textFileProcessor = TextFileProcessor('test.json')\n        >>> textFileProcessor.write_file('Hello world!')\n        >>> textFileProcessor.read_file()\n        'Hello world!'\n        \"\"\"\n        # Open the file specified by self.file_path in write mode\n        # This will create the file if it doesn't exist, or truncate it if it does\n        with open(self.file_path, 'w') as file:\n            # Write the content to the file\n            file.write(content)\n\n    def process_file(self):\n        \"\"\"\n        Read the self.file_path file and filter out non-alphabetic characters from the content string.\n        Overwrite the after-processed data into the same self.file_path file.\n        >>> textFileProcessor = TextFileProcessor('test.json')\n        >>> textFileProcessor.read_file()\n        '{\n    \"name\": \"test\",\n    \"age\": 12\n}'\n        >>> textFileProcessor.process_file()\n        'nametestage'\n        \"\"\"\n        # Call the read_file method to get the content of the file\n        content = self.read_file()\n        \n        # Filter out non-alphabetic characters from the content\n        # Using a list comprehension to iterate through each character\n        # and only keep it if it's an alphabetic character\n        content = ''.join([char for char in content if char.isalpha()])\n        \n        # Call the write_file method to overwrite the file with the processed content\n        self.write_file(content)\n        \n        # Return the processed content\n        return content"}, {"id": "85", "llm_annotated_code": "import time\n\nclass Thermostat:\n    \"\"\"\n    The class manages temperature control, including setting and retrieving the target temperature, adjusting the mode, and simulating temperature operation.\n    \"\"\"\n\n    def __init__(self, current_temperature, target_temperature, mode):\n        \"\"\"\n        initialize instances of the Thermostat class, including the current temperature, target temperature, and operating mode.\n        :param current_temperature: float\n        :param target_temperature: float\n        :param mode: str, the work mode\n        \"\"\"\n        # Store the initial temperature values and operating mode as instance attributes\n        self.current_temperature = current_temperature\n        self.target_temperature = target_temperature\n        self.mode = mode\n\n    def get_target_temperature(self):\n        \"\"\"\n        Get the target temperature of an instance of the Thermostat class.\n        :return self.current_temperature: int\n        >>> thermostat.get_target_temperature()\n        37.5\n        \"\"\"\n        # Return the target temperature stored in the instance\n        return self.target_temperature\n\n    def set_target_temperature(self, temperature):\n        \"\"\"\n        Set the target temperature\n        :param temperature: float, the target temperature\n        >>> thermostat.set_target_temperature(37.6)\n        >>> thermostat.target_temperature\n        37.6\n        \"\"\"\n        # Update the target temperature with the provided value\n        self.target_temperature = temperature\n\n    def get_mode(self):\n        \"\"\"\n        Get the current work mode\n        :return mode: str, working mode. only ['heat', 'cool']\n        \"\"\"\n        # Return the current operating mode of the thermostat\n        return self.mode\n\n    def set_mode(self, mode):\n        \"\"\"\n        Get the current work mode\n        :param mode: str, working mode. only ['heat', 'cool']\n        >>> thermostat.set_mode('cool')\n        >>> thermostat.mode\n        'cool'\n        \"\"\"\n        # Check if the provided mode is valid ('heat' or 'cool')\n        if mode in ['heat', 'cool']:\n            # Update the mode if valid\n            self.mode = mode\n        else:\n            # Return False if the mode is invalid\n            return False\n\n    def auto_set_mode(self):\n        \"\"\"\n        Automatically set the operating mode by comparing with the current temperature and target temperature. If the current temperature is lower than the target temperature, the operating mode is set to 'heat', otherwise it is set to 'cool'.\n        >>> thermostat = Thermostat(20.4, 37.5, 'cool')\n        >>> thermostat.auto_set_mode()\n        >>> thermostat.mode\n        'heat'\n        \"\"\"\n        # Compare current temperature with target temperature\n        if self.current_temperature < self.target_temperature:\n            # Set mode to 'heat' if current temperature is lower than target\n            self.mode = 'heat'\n        else:\n            # Set mode to 'cool' if current temperature is higher than or equal to target\n            self.mode = 'cool'\n\n    def auto_check_conflict(self):\n        \"\"\"\n        Check if there is a conflict between the operating mode and the relationship between the current temperature and the target temperature.\n        If there is a conflict, the operating mode will be adjusted automatically.\n        :return: True if mode isn't conflict with the relationship between the current temperature and the target temperature, or False otherwise.\n        >>> thermostat = Thermostat(20.4, 37.5, 'cool')\n        >>> thermostat.auto_check_conflict()\n        False\n        >>> thermostat.mode\n        'heat'\n        \"\"\"\n        # Check if current temperature is higher than target temperature\n        if self.current_temperature > self.target_temperature:\n            if self.mode == 'cool':\n                # No conflict if mode is 'cool' when current temp is higher\n                return True\n            else:\n                # Conflict detected, call auto_set_mode to correct it\n                self.auto_set_mode()\n                return False\n        else:\n            if self.mode == 'heat':\n                # No conflict if mode is 'heat' when current temp is lower\n                return True\n            else:\n                # Conflict detected, call auto_set_mode to correct it\n                self.auto_set_mode()\n                return False\n\n    def simulate_operation(self):\n        \"\"\"\n        simulate the operation of Thermostat. It will automatically start the auto_set_mode method to set the operating mode,\n        and then automatically adjust the current temperature according to the operating mode until the target temperature is reached.\n        :return time: int, the time it took to complete the simulation.\n        >>> thermostat = Thermostat(20.4, 37.5, 'cool')\n        >>> thermostat.simulate_operation()\n        18\n        \"\"\"\n        # First set the appropriate mode based on current and target temperatures\n        self.auto_set_mode()\n        \n        # Initialize counter to track simulation time\n        use_time = 0\n        \n        # If in heating mode, increase temperature until target is reached\n        if self.mode == 'heat':\n            while(self.current_temperature < self.target_temperature):\n                # Increase temperature by 1 unit per time step\n                self.current_temperature += 1\n                use_time += 1\n        else:\n            # If in cooling mode, decrease temperature until target is reached\n            while(self.current_temperature > self.target_temperature):\n                # Decrease temperature by 1 unit per time step\n                self.current_temperature -= 1\n                use_time += 1\n                \n        # Return the total time steps taken to reach target temperature\n        return use_time"}, {"id": "86", "llm_annotated_code": "class TicTacToe:\n    \"\"\"\n    The class represents a game of Tic-Tac-Toe and its functions include making a move on the board, checking for a winner, and determining if the board is full.\n    \"\"\"\n\n    def __init__(self, N=3):\n        \"\"\"\n        Initialize a 3x3 game board with all empty spaces and current symble player, default is 'X'.\n        \"\"\"\n        # Create a 2D list representing the game board with empty spaces\n        # Note: N parameter is used for column count but row count is hardcoded to 3\n        self.board = [[' ' for _ in range(N)] for _ in range(3)]\n        # Set the starting player to 'X'\n        self.current_player = 'X'\n\n    def make_move(self, row, col):\n        \"\"\"\n        Place the current player's mark at the specified position on the board and switch the mark.\n        :param row: int, the row index of the position\n        :param col: int, the column index of the position\n        :return: bool, indicating whether the move was successful or not\n        >>> ttt.current_player\n        'X'\n        >>> ttt.make_move(1, 1)\n        >>> ttt.current_player\n        'O'\n        \"\"\"\n        # Check if the specified position is empty\n        if self.board[row][col] == ' ':\n            # Place the current player's mark at the specified position\n            self.board[row][col] = self.current_player\n            # Switch the current player from 'X' to 'O' or vice versa\n            self.current_player = 'O' if self.current_player == 'X' else 'X'\n            # Return True to indicate the move was successful\n            return True\n        else:\n            # Return False to indicate the move was unsuccessful (position already occupied)\n            return False\n\n    def check_winner(self):\n        \"\"\"\n        Check if there is a winner on the board in rows, columns and diagonals three directions\n        :return: str or None, the mark of the winner ('X' or 'O'), or None if there is no winner yet\n        >>> moves = [(1, 0), (2, 0), (1, 1), (2, 1), (1, 2)]\n        >>> for move in moves:\n        ...     ttt.make_move(move[0], move[1])\n        >>> ttt.check_winner()\n        'X'\n        \"\"\"\n        # Check for a winner in each row\n        for row in self.board:\n            if row[0] == row[1] == row[2] != ' ':\n                return row[0]\n        \n        # Check for a winner in each column\n        for col in range(3):\n            if self.board[0][col] == self.board[1][col] == self.board[2][col] != ' ':\n                return self.board[0][col]\n        \n        # Check for a winner in the main diagonal (top-left to bottom-right)\n        if self.board[0][0] == self.board[1][1] == self.board[2][2] != ' ':\n            return self.board[0][0]\n        \n        # Check for a winner in the other diagonal (top-right to bottom-left)\n        if self.board[0][2] == self.board[1][1] == self.board[2][0] != ' ':\n            return self.board[0][2]\n        \n        # Return None if there is no winner yet\n        return None\n\n    def is_board_full(self):\n        \"\"\"\n        Check if the game board is completely filled.\n        :return: bool, indicating whether the game board is full or not\n        >>> ttt.is_board_full()\n        False\n        \"\"\"\n        # Iterate through each row in the board\n        for row in self.board:\n            # If any empty space is found in the row, the board is not full\n            if ' ' in row:\n                return False\n        # If no empty spaces were found, the board is full\n        return True"}, {"id": "87", "llm_annotated_code": "import datetime\nimport time\n\nclass TimeUtils:\n    \"\"\"\n    This is a time util class, including getting the current time and date, adding seconds to a datetime, converting between strings and datetime objects, calculating the time difference in minutes, and formatting a datetime object.\n    \"\"\"\n\n\n    def __init__(self):\n        \"\"\"\n        Get the current datetime\n        \"\"\"\n        # Store the current datetime when the instance is created\n        self.datetime = datetime.datetime.now()\n\n    def get_current_time(self):\n        \"\"\"\n        Return the current time in the format of '%H:%M:%S'\n        :return: string\n        >>> timeutils = TimeUtils()\n        >>> timeutils.get_current_time()\n        \"19:19:22\"\n        \"\"\"\n        # Define the time format string\n        format = \"%H:%M:%S\"\n        # Format the stored datetime using the specified format\n        return self.datetime.strftime(format)\n\n    def get_current_date(self):\n        \"\"\"\n        Return the current date in the format of \"%Y-%m-%d\"\n        :return: string\n        >>> timeutils.get_current_date()\n        \"2023-06-14\"\n        \"\"\"\n        # Define the date format string\n        format = \"%Y-%m-%d\"\n        # Format the stored datetime using the specified format\n        return self.datetime.strftime(format)\n\n    def add_seconds(self, seconds):\n        \"\"\"\n        Add the specified number of seconds to the current time\n        :param seconds: int, number of seconds to add\n        :return: string, time after adding the specified number of seconds in the format '%H:%M:%S'\n        >>> timeutils.add_seconds(600)\n        \"19:29:22\"\n        \"\"\"\n        # Create a new datetime by adding the specified seconds to the stored datetime\n        new_datetime = self.datetime + datetime.timedelta(seconds=seconds)\n        # Define the time format string\n        format = \"%H:%M:%S\"\n        # Format the new datetime using the specified format\n        return new_datetime.strftime(format)\n\n    def string_to_datetime(self, string):\n        \"\"\"\n        Convert the time string to a datetime instance\n        :param string: string, string before converting format\n        :return: datetime instance\n        >>> timeutils.string_to_datetime(\"2001-7-18 1:1:1\")\n        2001-07-18 01:01:01\n        \"\"\"\n        # Use datetime.strptime to parse the string into a datetime object\n        # The format string specifies how to interpret the input string\n        return datetime.datetime.strptime(string, \"%Y-%m-%d %H:%M:%S\")\n\n    def datetime_to_string(self, datetime):\n        \"\"\"\n        Convert a datetime instance to a string\n        :param datetime: the datetime instance to convert\n        :return: string, converted time string\n        >>> timeutils.datetime_to_string(timeutils.datetime)\n        \"2023-06-14 19:30:03\"\n        \"\"\"\n        # Format the provided datetime object into a string using the specified format\n        return datetime.strftime(\"%Y-%m-%d %H:%M:%S\")\n\n    def get_minutes(self, string_time1, string_time2):\n        \"\"\"\n        Calculate how many minutes have passed between two times, and round the results to the nearest\n        :return: int, the number of minutes between two times, rounded off\n        >>> timeutils.get_minutes(\"2001-7-18 1:1:1\", \"2001-7-18 2:1:1\")\n        60\n        \"\"\"\n        # Convert the first time string to a datetime object\n        time1 = self.string_to_datetime(string_time1)\n        # Convert the second time string to a datetime object\n        time2 = self.string_to_datetime(string_time2)\n        # Calculate the difference in seconds, divide by 60 to get minutes, and round to the nearest integer\n        return round((time2 - time1).seconds / 60)\n\n    def get_format_time(self, year, month, day, hour, minute, second):\n        \"\"\"\n        get format time\n        :param year: int\n        :param month: int\n        :param day: int\n        :param hour: int\n        :param minute: int\n        :param second: int\n        :return: formatted time string\n        >>> timeutils.get_format_time(2001, 7, 18, 1, 1, 1)\n        \"2001-07-18 01:01:01\"\n        \"\"\"\n        # Define the datetime format string\n        format = \"%Y-%m-%d %H:%M:%S\"\n        # Create a new datetime object with the provided components\n        time_item = datetime.datetime(year, month, day, hour, minute, second)\n        # Format the datetime object using the specified format\n        return time_item.strftime(format)"}, {"id": "88", "llm_annotated_code": "from math import pi, fabs\n\nclass TriCalculator:\n    \"\"\"\n    The class allows to calculate trigonometric values, including cosine, sine, and tangent, using Taylor series approximations.\n    \"\"\"\n\n\n    def __init__(self):\n        pass\n\n    def cos(self, x):\n        \"\"\"\n        Calculate the cos value of the x-degree angle\n        :param x:float\n        :return:float\n        >>> tricalculator = TriCalculator()\n        >>> tricalculator.cos(60)\n        0.5\n        \"\"\"\n        # Call the taylor method to calculate cosine using Taylor series approximation\n        # The second parameter (50) represents the number of terms in the Taylor series\n        # Round the result to 10 decimal places for precision\n        return round(self.taylor(x, 50), 10)\n\n    def factorial(self, a):\n        \"\"\"\n        Calculate the factorial of a\n        :param a: int\n        :return: int\n        >>> tricalculator.factorial(5)\n        120\n        \"\"\"\n        # Initialize the result to 1\n        b = 1\n        # Multiply b by each number from a down to 2\n        while a != 1:\n            b *= a\n            a -= 1\n        # Return the factorial result\n        return b\n\n    def taylor(self, x, n):\n        \"\"\"\n        Finding the n-order Taylor expansion value of cos (x/180 * pi)\n        :param x: int\n        :param n: int\n        :return: float\n        >>> tricalculator.taylor(60, 50)\n        0.5000000000000001\n        \"\"\"\n        # Initialize the result with the first term of the Taylor series (1)\n        a = 1\n        # Convert the angle from degrees to radians\n        x = x / 180 * pi\n        # Initialize a counter to track even/odd terms\n        count = 1\n        # Calculate the Taylor series for cosine up to n terms\n        for k in range(1, n):\n            # Alternate between subtraction and addition based on the term count\n            if count % 2 != 0:\n                a -= (x ** (2 * k)) / self.factorial(2 * k)\n            else:\n                a += (x ** (2 * k)) / self.factorial(2 * k)\n            count += 1\n        # Return the approximated cosine value\n        return a\n\n    def sin(self, x):\n        \"\"\"\n        Calculate the sin value of the x-degree angle\n        :param x: float\n        :return: float\n        >>> tricalculator.sin(30)\n        0.5\n        \"\"\"\n        # Convert the angle from degrees to radians\n        x = x / 180 * pi\n        # Initialize the result to 0\n        g = 0\n        # Initialize the first term of the Taylor series\n        t = x\n        # Initialize the counter for the factorial calculation\n        n = 1\n\n        # Continue adding terms until the term becomes negligibly small\n        while fabs(t) >= 1e-15:\n            # Add the current term to the result\n            g += t\n            # Increment the counter\n            n += 1\n            # Calculate the next term using the recurrence relation for sine Taylor series\n            t = -t * x * x / (2 * n - 1) / (2 * n - 2)\n        # Round the result to 10 decimal places for precision\n        return round(g, 10)\n\n\n    def tan(self, x):\n        \"\"\"\n        Calculate the tan value of the x-degree angle\n        :param x: float\n        :return: float\n        >>> tricalculator.tan(45)\n        1.0\n        \"\"\"\n        # Calculate cosine of x using the cos method\n        cos_x = self.cos(x)\n        # Check if cosine is zero to avoid division by zero\n        if cos_x != 0:\n            # Calculate tangent as sine divided by cosine\n            result = self.sin(x) / cos_x\n            # Round the result to 10 decimal places for precision\n            return round(result, 10)\n        else:\n            # Return False if cosine is zero (tangent is undefined)\n            return False"}, {"id": "89", "llm_annotated_code": "```python\nimport random\n\nclass TwentyFourPointGame:\n    \"\"\"\n    This ia a game of twenty-four points, which provides to generate four numbers and check whether player's expression is equal to 24.\n    \"\"\"\n\n    def __init__(self) -> None:\n        # Initialize an empty list to store the four random numbers\n        self.nums = []\n\n\n    def _generate_cards(self):\n        \"\"\"\n        Generate random numbers between 1 and 9 for the cards.\n        \"\"\"\n        # Generate 4 random integers between 1 and 9 and append them to self.nums\n        for i in range(4):\n            self.nums.append(random.randint(1, 9))\n        # Verify that exactly 4 numbers were generated\n        assert len(self.nums) == 4\n\n\n    def get_my_cards(self):\n        \"\"\"\n        Get a list of four random numbers between 1 and 9 representing the player's cards.\n        :return: list of integers, representing the player's cards\n        >>> game = TwentyFourPointGame()\n        >>> game.get_my_cards()\n\n        \"\"\"\n        # Reset the nums list to empty before generating new cards\n        self.nums = []\n        # Call the _generate_cards method to populate self.nums with 4 random numbers\n        self._generate_cards()\n        # Return the generated numbers\n        return self.nums\n    \n\n\n    def answer(self, expression):\n        \"\"\"\n        Check if a given mathematical expression using the cards can evaluate to 24.\n        :param expression: string, mathematical expression using the cards\n        :return: bool, True if the expression evaluates to 24, False otherwise\n        >>> game = TwentyFourPointGame()\n        >>> game.nums = [4, 3, 6, 6]\n        >>> ans = \"4*3+6+6\"\n        >>> ret = game.answer(ans)\n        True\n        \"\"\"\n        # If the player passes, generate new cards and return them\n        if expression == 'pass':\n            return self.get_my_cards()\n        \n        # Create a dictionary to count occurrences of each digit in the expression\n        statistic = {}\n        for c in expression:\n            # If the character is a digit and exists in self.nums, count it\n            if c.isdigit() and int(c) in self.nums:\n                statistic[c] = statistic.get(c, 0) + 1\n\n        # Create a copy of the statistics to track which numbers are used\n        nums_used = statistic.copy()\n\n        # Verify that all digits in the expression are from the available cards\n        for num in self.nums:\n            if nums_used.get(str(num), -100) != -100 and nums_used[str(num)] > 0:\n                nums_used[str(num)] -= 1\n            else:\n                return False\n\n        # If all numbers from self.nums are used in the expression, evaluate it\n        if all(count == 0 for count in nums_used.values()) == True:\n            return self.evaluate_expression(expression)\n        else:\n            return False\n\n\n    def evaluate_expression(self, expression):\n        \"\"\"\n        Evaluate a mathematical expression and check if the result is 24.\n        :param expression: string, mathematical expression\n        :return: bool, True if the expression evaluates to 24, False otherwise\n        >>> game = TwentyFourPointGame()\n        >>> nums = [4, 3, 6, 6]\n        >>> ans = \"4*3+6+6\"\n        >>> ret = game.evaluate_expression(ans)\n        True\n        \"\"\"\n        try:\n            # Use Python's eval function to evaluate the mathematical expression\n            # Return True if the result equals 24, False otherwise\n            if eval(expression) == 24:\n                return True\n            else:\n                return False\n        except Exception as e:\n            # If there's any error in evaluating the expression, return False\n            return False\n```"}, {"id": "90", "llm_annotated_code": "class URLHandler:\n    \"\"\"\n    The class supports to handle URLs, including extracting the scheme, host, path, query parameters, and fragment.\n    \"\"\"\n\n    def __init__(self, url):\n        \"\"\"\n        Initialize URLHandler's URL\n        \"\"\"\n        # Store the URL string for later parsing by other methods\n        self.url = url\n\n    def get_scheme(self):\n        \"\"\"\n        get the scheme of the URL\n        :return: string, If successful, return the scheme of the URL\n        >>> urlhandler = URLHandler(\"https://www.baidu.com/s?wd=aaa&rsv_spt=1#page\")\n        >>> urlhandler.get_scheme()\n        \"https\"\n        \"\"\"\n        # Find the position of \"://\" which marks the end of the scheme\n        scheme_end = self.url.find(\"://\")\n        # If \"://\" is found, return everything before it as the scheme\n        if scheme_end != -1:\n            return self.url[:scheme_end]\n        # Return None if no scheme is found\n        return None\n\n\n    def get_host(self):\n        \"\"\"\n        Get the second part of the URL, which is the host domain name\n        :return: string, If successful, return the host domain name of the URL\n        >>> urlhandler = URLHandler(\"https://www.baidu.com/s?wd=aaa&rsv_spt=1#page\")\n        >>> urlhandler.get_host()\n        \"www.baidu.com\"\n        \"\"\"\n        # Find the position of \"://\" which marks the end of the scheme\n        scheme_end = self.url.find(\"://\")\n        if scheme_end != -1:\n            # Extract the URL without the scheme part\n            url_without_scheme = self.url[scheme_end + 3:]\n            # Find the first \"/\" after the host which marks the end of the host\n            host_end = url_without_scheme.find(\"/\")\n            if host_end != -1:\n                # Return the host part if a \"/\" is found\n                return url_without_scheme[:host_end]\n            # If no \"/\" is found, the entire remaining string is the host\n            return url_without_scheme\n        # Return None if no scheme is found\n        return None\n\n\n    def get_path(self):\n        \"\"\"\n        Get the third part of the URL, which is the address of the resource\n        :return: string, If successful, return the address of the resource of the URL\n        >>> urlhandler = URLHandler(\"https://www.baidu.com/s?wd=aaa&rsv_spt=1#page\")\n        >>> urlhandler.get_path()\n        \"/s?wd=aaa&rsv_spt=1#page\"\n        \"\"\"\n        # Find the position of \"://\" which marks the end of the scheme\n        scheme_end = self.url.find(\"://\")\n        if scheme_end != -1:\n            # Extract the URL without the scheme part\n            url_without_scheme = self.url[scheme_end + 3:]\n            # Find the first \"/\" after the host which marks the beginning of the path\n            host_end = url_without_scheme.find(\"/\")\n            if host_end != -1:\n                # Return everything after the host as the path\n                return url_without_scheme[host_end:]\n        # Return None if no path is found\n        return None\n\n\n    def get_query_params(self):\n        \"\"\"\n        Get the request parameters for the URL\n        :return: dict, If successful, return the request parameters of the URL\n        >>> urlhandler = URLHandler(\"https://www.baidu.com/s?wd=aaa&rsv_spt=1#page\")\n        >>> urlhandler.get_query_params()\n        {\"wd\": \"aaa\", \"rsv_spt\": \"1\"}\n        \"\"\"\n        # Find the position of \"?\" which marks the beginning of query parameters\n        query_start = self.url.find(\"?\")\n        # Find the position of \"#\" which marks the beginning of the fragment\n        fragment_start = self.url.find(\"#\")\n        \n        if query_start != -1:\n            # Extract the query string between \"?\" and \"#\" (or end of string if no \"#\")\n            query_string = self.url[query_start + 1:fragment_start] if fragment_start != -1 else self.url[query_start + 1:]\n            params = {}\n            if len(query_string) > 0:\n                # Split the query string by \"&\" to get individual parameter pairs\n                param_pairs = query_string.split(\"&\")\n                for pair in param_pairs:\n                    # Split each pair by \"=\" to get key and value\n                    key_value = pair.split(\"=\")\n                    if len(key_value) == 2:\n                        key, value = key_value\n                        # Store the key-value pair in the params dictionary\n                        params[key] = value\n            return params\n        # Return None if no query parameters are found\n        return None\n\n\n    def get_fragment(self):\n        \"\"\"\n        Get the fragment after '#' in the URL\n        :return: string, If successful, return the fragment after '#' of the URL\n        >>> urlhandler = URLHandler(\"https://www.baidu.com/s?wd=aaa&rsv_spt=1#page\")\n        >>> urlhandler.get_fragment()\n        \"page\"\n        \"\"\"\n        # Find the position of \"#\" which marks the beginning of the fragment\n        fragment_start = self.url.find(\"#\")\n        # If \"#\" is found, return everything after it as the fragment\n        if fragment_start != -1:\n            return self.url[fragment_start + 1:]\n        # Return None if no fragment is found\n        return None"}, {"id": "91", "llm_annotated_code": "```python\nimport urllib.parse\n\nclass UrlPath:\n    \"\"\"\n    The  class is a utility for encapsulating and manipulating the path component of a URL, including adding nodes, parsing path strings, and building path strings with optional encoding.      \n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initializes the UrlPath object with an empty list of segments and a flag indicating the presence of an end tag.\n        \"\"\"\n        self.segments = []  # Initialize an empty list to store path segments\n        self.with_end_tag = False  # Flag to track if the path ends with a slash\n\n    def add(self, segment):\n        \"\"\"\n        Adds a segment to the list of segments in the UrlPath.\n        :param segment: str, the segment to add.\n        >>> url_path = UrlPath()\n        >>> url_path.add('foo')\n        >>> url_path.add('bar')\n\n        url_path.segments = ['foo', 'bar']\n        \"\"\"\n        # Use the fix_path static method to clean the segment before adding it to the segments list\n        self.segments.append(self.fix_path(segment))\n\n\n    def parse(self, path, charset):\n        \"\"\"\n        Parses a given path string and populates the list of segments in the UrlPath.\n        :param path: str, the path string to parse.\n        :param charset: str, the character encoding of the path string.\n        >>> url_path = UrlPath()\n        >>> url_path.parse('/foo/bar/', 'utf-8')\n\n        url_path.segments = ['foo', 'bar']\n        \"\"\"\n        if path:\n            # Check if the path ends with a slash and set the with_end_tag flag accordingly\n            if path.endswith('/'):\n                self.with_end_tag = True\n\n            # Clean the path using the fix_path static method\n            path = self.fix_path(path)\n            if path:\n                # Split the path by '/' to get individual segments\n                split = path.split('/')\n                for seg in split:\n                    # Use urllib.parse.unquote to decode URL-encoded characters in each segment\n                    decoded_seg = urllib.parse.unquote(seg, encoding=charset)\n                    # Add the decoded segment to the segments list\n                    self.segments.append(decoded_seg)\n\n\n    @staticmethod\n    def fix_path(path):\n        \"\"\"\n        Fixes the given path string by removing leading and trailing slashes.\n        :param path: str, the path string to fix.\n        :return: str, the fixed path string.\n        >>> url_path = UrlPath()\n        >>> url_path.fix_path('/foo/bar/')\n        'foo/bar'\n\n        \"\"\"\n        if not path:\n            return ''\n\n        # Remove leading and trailing slashes from the path\n        segment_str = path.strip('/')\n        return segment_str\n```"}, {"id": "92", "llm_annotated_code": "class UserLoginDB:\n    \"\"\"\n    This is a database management class for user login verification, providing functions for inserting user information, searching user information, deleting user information, and validating user login.\n    \"\"\"\n\n    def __init__(self, db_name):\n        \"\"\"\n        Initializes the UserLoginDB object with the specified database name.\n        :param db_name: str, the name of the SQLite database.\n        \"\"\"\n        # Connect to the SQLite database with the provided name\n        self.connection = sqlite3.connect(db_name)\n        # Create a cursor object to execute SQL commands\n        self.cursor = self.connection.cursor()\n\n    def insert_user(self, username, password):\n        \"\"\"\n        Inserts a new user into the \"users\" table.\n        :param username: str, the username of the user.\n        :param password: str, the password of the user.\n        :return: None\n        >>> user_db = UserLoginDB(\"user_database.db\")\n        >>> user_db.create_table()\n        >>> user_db.insert_user('user1', 'pass1')\n        \"\"\"\n        # Execute SQL to insert a new user with the provided username and password\n        # Uses parameterized query to prevent SQL injection\n        self.cursor.execute(\"\"\"\n            INSERT INTO users (username, password)\n            VALUES (?, ?)\n        \"\"\", (username, password))\n        # Commit the transaction to save changes to the database\n        self.connection.commit()\n\n\n    def search_user_by_username(self, username):\n        \"\"\"\n        Searches for users in the \"users\" table by username.\n        :param username: str, the username of the user to search for.\n        :return:list of tuples, the rows from the \"users\" table that match the search criteria.\n        >>> user_db = UserLoginDB(\"user_database.db\")\n        >>> user_db.create_table()\n        >>> user_db.insert_user('user1', 'pass1')\n        >>> result = user_db.search_user_by_username('user1')\n        len(result) = 1\n        \"\"\"\n        # Execute SQL to search for a user with the provided username\n        # Uses parameterized query with a tuple containing username\n        self.cursor.execute(\"\"\"\n            SELECT * FROM users WHERE username = ?\n        \"\"\", (username,))\n        # Fetch the first matching row (or None if no match)\n        user = self.cursor.fetchone()\n        # Return the user data (typically a tuple with id, username, password)\n        return user\n\n\n    def delete_user_by_username(self, username):\n        \"\"\"\n        Deletes a user from the \"users\" table by username.\n        :param username: str, the username of the user to delete.\n        :return: None\n        >>> user_db = UserLoginDB(\"user_database.db\")\n        >>> user_db.create_table()\n        >>> user_db.insert_user('user1', 'pass1')\n        >>> user_db.delete_user_by_username('user1')\n        \"\"\"\n        # Execute SQL to delete the user with the provided username\n        # Uses parameterized query to prevent SQL injection\n        self.cursor.execute(\"\"\"\n            DELETE FROM users WHERE username = ?\n        \"\"\", (username,))\n        # Commit the transaction to save changes to the database\n        self.connection.commit()\n\n\n    def validate_user_login(self, username, password):\n        \"\"\"\n        Determine whether the user can log in, that is, the user is in the database and the password is correct\n        :param username:str, the username of the user to validate.\n        :param password:str, the password of the user to validate.\n        :return:bool, representing whether the user can log in correctly\n        >>> user_db = UserLoginDB(\"user_database.db\")\n        >>> user_db.create_table()\n        >>> user_db.insert_user('user1', 'pass1')\n        >>> user_db.validate_user_login('user1', 'pass1')\n        True\n        \"\"\"\n        # Call the search_user_by_username method to get the user data\n        user = self.search_user_by_username(username)\n        # Check if the user exists and the password matches\n        # user[1] is the password field in the returned tuple\n        if user is not None and user[1] == password:\n            return True\n        # Return False if user doesn't exist or password doesn't match\n        return False"}, {"id": "94", "llm_annotated_code": "class VendingMachine:\n    \"\"\"\n    This is a class to simulate a vending machine, including adding products, inserting coins, purchasing products, viewing balance, replenishing product inventory, and displaying product information.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initializes the vending machine's inventory and balance.\n        \"\"\"\n        # Initialize an empty dictionary to store the inventory of products\n        self.inventory = {}\n        # Initialize the balance (money inserted by customers) to zero\n        self.balance = 0\n\n    def add_item(self, item_name, price, quantity):\n        \"\"\"\n        Adds a product to the vending machine's inventory.\n        :param item_name: The name of the product to be added, str.\n        :param price: The price of the product to be added, float.\n        :param quantity: The quantity of the product to be added, int.\n        :return: None\n        >>> vendingMachine = VendingMachine()\n        >>> vendingMachine.add_item('Coke', 1.25, 10)\n        >>> vendingMachine.inventory\n        {'Coke': {'price': 1.25, 'quantity': 10}}\n\n        \"\"\"\n        # First try to restock the item if it already exists in inventory\n        # If restock_item returns False (item doesn't exist), add it as a new item\n        if not self.restock_item(item_name, quantity):\n            # Create a new entry in the inventory dictionary with price and quantity\n            self.inventory[item_name] = {'price': price, 'quantity': quantity}\n\n    def insert_coin(self, amount):\n        \"\"\"\n        Inserts coins into the vending machine.\n        :param amount: The amount of coins to be inserted, float.\n        :return: The balance of the vending machine after the coins are inserted, float.\n        >>> vendingMachine = VendingMachine()\n        >>> vendingMachine.insert_coin(1.25)\n        1.25\n\n        \"\"\"\n        # Add the inserted amount to the current balance\n        self.balance += amount\n        # Return the updated balance\n        return self.balance\n\n    def purchase_item(self, item_name):\n        \"\"\"\n        Purchases a product from the vending machine and returns the balance after the purchase and display purchase unsuccessful if the product is out of stock.\n        :param item_name: The name of the product to be purchased, str.\n        :return: If successful, returns the balance of the vending machine after the product is purchased, float,otherwise,returns False.\n        >>> vendingMachine = VendingMachine()\n        >>> vendingMachine.inventory = {'Coke': {'price': 1.25, 'quantity': 10}}\n        >>> vendingMachine.balance = 1.25\n        >>> vendingMachine.purchase_item('Coke')\n        0.0\n        >>> vendingMachine.purchase_item('Pizza')\n        False\n\n        \"\"\"\n        # Check if the requested item exists in the inventory\n        if item_name in self.inventory:\n            # Get the item details from the inventory\n            item = self.inventory[item_name]\n            # Check if the item is in stock and if the customer has enough balance\n            if item['quantity'] > 0 and self.balance >= item['price']:\n                # Deduct the item price from the balance\n                self.balance -= item['price']\n                # Decrease the item quantity by 1\n                item['quantity'] -= 1\n                # Return the remaining balance\n                return self.balance\n            else:\n                # Return False if item is out of stock or insufficient balance\n                return False\n        else:\n            # Return False if the item doesn't exist in inventory\n            return False\n\n    def restock_item(self, item_name, quantity):\n        \"\"\"\n        Replenishes the inventory of a product already in the vending machine.\n        :param item_name: The name of the product to be replenished, str.\n        :param quantity: The quantity of the product to be replenished, int.\n        :return: If the product is already in the vending machine, returns True, otherwise, returns False.\n        >>> vendingMachine = VendingMachine()\n        >>> vendingMachine.inventory = {'Coke': {'price': 1.25, 'quantity': 10}}\n        >>> vendingMachine.restock_item('Coke', 10)\n        True\n        >>> vendingMachine.restock_item('Pizza', 10)\n        False\n\n        \"\"\"\n        # Check if the item exists in the inventory\n        if item_name in self.inventory:\n            # Increase the quantity of the existing item\n            self.inventory[item_name]['quantity'] += quantity\n            # Return True to indicate successful restocking\n            return True\n        else:\n            # Return False if the item doesn't exist in inventory\n            return False\n\n    def display_items(self):\n        \"\"\"\n        Displays the products in the vending machine.\n        :return: If the vending machine is empty, returns False, otherwise, returns a list of the products in the vending machine, str.\n        >>> vendingMachine = VendingMachine()\n        >>> vendingMachine.display_items()\n        False\n        >>> vendingMachine.inventory = {'Coke': {'price': 1.25, 'quantity': 10} }\n        >>> vendingMachine.display_items()\n        'Coke - $1.25 [10]'\n\n        \"\"\"\n        # Check if the inventory is empty\n        if not self.inventory:\n            # Return False if there are no items in the inventory\n            return False\n        else:\n            # Create an empty list to store formatted item strings\n            items = []\n            # Iterate through each item in the inventory\n            for item_name, item_info in self.inventory.items():\n                # Format each item as \"name - $price [quantity]\" and add to the list\n                items.append(f\"{item_name} - ${item_info['price']} [{item_info['quantity']}]\")\n            # Join all formatted item strings with newlines and return\n            return \"\\n\".join(items)"}, {"id": "95", "llm_annotated_code": "class Warehouse:\n    \"\"\"\n    The class manages inventory and orders, including adding products, updating product quantities, retrieving product quantities, creating orders, changing order statuses, and tracking orders.    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize two fields.\n        self.inventory is a dict that stores the products.\n        self.inventory = {Product ID: Product}\n        self.orders is a dict that stores the products in a order.\n        self.orders = {Order ID: Order}\n        \"\"\"\n        self.inventory = {}  # Product ID: Product\n        self.orders = {}  # Order ID: Order\n\n    def add_product(self, product_id, name, quantity):\n        \"\"\"\n        Add product to inventory and plus the quantity if it has existed in inventory.\n        Or just add new product to dict otherwise.\n        :param product_id: int\n        :param name: str, product name\n        :param quantity: int, product quantity\n        >>> warehouse.add_product(1, \"product1\", 3)\n        >>> warehouse.inventory\n        {1: {'name': 'product1', 'quantity': 3}}\n        \"\"\"\n        # Check if the product already exists in the inventory\n        if product_id not in self.inventory:\n            # If not, create a new product entry with the given name and quantity\n            self.inventory[product_id] = {'name': name, 'quantity': quantity}\n        else:\n            # If the product exists, increment its quantity by the given amount\n            self.inventory[product_id]['quantity'] += quantity\n\n    def update_product_quantity(self, product_id, quantity):\n        \"\"\"\n        According to product_id, add the quantity to the corresponding product in inventory.\n        >>> warehouse.add_product(1, \"product1\", 3)\n        >>> warehouse.update_product_quantity(1, -1)\n        >>> warehouse.inventory\n        {1: {'name': 'product1', 'quantity': 2}}\n        \"\"\"\n        # Check if the product exists in the inventory\n        if product_id in self.inventory:\n            # Update the product quantity by adding the given quantity (can be positive or negative)\n            self.inventory[product_id]['quantity'] += quantity\n\n    def get_product_quantity(self, product_id):\n        \"\"\"\n        Get the quantity of specific product by product_id.\n        :param product_id, int\n        :return: if the product_id is in inventory then return the corresponding quantity,\n                or False otherwise.\n        >>> warehouse.add_product(1, \"product1\", 3)\n        >>> warehouse.get_product_quantity(1)\n        3\n        >>> warehouse.get_product_quantity(2)\n        False\n        \"\"\"\n        # Check if the product exists in the inventory\n        if product_id in self.inventory:\n            # Return the quantity of the product\n            return self.inventory[product_id]['quantity']\n        else:\n            # Return False if the product doesn't exist\n            return False\n\n    def create_order(self, order_id, product_id, quantity):\n        \"\"\"\n        Create a order which includes the infomation of product, like id and quantity.\n        And put the new order into self.orders.\n        The default value of status is 'Shipped'.\n        :param order_id: int\n        :param product_id: int\n        :param quantity: the quantity of product that be selected.\n        :return False: only if product_id is not in inventory or the quantity is not adequate\n        >>> warehouse.add_product(1, \"product1\", 3)\n        >>> warehouse.create_order(1, 1, 2)\n        >>> warehouse.orders\n        {1: {'product_id': 1, 'quantity': 2, 'status': 'Shipped'}}\n        >>> warehouse.create_order(1, 2, 2)\n        False\n        \"\"\"\n        # Use the get_product_quantity method to check if the product exists and has enough quantity\n        if self.get_product_quantity(product_id) >= quantity:\n            # Update the product quantity by subtracting the ordered amount\n            self.update_product_quantity(product_id, -quantity)\n            # Create a new order with the given product_id, quantity, and default status 'Shipped'\n            self.orders[order_id] = {'product_id': product_id, 'quantity': quantity, 'status': 'Shipped'}\n        else:\n            # Return False if the product doesn't exist or doesn't have enough quantity\n            return False\n\n    def change_order_status(self, order_id, status):\n        \"\"\"\n        Change the status of order if the input order_id is in self.orders.\n        :param order_id: int\n        :param status: str, the state that is going to change to\n        :return False: only if the order_id is not in self.orders\n        >>> warehouse.add_product(1, \"product1\", 3)\n        >>> warehouse.create_order(1, 1, 2)\n        >>> warehouse.change_order_status(1, \"done\")\n        >>> warehouse.orders\n        {1: {'product_id': 1, 'quantity': 2, 'status': 'done'}}\n        \"\"\"\n        # Check if the order exists in the orders dictionary\n        if order_id in self.orders:\n            # Update the status of the order\n            self.orders[order_id]['status'] = status\n        else:\n            # Return False if the order doesn't exist\n            return False\n\n    def track_order(self, order_id):\n        \"\"\"\n        Get the status of specific order.\n        :param order_id: int\n        :return False: only if the order_id is not in self.orders.\n        >>> warehouse.add_product(1, \"product1\", 3)\n        >>> warehouse.create_order(1, 1, 2)\n        >>> warehouse.track_order(1)\n        'Shipped'\n        \"\"\"\n        # Check if the order exists in the orders dictionary\n        if order_id in self.orders:\n            # Return the status of the order\n            return self.orders[order_id]['status']\n        else:\n            # Return False if the order doesn't exist\n            return False"}, {"id": "96", "llm_annotated_code": "class WeatherSystem:\n    \"\"\"\n    This is a class representing a weather system that provides functionality to query weather information for a specific city and convert temperature units between Celsius and Fahrenheit.     \n    \"\"\"\n\n    def __init__(self, city) -> None:\n        \"\"\"\n        Initialize the weather system with a city name.\n        \"\"\"\n        # Initialize temperature attribute to None\n        self.temperature = None\n        # Initialize weather attribute to None\n        self.weather = None\n        # Store the city name passed as parameter\n        self.city = city\n        # Initialize an empty dictionary to store weather data\n        self.weather_list = {}\n\n    def query(self, weather_list, tmp_units = 'celsius'):\n        \"\"\"\n        Query the weather system for the weather and temperature of the city,and convert the temperature units based on the input parameter.\n        :param weather_list: a dictionary of weather information for different cities,dict.\n        :param tmp_units: the temperature units to convert to, str.\n        :return: the temperature and weather of the city, tuple.\n        >>> weatherSystem = WeatherSystem('New York')\n        >>> weather_list = {'New York': {'weather': 'sunny','temperature': 27,'temperature units': 'celsius'},'Beijing': {'weather': 'cloudy','temperature': 23,'temperature units': 'celsius'}} \n        >>> weatherSystem.query(weather_list)\n        (27, 'sunny')\n\n        \"\"\"\n        # Store the weather_list dictionary in the instance variable\n        self.weather_list = weather_list\n        # Check if the current city exists in the weather_list\n        if self.city not in weather_list:\n            # Return False if city not found\n            return False\n        else:\n            # Extract temperature and weather for the city from weather_list\n            self.temperature = self.weather_list[self.city]['temperature']\n            self.weather = self.weather_list[self.city]['weather']\n        # Check if temperature units conversion is needed\n        if self.weather_list[self.city]['temperature units'] != tmp_units:\n            if tmp_units == 'celsius':\n                # Convert from Fahrenheit to Celsius using class method\n                return self.fahrenheit_to_celsius(), self.weather\n            elif tmp_units == 'fahrenheit':\n                # Convert from Celsius to Fahrenheit using class method\n                return self.celsius_to_fahrenheit(), self.weather\n        else:\n            # Return temperature and weather without conversion\n            return self.temperature, self.weather\n\n    def set_city(self, city):\n        \"\"\"\n        Set the city of the weather system.\n        :param city: the city to set, str.\n        :return: None\n        >>> weatherSystem = WeatherSystem('New York')\n        >>> weatherSystem.set_city('Beijing')\n        >>> weatherSystem.city\n        'Beijing'\n\n        \"\"\"\n        # Update the city attribute with the new city name\n        self.city = city\n\n    def celsius_to_fahrenheit(self):\n        \"\"\"\n        Convert the temperature from Celsius to Fahrenheit.\n        :return: the temperature in Fahrenheit, float.\n        >>> weatherSystem = WeatherSystem('New York')\n        >>> weatherSystem.temperature = 27\n        >>> weatherSystem.celsius_to_fahrenheit()\n        80.6\n\n        \"\"\"\n        # Apply the Celsius to Fahrenheit conversion formula to self.temperature\n        # Formula: (C \u00d7 9/5) + 32 = F\n        return (self.temperature * 9/5) + 32\n\n    def fahrenheit_to_celsius(self):\n        \"\"\"\n        Convert the temperature from Fahrenheit to Celsius.\n        :return: the temperature in Celsius, float.\n        >>> weatherSystem = WeatherSystem('New York')\n        >>> weatherSystem.temperature = 80.6\n        >>> weatherSystem.fahrenheit_to_celsius()\n        26.999999999999996\n\n        \"\"\"\n        # Apply the Fahrenheit to Celsius conversion formula to self.temperature\n        # Formula: (F - 32) \u00d7 5/9 = C\n        return (self.temperature - 32) * 5/9"}, {"id": "97", "llm_annotated_code": "class Words2Numbers:\n    \"\"\"\n    The class provides a text-to-number conversion utility, allowing conversion of written numbers (in words) to their numerical representation.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the word lists and dictionaries required for conversion\n        \"\"\"\n        self.numwords = {}\n        self.units = [\n            \"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\",\n            \"nine\", \"ten\", \"eleven\", \"twelve\", \"thirteen\", \"fourteen\", \"fifteen\",\n            \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\",\n        ]\n        self.tens = [\"\", \"\", \"twenty\", \"thirty\", \"forty\", \"fifty\", \"sixty\", \"seventy\", \"eighty\", \"ninety\"]\n        self.scales = [\"hundred\", \"thousand\", \"million\", \"billion\", \"trillion\"]\n\n        # Add \"and\" to the numwords dictionary with a value of (1, 0)\n        self.numwords[\"and\"] = (1, 0)\n        # Populate numwords dictionary with unit words (one, two, etc.) and their values\n        for idx, word in enumerate(self.units):\n            self.numwords[word] = (1, idx)\n        # Populate numwords dictionary with tens words (twenty, thirty, etc.) and their values\n        for idx, word in enumerate(self.tens):\n            self.numwords[word] = (1, idx * 10)\n        # Populate numwords dictionary with scale words (hundred, thousand, etc.) and their values\n        for idx, word in enumerate(self.scales):\n            self.numwords[word] = (10 ** (idx * 3 or 2), 0)\n\n        # Dictionary for special ordinal words that don't follow regular patterns\n        self.ordinal_words = {'first': 1, 'second': 2, 'third': 3, 'fifth': 5, 'eighth': 8, 'ninth': 9, 'twelfth': 12}\n        # List of tuples for ordinal endings and their replacements\n        self.ordinal_endings = [('ieth', 'y'), ('th', '')]\n\n\n    def text2int(self, textnum):\n        \"\"\"\n        Convert the word string to the corresponding integer string\n        :param textnum: string, the word string to be converted\n        :return: string, the final converted integer string\n        >>> w2n = Words2Numbers()\n        >>> w2n.text2int(\"thirty-two\")\n        \"32\"\n        \"\"\"\n\n        # Replace hyphens with spaces to standardize input format\n        textnum = textnum.replace('-', ' ')\n\n        # Initialize variables to track current value, result, and state\n        current = result = 0\n        curstring = \"\"\n        onnumber = False\n\n        # Process each word in the input text\n        for word in textnum.split():\n            # Check if the word is a special ordinal word\n            if word in self.ordinal_words:\n                scale, increment = (1, self.ordinal_words[word])\n                current = current * scale + increment\n                onnumber = True\n            else:\n                # Check if the word has an ordinal ending and transform it\n                for ending, replacement in self.ordinal_endings:\n                    if word.endswith(ending):\n                        word = \"%s%s\" % (word[:-len(ending)], replacement)\n                \n                # If the word is not in our dictionary, handle non-numeric text\n                if word not in self.numwords:\n                    if onnumber:\n                        # Add the current number to the result string\n                        curstring += repr(result + current) + \" \"\n                        curstring += word + \" \"\n                    # Reset tracking variables\n                    result = current = 0\n                    onnumber = False\n                else:\n                    # Get the scale and increment values for this word\n                    scale, increment = self.numwords[word]\n                    # Apply the scale and increment to the current value\n                    current = current * scale + increment\n                    # If we hit a large scale word (hundred or above), add to result\n                    if scale > 100:\n                        result += current\n                        current = 0\n                    onnumber = True\n\n        # Add any remaining number to the result string\n        if onnumber:\n            curstring += repr(result + current)\n        \n        # Return the final converted string\n        return curstring\n\n    def is_valid_input(self, textnum):\n        \"\"\"\n        Check if the input text contains only valid words that can be converted into numbers.\n        :param textnum: The input text containing words representing numbers.\n        :return: True if input is valid, False otherwise.\n        >>> w2n = Words2Numbers()\n        >>> w2n.is_valid_input(\"thirty-two\")\n        False\n        \"\"\"\n\n        # Replace hyphens with spaces to standardize input format\n        textnum = textnum.replace('-', ' ')\n        \n        # Check each word in the input text\n        for word in textnum.split():\n            # Check if the word is a special ordinal word\n            if word in self.ordinal_words:\n                continue\n            else:\n                # Check if the word has an ordinal ending and transform it\n                for ending, replacement in self.ordinal_endings:\n                    if word.endswith(ending):\n                        word = \"%s%s\" % (word[:-len(ending)], replacement)\n                \n                # If the word is not in our dictionary, the input is invalid\n                if word not in self.numwords:\n                    return False\n        \n        # If all words are valid, return True\n        return True"}, {"id": "98", "llm_annotated_code": "```python\nimport xml.etree.ElementTree as ET\n\n\nclass XMLProcessor:\n    \"\"\"\n    This is a class as XML files handler, including reading, writing, processing as well as finding elements in a XML file.\n    \"\"\"\n\n    def __init__(self, file_name):\n        \"\"\"\n        Initialize the XMLProcessor object with the given file name.\n        :param file_name:string, the name of the XML file to be processed.\n        \"\"\"\n        self.file_name = file_name\n        self.root = None\n\n    def read_xml(self):\n        \"\"\"\n        Reads the XML file and returns the root element.\n        :return: Element, the root element of the XML file.\n        >>> xml_processor = XMLProcessor('test.xml')\n        >>> root_element = xml_processor.read_xml()\n        >>> print(root_element)\n        <Element 'root' at 0x7f8e3b7eb180>\n        \"\"\"\n        try:\n            # Use ElementTree to parse the XML file specified by self.file_name\n            tree = ET.parse(self.file_name)\n            # Get the root element of the parsed XML tree\n            self.root = tree.getroot()\n            # Return the root element\n            return self.root\n        except:\n            # Return None if there's an error parsing the XML file\n            return None\n\n\n    def write_xml(self, file_name):\n        \"\"\"\n        Writes the XML data to the specified file.\n        :param file_name: string, the name of the file to write the XML data.\n        :return: bool, True if the write operation is successful, False otherwise.\n        >>> xml_processor = XMLProcessor('test.xml')\n        >>> root = xml_processor.read_xml()\n        >>> success = xml_processor.write_xml('output.xml')\n        >>> print(success)\n        True\n        \"\"\"\n        try:\n            # Create an ElementTree object with self.root as the root element\n            tree = ET.ElementTree(self.root)\n            # Write the ElementTree to the specified file\n            tree.write(file_name)\n            # Return True to indicate success\n            return True\n        except:\n            # Return False if there's an error writing the XML file\n            return False\n\n\n    def process_xml_data(self, file_name):\n        \"\"\"\n        Modifies the data in XML elements and writes the updated XML data to a new file.\n        :param file_name: string, the name of the file to write the modified XML data.\n        :return: bool, True if the write operation is successful, False otherwise.\n        >>> xml_processor = XMLProcessor('test.xml')\n        >>> root = xml_processor.read_xml()\n        >>> success = xml_processor.process_xml_data('processed.xml')\n        >>> print(success)\n        True\n        \"\"\"\n        # Iterate through all 'item' elements in the XML tree\n        for element in self.root.iter('item'):\n            # Get the text content of the element\n            text = element.text\n            # Convert the text to uppercase\n            element.text = text.upper()\n        # Write the modified XML tree to the specified file using the write_xml method\n        return self.write_xml(file_name)\n\n\n    def find_element(self, element_name):\n        \"\"\"\n        Finds the XML elements with the specified name.\n        :param element_name: string, the name of the elements to find.\n        :return: list, a list of found elements with the specified name.\n        >>> xml_processor = XMLProcessor('test.xml')\n        >>> root = xml_processor.read_xml()\n        >>> items = xml_processor.find_element('item')\n        >>> for item in items:\n        >>>     print(item.text)\n        apple\n        banana\n        orange\n        \"\"\"\n        # Use the findall method of the root element to find all elements with the specified name\n        elements = self.root.findall(element_name)\n        # Return the list of found elements\n        return elements\n```"}, {"id": "99", "llm_annotated_code": "import zipfile\n\n\nclass ZipFileProcessor:\n    \"\"\"\n    This is a compressed file processing class that provides the ability to read and decompress compressed files\n    \"\"\"\n\n    def __init__(self, file_name):\n        \"\"\"\n        Initialize file name\n        :param file_name:string\n        \"\"\"\n        # Store the file name for later use in other methods\n        self.file_name = file_name\n\n    def read_zip_file(self):\n        \"\"\"\n        Get open file object\n        :return:If successful, returns the open file object; otherwise, returns None\n        >>> zfp = ZipFileProcessor(\"aaa.zip\")\n        >>> file = zfp.read_zip_file()\n        \"\"\"\n        try:\n            # Use zipfile.ZipFile to open the file specified in self.file_name in read mode\n            # This creates a ZipFile object that can be used to access the contents\n            zip_file = zipfile.ZipFile(self.file_name, 'r')\n            return zip_file\n        except:\n            # Return None if any exception occurs during file opening\n            # This could be due to file not found, invalid zip format, etc.\n            return None\n\n    def extract_all(self, output_path):\n        \"\"\"\n        Extract all zip files and place them in the specified path\n        :param output_path: string, The location of the extracted file\n        :return: True or False, representing whether the extraction operation was successful\n        >>> zfp = ZipFileProcessor(\"aaa.zip\")\n        >>> zfp.extract_all(\"result/aaa\")\n        \"\"\"\n        try:\n            # Open the zip file using a context manager to ensure proper closure\n            # Use the file name stored in self.file_name in read mode\n            with zipfile.ZipFile(self.file_name, 'r') as zip_file:\n                # Extract all files from the zip to the specified output_path\n                zip_file.extractall(output_path)\n            return True\n        except:\n            # Return False if any exception occurs during extraction\n            # This could be due to permission issues, disk space, etc.\n            return False\n\n    def extract_file(self, file_name, output_path):\n        \"\"\"\n        Extract the file with the specified name from the zip file and place it in the specified path\n        :param file_name:string, The name of the file to be uncompressed\n        :param output_path:string, The location of the extracted file\n        :return: True or False, representing whether the extraction operation was successful\n        >>> zfp = ZipFileProcessor(\"aaa.zip\")\n        >>> zfp.extract_file(\"bbb.txt\", \"result/aaa\")\n        \"\"\"\n        try:\n            # Open the zip file using a context manager to ensure proper closure\n            # Use the file name stored in self.file_name in read mode\n            with zipfile.ZipFile(self.file_name, 'r') as zip_file:\n                # Extract only the specified file_name to the output_path\n                # This is different from extractall as it only extracts one file\n                zip_file.extract(file_name, output_path)\n            return True\n        except:\n            # Return False if any exception occurs during extraction\n            # This could be due to file not found in the zip, permission issues, etc.\n            return False\n\n    def create_zip_file(self, files, output_file_name):\n        \"\"\"\n        Compress the specified file list into a zip file and place it in the specified path\n        :param files:list of string, List of files to compress\n        :param output_file_name: string, Specified output path\n        :return:True or False, representing whether the compression operation was successful\n        >>> zfp = ZipFileProcessor(\"aaa.zip\")\n        >>> zfp.create_zip_file([\"bbb.txt\", \"ccc,txt\", \"ddd.txt\"], \"output/bcd\")\n        \"\"\"\n        try:\n            # Open a new zip file for writing at the specified output_file_name\n            # Note: This doesn't use self.file_name as it's creating a new zip file\n            with zipfile.ZipFile(output_file_name, 'w') as zip_file:\n                # Iterate through each file in the provided list\n                for file in files:\n                    # Add each file to the zip archive\n                    # The write method preserves the directory structure\n                    zip_file.write(file)\n            return True\n        except:\n            # Return False if any exception occurs during compression\n            # This could be due to files not found, permission issues, etc.\n            return False"}]