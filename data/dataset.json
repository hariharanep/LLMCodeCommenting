[
    {
        "id" : "0",
        "code" : "import logging\nimport datetime\n\n\nclass AccessGatewayFilter:\n    \"\"\"\n    This class is a filter used for accessing gateway filtering, primarily for authentication and access log recording.\n    \"\"\"\n\n    def __init__(self):\n        pass\n\n    def filter(self, request):\n        \"\"\"\n        Filter the incoming request based on certain rules and conditions.\n        :param request: dict, the incoming request details\n        :return: bool, True if the request is allowed, False otherwise\n        >>> filter = AccessGatewayFilter()\n        >>> filter.filter({'path': '/login', 'method': 'POST'})\n        True\n\n        >>> filter = AccessGatewayFilter()\n        >>> filter.filter({'path': '/abc', 'method': 'POST', 'headers': {'Authorization': {'user': {'name': 'user1', 'level': 3, 'address': 'address1'}, 'jwt': 'user2' + str(datetime.date.today() - datetime.timedelta(days=365))}}})\n        True\n\n        \"\"\"\n\n        request_uri = request['path'] \n\n        if self.is_start_with(request_uri):\n            return True\n\n        try:\n            authorization = self.get_jwt_user(request)\n            user = authorization['user']\n\n            if user['level'] > 2:\n                self.set_current_user_info_and_log(user)\n                return True\n        except:\n            return False\n        \n        return False\n\n    def is_start_with(self, request_uri):\n        \"\"\"\n        Check if the request URI starts with certain prefixes.\n        Currently, the prefixes being checked are \"/api\" and \"/login\".\n        :param request_uri: str, the URI of the request\n        :return: bool, True if the URI starts with certain prefixes, False otherwise\n        >>> filter = AccessGatewayFilter()\n        >>> filter.is_start_with('/api/data')\n        True\n\n        \"\"\"\n        \n        start_with = [\"/api\", \"/login\"]\n        for s in start_with:\n            if request_uri.startswith(s):\n                return True\n            \n        return False\n\n    def get_jwt_user(self, request):\n        \"\"\"\n        Get the user information from the JWT token in the request.\n        :param request: dict, the incoming request details\n        :return: dict or None, the user information if the token is valid, None otherwise\n        >>> filter = AccessGatewayFilter()\n        >>> filter.get_jwt_user({'headers': {'Authorization': {'user': {'name': 'user1'}, 'jwt': 'user1'+str(datetime.date.today())}}})\n        {'user': {'name': 'user1'}\n\n        \"\"\"\n         \n        authorization = request['headers']['Authorization']\n        user = authorization['user']\n        jwt = authorization['jwt'] \n\n        if jwt.startswith(user['name']):\n            jwt_str_date = jwt.split(user['name'])[1] \n            jwt_date = datetime.datetime.strptime(jwt_str_date, \"%Y-%m-%d\") \n            if datetime.datetime.today() - jwt_date >= datetime.timedelta(days=3):\n                return None\n\n        return authorization\n\n    def set_current_user_info_and_log(self, user):\n        \"\"\"\n        Set the current user information and log the access.\n        :param user: dict, the user information\n        :return: None\n        >>> filter = AccessGatewayFilter()\n        >>> user = {'name': 'user1', 'address': '127.0.0.1'}\n        >>> filter.set_current_user_info_and_log(user)\n\n        \"\"\"\n\n        name = user[name] \n        host = user['address']\n        logging.log(msg=name + host + str(datetime.datetime.now()), level=1)",
        "annotated_code" : "import logging\nimport datetime\n\n\nclass AccessGatewayFilter:\n    \"\"\"\n    This class is a filter used for accessing gateway filtering, primarily for authentication and access log recording.\n    \"\"\"\n\n    def __init__(self):\n        pass\n\n    def filter(self, request):\n        \"\"\"\n        Filter the incoming request based on certain rules and conditions.\n        :param request: dict, the incoming request details\n        :return: bool, True if the request is allowed, False otherwise\n        >>> filter = AccessGatewayFilter()\n        >>> filter.filter({'path': '/login', 'method': 'POST'})\n        True\n\n        >>> filter = AccessGatewayFilter()\n        >>> filter.filter({'path': '/abc', 'method': 'POST', 'headers': {'Authorization': {'user': {'name': 'user1', 'level': 3, 'address': 'address1'}, 'jwt': 'user2' + str(datetime.date.today() - datetime.timedelta(days=365))}}})\n        True\n\n        \"\"\"\n\n        # Extract the URI from the request\n        request_uri = request['path'] \n\n        # Use the is_start_with class method to return True if the request URI starts with valid prefixes\n        if self.is_start_with(request_uri):\n            return True\n\n        try:\n            # Use the get_jwt_user class method to attempt to extract the user authorization information from the request\n            authorization = self.get_jwt_user(request)\n            user = authorization['user']\n\n            # If the user has a sufficient access level (greater than 2) use the set_current_user_info_and_log class method to log the user access info and return True\n            if user['level'] > 2:\n                self.set_current_user_info_and_log(user)\n                return True\n        except:\n            # Return False in the case that any exception comes up\n            return False\n\n        # Return False if none of the above criteria to return True is met\n        return False\n\n    def is_start_with(self, request_uri):\n        \"\"\"\n        Check if the request URI starts with certain prefixes.\n        Currently, the prefixes being checked are \"/api\" and \"/login\".\n        :param request_uri: str, the URI of the request\n        :return: bool, True if the URI starts with certain prefixes, False otherwise\n        >>> filter = AccessGatewayFilter()\n        >>> filter.is_start_with('/api/data')\n        True\n\n        \"\"\"\n        \n        # A list of valid URI prefixes\n        start_with = [\"/api\", \"/login\"]\n        \n        # Return True if request_uri starts with any of the valid URI prefixes \n        for s in start_with:\n            if request_uri.startswith(s):\n                return True\n            \n        # Return False if none of the above criteria to return True is met\n        return False\n\n    def get_jwt_user(self, request):\n        \"\"\"\n        Get the user information from the JWT token in the request.\n        :param request: dict, the incoming request details\n        :return: dict or None, the user information if the token is valid, None otherwise\n        >>> filter = AccessGatewayFilter()\n        >>> filter.get_jwt_user({'headers': {'Authorization': {'user': {'name': 'user1'}, 'jwt': 'user1'+str(datetime.date.today())}}})\n        {'user': {'name': 'user1'}\n\n        \"\"\"\n         \n        # Extract the user information and the jwt token from the request\n        authorization = request['headers']['Authorization']\n        user = authorization['user']\n        jwt = authorization['jwt'] \n\n        # Check if the start of the jwt token matches the user's name\n        if jwt.startswith(user['name']):\n            # Use the datetime.datetime.strptime method to convert the string jwt date in the \"%Y-%m-%d\" format to a datetime object\n            jwt_str_date = jwt.split(user['name'])[1] \n            jwt_date = datetime.datetime.strptime(jwt_str_date, \"%Y-%m-%d\") \n\n            # Use the datetime.datetime.today() method to get the current date and use the datetime.timedelta method to check if the difference between the current date and the jwt date is 3 days or more\n            if datetime.datetime.today() - jwt_date >= datetime.timedelta(days=3):\n                return None\n\n        # Return the authorization information \n        return authorization\n\n    def set_current_user_info_and_log(self, user):\n        \"\"\"\n        Set the current user information and log the access.\n        :param user: dict, the user information\n        :return: None\n        >>> filter = AccessGatewayFilter()\n        >>> user = {'name': 'user1', 'address': '127.0.0.1'}\n        >>> filter.set_current_user_info_and_log(user)\n\n        \"\"\"\n        # Extract the name and host IP address from user\n        name = user[name] \n        host = user['address']\n        \n        # Use the logging.log method to log the user’s name, user's address, and the current time at the INFO level\n        logging.log(msg=name + host + str(datetime.datetime.now()), level=1)"
    },
    {
        "id" : "1",
        "code" : "import math\n\nclass AreaCalculator:\n    \"\"\"\n    This is a class for calculating the area of different shapes, including circle, sphere, cylinder, sector and annulus.\n    \"\"\"\n\n    def __init__(self, radius):\n        \"\"\"\n        Initialize the radius for shapes.\n        :param radius: float\n        \"\"\"\n        self.radius = radius\n\n    def calculate_circle_area(self):\n        \"\"\"\n        calculate the area of circle based on self.radius\n        :return: area of circle, float\n        >>> areaCalculator = AreaCalculator(2)\n        >>> areaCalculator.calculate_circle_area()\n        12.566370614359172\n        \"\"\"\n        return math.pi * self.radius ** 2\n\n    def calculate_sphere_area(self):\n        \"\"\"\n        calculate the area of sphere based on self.radius\n        :return: area of sphere, float\n        >>> areaCalculator = AreaCalculator(2)\n        >>> areaCalculator.calculate_sphere_area()\n        50.26548245743669\n        \"\"\"\n        return 4 * math.pi * self.radius ** 2\n\n    def calculate_cylinder_area(self, height):\n        \"\"\"\n        calculate the area of cylinder based on self.radius and height\n        :param height: height of cylinder, float\n        :return: area of cylinder, float\n        >>> areaCalculator = AreaCalculator(2)\n        >>> areaCalculator.calculate_cylinder_area(3)\n        62.83185307179586\n        \"\"\"\n        return 2 * math.pi * self.radius * (self.radius + height)\n\n    def calculate_sector_area(self, angle):\n        \"\"\"\n        calculate the area of sector based on self.radius and angle\n        :param angle: angle of sector, float\n        :return: area of sector, float\n        >>> areaCalculator = AreaCalculator(2)\n        >>> areaCalculator.calculate_sector_area(math.pi)\n        6.283185307179586\n        \"\"\"\n        return self.radius ** 2 * angle / 2\n\n    def calculate_annulus_area(self, inner_radius, outer_radius):\n        \"\"\"\n        calculate the area of annulus based on inner_radius and out_radius\n        :param inner_radius: inner radius of sector, float\n        :param outer_radius: outer radius of sector, float\n        :return: area of annulus, float\n        >>> areaCalculator.calculate_annulus_area(2, 3)\n        15.707963267948966\n        \"\"\"\n        return math.pi * (outer_radius ** 2 - inner_radius ** 2)",
        "annotated_code" : "import math\n\nclass AreaCalculator:\n    \"\"\"\n    This is a class for calculating the area of different shapes, including circle, sphere, cylinder, sector and annulus.\n    \"\"\"\n\n    def __init__(self, radius):\n        \"\"\"\n        Initialize the radius for shapes.\n        :param radius: float\n        \"\"\"\n        self.radius = radius\n\n    def calculate_circle_area(self):\n        \"\"\"\n        calculate the area of circle based on self.radius\n        :return: area of circle, float\n        >>> areaCalculator = AreaCalculator(2)\n        >>> areaCalculator.calculate_circle_area()\n        12.566370614359172\n        \"\"\"\n        # Use the math.pi constant to calculate the area = π * radius^2 \n        return math.pi * self.radius ** 2\n\n    def calculate_sphere_area(self):\n        \"\"\"\n        calculate the area of sphere based on self.radius\n        :return: area of sphere, float\n        >>> areaCalculator = AreaCalculator(2)\n        >>> areaCalculator.calculate_sphere_area()\n        50.26548245743669\n        \"\"\"\n        # Use the math.pi constant to calculate the area = 4 * π * radius^2\n        return 4 * math.pi * self.radius ** 2\n\n    def calculate_cylinder_area(self, height):\n        \"\"\"\n        calculate the area of cylinder based on self.radius and height\n        :param height: height of cylinder, float\n        :return: area of cylinder, float\n        >>> areaCalculator = AreaCalculator(2)\n        >>> areaCalculator.calculate_cylinder_area(3)\n        62.83185307179586\n        \"\"\"\n        # Use the math.pi constant to calculate the area = 2 * π * radius * (radius + height)\n        return 2 * math.pi * self.radius * (self.radius + height)\n\n    def calculate_sector_area(self, angle):\n        \"\"\"\n        calculate the area of sector based on self.radius and angle\n        :param angle: angle of sector, float\n        :return: area of sector, float\n        >>> areaCalculator = AreaCalculator(2)\n        >>> areaCalculator.calculate_sector_area(math.pi)\n        6.283185307179586\n        \"\"\"\n        # Use the formula radius^2 * angle / 2 to calculate the area\n        return self.radius ** 2 * angle / 2\n\n    def calculate_annulus_area(self, inner_radius, outer_radius):\n        \"\"\"\n        calculate the area of annulus based on inner_radius and out_radius\n        :param inner_radius: inner radius of sector, float\n        :param outer_radius: outer radius of sector, float\n        :return: area of annulus, float\n        >>> areaCalculator.calculate_annulus_area(2, 3)\n        15.707963267948966\n        \"\"\"\n        # Use the math.pi constant to calculate the area = π * (outer_radius^2 - inner_radius^2)\n        return math.pi * (outer_radius ** 2 - inner_radius ** 2)"
    },
    {
        "id" : "2",
        "code" : "class ArgumentParser:\n    \"\"\"\n    This is a class for parsing command line arguments to a dictionary.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the fields.\n        self.arguments is a dict that stores the args in a command line\n        self.requried is a set that stores the required arguments\n        self.types is a dict that stores type of every arguments.\n        >>> parser.arguments\n        {'key1': 'value1', 'option1': True}\n        >>> parser.required\n        {'arg1'}\n        >>> parser.types\n        {'arg1': 'type1'}\n        \"\"\"\n        self.arguments = {}\n        self.required = set()\n        self.types = {}\n\n    def parse_arguments(self, command_string):\n        \"\"\"\n        Parses the given command line argument string and invoke _convert_type to stores the parsed result in specific type in the arguments dictionary.\n        Checks for missing required arguments, if any, and returns False with the missing argument names, otherwise returns True.\n        :param command_string: str, command line argument string, formatted like \"python script.py --arg1=value1 -arg2 value2 --option1 -option2\"\n        :return tuple: (True, None) if parsing is successful, (False, missing_args) if parsing fails,\n            where missing_args is a set of the missing argument names which are str.\n        >>> parser.parse_arguments(\"python script.py --arg1=value1 -arg2 value2 --option1 -option2\")\n        (True, None)\n        >>> parser.arguments\n        {'arg1': 'value1', 'arg2': 'value2', 'option1': True, 'option2': True}\n        \"\"\"\n\n        args = command_string.split()[1:]\n        for i in range(len(args)):\n            arg = args[i]\n            if arg.startswith('--'):\n                key_value = arg[2:].split('=')\n                if len(key_value) == 2:\n                    self.arguments[key_value[0]] = self._convert_type(key_value[0], key_value[1])\n                else:\n                    self.arguments[key_value[0]] = True\n            elif arg.startswith('-'):\n                key = arg[1:]\n                if i + 1 < len(args) and not args[i + 1].startswith('-'):\n                    self.arguments[key] = self._convert_type(key, args[i + 1])\n                else:\n                    self.arguments[key] = True\n\n        missing_args = self.required - set(self.arguments.keys())\n        if missing_args:\n            return False, missing_args\n\n        return True, None\n\n\n    def get_argument(self, arg):\n        \"\"\"\n        Retrieves the value of the specified argument from the arguments dictionary and returns it.\n        :param arg: str, argument name\n        :return: The value of the argument, or None if the argument does not exist.\n        >>> parser.arguments\n        {'arg1': 'value1', 'arg2': 'value2', 'option1': True, 'option2': True}\n        >>> parser.get_argument('arg2')\n        'value2'\n        \"\"\"\n\n        return self.arguments.get(arg)\n\n    def add_argument(self, arg, required=False, arg_type=str):\n        \"\"\"\n        Adds an argument to self.types and self.required.\n        Check if it is a required argument and store the argument type.\n        If the argument is set as required, it wull be added to the required set.\n        The argument type and name are stored in the types dictionary as key-value pairs.\n        :param arg: str, argument name\n        :param required: bool, whether the argument is required, default is False\n        :param arg_type:str, Argument type, default is str\n        >>> parser.add_argument('arg1', True, 'int')\n        >>> parser.required\n        {'arg1'}\n        >>> parser.types\n        {'arg1': 'int'}\n        \"\"\"\n\n        if required:\n            self.required.add(arg)\n        self.types[arg] = arg_type\n\n\n    def _convert_type(self, arg, value):\n        \"\"\"\n        Try to convert the type of input value by searching in self.types.\n        :param value: str, the input value in command line\n        :return: return corresponding value in self.types if convert successfully, or the input value oherwise\n        >>> parser.types\n        {'arg1': int}\n        >>> parser._convert_type('arg1', '21')\n        21\n        \"\"\"\n\n        try:\n            return self.types[arg](value)\n        except (ValueError, KeyError):\n            return value",
        "annotated_code" : "class ArgumentParser:\n    \"\"\"\n    This is a class for parsing command line arguments to a dictionary.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the fields.\n        self.arguments is a dict that stores the args in a command line\n        self.requried is a set that stores the required arguments\n        self.types is a dict that stores type of every arguments.\n        >>> parser.arguments\n        {'key1': 'value1', 'option1': True}\n        >>> parser.required\n        {'arg1'}\n        >>> parser.types\n        {'arg1': 'type1'}\n        \"\"\"\n        self.arguments = {}\n        self.required = set()\n        self.types = {}\n\n    def parse_arguments(self, command_string):\n        \"\"\"\n        Parses the given command line argument string and invoke _convert_type to stores the parsed result in specific type in the arguments dictionary.\n        Checks for missing required arguments, if any, and returns False with the missing argument names, otherwise returns True.\n        :param command_string: str, command line argument string, formatted like \"python script.py --arg1=value1 -arg2 value2 --option1 -option2\"\n        :return tuple: (True, None) if parsing is successful, (False, missing_args) if parsing fails,\n            where missing_args is a set of the missing argument names which are str.\n        >>> parser.parse_arguments(\"python script.py --arg1=value1 -arg2 value2 --option1 -option2\")\n        (True, None)\n        >>> parser.arguments\n        {'arg1': 'value1', 'arg2': 'value2', 'option1': True, 'option2': True}\n        \"\"\"\n\n        # Split command string into a list of arguments\n        args = command_string.split()[1:]\n\n        # Iterate through the list of arguments\n        for i in range(len(args)):\n            arg = args[i]\n\n            # Check if the argument starts with '--' or '-' and process accordingly\n            if arg.startswith('--'):\n                # Split the argument into key and value as if it's in the form of '--key=value'\n                key_value = arg[2:].split('=')\n\n                # If the argument has a value, convert it to the specified type and store it in the arguments dictionary\n                # Otherwise, store it in the arguments dictionary as True\n                if len(key_value) == 2:\n                    self.arguments[key_value[0]] = self._convert_type(key_value[0], key_value[1])\n                else:\n                    self.arguments[key_value[0]] = True\n            elif arg.startswith('-'):\n                # If the argument starts with '-', check if it has a value or not\n                key = arg[1:]\n\n                # If the next argument is not another flag, convert it to the specified type and store it in the arguments dictionary\n                # Otherwise, store it in the arguments dictionary as True\n                if i + 1 < len(args) and not args[i + 1].startswith('-'):\n                    self.arguments[key] = self._convert_type(key, args[i + 1])\n                else:\n                    self.arguments[key] = True\n\n        # Check for missing required arguments by comparing the required set with the set of keys in the arguments dictionary\n        missing_args = self.required - set(self.arguments.keys())\n        if missing_args:\n            # If there are missing required arguments, return False and the set of missing arguments\n            return False, missing_args\n\n        # If all required arguments are present, return True and None\n        return True, None\n\n\n    def get_argument(self, arg):\n        \"\"\"\n        Retrieves the value of the specified argument from the arguments dictionary and returns it.\n        :param arg: str, argument name\n        :return: The value of the argument, or None if the argument does not exist.\n        >>> parser.arguments\n        {'arg1': 'value1', 'arg2': 'value2', 'option1': True, 'option2': True}\n        >>> parser.get_argument('arg2')\n        'value2'\n        \"\"\"\n\n        # Return the value for the specified key from the arguments dictionary\n        return self.arguments.get(arg)\n\n    def add_argument(self, arg, required=False, arg_type=str):\n        \"\"\"\n        Adds an argument to self.types and self.required.\n        Check if it is a required argument and store the argument type.\n        If the argument is set as required, it wull be added to the required set.\n        The argument type and name are stored in the types dictionary as key-value pairs.\n        :param arg: str, argument name\n        :param required: bool, whether the argument is required, default is False\n        :param arg_type:str, Argument type, default is str\n        >>> parser.add_argument('arg1', True, 'int')\n        >>> parser.required\n        {'arg1'}\n        >>> parser.types\n        {'arg1': 'int'}\n        \"\"\"\n\n        # If the argument is required add it to the required set\n        if required:\n            self.required.add(arg)\n\n        # Store the argument type in the types dictionary\n        self.types[arg] = arg_type\n\n\n    def _convert_type(self, arg, value):\n        \"\"\"\n        Try to convert the type of input value by searching in self.types.\n        :param value: str, the input value in command line\n        :return: return corresponding value in self.types if convert successfully, or the input value oherwise\n        >>> parser.types\n        {'arg1': int}\n        >>> parser._convert_type('arg1', '21')\n        21\n        \"\"\"\n\n        try:\n            # Attempt to cast value to the specified type for arg in the types dictionary\n            return self.types[arg](value)\n        except (ValueError, KeyError):\n            # If casting fails or arg is not found in the types dictionary, return value\n            return value"
    },
    {
        "id" : "3",
        "code" : "import itertools\n\nclass ArrangementCalculator:\n    \"\"\"\n    The Arrangement class provides permutation calculations and selection operations for a given set of data elements.\n    \"\"\"\n\n    def __init__(self, datas):\n        \"\"\"\n        Initializes the ArrangementCalculator object with a list of datas.\n        :param datas: List, the data elements to be used for arrangements.\n        \"\"\"\n        self.datas = datas\n\n    @staticmethod\n    def count(n, m=None):\n        \"\"\"\n        Counts the number of arrangements by choosing m items from n items (permutations).\n        If m is not provided or n equals m, returns factorial(n).\n        :param n: int, the total number of items.\n        :param m: int, the number of items to be chosen (default=None).\n        :return: int, the count of arrangements.\n        >>> ArrangementCalculator.count(5, 3)\n        60\n\n        \"\"\"\n\n        if m is None or n == m:\n            return ArrangementCalculator.factorial(n)\n        else:\n            return ArrangementCalculator.factorial(n) // ArrangementCalculator.factorial(n - m)\n\n    @staticmethod\n    def count_all(n):\n        \"\"\"\n        Counts the total number of all possible arrangements by choosing at least 1 item and at most n items from n items.\n        :param n: int, the total number of items.\n        :return: int, the count of all arrangements.\n        >>> ArrangementCalculator.count_all(4)\n        64\n\n        \"\"\"\n\n        total = 0\n        for i in range(1, n + 1):\n            total += ArrangementCalculator.count(n, i)\n        \n        return total\n\n\n    def select(self, m=None):\n        \"\"\"\n        Generates a list of arrangements by selecting m items from the internal datas.\n        If m is not provided, selects all items.\n        :param m: int, the number of items to be chosen (default=None).\n        :return: List, a list of arrangements.\n        >>> ac = ArrangementCalculator([1, 2, 3, 4])\n        >>> ac.select(2)\n        [[1, 2], [1, 3], [1, 4], [2, 1], [2, 3], [2, 4], [3, 1], [3, 2], [3, 4], [4, 1], [4, 2], [4, 3]]\n\n        \"\"\"\n\n        if m is None:\n            m = len(self.datas)\n\n        result = []\n        for permutation in itertools.permutations(self.datas, m):\n            result.append(list(permutation))\n        \n        return result\n\n\n    def select_all(self):\n        \"\"\"\n        Generates a list of all arrangements by selecting at least 1 item and at most the number of internal datas.\n        :return: List, a list of all arrangements.\n        >>> ac = ArrangementCalculator([1, 2, 3])\n        >>> ac.select_all()\n        [[1], [2], [3], [1, 2], [1, 3], [2, 1], [2, 3], [3, 1], [3, 2], [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]\n\n        \"\"\"\n\n        result = []\n        for i in range(1, len(self.datas) + 1):\n            result.extend(self.select(i))\n        \n        return result\n\n\n    @staticmethod\n    def factorial(n):\n        \"\"\"\n        Calculates the factorial of a given number.\n        :param n: int, the number to calculate the factorial.\n        :return: int, the factorial of the given number.\n        >>> ArrangementCalculator.factorial(4)\n        24\n\n        \"\"\"\n\n        result = 1\n        for i in range(2, n + 1):\n            result *= i\n        return result",
        "annotated_code" : "import itertools\n\nclass ArrangementCalculator:\n    \"\"\"\n    The Arrangement class provides permutation calculations and selection operations for a given set of data elements.\n    \"\"\"\n\n    def __init__(self, datas):\n        \"\"\"\n        Initializes the ArrangementCalculator object with a list of datas.\n        :param datas: List, the data elements to be used for arrangements.\n        \"\"\"\n        self.datas = datas\n\n    @staticmethod\n    def count(n, m=None):\n        \"\"\"\n        Counts the number of arrangements by choosing m items from n items (permutations).\n        If m is not provided or n equals m, returns factorial(n).\n        :param n: int, the total number of items.\n        :param m: int, the number of items to be chosen (default=None).\n        :return: int, the count of arrangements.\n        >>> ArrangementCalculator.count(5, 3)\n        60\n\n        \"\"\"\n        # If m is None or n equals m, use the factorial class method to return n!\n        # Otherwise, use the factorial class method to return n! // (n - m)!\n        if m is None or n == m:\n            return ArrangementCalculator.factorial(n)\n        else:\n            return ArrangementCalculator.factorial(n) // ArrangementCalculator.factorial(n - m)\n\n    @staticmethod\n    def count_all(n):\n        \"\"\"\n        Counts the total number of all possible arrangements by choosing at least 1 item and at most n items from n items.\n        :param n: int, the total number of items.\n        :return: int, the count of all arrangements.\n        >>> ArrangementCalculator.count_all(4)\n        64\n\n        \"\"\"\n        # Count all arrangements by summing the counts for picking i items from n items using the count class method for i in range 1 to n inclusive\n        total = 0\n        for i in range(1, n + 1):\n            total += ArrangementCalculator.count(n, i)\n        \n        # Return the total count of arrangements\n        return total\n\n\n    def select(self, m=None):\n        \"\"\"\n        Generates a list of arrangements by selecting m items from the internal datas.\n        If m is not provided, selects all items.\n        :param m: int, the number of items to be chosen (default=None).\n        :return: List, a list of arrangements.\n        >>> ac = ArrangementCalculator([1, 2, 3, 4])\n        >>> ac.select(2)\n        [[1, 2], [1, 3], [1, 4], [2, 1], [2, 3], [2, 4], [3, 1], [3, 2], [3, 4], [4, 1], [4, 2], [4, 3]]\n\n        \"\"\"\n\n        # If m is None, set m to the length of the internal datas\n        if m is None:\n            m = len(self.datas)\n\n        # Generate all arrangements of selecting m items from the internal datas using the itertools.permutations function and append each arrangement to result\n        result = []\n        for permutation in itertools.permutations(self.datas, m):\n            result.append(list(permutation))\n        \n        # Return the list of arrangements\n        return result\n\n\n    def select_all(self):\n        \"\"\"\n        Generates a list of all arrangements by selecting at least 1 item and at most the number of internal datas.\n        :return: List, a list of all arrangements.\n        >>> ac = ArrangementCalculator([1, 2, 3])\n        >>> ac.select_all()\n        [[1], [2], [3], [1, 2], [1, 3], [2, 1], [2, 3], [3, 1], [3, 2], [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]\n\n        \"\"\"\n\n        # Generate a list of all arrangements of selecting at least 1 item and at most len(self.datas) items from the internal datas using the select class method\n        result = []\n        for i in range(1, len(self.datas) + 1):\n            result.extend(self.select(i))\n        \n        # Return the list of all arrangements\n        return result\n\n\n    @staticmethod\n    def factorial(n):\n        \"\"\"\n        Calculates the factorial of a given number.\n        :param n: int, the number to calculate the factorial.\n        :return: int, the factorial of the given number.\n        >>> ArrangementCalculator.factorial(4)\n        24\n\n        \"\"\"\n\n        # Calculate the factorial of n by multiplying all integers from 2 to n and return the result\n        result = 1\n        for i in range(2, n + 1):\n            result *= i\n        return result"
    },
    {
        "id" : "4",
        "code" : "class AssessmentSystem:\n    \"\"\"\n    This is a class as an student assessment system, which supports add student, add course score, calculate GPA, and other functions for students and courses.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the students dict in assessment system.\n        \"\"\"\n        self.students = {}\n\n    def add_student(self, name, grade, major):\n        \"\"\"\n        Add a new student into self.students dict\n        :param name: str, student name\n        :param grade: int, student grade\n        :param major: str, student major\n        >>> system.add_student('student 1', 3, 'SE')\n        >>> system.students\n        {'student 1': {'name': 'student 1', 'grade': 3, 'major': 'SE', 'courses': {}}}\n        \"\"\"\n\n        self.students[name] = {'name': name, 'grade': grade, 'major': major, 'courses': {}}\n\n    def add_course_score(self, name, course, score):\n        \"\"\"\n        Add score of specific course for student in self.students\n        :param name: str, student name\n        :param course: str, course name\n        :param score: int, course score\n        >>> system.add_student('student 1', 3, 'SE')\n        >>> system.add_course_score('student 1', 'math', 94)\n        >>> system.students\n        {'student 1': {'name': 'student 1', 'grade': 3, 'major': 'SE', 'courses': {'math': 94}}}\n        \"\"\"\n\n        if name in self.students:\n            self.students[name]['courses'][course] = score\n\n    def get_gpa(self, name):\n        \"\"\"\n        Get average grade of one student.\n        :param name: str, student name\n        :return: if name is in students and this students have courses grade, return average grade(float)\n                    or None otherwise\n        >>> system.add_student('student 1', 3, 'SE')\n        >>> system.add_course_score('student 1', 'math', 94)\n        >>> system.add_course_score('student 1', 'Computer Network', 92)\n        >>> system.get_gpa('student 1')\n        93.0\n\n        \"\"\"\n\n        if name in self.students and self.students[name]['courses']:\n            return sum(self.students[name]['courses'].values()) / len(self.students[name]['courses'])\n        else:\n            return None\n\n    def get_all_students_with_fail_course(self):\n        \"\"\"\n        Get all students who have any score blow 60\n        :return: list of str ,student name\n        >>> system.add_course_score('student 1', 'Society', 59)\n        >>> system.get_all_students_with_fail_course()\n        ['student 1']\n        \"\"\"\n\n        students = []\n        for name, student in self.students.items():\n            for course, score in student['courses'].items():\n                if score < 60:\n                    students.append(name)\n                    break\n        return students\n\n    def get_course_average(self, course):\n        \"\"\"\n        Get the average score of a specific course.\n        :param course: str, course name\n        :return: float, average scores of this course if anyone have score of this course, or None if nobody have records.\n        \"\"\"\n\n        total = 0\n        count = 0\n        for student in self.students.values():\n            if course in student['courses']:\n                score = student['courses'][course]\n                if score is not None:\n                    total += score\n                    count += 1\n        return total / count if count > 0 else None\n\n    def get_top_student(self):\n        \"\"\"\n        Calculate every student's gpa with get_gpa method, and find the student with highest gpa\n        :return: str, name of student whose gpa is highest\n        >>> system.add_student('student 1', 3, 'SE')\n        >>> system.add_student('student 2', 2, 'SE')\n        >>> system.add_course_score('student 1', 'Computer Network', 92)\n        >>> system.add_course_score('student 2', 'Computer Network', 97)\n        >>> system.get_top_student()\n        'student 2'\n        \"\"\"\n\n        top_student = None\n        top_gpa = 0\n        for name, student in self.students.items():\n            gpa = self.get_gpa(name)\n            if gpa is not None and gpa > top_gpa:\n                top_gpa = gpa\n                top_student = name\n        return top_student",
        "annotated_code" : "class AssessmentSystem:\n    \"\"\"\n    This is a class as an student assessment system, which supports add student, add course score, calculate GPA, and other functions for students and courses.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the students dict in assessment system.\n        \"\"\"\n        self.students = {}\n\n    def add_student(self, name, grade, major):\n        \"\"\"\n        Add a new student into self.students dict\n        :param name: str, student name\n        :param grade: int, student grade\n        :param major: str, student major\n        >>> system.add_student('student 1', 3, 'SE')\n        >>> system.students\n        {'student 1': {'name': 'student 1', 'grade': 3, 'major': 'SE', 'courses': {}}}\n        \"\"\"\n\n        # Add a new student into the students dictionary with the given name, grade, and major\n        self.students[name] = {'name': name, 'grade': grade, 'major': major, 'courses': {}}\n\n    def add_course_score(self, name, course, score):\n        \"\"\"\n        Add score of specific course for student in self.students\n        :param name: str, student name\n        :param course: str, course name\n        :param score: int, course score\n        >>> system.add_student('student 1', 3, 'SE')\n        >>> system.add_course_score('student 1', 'math', 94)\n        >>> system.students\n        {'student 1': {'name': 'student 1', 'grade': 3, 'major': 'SE', 'courses': {'math': 94}}}\n        \"\"\"\n\n        # If the student exists in the students dictionary, add the course and score to the student's courses dictionary\n        if name in self.students:\n            self.students[name]['courses'][course] = score\n\n    def get_gpa(self, name):\n        \"\"\"\n        Get average grade of one student.\n        :param name: str, student name\n        :return: if name is in students and this students have courses grade, return average grade(float)\n                    or None otherwise\n        >>> system.add_student('student 1', 3, 'SE')\n        >>> system.add_course_score('student 1', 'math', 94)\n        >>> system.add_course_score('student 1', 'Computer Network', 92)\n        >>> system.get_gpa('student 1')\n        93.0\n\n        \"\"\"\n\n        # If the student exists in the students dictionary and has courses, calculate the GPA by averaging the scores\n        # Otherwise, return None\n        if name in self.students and self.students[name]['courses']:\n            return sum(self.students[name]['courses'].values()) / len(self.students[name]['courses'])\n        else:\n            return None\n\n    def get_all_students_with_fail_course(self):\n        \"\"\"\n        Get all students who have any score blow 60\n        :return: list of str ,student name\n        >>> system.add_course_score('student 1', 'Society', 59)\n        >>> system.get_all_students_with_fail_course()\n        ['student 1']\n        \"\"\"\n\n        students = []\n\n        # For each student in the students dictionary, iterate through their courses and scores\n        for name, student in self.students.items():\n            for course, score in student['courses'].items():\n                # If any score is below 60, add the student's name to a list and break out of the inner loop\n                if score < 60:\n                    students.append(name)\n                    break\n\n        # Return the list of students who have failed any course\n        return students\n\n    def get_course_average(self, course):\n        \"\"\"\n        Get the average score of a specific course.\n        :param course: str, course name\n        :return: float, average scores of this course if anyone have score of this course, or None if nobody have records.\n        \"\"\"\n\n        total = 0\n        count = 0\n\n        # For each student in the students dictionary, check if they have a score for the given course\n        for student in self.students.values():\n\n            # If the course exists in the student's courses dictionary, add the score to the total and increment the count\n            if course in student['courses']:\n                score = student['courses'][course]\n                if score is not None:\n                    total += score\n                    count += 1\n        \n        # Calculate and return the average score for the course, or None if no students have scores for the course\n        return total / count if count > 0 else None\n\n    def get_top_student(self):\n        \"\"\"\n        Calculate every student's gpa with get_gpa method, and find the student with highest gpa\n        :return: str, name of student whose gpa is highest\n        >>> system.add_student('student 1', 3, 'SE')\n        >>> system.add_student('student 2', 2, 'SE')\n        >>> system.add_course_score('student 1', 'Computer Network', 92)\n        >>> system.add_course_score('student 2', 'Computer Network', 97)\n        >>> system.get_top_student()\n        'student 2'\n        \"\"\"\n\n        top_student = None\n        top_gpa = 0\n\n        # Iterate through the students dictionary and get the GPA for each student using the get_gpa class method\n        for name, student in self.students.items():\n            gpa = self.get_gpa(name)\n\n            # If the GPA is higher than the current top GPA, update the top student and top GPA\n            if gpa is not None and gpa > top_gpa:\n                top_gpa = gpa\n                top_student = name\n        \n        # Return the name of the student with the highest GPA\n        return top_student"
    },
    {
        "id" : "5",
        "code" : "class AutomaticGuitarSimulator:\n\n    # This class is an automatic guitar simulator that can interpret and play based on the input guitar sheet music.\n\n    def __init__(self, text) -> None:\n        \"\"\"\n        Initialize the score to be played\n        :param text:str, score to be played\n        \"\"\"\n        self.play_text = text\n\n    def interpret(self, display=False):\n        \"\"\"\n        Interpret the music score to be played\n        :param display:Bool, representing whether to print the interpreted score\n        :return: list of dict, The dict includes two fields, Chord and Tune, which are letters and numbers, respectively. If the input is empty or contains only whitespace, an empty list is returned.\n        >>> context = AutomaticGuitarSimulator(\"C53231323 Em43231323 F43231323 G63231323\")\n        >>> play_list = context.interpret(display = False)\n        [{'Chord': 'C', 'Tune': '53231323'}, {'Chord': 'Em', 'Tune': '43231323'}, {'Chord': 'F', 'Tune': '43231323'}, {'Chord': 'G', 'Tune': '63231323'}]\n\n        \"\"\"\n\n        if not self.play_text.strip():\n            return []\n        else:\n            play_list = []\n            play_segs = self.play_text.split(\" \")\n            for play_seg in play_segs:\n                pos = 0\n                for ele in play_seg:\n                    if ele.isalpha():\n                        pos += 1\n                        continue\n                    break\n                play_chord = play_seg[0:pos]\n                play_value = play_seg[pos:]\n                play_list.append({'Chord': play_chord, 'Tune': play_value})\n                if display:\n                    self.display(play_chord, play_value)\n            return play_list\n\n    def display(self, key, value):\n        \"\"\"\n        Print out chord and play tune with following format: Normal Guitar Playing -- Chord: %s, Play Tune: %s\n        :param key:str, chord\n        :param value:str, play tune\n        :return: str\n        >>> context = AutomaticGuitarSimulator(\"C53231323 Em43231323 F43231323 G63231323\")\n        >>> context.display(\"C\", \"53231323\")\n        Normal Guitar Playing -- Chord: C, Play Tune: 53231323\n\n        \"\"\"\n\n        return \"Normal Guitar Playing -- Chord: %s, Play Tune: %s\" % (key, value)",
        "annotated_code" : "class AutomaticGuitarSimulator:\n\n    # This class is an automatic guitar simulator that can interpret and play based on the input guitar sheet music.\n\n    def __init__(self, text) -> None:\n        \"\"\"\n        Initialize the score to be played\n        :param text:str, score to be played\n        \"\"\"\n        self.play_text = text\n\n    def interpret(self, display=False):\n        \"\"\"\n        Interpret the music score to be played\n        :param display:Bool, representing whether to print the interpreted score\n        :return: list of dict, The dict includes two fields, Chord and Tune, which are letters and numbers, respectively. If the input is empty or contains only whitespace, an empty list is returned.\n        >>> context = AutomaticGuitarSimulator(\"C53231323 Em43231323 F43231323 G63231323\")\n        >>> play_list = context.interpret(display = False)\n        [{'Chord': 'C', 'Tune': '53231323'}, {'Chord': 'Em', 'Tune': '43231323'}, {'Chord': 'F', 'Tune': '43231323'}, {'Chord': 'G', 'Tune': '63231323'}]\n\n        \"\"\"\n\n        # If the score to be played is empty or contains only whitespace, an empty list is returned.\n        if not self.play_text.strip():\n            return []\n        else:\n            # Split the score to be played into segments based on spaces\n            play_list = []\n            play_segs = self.play_text.split(\" \")\n\n            # Process each segment to extract the chord and play tune\n            for play_seg in play_segs:\n                # Find the first position where a non-alphabetic character occurs\n                pos = 0\n                for ele in play_seg:\n                    if ele.isalpha():\n                        pos += 1\n                        continue\n                    break\n\n                # Extract the chord and play tune based on the position found\n                play_chord = play_seg[0:pos]\n                play_value = play_seg[pos:]\n\n                # Append the extracted chord and play tune to the play_list\n                play_list.append({'Chord': play_chord, 'Tune': play_value})\n\n                # If display is True, use the display class method to print the chord and play tune\n                if display:\n                    self.display(play_chord, play_value)\n            \n            # Return the list of chords and play tunes\n            return play_list\n\n    def display(self, key, value):\n        \"\"\"\n        Print out chord and play tune with following format: Normal Guitar Playing -- Chord: %s, Play Tune: %s\n        :param key:str, chord\n        :param value:str, play tune\n        :return: str\n        >>> context = AutomaticGuitarSimulator(\"C53231323 Em43231323 F43231323 G63231323\")\n        >>> context.display(\"C\", \"53231323\")\n        Normal Guitar Playing -- Chord: C, Play Tune: 53231323\n\n        \"\"\"\n\n        # Return a string with following format: Normal Guitar Playing -- Chord: %s, Play Tune: %s\n        return \"Normal Guitar Playing -- Chord: %s, Play Tune: %s\" % (key, value)"
    },
    {
        "id" : "6",
        "code" : "class AvgPartition:\n    \"\"\"\n    This is a class that partitions the given list into different blocks by specifying the number of partitions, with each block having a uniformly distributed length.\n    \"\"\"\n\n    def __init__(self, lst, limit):\n        \"\"\"\n        Initialize the class with the given list and the number of partitions, and check if the number of partitions is greater than 0.\n        \"\"\"\n        self.lst = lst\n        self.limit = limit\n\n    def setNum(self):\n        \"\"\"\n        Calculate the size of each block and the remainder of the division.\n        :return: the size of each block and the remainder of the division, tuple.\n        >>> a = AvgPartition([1, 2, 3, 4], 2)\n        >>> a.setNum()\n        (2, 0)\n\n        \"\"\"\n\n        size = len(self.lst) // self.limit\n        remainder = len(self.lst) % self.limit\n        return size, remainder\n\n\n    def get(self, index):\n        \"\"\"\n        calculate the size of each block and the remainder of the division, and calculate the corresponding start and end positions based on the index of the partition.\n        :param index: the index of the partition,int.\n        :return: the corresponding block, list.\n        >>> a = AvgPartition([1, 2, 3, 4], 2)\n        >>> a.get(0)\n        [1, 2]\n\n        \"\"\"\n\n        size, remainder = self.setNum()\n        start = index * size + min(index, remainder)\n        end = start + size\n        if index + 1 <= remainder:\n            end += 1\n        return self.lst[start:end]",
        "annotated_code" : "class AvgPartition:\n    \"\"\"\n    This is a class that partitions the given list into different blocks by specifying the number of partitions, with each block having a uniformly distributed length.\n    \"\"\"\n\n    def __init__(self, lst, limit):\n        \"\"\"\n        Initialize the class with the given list and the number of partitions, and check if the number of partitions is greater than 0.\n        \"\"\"\n        self.lst = lst\n        self.limit = limit\n\n    def setNum(self):\n        \"\"\"\n        Calculate the size of each block and the remainder of the division.\n        :return: the size of each block and the remainder of the division, tuple.\n        >>> a = AvgPartition([1, 2, 3, 4], 2)\n        >>> a.setNum()\n        (2, 0)\n\n        \"\"\"\n\n        # Calculate the size of each block and the remainder of the division\n        size = len(self.lst) // self.limit\n        remainder = len(self.lst) % self.limit\n\n        # Return the size of each block and the remainder of the division\n        return size, remainder\n\n\n    def get(self, index):\n        \"\"\"\n        calculate the size of each block and the remainder of the division, and calculate the corresponding start and end positions based on the index of the partition.\n        :param index: the index of the partition,int.\n        :return: the corresponding block, list.\n        >>> a = AvgPartition([1, 2, 3, 4], 2)\n        >>> a.get(0)\n        [1, 2]\n\n        \"\"\"\n\n        # Use the setNum class method to calculate the size of each block and the remainder of the division\n        size, remainder = self.setNum()\n\n        # Calculate the corresponding start position based on the index of the partition\n        # Add an element to the start position to distribute the remainder evenly\n        start = index * size + min(index, remainder)\n\n        # Calculate the corresponding end position based on the start and size of the partition\n        end = start + size\n\n        # Add 1 to the end position if the index corresponds to a block that has an extra element\n        if index + 1 <= remainder:\n            end += 1\n\n        # Return the corresponding block\n        return self.lst[start:end]"
    },
    {
        "id" : "7",
        "code" : "class BalancedBrackets:\n    \"\"\"\n    This is a class that checks for bracket matching\n    \"\"\"\n\n    def __init__(self, expr):\n        \"\"\"\n        Initializes the class with an expression.\n        :param expr: The expression to check for balanced brackets,str.\n        \"\"\"\n        self.stack = []\n        self.left_brackets = [\"(\", \"{\", \"[\"]\n        self.right_brackets = [\")\", \"}\", \"]\"]\n        self.expr = expr\n\n    def clear_expr(self):\n        \"\"\"\n        Clears the expression of all characters that are not brackets.\n        >>> b = BalancedBrackets(\"a(b)c\")\n        >>> b.clear_expr()\n        >>> b.expr\n        '()'\n\n        \"\"\"\n\n        self.expr = ''.join(c for c in self.expr if (c in self.left_brackets or c in self.right_brackets))\n\n    def check_balanced_brackets(self):\n        \"\"\"\n        Checks if the expression has balanced brackets.\n        :return: True if the expression has balanced brackets, False otherwise.\n        >>> b = BalancedBrackets(\"a(b)c\")\n        >>> b.check_balanced_brackets()\n        True\n\n        \"\"\"\n\n        self.clear_expr()\n        for Brkt in self.expr:\n            if Brkt in self.left_brackets:\n                self.stack.append(Brkt)\n            else:\n                if self.stack:\n                    Current_Brkt = self.stack.pop()\n                else:\n                    continue\n                if Current_Brkt == \"(\":\n                    if Brkt != \")\":\n                        return False\n                if Current_Brkt == \"{\":\n                    if Brkt != \"}\":\n                        return False\n                if Current_Brkt == \"[\":\n                    if Brkt != \"]\":\n                        return False\n        if self.stack:\n            return False\n        return True",
        "annotated_code" : "class BalancedBrackets:\n    \"\"\"\n    This is a class that checks for bracket matching\n    \"\"\"\n\n    def __init__(self, expr):\n        \"\"\"\n        Initializes the class with an expression.\n        :param expr: The expression to check for balanced brackets,str.\n        \"\"\"\n        self.stack = []\n        self.left_brackets = [\"(\", \"{\", \"[\"]\n        self.right_brackets = [\")\", \"}\", \"]\"]\n        self.expr = expr\n\n    def clear_expr(self):\n        \"\"\"\n        Clears the expression of all characters that are not brackets.\n        >>> b = BalancedBrackets(\"a(b)c\")\n        >>> b.clear_expr()\n        >>> b.expr\n        '()'\n\n        \"\"\"\n\n        # Removes all characters that are not brackets from the expression.\n        self.expr = ''.join(c for c in self.expr if (c in self.left_brackets or c in self.right_brackets))\n\n    def check_balanced_brackets(self):\n        \"\"\"\n        Checks if the expression has balanced brackets.\n        :return: True if the expression has balanced brackets, False otherwise.\n        >>> b = BalancedBrackets(\"a(b)c\")\n        >>> b.check_balanced_brackets()\n        True\n\n        \"\"\"\n\n        # Use the clear_expr class method to clear the expression of all characters that are not brackets.\n        self.clear_expr()\n\n        # Iterate through the expression and check for balanced brackets.\n        for Brkt in self.expr:\n\n            # If the bracket is a left bracket, push it onto the stack.\n            # If the bracket is a right bracket, pop the stack and check if the bracket matches what was popped.\n            if Brkt in self.left_brackets:\n                self.stack.append(Brkt)\n            else:\n                # Only if the stack is not empty, pop the stack and check if the bracket matches what was popped.\n                # Otherwise continue to the next iteration\n                if self.stack:\n                    Current_Brkt = self.stack.pop()\n                else:\n                    continue\n                # Return False if the brackets do not match.\n                if Current_Brkt == \"(\":\n                    if Brkt != \")\":\n                        return False\n                if Current_Brkt == \"{\":\n                    if Brkt != \"}\":\n                        return False\n                if Current_Brkt == \"[\":\n                    if Brkt != \"]\":\n                        return False\n        \n        # If the stack is not empty, return False.\n        # Otherwise return True.\n        if self.stack:\n            return False\n        return True"
    },
    {
        "id" : "8",
        "code" : "class BankAccount:\n    \"\"\"\n    This is a class as a bank account system, which supports deposit money, withdraw money, view balance, and transfer money.\n    \"\"\"\n\n    def __init__(self, balance=0):\n        \"\"\"\n        Initializes a bank account object with an attribute balance, default value is 0.\n        \"\"\"\n        self.balance = balance\n\n    def deposit(self, amount):\n        \"\"\"\n        Deposits a certain amount into the account, increasing the account balance, return the current account balance.\n        If amount is negative, raise a ValueError(\"Invalid amount\").\n        :param amount: int\n        \"\"\"\n\n        if amount < 0:\n            raise ValueError(\"Invalid amount\")\n        self.balance += amount\n        return self.balance\n\n    def withdraw(self, amount):\n        \"\"\"\n        Withdraws a certain amount from the account, decreasing the account balance, return the current account balance.\n        If amount is negative, raise a ValueError(\"Invalid amount\").\n        If the withdrawal amount is greater than the account balance, raise a ValueError(\"Insufficient balance.\").\n        :param amount: int\n        \"\"\"\n\n        if amount < 0:\n            raise ValueError(\"Invalid amount\")\n        if amount > self.balance:\n            raise ValueError(\"Insufficient balance.\")\n        self.balance -= amount\n        return self.balance\n\n    def view_balance(self):\n        \"\"\"\n        Return the account balance.\n        \"\"\"\n        return self.balance\n\n    def transfer(self, other_account, amount):\n        \"\"\"\n        Transfers a certain amount from the current account to another account.\n        :param other_account: BankAccount\n        :param amount: int\n        >>> account1 = BankAccount()\n        >>> account2 = BankAccount()\n        >>> account1.deposit(1000)\n        >>> account1.transfer(account2, 300)\n        account1.balance = 700 account2.balance = 300\n        \"\"\"\n\n        self.withdraw(amount)\n        other_account.deposit(amount)",
        "annotated_code" : "class BankAccount:\n    \"\"\"\n    This is a class as a bank account system, which supports deposit money, withdraw money, view balance, and transfer money.\n    \"\"\"\n\n    def __init__(self, balance=0):\n        \"\"\"\n        Initializes a bank account object with an attribute balance, default value is 0.\n        \"\"\"\n        self.balance = balance\n\n    def deposit(self, amount):\n        \"\"\"\n        Deposits a certain amount into the account, increasing the account balance, return the current account balance.\n        If amount is negative, raise a ValueError(\"Invalid amount\").\n        :param amount: int\n        \"\"\"\n\n        # If the amount is negative, raise a ValueError\n        # Otherwise add the amount to the balance\n        if amount < 0:\n            raise ValueError(\"Invalid amount\")\n        self.balance += amount\n\n        # Return the balance\n        return self.balance\n\n    def withdraw(self, amount):\n        \"\"\"\n        Withdraws a certain amount from the account, decreasing the account balance, return the current account balance.\n        If amount is negative, raise a ValueError(\"Invalid amount\").\n        If the withdrawal amount is greater than the account balance, raise a ValueError(\"Insufficient balance.\").\n        :param amount: int\n        \"\"\"\n\n        # If the amount is negative, raise a ValueError\n        # If the amount is greater than the balance, raise a ValueError\n        # Otherwise subtract the amount from the balance\n        if amount < 0:\n            raise ValueError(\"Invalid amount\")\n        if amount > self.balance:\n            raise ValueError(\"Insufficient balance.\")\n        self.balance -= amount\n\n        # Return the balance\n        return self.balance\n\n    def view_balance(self):\n        \"\"\"\n        Return the account balance.\n        \"\"\"\n\n        # Return the balance\n        return self.balance\n\n    def transfer(self, other_account, amount):\n        \"\"\"\n        Transfers a certain amount from the current account to another account.\n        :param other_account: BankAccount\n        :param amount: int\n        >>> account1 = BankAccount()\n        >>> account2 = BankAccount()\n        >>> account1.deposit(1000)\n        >>> account1.transfer(account2, 300)\n        account1.balance = 700 account2.balance = 300\n        \"\"\"\n\n        # Use the withdraw class method to withdraw amount from the current account\n        self.withdraw(amount)\n\n        # Use the deposit class method to deposit amount into the other account\n        other_account.deposit(amount)"
    },
    {
        "id" : "9",
        "code" : "class BigNumCalculator:\n    \"\"\"\n    This is a class that implements big number calculations, including adding, subtracting and multiplying.\n    \"\"\"\n\n    @staticmethod\n    def add(num1, num2):\n        \"\"\"\n        Adds two big numbers.\n        :param num1: The first number to add,str.\n        :param num2: The second number to add,str.\n        :return: The sum of the two numbers,str.\n        >>> bigNum = BigNumCalculator()\n        >>> bigNum.add(\"12345678901234567890\", \"98765432109876543210\")\n        '111111111011111111100'\n\n        \"\"\"\n\n        max_length = max(len(num1), len(num2))\n        num1 = num1.zfill(max_length)\n        num2 = num2.zfill(max_length)\n\n        carry = 0\n        result = []\n        for i in range(max_length - 1, -1, -1):\n            digit_sum = int(num1[i]) + int(num2[i]) + carry\n            carry = digit_sum // 10\n            digit = digit_sum % 10\n            result.insert(0, str(digit))\n\n        if carry > 0:\n            result.insert(0, str(carry))\n        return ''.join(result)\n\n    @staticmethod\n    def subtract(num1, num2):\n        \"\"\"\n        Subtracts two big numbers.\n        :param num1: The first number to subtract,str.\n        :param num2: The second number to subtract,str.\n        :return: The difference of the two numbers,str.\n        >>> bigNum = BigNumCalculator()\n        >>> bigNum.subtract(\"12345678901234567890\", \"98765432109876543210\")\n        '-86419753208641975320'\n\n        \"\"\"\n        negative = False\n        if len(num1) < len(num2):\n            num1, num2 = num2, num1\n            negative = True\n        elif len(num1) > len(num2):\n            negative = False\n        else:\n            if float(num1) < float(num2):\n                num1, num2 = num2, num1\n                negative = True\n        max_length = max(len(num1), len(num2))\n        num1 = num1.zfill(max_length)\n        num2 = num2.zfill(max_length)\n\n        borrow = 0\n        result = []\n        for i in range(max_length - 1, -1, -1):\n            digit_diff = int(num1[i]) - int(num2[i]) - borrow\n            if digit_diff < 0:\n                digit_diff += 10\n                borrow = 1\n            else:\n                borrow = 0\n            result.insert(0, str(digit_diff))\n        while len(result) > 1 and result[0] == '0':\n            result.pop(0)\n        if negative:\n            result.insert(0, '-')\n        return ''.join(result)\n\n    @staticmethod\n    def multiply(num1, num2):\n        \"\"\"\n        Multiplies two big numbers.\n        :param num1: The first number to multiply,str.\n        :param num2: The second number to multiply,str.\n        :return: The product of the two numbers,str.\n        >>> bigNum = BigNumCalculator()\n        >>> bigNum.multiply(\"12345678901234567890\", \"98765432109876543210\")\n        '1219326311370217952237463801111263526900'\n\n        \"\"\"\n\n        len1, len2 = len(num1), len(num2)\n        result = [0] * (len1 + len2)\n\n        for i in range(len1 - 1, -1, -1):\n            for j in range(len2 - 1, -1, -1):\n                mul = int(num1[i]) * int(num2[j])\n                p1, p2 = i + j, i + j + 1\n                total = mul + result[p2]\n                result[p1] += total // 10\n                result[p2] = total % 10\n\n        start = 0\n        while start < len(result) - 1 and result[start] == 0:\n            start += 1\n        return ''.join(map(str, result[start:]))",
        "annotated_code" : "class BigNumCalculator:\n    \"\"\"\n    This is a class that implements big number calculations, including adding, subtracting and multiplying.\n    \"\"\"\n\n    @staticmethod\n    def add(num1, num2):\n        \"\"\"\n        Adds two big numbers.\n        :param num1: The first number to add,str.\n        :param num2: The second number to add,str.\n        :return: The sum of the two numbers,str.\n        >>> bigNum = BigNumCalculator()\n        >>> bigNum.add(\"12345678901234567890\", \"98765432109876543210\")\n        '111111111011111111100'\n\n        \"\"\"\n\n        # Pad the numbers with leading zeros to make them the same length\n        max_length = max(len(num1), len(num2))\n        num1 = num1.zfill(max_length)\n        num2 = num2.zfill(max_length)\n\n        # Initialize carry and result\n        carry = 0\n        result = []\n\n        # Perform addition from the last digit to the first\n        for i in range(max_length - 1, -1, -1):\n\n            # Calculate the sum of the digits and the carry\n            digit_sum = int(num1[i]) + int(num2[i]) + carry\n\n            # Update the carry and the digit to be added to the result\n            carry = digit_sum // 10\n            digit = digit_sum % 10\n            result.insert(0, str(digit))\n\n        # If there's a carry left after the last addition, add it to the result\n        if carry > 0:\n            result.insert(0, str(carry))\n\n        # Return the result as a string\n        return ''.join(result)\n\n    @staticmethod\n    def subtract(num1, num2):\n        \"\"\"\n        Subtracts two big numbers.\n        :param num1: The first number to subtract,str.\n        :param num2: The second number to subtract,str.\n        :return: The difference of the two numbers,str.\n        >>> bigNum = BigNumCalculator()\n        >>> bigNum.subtract(\"12345678901234567890\", \"98765432109876543210\")\n        '-86419753208641975320'\n\n        \"\"\"\n        negative = False\n\n        # Check if the first number is smaller than the second\n        # If so, swap them and set the negative flag\n        # If the lengths are equal, compare the numbers as floats\n        if len(num1) < len(num2):\n            num1, num2 = num2, num1\n            negative = True\n        elif len(num1) > len(num2):\n            negative = False\n        else:\n            # If the first number is smaller, swap them and set the negative flag\n            if float(num1) < float(num2):\n                num1, num2 = num2, num1\n                negative = True\n\n        # Pad the numbers with leading zeros to make them the same length\n        max_length = max(len(num1), len(num2))\n        num1 = num1.zfill(max_length)\n        num2 = num2.zfill(max_length)\n\n        # Initialize the borrow and result\n        borrow = 0\n        result = []\n\n        # Perform subtraction from the last digit to the first\n        for i in range(max_length - 1, -1, -1):\n\n            # Calculate the difference of the digits and the borrow\n            digit_diff = int(num1[i]) - int(num2[i]) - borrow\n\n            # If the difference is negative, borrow from the next digit\n            if digit_diff < 0:\n                digit_diff += 10\n                borrow = 1\n            # Otherwise, set the borrow to 0\n            else:\n                borrow = 0\n\n            # Insert the digit at the beginning of the result\n            result.insert(0, str(digit_diff))\n\n        # Remove leading zeros from the result\n        while len(result) > 1 and result[0] == '0':\n            result.pop(0)\n\n        # If the result is negative, insert the negative sign at the beginning\n        if negative:\n            result.insert(0, '-')\n\n        # Return the result as a string\n        return ''.join(result)\n\n    @staticmethod\n    def multiply(num1, num2):\n        \"\"\"\n        Multiplies two big numbers.\n        :param num1: The first number to multiply,str.\n        :param num2: The second number to multiply,str.\n        :return: The product of the two numbers,str.\n        >>> bigNum = BigNumCalculator()\n        >>> bigNum.multiply(\"12345678901234567890\", \"98765432109876543210\")\n        '1219326311370217952237463801111263526900'\n\n        \"\"\"\n\n        # Initialize the lengths of the numbers and the result as a list of zeros\n        len1, len2 = len(num1), len(num2)\n        result = [0] * (len1 + len2)\n\n        # Perform multiplication from the last digit of each number\n        for i in range(len1 - 1, -1, -1):\n            for j in range(len2 - 1, -1, -1):\n\n                # Calculate the product of the digits and their positions\n                mul = int(num1[i]) * int(num2[j])\n                p1, p2 = i + j, i + j + 1\n\n                # Add the product to the result at the correct position\n                total = mul + result[p2]\n\n                # Update the result with the carry and the digit\n                result[p1] += total // 10\n                result[p2] = total % 10\n\n        # Remove leading zeros from the result\n        start = 0\n        while start < len(result) - 1 and result[start] == 0:\n            start += 1\n\n        # Return the result as a string\n        return ''.join(map(str, result[start:]))"
    },
    {
        "id" : "10",
        "code" : "class BinaryDataProcessor:\n    \"\"\"\n    This is a class used to process binary data, which includes functions such as clearing non 0 or 1 characters, counting binary string information, and converting to corresponding strings based on different encoding methods.\n    \"\"\"\n\n    def __init__(self, binary_string):\n        \"\"\"\n        Initialize the class with a binary string and clean it by removing all non 0 or 1 characters.\n        \"\"\"\n        self.binary_string = binary_string\n        self.clean_non_binary_chars()\n\n    def clean_non_binary_chars(self):\n        \"\"\"\n        Clean the binary string by removing all non 0 or 1 characters.\n        >>> bdp = BinaryDataProcessor(\"01101000daf3e4r01100101011011000110110001101111\")\n        >>> bdp.clean_non_binary_chars()\n        >>> bdp.binary_string\n        '0110100001100101011011000110110001101111'\n\n        \"\"\"\n        self.binary_string = ''.join(filter(lambda x: x in '01', self.binary_string))\n\n    def calculate_binary_info(self):\n        \"\"\"\n        Calculate the binary string information, including the percentage of 0 and 1, and the total length of the binary string.\n        >>> bdp = BinaryDataProcessor(\"0110100001100101011011000110110001101111\")\n        >>> bdp.calculate_binary_info()\n        {'Zeroes': 0.475, 'Ones': 0.525, 'Bit length': 40}\n\n        \"\"\"\n        zeroes_count = self.binary_string.count('0')\n        ones_count = self.binary_string.count('1')\n        total_length = len(self.binary_string)\n        zeroes_percentage = (zeroes_count / total_length)\n        ones_percentage = (ones_count / total_length)\n\n        return {\n            'Zeroes': zeroes_percentage,\n            'Ones': ones_percentage,\n            'Bit length': total_length\n        }\n\n    def convert_to_ascii(self):\n        \"\"\"\n        Convert the binary string to ascii string.\n        >>> bdp = BinaryDataProcessor(\"0110100001100101011011000110110001101111\")\n        >>> bdp.convert_to_ascii()\n        'hello'\n\n        \"\"\"\n\n        byte_array = bytearray()\n        for i in range(0, len(self.binary_string), 8):\n            byte = self.binary_string[i:i+8]\n            decimal = int(byte, 2)\n            byte_array.append(decimal)\n        return byte_array.decode('ascii')\n\n    def convert_to_utf8(self):\n        \"\"\"\n        Convert the binary string to utf-8 string.\n        >>> bdp = BinaryDataProcessor(\"0110100001100101011011000110110001101111\")\n        >>> bdp.convert_to_utf8()\n        'hello'\n\n        \"\"\"\n\n        byte_array = bytearray()\n        for i in range(0, len(self.binary_string), 8):\n            byte = self.binary_string[i:i+8]\n            decimal = int(byte, 2)\n            byte_array.append(decimal)\n        return byte_array.decode('utf-8')",
        "annotated_code" : "class BinaryDataProcessor:\n    \"\"\"\n    This is a class used to process binary data, which includes functions such as clearing non 0 or 1 characters, counting binary string information, and converting to corresponding strings based on different encoding methods.\n    \"\"\"\n\n    def __init__(self, binary_string):\n        \"\"\"\n        Initialize the class with a binary string and clean it by removing all non 0 or 1 characters.\n        \"\"\"\n        self.binary_string = binary_string\n\n        # Use the clean_non_binary_chars class method to remove all non-binary characters\n        self.clean_non_binary_chars()\n\n    def clean_non_binary_chars(self):\n        \"\"\"\n        Clean the binary string by removing all non 0 or 1 characters.\n        >>> bdp = BinaryDataProcessor(\"01101000daf3e4r01100101011011000110110001101111\")\n        >>> bdp.clean_non_binary_chars()\n        >>> bdp.binary_string\n        '0110100001100101011011000110110001101111'\n\n        \"\"\"\n        # Remove all non-binary characters\n        self.binary_string = ''.join(filter(lambda x: x in '01', self.binary_string))\n\n    def calculate_binary_info(self):\n        \"\"\"\n        Calculate the binary string information, including the percentage of 0 and 1, and the total length of the binary string.\n        >>> bdp = BinaryDataProcessor(\"0110100001100101011011000110110001101111\")\n        >>> bdp.calculate_binary_info()\n        {'Zeroes': 0.475, 'Ones': 0.525, 'Bit length': 40}\n\n        \"\"\"\n        # Calculate the percentage of 0's, percentage of 1's, and the total length of the binary string\n        zeroes_count = self.binary_string.count('0')\n        ones_count = self.binary_string.count('1')\n        total_length = len(self.binary_string)\n        zeroes_percentage = (zeroes_count / total_length)\n        ones_percentage = (ones_count / total_length)\n\n        # Return the results as a dictionary\n        return {\n            'Zeroes': zeroes_percentage,\n            'Ones': ones_percentage,\n            'Bit length': total_length\n        }\n\n    def convert_to_ascii(self):\n        \"\"\"\n        Convert the binary string to ascii string.\n        >>> bdp = BinaryDataProcessor(\"0110100001100101011011000110110001101111\")\n        >>> bdp.convert_to_ascii()\n        'hello'\n\n        \"\"\"\n\n        byte_array = bytearray()\n\n        # Iterate through the binary string in chunks of 8 bits (1 byte)\n        for i in range(0, len(self.binary_string), 8):\n            # Get each byte (8 bits)\n            byte = self.binary_string[i:i+8]\n            # Convert the byte to a decimal value\n            decimal = int(byte, 2)\n            # Append the decimal value to the byte array\n            byte_array.append(decimal)\n\n        # Convert the byte array to an ascii string and return it\n        return byte_array.decode('ascii')\n\n    def convert_to_utf8(self):\n        \"\"\"\n        Convert the binary string to utf-8 string.\n        >>> bdp = BinaryDataProcessor(\"0110100001100101011011000110110001101111\")\n        >>> bdp.convert_to_utf8()\n        'hello'\n\n        \"\"\"\n\n        byte_array = bytearray()\n\n        # Iterate through the binary string in chunks of 8 bits (1 byte)\n        for i in range(0, len(self.binary_string), 8):\n            # Get each byte (8 bits)\n            byte = self.binary_string[i:i+8]\n            # Convert the byte to decimal\n            decimal = int(byte, 2)\n            # Append the decimal value to the byte array\n            byte_array.append(decimal)\n\n        # Convert the byte array to a utf-8 string and return it\n        return byte_array.decode('utf-8')"
    },
    {
        "id" : "11",
        "code" : "class BitStatusUtil:\n    \"\"\"\n    This is a utility class that provides methods for manipulating and checking status using bitwise operations.\n    \"\"\"\n\n    @staticmethod\n    def add(states, stat):\n        \"\"\"\n        Add a status to the current status,and check the parameters wheather they are legal.\n        :param states: Current status,int.\n        :param stat: Status to be added,int.\n        :return: The status after adding the status,int.\n        >>> bit_status_util = BitStatusUtil()\n        >>> bit_status_util.add(2,4)\n        6\n\n        \"\"\"\n\n        BitStatusUtil.check([states, stat])\n        return states | stat\n\n    @staticmethod\n    def has(states, stat):\n        \"\"\"\n        Check if the current status contains the specified status,and check the parameters wheather they are legal.\n        :param states: Current status,int.\n        :param stat: Specified status,int.\n        :return: True if the current status contains the specified status,otherwise False,bool.\n        >>> bit_status_util = BitStatusUtil()\n        >>> bit_status_util.has(6,2)\n        True\n\n        \"\"\"\n\n        BitStatusUtil.check([states, stat])\n        return (states & stat) == stat\n\n    @staticmethod\n    def remove(states, stat):\n        \"\"\"\n        Remove the specified status from the current status,and check the parameters wheather they are legal.\n        :param states: Current status,int.\n        :param stat: Specified status,int.\n        :return: The status after removing the specified status,int.\n        >>> bit_status_util = BitStatusUtil()\n        >>> bit_status_util.remove(6,2)\n        4\n\n        \"\"\"\n\n        BitStatusUtil.check([states, stat])\n        if BitStatusUtil.has(states, stat):\n            return states ^ stat\n        return states\n\n    @staticmethod\n    def check(args):\n        \"\"\"\n        Check if the parameters are legal, args must be greater than or equal to 0 and must be even,if not,raise ValueError.\n        :param args: Parameters to be checked,list.\n        :return: None.\n        >>> bit_status_util = BitStatusUtil()\n        >>> bit_status_util.check([2,3,4])\n        Traceback (most recent call last):\n        ...\n        ValueError: 3 not even\n        \"\"\"\n\n        for arg in args:\n            if arg < 0:\n                raise ValueError(f\"{arg} must be greater than or equal to 0\")\n            if arg % 2 != 0:\n                raise ValueError(f\"{arg} not even\")",
        "annotated_code" : "class BitStatusUtil:\n    \"\"\"\n    This is a utility class that provides methods for manipulating and checking status using bitwise operations.\n    \"\"\"\n\n    @staticmethod\n    def add(states, stat):\n        \"\"\"\n        Add a status to the current status,and check the parameters wheather they are legal.\n        :param states: Current status,int.\n        :param stat: Status to be added,int.\n        :return: The status after adding the status,int.\n        >>> bit_status_util = BitStatusUtil()\n        >>> bit_status_util.add(2,4)\n        6\n\n        \"\"\"\n\n        # Use the check class method to check if the parameters are legal\n        BitStatusUtil.check([states, stat])\n\n        # Add the status to the current status using the bitwise OR operation\n        return states | stat\n\n    @staticmethod\n    def has(states, stat):\n        \"\"\"\n        Check if the current status contains the specified status,and check the parameters wheather they are legal.\n        :param states: Current status,int.\n        :param stat: Specified status,int.\n        :return: True if the current status contains the specified status,otherwise False,bool.\n        >>> bit_status_util = BitStatusUtil()\n        >>> bit_status_util.has(6,2)\n        True\n\n        \"\"\"\n\n        # Use the check class method to check if the parameters are legal\n        BitStatusUtil.check([states, stat])\n\n        # Check if the current status contains the specified status using the bitwise AND operation\n        return (states & stat) == stat\n\n    @staticmethod\n    def remove(states, stat):\n        \"\"\"\n        Remove the specified status from the current status,and check the parameters wheather they are legal.\n        :param states: Current status,int.\n        :param stat: Specified status,int.\n        :return: The status after removing the specified status,int.\n        >>> bit_status_util = BitStatusUtil()\n        >>> bit_status_util.remove(6,2)\n        4\n\n        \"\"\"\n\n        # Use the check class method to check if the parameters are legal\n        BitStatusUtil.check([states, stat])\n\n        # Use the has class method to check if the current status contains the specified status\n        # If so, remove it using bitwise XOR operation\n        if BitStatusUtil.has(states, stat):\n            return states ^ stat\n        \n        # Return the new status\n        return states\n\n    @staticmethod\n    def check(args):\n        \"\"\"\n        Check if the parameters are legal, args must be greater than or equal to 0 and must be even,if not,raise ValueError.\n        :param args: Parameters to be checked,list.\n        :return: None.\n        >>> bit_status_util = BitStatusUtil()\n        >>> bit_status_util.check([2,3,4])\n        Traceback (most recent call last):\n        ...\n        ValueError: 3 not even\n        \"\"\"\n\n        # Check if the parameters are legal\n        for arg in args:\n            # Check if the parameter is greater than or equal to 0\n            # If not, raise ValueError\n            if arg < 0:\n                raise ValueError(f\"{arg} must be greater than or equal to 0\")\n            \n            # Check if the parameter is even\n            # If not, raise ValueError\n            if arg % 2 != 0:\n                raise ValueError(f\"{arg} not even\")"
    },
    {
        "id" : "12",
        "code" : "import random\nclass BlackjackGame:\n    \"\"\"\n    This is a class representing a game of blackjack, which includes creating a deck, calculating the value of a hand, and determine the winner based on the hand values of the player and dealer.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the Blackjack Game with the attribute deck, player_hand and dealer_hand.\n        While initializing deck attribute, call the create_deck method to generate.\n        The deck stores 52 random order poker with the Jokers removed, format is ['AS', '2S', ...].\n        player_hand is a list which stores player's hand cards.\n        dealer_hand is is a list which stores dealer's hand cards.\n        \"\"\"\n        self.deck = self.create_deck()\n        self.player_hand = []\n        self.dealer_hand = []\n\n    def create_deck(self):\n        \"\"\"\n        Create a deck of 52 cards, which stores 52 random order poker with the Jokers removed.\n        :return: a list of 52 random order poker with the Jokers removed, format is ['AS', '2S', ...].\n        >>> black_jack_game = BlackjackGame()\n        >>> black_jack_game.create_deck()\n        ['QD', '9D', 'JC', 'QH', '2S', 'JH', '7D', '6H', '9S', '5C', '7H', 'QS', '5H',\n        '6C', '7C', '3D', '10C', 'AD', '4C', '5D', 'AH', '2D', 'QC', 'KH', '9C', '9H',\n        '4H', 'JS', '6S', '8H', '8C', '4S', '3H', '10H', '7S', '6D', '3C', 'KC', '3S',\n        '2H', '10D', 'KS', '4D', 'AC', '10S', '2C', 'KD', '5S', 'JD', '8S', 'AS', '8D']\n        \"\"\"\n\n        deck = []\n        suits = ['S', 'C', 'D', 'H']\n        ranks = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K']\n        for suit in suits:\n            for rank in ranks:\n                deck.append(rank + suit)\n        random.shuffle(deck)\n        return deck\n\n    def calculate_hand_value(self, hand):\n        \"\"\"\n        Calculate the value of the poker cards stored in hand list according to the rules of the Blackjack Game.\n        If the card is a digit, its value is added to the total hand value.\n        Value of J, Q, or K is 10, while Aces are worth 11.\n        If the total hand value exceeds 21 and there are Aces present, one Ace is treated as having a value of 1 instead of 11,\n        until the hand value is less than or equal to 21, or all Aces have been counted as value of 1.\n        :param hand: list\n        :return: the value of the poker cards stored in hand list, a number.\n        >>> black_jack_game.calculate_hand_value(['QD', '9D', 'JC', 'QH', 'AS'])\n        40\n        \"\"\"\n\n        value = 0\n        num_aces = 0\n        for card in hand:\n            rank = card[:-1]\n            if rank.isdigit():\n                value += int(rank)\n            elif rank in ['J', 'Q', 'K']:\n                value += 10\n            elif rank == 'A':\n                value += 11\n                num_aces += 1\n        while value > 21 and num_aces > 0:\n            value -= 10\n            num_aces -= 1\n        return value\n\n    def check_winner(self, player_hand, dealer_hand):\n        \"\"\"\n        Determines the winner of a game by comparing the hand values of the player and dealer.\n        rule:\n        If both players have hand values that are equal to or less than 21, the winner is the one whose hand value is closer to 21.\n        Otherwise, the winner is the one with the lower hand value.\n        :param player_hand: list\n        :param dealer_hand: list\n        :return: the result of the game, only two certain str: 'Dealer wins' or 'Player wins'\n        >>> black_jack_game.check_winner(['QD', '9D', 'JC', 'QH', 'AS'], ['QD', '9D', 'JC', 'QH', '2S'])\n        'Player wins'\n        \"\"\"\n        player_value = self.calculate_hand_value(player_hand)\n        dealer_value = self.calculate_hand_value(dealer_hand)\n        if player_value > 21 and dealer_value > 21:\n            if player_value < dealer_value:\n                return 'Player wins'\n            elif player_value > dealer_value:\n                return 'Dealer wins'\n        elif player_value > 21:\n            return 'Dealer wins'\n        elif dealer_value > 21:\n            return 'Player wins'\n        else:\n            if player_value < dealer_value:\n                return 'Dealer wins'\n            elif player_value > dealer_value:\n                return 'Player wins'\n", 
        "annotated_code" : "import random\nclass BlackjackGame:\n    \"\"\"\n    This is a class representing a game of blackjack, which includes creating a deck, calculating the value of a hand, and determine the winner based on the hand values of the player and dealer.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the Blackjack Game with the attribute deck, player_hand and dealer_hand.\n        While initializing deck attribute, call the create_deck method to generate.\n        The deck stores 52 random order poker with the Jokers removed, format is ['AS', '2S', ...].\n        player_hand is a list which stores player's hand cards.\n        dealer_hand is is a list which stores dealer's hand cards.\n        \"\"\"\n\n        # Use the create_deck class method to generate a deck of cards\n        self.deck = self.create_deck()\n        self.player_hand = []\n        self.dealer_hand = []\n\n    def create_deck(self):\n        \"\"\"\n        Create a deck of 52 cards, which stores 52 random order poker with the Jokers removed.\n        :return: a list of 52 random order poker with the Jokers removed, format is ['AS', '2S', ...].\n        >>> black_jack_game = BlackjackGame()\n        >>> black_jack_game.create_deck()\n        ['QD', '9D', 'JC', 'QH', '2S', 'JH', '7D', '6H', '9S', '5C', '7H', 'QS', '5H',\n        '6C', '7C', '3D', '10C', 'AD', '4C', '5D', 'AH', '2D', 'QC', 'KH', '9C', '9H',\n        '4H', 'JS', '6S', '8H', '8C', '4S', '3H', '10H', '7S', '6D', '3C', 'KC', '3S',\n        '2H', '10D', 'KS', '4D', 'AC', '10S', '2C', 'KD', '5S', 'JD', '8S', 'AS', '8D']\n        \"\"\"\n\n        # Create a deck of 52 cards, which stores 52 random order cards with the Jokers removed.\n        deck = []\n        suits = ['S', 'C', 'D', 'H']\n        ranks = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K']\n        # Generate all combinations of ranks and suits and append them to the deck\n        for suit in suits:\n            for rank in ranks:\n                deck.append(rank + suit)\n        \n        # Use the random.shuffle method to randomize the order of cards\n        random.shuffle(deck)\n\n        # Return the shuffled deck\n        return deck\n\n    def calculate_hand_value(self, hand):\n        \"\"\"\n        Calculate the value of the poker cards stored in hand list according to the rules of the Blackjack Game.\n        If the card is a digit, its value is added to the total hand value.\n        Value of J, Q, or K is 10, while Aces are worth 11.\n        If the total hand value exceeds 21 and there are Aces present, one Ace is treated as having a value of 1 instead of 11,\n        until the hand value is less than or equal to 21, or all Aces have been counted as value of 1.\n        :param hand: list\n        :return: the value of the poker cards stored in hand list, a number.\n        >>> black_jack_game.calculate_hand_value(['QD', '9D', 'JC', 'QH', 'AS'])\n        40\n        \"\"\"\n\n        value = 0\n        num_aces = 0\n\n        # Iterate through each card in the hand\n        for card in hand:\n            rank = card[:-1]\n\n            # If the rank is a digit, add its integer value to the total hand value\n            if rank.isdigit():\n                value += int(rank)\n            # If the rank is J, Q, or K, add 10 to the total hand value\n            elif rank in ['J', 'Q', 'K']:\n                value += 10\n            # If the rank is A, add 11 to the total hand value and increment the number of Aces\n            elif rank == 'A':\n                value += 11\n                num_aces += 1\n\n        # Adjust the value of Aces if the total hand value exceeds 21\n        while value > 21 and num_aces > 0:\n            value -= 10\n            num_aces -= 1\n\n        # Return the final hand value\n        return value\n\n    def check_winner(self, player_hand, dealer_hand):\n        \"\"\"\n        Determines the winner of a game by comparing the hand values of the player and dealer.\n        rule:\n        If both players have hand values that are equal to or less than 21, the winner is the one whose hand value is closer to 21.\n        Otherwise, the winner is the one with the lower hand value.\n        :param player_hand: list\n        :param dealer_hand: list\n        :return: the result of the game, only two certain str: 'Dealer wins' or 'Player wins'\n        >>> black_jack_game.check_winner(['QD', '9D', 'JC', 'QH', 'AS'], ['QD', '9D', 'JC', 'QH', '2S'])\n        'Player wins'\n        \"\"\"\n\n        # Use the calculate_hand_value class method to calculate the hand values for both player and dealer\n        player_value = self.calculate_hand_value(player_hand)\n        dealer_value = self.calculate_hand_value(dealer_hand)\n\n        # If both players exceed 21, the one with the lower hand value wins\n        if player_value > 21 and dealer_value > 21:\n            if player_value < dealer_value:\n                return 'Player wins'\n            elif player_value > dealer_value:\n                return 'Dealer wins'\n        # If the player exceeds 21 and the dealer doesn't exceed 21, the dealer wins\n        elif player_value > 21:\n            return 'Dealer wins'\n        # If the dealer exceeds 21 and the player doesn't exceed 21, the player wins\n        elif dealer_value > 21:\n            return 'Player wins'\n        else:\n        # If both players are within the limit, the one with the higher hand value wins\n            if player_value < dealer_value:\n                return 'Dealer wins'\n            elif player_value > dealer_value:\n                return 'Player wins'\n"
    },
    {
        "id" : "13",
        "code" : "class BookManagement:\n    \"\"\"\n    This is a class as managing books system, which supports to add and remove books from the inventory dict, view the inventory, and check the quantity of a specific book.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the inventory of Book Manager.\n        \"\"\"\n        self.inventory = {}\n\n    def add_book(self, title, quantity=1):\n        \"\"\"\n        Add one or several books to inventory which is sorted by book title.\n        :param title: str, the book title\n        :param quantity: int, default value is 1.\n        \"\"\"\n\n        if title in self.inventory:\n            self.inventory[title] += quantity\n        else:\n            self.inventory[title] = quantity\n\n    def remove_book(self, title, quantity):\n        \"\"\"\n        Remove one or several books from inventory which is sorted by book title.\n        Raise false while get invalid input.\n        :param title: str, the book title\n        :param quantity: int\n        \"\"\"\n\n        if title not in self.inventory or self.inventory[title] < quantity:\n            raise False\n        self.inventory[title] -= quantity\n        if self.inventory[title] == 0:\n            del (self.inventory[title])\n\n    def view_inventory(self):\n        \"\"\"\n        Get the inventory of the Book Management.\n        :return self.inventory: dictionary, {title(str): quantity(int), ...}\n        >>> bookManagement = BookManagement()\n        >>> bookManagement.add_book(\"book1\", 1)\n        >>> bookManagement.add_book(\"book2\", 1)\n        >>> bookManagement.view_inventory()\n        {'book1': 1, 'book2': 1}\n        \"\"\"\n\n        return self.inventory\n\n    def view_book_quantity(self, title):\n        \"\"\"\n        Get the quantity of a book.\n        :param title: str, the title of the book.\n        :return quantity: the quantity of this book title. return 0 when the title does not exist in self.invenroty\n        >>> bookManagement = BookManagement()\n        >>> bookManagement.add_book(\"book1\", 1)\n        >>> bookManagement.view_book_quantity(\"book3\")\n        0\n        \"\"\"\n\n        if title not in self.inventory:\n            return 0\n        return self.inventory[title]",
        "annotated_code" : "class BookManagement:\n    \"\"\"\n    This is a class as managing books system, which supports to add and remove books from the inventory dict, view the inventory, and check the quantity of a specific book.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the inventory of Book Manager.\n        \"\"\"\n        self.inventory = {}\n\n    def add_book(self, title, quantity=1):\n        \"\"\"\n        Add one or several books to inventory which is sorted by book title.\n        :param title: str, the book title\n        :param quantity: int, default value is 1.\n        \"\"\"\n\n        # If the book title is in the inventory, add the quantity to the existing quantity for the book\n        if title in self.inventory:\n            self.inventory[title] += quantity\n        # Otherwise, add the book title and quantity to the inventory\n        else:\n            self.inventory[title] = quantity\n\n    def remove_book(self, title, quantity):\n        \"\"\"\n        Remove one or several books from inventory which is sorted by book title.\n        Raise false while get invalid input.\n        :param title: str, the book title\n        :param quantity: int\n        \"\"\"\n\n        # If the book title is not in the inventory or quantity is larger than the existing quantity for the book, return False\n        if title not in self.inventory or self.inventory[title] < quantity:\n            raise False\n        \n        # Otherwise, decrease the existing quantity for the book by quantity\n        self.inventory[title] -= quantity\n\n        # If the quantity for the book is 0, remove the book from the inventory\n        if self.inventory[title] == 0:\n            del (self.inventory[title])\n\n    def view_inventory(self):\n        \"\"\"\n        Get the inventory of the Book Management.\n        :return self.inventory: dictionary, {title(str): quantity(int), ...}\n        >>> bookManagement = BookManagement()\n        >>> bookManagement.add_book(\"book1\", 1)\n        >>> bookManagement.add_book(\"book2\", 1)\n        >>> bookManagement.view_inventory()\n        {'book1': 1, 'book2': 1}\n        \"\"\"\n\n        # Return the inventory\n        return self.inventory\n\n    def view_book_quantity(self, title):\n        \"\"\"\n        Get the quantity of a book.\n        :param title: str, the title of the book.\n        :return quantity: the quantity of this book title. return 0 when the title does not exist in self.invenroty\n        >>> bookManagement = BookManagement()\n        >>> bookManagement.add_book(\"book1\", 1)\n        >>> bookManagement.view_book_quantity(\"book3\")\n        0\n        \"\"\"\n\n        # If the book title is not in the inventory, return 0\n        if title not in self.inventory:\n            return 0\n        \n        # Otherwise, return the quantity of the book\n        return self.inventory[title]"
    },
    {
        "id" : "14",
        "code" : "import sqlite3\n\nclass BookManagementDB:\n    '''\n    This is a database class as a book management system, used to handle the operations of adding, removing, updating, and searching books.\n    '''\n\n\n    def __init__(self, db_name):\n        '''\n        Initializes the class by creating a database connection and cursor, \n        and creates the book table if it does not already exist\n        :param db_name: str, the name of db file\n        '''\n        self.connection = sqlite3.connect(db_name)\n        self.cursor = self.connection.cursor()\n        self.create_table()\n\n    def create_table(self):\n        '''\n        Creates the book table in the database if it does not already exist.\n        >>> book_db = BookManagementDB(\"test.db\")\n        >>> book_db.create_table()\n        '''\n\n        self.cursor.execute('''\n            CREATE TABLE IF NOT EXISTS books (\n                id INTEGER PRIMARY KEY,\n                title TEXT,\n                author TEXT,\n                available INTEGER\n            )\n        ''')\n        self.connection.commit()\n\n    def add_book(self, title, author):\n        '''\n        Adds a book to the database with the specified title and author, \n        setting its availability to 1 as free to borrow.\n        :param title: str, book title\n        :param author: str, author name\n        >>> book_db = BookManagementDB(\"test.db\")\n        >>> book_db.create_table()\n        >>> book_db.add_book('book1', 'author')\n        '''\n\n        self.cursor.execute('''\n            INSERT INTO books (title, author, available)\n            VALUES (?, ?, 1)\n        ''', (title, author))\n        self.connection.commit()\n\n    def remove_book(self, book_id):\n        '''\n        Removes a book from the database based on the given book ID.\n        :param book_id: int\n        >>> book_db = BookManagementDB(\"test.db\")\n        >>> book_db.remove_book(1)\n        '''\n\n        self.cursor.execute('''\n            DELETE FROM books WHERE id = ?\n        ''', (book_id,))\n        self.connection.commit()\n\n    def borrow_book(self, book_id):\n        '''\n        Marks a book as borrowed in the database based on the given book ID.\n        :param book_id: int\n        >>> book_db = BookManagementDB(\"test.db\")\n        >>> book_db.borrow_book(1)\n        '''\n\n        self.cursor.execute('''\n            UPDATE books SET available = 0 WHERE id = ?\n        ''', (book_id,))\n        self.connection.commit()\n\n    def return_book(self, book_id):\n        '''\n        Marks a book as returned in the database based on the given book ID.\n        :param book_id: int\n        >>> book_db = BookManagementDB(\"test.db\")\n        >>> book_db.return_book(1)\n        '''\n\n        self.cursor.execute('''\n            UPDATE books SET available = 1 WHERE id = ?\n        ''', (book_id,))\n        self.connection.commit()\n\n    def search_books(self):\n        '''\n        Retrieves all books from the database and returns their information.\n        :return books: list[tuple], the information of all books in database\n        >>> book_db.search_books()\n        [(1, 'book1', 'author', 1)]\n        '''\n\n        self.cursor.execute('''\n            SELECT * FROM books\n        ''')\n        books = self.cursor.fetchall()\n        return books",
        "annotated_code" : "import sqlite3\n\nclass BookManagementDB:\n    '''\n    This is a database class as a book management system, used to handle the operations of adding, removing, updating, and searching books.\n    '''\n\n\n    def __init__(self, db_name):\n        '''\n        Initializes the class by creating a database connection and cursor, \n        and creates the book table if it does not already exist\n        :param db_name: str, the name of db file\n        '''\n        self.connection = sqlite3.connect(db_name)\n        self.cursor = self.connection.cursor()\n        self.create_table()\n\n    def create_table(self):\n        '''\n        Creates the book table in the database if it does not already exist.\n        >>> book_db = BookManagementDB(\"test.db\")\n        >>> book_db.create_table()\n        '''\n\n        # Execute the SQL query to create the books table if it does not exist\n        self.cursor.execute('''\n            CREATE TABLE IF NOT EXISTS books (\n                id INTEGER PRIMARY KEY,\n                title TEXT,\n                author TEXT,\n                available INTEGER\n            )\n        ''')\n\n        # Commit the changes to the database\n        self.connection.commit()\n\n    def add_book(self, title, author):\n        '''\n        Adds a book to the database with the specified title and author, \n        setting its availability to 1 as free to borrow.\n        :param title: str, book title\n        :param author: str, author name\n        >>> book_db = BookManagementDB(\"test.db\")\n        >>> book_db.create_table()\n        >>> book_db.add_book('book1', 'author')\n        '''\n\n        # Execute the SQL query to insert a new book into the table\n        self.cursor.execute('''\n            INSERT INTO books (title, author, available)\n            VALUES (?, ?, 1)\n        ''', (title, author))\n\n        # Commit the changes to the database\n        self.connection.commit()\n\n    def remove_book(self, book_id):\n        '''\n        Removes a book from the database based on the given book ID.\n        :param book_id: int\n        >>> book_db = BookManagementDB(\"test.db\")\n        >>> book_db.remove_book(1)\n        '''\n\n        # Execute the SQL query to delete the book with the given ID\n        self.cursor.execute('''\n            DELETE FROM books WHERE id = ?\n        ''', (book_id,))\n\n        # Commit the changes to the database\n        self.connection.commit()\n\n    def borrow_book(self, book_id):\n        '''\n        Marks a book as borrowed in the database based on the given book ID.\n        :param book_id: int\n        >>> book_db = BookManagementDB(\"test.db\")\n        >>> book_db.borrow_book(1)\n        '''\n\n        # Execute the SQL query to update the book's availability to 0(borrowed)\n        self.cursor.execute('''\n            UPDATE books SET available = 0 WHERE id = ?\n        ''', (book_id,))\n\n        # Commit the changes to the database\n        self.connection.commit()\n\n    def return_book(self, book_id):\n        '''\n        Marks a book as returned in the database based on the given book ID.\n        :param book_id: int\n        >>> book_db = BookManagementDB(\"test.db\")\n        >>> book_db.return_book(1)\n        '''\n\n        # Execute the SQL query to update the book's availability to 1(available)\n        self.cursor.execute('''\n            UPDATE books SET available = 1 WHERE id = ?\n        ''', (book_id,))\n\n        # Commit the changes to the database\n        self.connection.commit()\n\n    def search_books(self):\n        '''\n        Retrieves all books from the database and returns their information.\n        :return books: list[tuple], the information of all books in database\n        >>> book_db.search_books()\n        [(1, 'book1', 'author', 1)]\n        '''\n\n        # Execute the SQL query to fetch all books\n        self.cursor.execute('''\n            SELECT * FROM books\n        ''')\n\n        # Fetch all results from the executed query\n        books = self.cursor.fetchall()\n\n        # Return the list of books\n        return books"
    },
    {
        "id" : "15",
        "code" : "class BoyerMooreSearch:\n    \"\"\"\n    This is a class that implements the Boyer-Moore algorithm for string searching, which is used to find occurrences of a pattern within a given text.\n    \"\"\"\n\n    def __init__(self, text, pattern):\n        \"\"\"\n        Initializes the BoyerMooreSearch class with the given text and pattern.\n        :param text: The text to be searched, str.\n        :param pattern: The pattern to be searched for, str.\n        \"\"\"\n        self.text, self.pattern = text, pattern\n        self.textLen, self.patLen = len(text), len(pattern)\n\n    def match_in_pattern(self, char):\n        \"\"\"\n        Finds the rightmost occurrence of a character in the pattern.\n        :param char: The character to be searched for, str.\n        :return: The index of the rightmost occurrence of the character in the pattern, int.\n        >>> boyerMooreSearch = BoyerMooreSearch(\"ABAABA\", \"AB\")\n        >>> boyerMooreSearch.match_in_pattern(\"A\")\n        0\n\n        \"\"\"\n\n        for i in range(self.patLen - 1, -1, -1):\n            if char == self.pattern[i]:\n                return i\n        return -1\n\n    def mismatch_in_text(self, currentPos):\n        \"\"\"\n        Determines the position of the first mismatch between the pattern and the text.\n        :param currentPos: The current position in the text, int.\n        :return: The position of the first mismatch between the pattern and the text, int,otherwise -1.\n        >>> boyerMooreSearch = BoyerMooreSearch(\"ABAABA\", \"ABC\")\n        >>> boyerMooreSearch.mismatch_in_text(0)\n        2\n\n        \"\"\"\n\n        for i in range(self.patLen - 1, -1, -1):\n            if self.pattern[i] != self.text[currentPos + i]:\n                return currentPos + i\n        return -1\n\n    def bad_character_heuristic(self):\n        \"\"\"\n        Finds all occurrences of the pattern in the text.\n        :return: A list of all positions of the pattern in the text, list.\n        >>> boyerMooreSearch = BoyerMooreSearch(\"ABAABA\", \"AB\")\n        >>> boyerMooreSearch.bad_character_heuristic()\n        [0, 3]\n\n        \"\"\"\n\n        positions = []\n        i = 0\n        while i <= self.textLen - self.patLen:\n            mismatch_index = self.mismatch_in_text(i)\n            if mismatch_index == -1:\n                positions.append(i)\n                i += 1\n            else:\n                match_index = self.match_in_pattern(self.text[mismatch_index])\n                i += max(1, mismatch_index - match_index)\n        return positions",
        "annotated_code" : "class BoyerMooreSearch:\n    \"\"\"\n    This is a class that implements the Boyer-Moore algorithm for string searching, which is used to find occurrences of a pattern within a given text.\n    \"\"\"\n\n    def __init__(self, text, pattern):\n        \"\"\"\n        Initializes the BoyerMooreSearch class with the given text and pattern.\n        :param text: The text to be searched, str.\n        :param pattern: The pattern to be searched for, str.\n        \"\"\"\n        self.text, self.pattern = text, pattern\n        self.textLen, self.patLen = len(text), len(pattern)\n\n    def match_in_pattern(self, char):\n        \"\"\"\n        Finds the rightmost occurrence of a character in the pattern.\n        :param char: The character to be searched for, str.\n        :return: The index of the rightmost occurrence of the character in the pattern, int.\n        >>> boyerMooreSearch = BoyerMooreSearch(\"ABAABA\", \"AB\")\n        >>> boyerMooreSearch.match_in_pattern(\"A\")\n        0\n\n        \"\"\"\n\n        # Iterate from the end of the pattern to the beginning\n        for i in range(self.patLen - 1, -1, -1):\n            # If the character is found, return its index\n            if char == self.pattern[i]:\n                return i\n        # If the character is not found, return -1\n        return -1\n\n    def mismatch_in_text(self, currentPos):\n        \"\"\"\n        Determines the position of the first mismatch between the pattern and the text.\n        :param currentPos: The current position in the text, int.\n        :return: The position of the first mismatch between the pattern and the text, int,otherwise -1.\n        >>> boyerMooreSearch = BoyerMooreSearch(\"ABAABA\", \"ABC\")\n        >>> boyerMooreSearch.mismatch_in_text(0)\n        2\n\n        \"\"\"\n\n        # Iterate from the end of the pattern to the beginning\n        for i in range(self.patLen - 1, -1, -1):\n            # If a mismatch is found, return the position of the mismatch in the text\n            if self.pattern[i] != self.text[currentPos + i]:\n                return currentPos + i\n        # If no mismatch is found, return -1\n        return -1\n\n    def bad_character_heuristic(self):\n        \"\"\"\n        Finds all occurrences of the pattern in the text.\n        :return: A list of all positions of the pattern in the text, list.\n        >>> boyerMooreSearch = BoyerMooreSearch(\"ABAABA\", \"AB\")\n        >>> boyerMooreSearch.bad_character_heuristic()\n        [0, 3]\n\n        \"\"\"\n\n        positions = []\n        i = 0\n        # Iterate through the text\n        while i <= self.textLen - self.patLen:\n            # Use the mismatch_in_text class method to find the position of the first mismatch between the pattern and the text starting from the current position\n            mismatch_index = self.mismatch_in_text(i)\n\n            # If no mismatch is found, add the current position to the list of positions and move to the next position\n            if mismatch_index == -1:\n                positions.append(i)\n                i += 1\n            # If a mismatch is found, use the match_in_pattern class method to find the rightmost occurrence of the mismatched character in the pattern\n            # Move the current position to the right so that the last occurrence of the mismatched character in the pattern aligns with the mismatched character in the text\n            else:\n                match_index = self.match_in_pattern(self.text[mismatch_index])\n                i += max(1, mismatch_index - match_index)\n\n        # Return the list of positions\n        return positions"
    },
    {
        "id" : "16",
        "code" : "class Calculator:\n    \"\"\"\n    This is a class for a calculator, capable of performing basic arithmetic calculations on numerical expressions using the operators +, -, *, /, and ^ (exponentiation).\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the operations performed by the five operators'+','-','*','/','^'\n        \"\"\"\n        self.operators = {\n            '+': lambda x, y: x + y,\n            '-': lambda x, y: x - y,\n            '*': lambda x, y: x * y,\n            '/': lambda x, y: x / y,\n            '^': lambda x, y: x ** y\n        }\n\n    def calculate(self, expression):\n        \"\"\"\n        Calculate the value of a given expression\n        :param expression: string, given expression\n        :return:If successful, returns the value of the expression; otherwise, returns None\n        >>> calculator = Calculator()\n        >>> calculator.calculate('1+2-3')\n        0.0\n        \"\"\"\n\n        operand_stack = []\n        operator_stack = []\n        num_buffer = ''\n        for char in expression:\n            if char.isdigit() or char == '.':\n                num_buffer += char\n            else:\n                if num_buffer:\n                    operand_stack.append(float(num_buffer))\n                    num_buffer = ''\n                if char in '+-*/^':\n                    while (\n                            operator_stack and\n                            operator_stack[-1] != '(' and\n                            self.precedence(operator_stack[-1]) >= self.precedence(char)\n                    ):\n                        operand_stack, operator_stack = self.apply_operator(operand_stack, operator_stack)\n                    operator_stack.append(char)\n                elif char == '(':\n                    operator_stack.append(char)\n                elif char == ')':\n                    while operator_stack and operator_stack[-1] != '(':\n                        operand_stack, operator_stack = self.apply_operator(operand_stack, operator_stack)\n                    operator_stack.pop()\n        if num_buffer:\n            operand_stack.append(float(num_buffer))\n        while operator_stack:\n            operand_stack, operator_stack = self.apply_operator(operand_stack, operator_stack)\n        return operand_stack[-1] if operand_stack else None\n\n    def precedence(self, operator):\n        \"\"\"\n        Returns the priority of the specified operator, where the higher the priority, the greater the assignment. The priority of '^' is greater than '/' and '*', and the priority of '/' and '*' is greater than '+' and '-'\n        :param operator: string, given operator\n        :return: int, the priority of the given operator, otherwise return 0\n        >>> calculator = Calculator()\n        >>> calculator.precedence('+')\n        1\n        >>> calculator.precedence('^')\n        3\n        \"\"\"\n\n        precedences = {\n            '+': 1,\n            '-': 1,\n            '*': 2,\n            '/': 2,\n            '^': 3\n        }\n        return precedences.get(operator, 0)\n\n    def apply_operator(self, operand_stack, operator_stack):\n        \"\"\"\n        Use the operator at the top of the operator stack to perform the operation on the two numbers at the top of the operator stack, and store the results at the top of the operator stack\n        :param operand_stack:list\n        :param operator_stack:list\n        :return: the updated operand_stack and operator_stack\n        >>> calculator = Calculator()\n        >>> calculator.apply_operator([1, 2, 3], ['+', '-'])\n        ([1, -1], ['-'])\n        \"\"\"\n\n        operator = operator_stack.pop()\n        operand2 = operand_stack.pop()\n        operand1 = operand_stack.pop()\n        result = self.operators[operator](operand1, operand2)\n        operand_stack.append(result)\n        return operand_stack, operator_stack",
        "annotated_code" : "class Calculator:\n    \"\"\"\n    This is a class for a calculator, capable of performing basic arithmetic calculations on numerical expressions using the operators +, -, *, /, and ^ (exponentiation).\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the operations performed by the five operators'+','-','*','/','^'\n        \"\"\"\n        self.operators = {\n            '+': lambda x, y: x + y,\n            '-': lambda x, y: x - y,\n            '*': lambda x, y: x * y,\n            '/': lambda x, y: x / y,\n            '^': lambda x, y: x ** y\n        }\n\n    def calculate(self, expression):\n        \"\"\"\n        Calculate the value of a given expression\n        :param expression: string, given expression\n        :return:If successful, returns the value of the expression; otherwise, returns None\n        >>> calculator = Calculator()\n        >>> calculator.calculate('1+2-3')\n        0.0\n        \"\"\"\n\n        operand_stack = []\n        operator_stack = []\n        num_buffer = ''\n\n        # Iterate through each character in the expression\n        for char in expression:\n\n            # If the character is a digit or a decimal point add it to the number buffer\n            if char.isdigit() or char == '.':\n                num_buffer += char\n            # If the character is an operator or a parenthesis, process it\n            else:\n                # If there is a number in the buffer, convert it to float and push it onto the operand stack\n                if num_buffer:\n                    operand_stack.append(float(num_buffer))\n                    num_buffer = ''\n\n                # Process the operator or parenthesis\n                if char in '+-*/^':\n                    # While there are operators in the stack and the top operator is not a left paranthesis, use the precedence class method to check if the top operator has greater or equal precedence than the current operator\n                    # If so, use the apply_operator class method to apply the top operator to the operands\n                    while (\n                            operator_stack and\n                            operator_stack[-1] != '(' and\n                            self.precedence(operator_stack[-1]) >= self.precedence(char)\n                    ):\n                        operand_stack, operator_stack = self.apply_operator(operand_stack, operator_stack)\n                    \n                    # Push the current operator onto the operator stack\n                    operator_stack.append(char)\n                elif char == '(':\n                    # Push the left parenthesis onto the operator stack\n                    operator_stack.append(char)\n                elif char == ')':\n                    # While there are operators in the stack and the top operator is not a left parenthesis, use the apply_operator class method to apply the top operator to the operands\n                    while operator_stack and operator_stack[-1] != '(':\n                        operand_stack, operator_stack = self.apply_operator(operand_stack, operator_stack)\n                    \n                    # Pop the left parenthesis from the operator stack\n                    operator_stack.pop()\n\n        # If there is a number in the buffer, convert it to float and push it onto the operand stack\n        if num_buffer:\n            operand_stack.append(float(num_buffer))\n\n        # While there are operators in the stack, use the apply_operator class method to apply the top operator to the operands\n        while operator_stack:\n            operand_stack, operator_stack = self.apply_operator(operand_stack, operator_stack)\n\n        # Return the final result, which is the last element in the operand stack\n        return operand_stack[-1] if operand_stack else None\n\n    def precedence(self, operator):\n        \"\"\"\n        Returns the priority of the specified operator, where the higher the priority, the greater the assignment. The priority of '^' is greater than '/' and '*', and the priority of '/' and '*' is greater than '+' and '-'\n        :param operator: string, given operator\n        :return: int, the priority of the given operator, otherwise return 0\n        >>> calculator = Calculator()\n        >>> calculator.precedence('+')\n        1\n        >>> calculator.precedence('^')\n        3\n        \"\"\"\n\n        # Define the precedence of each operator\n        precedences = {\n            '+': 1,\n            '-': 1,\n            '*': 2,\n            '/': 2,\n            '^': 3\n        }\n\n        # Return the precedence of the operator, defaulting to 0 if not found\n        return precedences.get(operator, 0)\n\n    def apply_operator(self, operand_stack, operator_stack):\n        \"\"\"\n        Use the operator at the top of the operator stack to perform the operation on the two numbers at the top of the operator stack, and store the results at the top of the operator stack\n        :param operand_stack:list\n        :param operator_stack:list\n        :return: the updated operand_stack and operator_stack\n        >>> calculator = Calculator()\n        >>> calculator.apply_operator([1, 2, 3], ['+', '-'])\n        ([1, -1], ['-'])\n        \"\"\"\n\n        # Pop the operator from the operator stack\n        operator = operator_stack.pop()\n\n        # Pop the two operands from the operand stack\n        operand2 = operand_stack.pop()\n        operand1 = operand_stack.pop()\n\n        # Perform the operation and push the result back onto the operand stack\n        result = self.operators[operator](operand1, operand2)\n        operand_stack.append(result)\n\n        # Return the updated stacks\n        return operand_stack, operator_stack"
    },
    {
        "id" : "17",
        "code" : "from datetime import datetime, timedelta\n\nclass CalendarUtil:\n    \"\"\"\n    This is a class as CalendarUtil that provides functionalities to manage calendar events, schedule appointments, and perform conflict checks.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the calendar with an empty list of events.\n        \"\"\"\n        self.events = []\n\n    def add_event(self, event):\n        \"\"\"\n        Add an event to the calendar.\n        :param event: The event to be added to the calendar,dict.\n        >>> calendar = CalendarUtil()\n        >>> calendar.add_event({'date': datetime(2023, 1, 1, 0, 0), 'start_time': datetime(2023, 1, 1, 0, 0), 'end_time': datetime(2023, 1, 1, 1, 0), 'description': 'New Year'})\n        >>> calendar.events\n        [{'date': datetime.datetime(2023, 1, 1, 0, 0), 'start_time': datetime.datetime(2023, 1, 1, 0, 0), 'end_time': datetime.datetime(2023, 1, 1, 1, 0), 'description': 'New Year'}]\n\n        \"\"\"\n\n        self.events.append(event)\n\n    def remove_event(self, event):\n        \"\"\"\n        Remove an event from the calendar.\n        :param event: The event to be removed from the calendar,dict.\n        >>> calendar = CalendarUtil()\n        >>> calendar.events = [{'date': datetime(2023, 1, 1, 0, 0), 'start_time': datetime(2023, 1, 1, 0, 0), 'end_time': datetime(2023, 1, 1, 1, 0), 'description': 'New Year'}]\n        >>> calendar.remove_event({'date': datetime(2023, 1, 1, 0, 0), 'start_time': datetime(2023, 1, 1, 0, 0), 'end_time': datetime(2023, 1, 1, 1, 0), 'description': 'New Year'})\n        >>> calendar.events\n        []\n\n        \"\"\"\n\n        if event in self.events:\n            self.events.remove(event)\n\n    def get_events(self, date):\n        \"\"\"\n        Get all events on a given date.\n        :param date: The date to get events for,datetime.\n        :return: A list of events on the given date,list.\n        >>> calendar = CalendarUtil()\n        >>> calendar.events = [{'date': datetime(2023, 1, 1, 0, 0), 'start_time': datetime(2023, 1, 1, 0, 0), 'end_time': datetime(2023, 1, 1, 1, 0), 'description': 'New Year'}]\n        >>> calendar.get_events(datetime(2023, 1, 1, 0, 0))\n        [{'date': datetime.datetime(2023, 1, 1, 0, 0), 'start_time': datetime.datetime(2023, 1, 1, 0, 0), 'end_time': datetime.datetime(2023, 1, 1, 1, 0), 'description': 'New Year'}]\n\n        \"\"\"\n\n        events_on_date = []\n        for event in self.events:\n            if event['date'].date() == date.date():\n                events_on_date.append(event)\n        return events_on_date\n\n    def is_available(self, start_time, end_time):\n        \"\"\"\n        Check if the calendar is available for a given time slot.\n        :param start_time: The start time of the time slot,datetime.\n        :param end_time: The end time of the time slot,datetime.\n        :return: True if the calendar is available for the given time slot, False otherwise,bool.\n        >>> calendar = CalendarUtil()\n        >>> calendar.events = [{'date': datetime(2023, 1, 1, 0, 0), 'start_time': datetime(2023, 1, 1, 0, 0), 'end_time': datetime(2023, 1, 1, 1, 0), 'description': 'New Year'}]\n        >>> calendar.is_available(datetime(2023, 1, 1, 0, 0), datetime(2023, 1, 1, 1, 0))\n        False\n\n        \"\"\"\n\n        for event in self.events:\n            if start_time < event['end_time'] and end_time > event['start_time']:\n                return False\n        return True\n\n    def get_available_slots(self, date):\n        \"\"\"\n        Get all available time slots on a given date.\n        :param date: The date to get available time slots for,datetime.\n        :return: A list of available time slots on the given date,list.\n        >>> calendar = CalendarUtil()\n        >>> calendar.events = [{'date': datetime(2023, 1, 1, 0, 0), 'start_time': datetime(2023, 1, 1, 0, 0), 'end_time': datetime(2023, 1, 1, 23, 0), 'description': 'New Year'}]\n        >>> calendar.get_available_slots(datetime(2023, 1, 1))\n        [(datetime.datetime(2023, 1, 1, 23, 0), datetime.datetime(2023, 1, 2, 0, 0))]\n\n        \"\"\"\n\n        available_slots = []\n        start_time = datetime(date.year, date.month, date.day, 0, 0)\n        end_time = datetime(date.year, date.month, date.day, 23, 59)\n\n        while start_time < end_time:\n            slot_end_time = start_time + timedelta(minutes=60)\n            if self.is_available(start_time, slot_end_time):\n                available_slots.append((start_time, slot_end_time))\n            start_time += timedelta(minutes=60)\n        return available_slots\n\n    def get_upcoming_events(self, num_events):\n        \"\"\"\n        Get the next n upcoming events from a given date.\n        :param date: The date to get upcoming events from,datetime.\n        :param n: The number of upcoming events to get,int.\n        :return: A list of the next n upcoming events from the given date,list.\n        >>> calendar = CalendarUtil()\n        >>> calendar.events = [{'date': datetime(2023, 1, 1, 0, 0), 'start_time': datetime(2023, 1, 1, 0, 0), 'end_time': datetime(2023, 1, 1, 23, 0), 'description': 'New Year'},{'date': datetime(2023, 1, 2, 0, 0),'end_time': datetime(2023, 1, 2, 1, 0), 'description': 'New Year 2'}]\n        >>> calendar.get_upcoming_events(1)\n        [{'date': datetime.datetime(2023, 1, 1, 0, 0), 'start_time': datetime.datetime(2023, 1, 1, 0, 0), 'end_time': datetime.datetime(2023, 1, 1, 23, 0), 'description': 'New Year'}, {'date': datetime.datetime(2023, 1, 2, 0, 0), 'end_time': datetime.datetime(2023, 1, 2, 1, 0), 'description': 'New Year 2'}]\n\n        \"\"\"\n\n        now = datetime.now()\n        upcoming_events = []\n\n        for event in self.events:\n            if event['start_time'] >= now:\n                upcoming_events.append(event)\n            if len(upcoming_events) == num_events:\n                break\n        \n        return upcoming_events",
        "annotated_code" : "from datetime import datetime, timedelta\n\nclass CalendarUtil:\n    \"\"\"\n    This is a class as CalendarUtil that provides functionalities to manage calendar events, schedule appointments, and perform conflict checks.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the calendar with an empty list of events.\n        \"\"\"\n        self.events = []\n\n    def add_event(self, event):\n        \"\"\"\n        Add an event to the calendar.\n        :param event: The event to be added to the calendar,dict.\n        >>> calendar = CalendarUtil()\n        >>> calendar.add_event({'date': datetime(2023, 1, 1, 0, 0), 'start_time': datetime(2023, 1, 1, 0, 0), 'end_time': datetime(2023, 1, 1, 1, 0), 'description': 'New Year'})\n        >>> calendar.events\n        [{'date': datetime.datetime(2023, 1, 1, 0, 0), 'start_time': datetime.datetime(2023, 1, 1, 0, 0), 'end_time': datetime.datetime(2023, 1, 1, 1, 0), 'description': 'New Year'}]\n\n        \"\"\"\n\n        # Add the event to the list of events\n        self.events.append(event)\n\n    def remove_event(self, event):\n        \"\"\"\n        Remove an event from the calendar.\n        :param event: The event to be removed from the calendar,dict.\n        >>> calendar = CalendarUtil()\n        >>> calendar.events = [{'date': datetime(2023, 1, 1, 0, 0), 'start_time': datetime(2023, 1, 1, 0, 0), 'end_time': datetime(2023, 1, 1, 1, 0), 'description': 'New Year'}]\n        >>> calendar.remove_event({'date': datetime(2023, 1, 1, 0, 0), 'start_time': datetime(2023, 1, 1, 0, 0), 'end_time': datetime(2023, 1, 1, 1, 0), 'description': 'New Year'})\n        >>> calendar.events\n        []\n\n        \"\"\"\n\n        # Remove the event from the list of events\n        if event in self.events:\n            self.events.remove(event)\n\n    def get_events(self, date):\n        \"\"\"\n        Get all events on a given date.\n        :param date: The date to get events for,datetime.\n        :return: A list of events on the given date,list.\n        >>> calendar = CalendarUtil()\n        >>> calendar.events = [{'date': datetime(2023, 1, 1, 0, 0), 'start_time': datetime(2023, 1, 1, 0, 0), 'end_time': datetime(2023, 1, 1, 1, 0), 'description': 'New Year'}]\n        >>> calendar.get_events(datetime(2023, 1, 1, 0, 0))\n        [{'date': datetime.datetime(2023, 1, 1, 0, 0), 'start_time': datetime.datetime(2023, 1, 1, 0, 0), 'end_time': datetime.datetime(2023, 1, 1, 1, 0), 'description': 'New Year'}]\n\n        \"\"\"\n\n        events_on_date = []\n\n        # Iterate through the list of events``\n        for event in self.events:\n\n            # If the event date matches the given date, add it to the list\n            if event['date'].date() == date.date():\n                events_on_date.append(event)\n\n        # Return the list of events on the given date\n        return events_on_date\n\n    def is_available(self, start_time, end_time):\n        \"\"\"\n        Check if the calendar is available for a given time slot.\n        :param start_time: The start time of the time slot,datetime.\n        :param end_time: The end time of the time slot,datetime.\n        :return: True if the calendar is available for the given time slot, False otherwise,bool.\n        >>> calendar = CalendarUtil()\n        >>> calendar.events = [{'date': datetime(2023, 1, 1, 0, 0), 'start_time': datetime(2023, 1, 1, 0, 0), 'end_time': datetime(2023, 1, 1, 1, 0), 'description': 'New Year'}]\n        >>> calendar.is_available(datetime(2023, 1, 1, 0, 0), datetime(2023, 1, 1, 1, 0))\n        False\n\n        \"\"\"\n\n        # Iterate through the list of events\n        for event in self.events:\n\n            # If the given time slot overlaps with an existing event, return False\n            if start_time < event['end_time'] and end_time > event['start_time']:\n                return False\n        \n        # If no overlaps are found, return True\n        return True\n\n    def get_available_slots(self, date):\n        \"\"\"\n        Get all available time slots on a given date.\n        :param date: The date to get available time slots for,datetime.\n        :return: A list of available time slots on the given date,list.\n        >>> calendar = CalendarUtil()\n        >>> calendar.events = [{'date': datetime(2023, 1, 1, 0, 0), 'start_time': datetime(2023, 1, 1, 0, 0), 'end_time': datetime(2023, 1, 1, 23, 0), 'description': 'New Year'}]\n        >>> calendar.get_available_slots(datetime(2023, 1, 1))\n        [(datetime.datetime(2023, 1, 1, 23, 0), datetime.datetime(2023, 1, 2, 0, 0))]\n\n        \"\"\"\n\n        available_slots = []\n\n        # Use the datetime function to initialize start and end times for the day\n        start_time = datetime(date.year, date.month, date.day, 0, 0)\n        end_time = datetime(date.year, date.month, date.day, 23, 59)\n\n        # Iterate through the day in 1-hour intervals\n        while start_time < end_time:\n\n            # Calculate the end time for the current slot using the timedelta function to add 60 minutes to the start time\n            slot_end_time = start_time + timedelta(minutes=60)\n\n            # Use the is_available class method to add the current slot to the list of available slots if it is available\n            if self.is_available(start_time, slot_end_time):\n                available_slots.append((start_time, slot_end_time))\n            \n            # Use the timedelta function to increment the start time by 60 minutes to check the next slot\n            start_time += timedelta(minutes=60)\n        \n        # Return the list of available slots\n        return available_slots\n\n    def get_upcoming_events(self, num_events):\n        \"\"\"\n        Get the next n upcoming events from a given date.\n        :param date: The date to get upcoming events from,datetime.\n        :param n: The number of upcoming events to get,int.\n        :return: A list of the next n upcoming events from the given date,list.\n        >>> calendar = CalendarUtil()\n        >>> calendar.events = [{'date': datetime(2023, 1, 1, 0, 0), 'start_time': datetime(2023, 1, 1, 0, 0), 'end_time': datetime(2023, 1, 1, 23, 0), 'description': 'New Year'},{'date': datetime(2023, 1, 2, 0, 0),'end_time': datetime(2023, 1, 2, 1, 0), 'description': 'New Year 2'}]\n        >>> calendar.get_upcoming_events(1)\n        [{'date': datetime.datetime(2023, 1, 1, 0, 0), 'start_time': datetime.datetime(2023, 1, 1, 0, 0), 'end_time': datetime.datetime(2023, 1, 1, 23, 0), 'description': 'New Year'}, {'date': datetime.datetime(2023, 1, 2, 0, 0), 'end_time': datetime.datetime(2023, 1, 2, 1, 0), 'description': 'New Year 2'}]\n\n        \"\"\"\n\n        # Use the datetime.now() function to get the current date and time\n        now = datetime.now()\n\n        upcoming_events = []\n\n        # Iterate through the list of events\n        for event in self.events:\n\n            # If the event start time is greater than or equal to the current time, add it to the list of upcoming events\n            if event['start_time'] >= now:\n                upcoming_events.append(event)\n            \n            # If the number of upcoming events reaches num_events, break the loop\n            if len(upcoming_events) == num_events:\n                break\n        \n        # Return the list of upcoming events\n        return upcoming_events"
    },
    {
        "id" : "18",
        "code" : "class CamelCaseMap:\n    \"\"\"\n    This is a custom class that allows keys to be in camel case style by converting them from underscore style, which provides dictionary-like functionality.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize data to an empty dictionary\n        \"\"\"\n        self._data = {}\n\n    def __getitem__(self, key):\n        \"\"\"\n        Return the value corresponding to the key\n        :param key:str\n        :return:str,the value corresponding to the key\n        >>> camelize_map = CamelCaseMap()\n        >>> camelize_map['first_name'] = 'John'\n        >>> camelize_map.__getitem__('first_name')\n        'John'\n        \"\"\"\n\n        return self._data[self._convert_key(key)]\n\n    def __setitem__(self, key, value):\n        \"\"\"\n        Set the value corresponding to the key to the specified value\n        :param key:str\n        :param value:str, the specified value\n        :return:None\n        >>> camelize_map = CamelCaseMap()\n        >>> camelize_map['first_name'] = 'John'\n        >>> camelize_map.__setitem__('first_name', 'new name')\n        camelize_map['first_name'] = 'new name'\n        \"\"\"\n\n        self._data[self._convert_key(key)] = value\n\n    def __delitem__(self, key):\n        \"\"\"\n        Delete the value corresponding to the key\n        :param key:str\n        :return:None\n        >>> camelize_map = CamelCaseMap()\n        >>> camelize_map['first_name'] = 'John'\n        >>> camelize_map.__delitem__('first_name')\n        >>> flag = 'first_name' in camelize_map\n        flag = False\n        \"\"\"\n\n        del self._data[self._convert_key(key)]\n\n    def __iter__(self):\n        \"\"\"\n        Returning Iterateable Objects with Own Data\n        :return:Iterator\n        >>> camelize_map = CamelCaseMap()\n        >>> camelize_map['first_name'] = 'John'\n        >>> camelize_map['last_name'] = 'Doe'\n        >>> camelize_map['age'] = 30\n        >>> camelize_map.__iter__()\n        <dict_keyiterator object at 0x0000026739977C20>\n        \"\"\"\n\n        return iter(self._data)\n\n    def __len__(self):\n        \"\"\"\n        Returns the length of the own data\n        :return:int, length of data\n        >>> camelize_map = CamelCaseMap()\n        >>> camelize_map['first_name'] = 'John'\n        >>> camelize_map['last_name'] = 'Doe'\n        >>> camelize_map['age'] = 30\n        >>> camelize_map.__len__()\n        3\n        \"\"\"\n\n        return len(self._data)\n\n    def _convert_key(self, key):\n        \"\"\"\n        convert key string into camel case\n        :param key:str\n        :return:str, converted key string\n        >>> camelize_map = CamelCaseMap()\n        >>> camelize_map._convert_key('first_name')\n        'firstName'\n        \"\"\"\n\n        if isinstance(key, str):\n            return self._to_camel_case(key)\n        return key\n\n    @staticmethod\n    def _to_camel_case(key):\n        \"\"\"\n        convert key string into camel case\n        :param key:str\n        :return:str, converted key string\n        >>> camelize_map = CamelCaseMap()\n        >>> camelize_map._to_camel_case('first_name')\n        'firstName'\n        \"\"\"\n\n        parts = key.split('_')\n        return parts[0] + ''.join(part.title() for part in parts[1:])",
        "annotated_code" : "class CamelCaseMap:\n    \"\"\"\n    This is a custom class that allows keys to be in camel case style by converting them from underscore style, which provides dictionary-like functionality.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize data to an empty dictionary\n        \"\"\"\n        self._data = {}\n\n    def __getitem__(self, key):\n        \"\"\"\n        Return the value corresponding to the key\n        :param key:str\n        :return:str,the value corresponding to the key\n        >>> camelize_map = CamelCaseMap()\n        >>> camelize_map['first_name'] = 'John'\n        >>> camelize_map.__getitem__('first_name')\n        'John'\n        \"\"\"\n\n        # Use the _convert_key class method to convert the key to camel case and get the value corresponding to the converted key from the _data dictionary\n        return self._data[self._convert_key(key)]\n\n    def __setitem__(self, key, value):\n        \"\"\"\n        Set the value corresponding to the key to the specified value\n        :param key:str\n        :param value:str, the specified value\n        :return:None\n        >>> camelize_map = CamelCaseMap()\n        >>> camelize_map['first_name'] = 'John'\n        >>> camelize_map.__setitem__('first_name', 'new name')\n        camelize_map['first_name'] = 'new name'\n        \"\"\"\n\n        # Use the _convert_key class method to convert the key to camel case and set the value corresponding to the converted key in the _data dictionary\n        self._data[self._convert_key(key)] = value\n\n    def __delitem__(self, key):\n        \"\"\"\n        Delete the value corresponding to the key\n        :param key:str\n        :return:None\n        >>> camelize_map = CamelCaseMap()\n        >>> camelize_map['first_name'] = 'John'\n        >>> camelize_map.__delitem__('first_name')\n        >>> flag = 'first_name' in camelize_map\n        flag = False\n        \"\"\"\n\n        # Use the _convert_key class method to convert the key to camel case and delete the entry corresponding to the converted key from the _data dictionary\n        del self._data[self._convert_key(key)]\n\n    def __iter__(self):\n        \"\"\"\n        Returning Iterateable Objects with Own Data\n        :return:Iterator\n        >>> camelize_map = CamelCaseMap()\n        >>> camelize_map['first_name'] = 'John'\n        >>> camelize_map['last_name'] = 'Doe'\n        >>> camelize_map['age'] = 30\n        >>> camelize_map.__iter__()\n        <dict_keyiterator object at 0x0000026739977C20>\n        \"\"\"\n\n        # Return an iterator over the keys of the _data dictionary\n        return iter(self._data)\n\n    def __len__(self):\n        \"\"\"\n        Returns the length of the own data\n        :return:int, length of data\n        >>> camelize_map = CamelCaseMap()\n        >>> camelize_map['first_name'] = 'John'\n        >>> camelize_map['last_name'] = 'Doe'\n        >>> camelize_map['age'] = 30\n        >>> camelize_map.__len__()\n        3\n        \"\"\"\n\n        # Return the length of the _data dictionary\n        return len(self._data)\n\n    def _convert_key(self, key):\n        \"\"\"\n        convert key string into camel case\n        :param key:str\n        :return:str, converted key string\n        >>> camelize_map = CamelCaseMap()\n        >>> camelize_map._convert_key('first_name')\n        'firstName'\n        \"\"\"\n\n        # If the key is a string, convert it to camel case with the _to_camel_case class method and return it\n        if isinstance(key, str):\n            return self._to_camel_case(key)\n        \n        # If the key is not a string, return it as is\n        return key\n\n    @staticmethod\n    def _to_camel_case(key):\n        \"\"\"\n        convert key string into camel case\n        :param key:str\n        :return:str, converted key string\n        >>> camelize_map = CamelCaseMap()\n        >>> camelize_map._to_camel_case('first_name')\n        'firstName'\n        \"\"\"\n\n        # Split the key by underscores and capitalize the first letter of each part except the first part and return the result\n        parts = key.split('_')\n        return parts[0] + ''.join(part.title() for part in parts[1:])"
    },
    {
        "id" : "19",
        "code" : "class ChandrasekharSieve:\n    \"\"\"\n    This is a class that uses the Chandrasekhar's Sieve method to find all prime numbers within the range\n    \"\"\"\n\n    def __init__(self, n):\n        \"\"\"\n        Initialize the ChandrasekharSieve class with the given limit.\n        :param n: int, the upper limit for generating prime numbers\n        \"\"\"\n        self.n = n\n        self.primes = self.generate_primes()\n\n    def generate_primes(self):\n        \"\"\"\n        Generate prime numbers up to the specified limit using the Chandrasekhar sieve algorithm.\n        :return: list, a list of prime numbers\n        >>> cs = ChandrasekharSieve(20)\n        >>> cs.generate_primes()\n        [2, 3, 5, 7, 11, 13, 17, 19]\n\n        \"\"\"\n\n        if self.n < 2:\n            return []\n        sieve = [True] * (self.n + 1)\n        sieve[0] = sieve[1] = False\n\n        p = 2\n        while p * p <= self.n:\n            if sieve[p]:\n                for i in range(p * p, self.n + 1, p):\n                    sieve[i] = False\n            p += 1\n\n        primes = []\n        for i in range(2, self.n + 1):\n            if sieve[i]:\n                primes.append(i)\n\n        return primes\n\n    def get_primes(self):\n        \"\"\"\n        Get the list of generated prime numbers.\n        :return: list, a list of prime numbers\n        >>> cs = ChandrasekharSieve(20)\n        >>> cs.get_primes()\n        [2, 3, 5, 7, 11, 13, 17, 19]\n\n        \"\"\"\n\n        return self.primes",
        "annotated_code" : "class ChandrasekharSieve:\n    \"\"\"\n    This is a class that uses the Chandrasekhar's Sieve method to find all prime numbers within the range\n    \"\"\"\n\n    def __init__(self, n):\n        \"\"\"\n        Initialize the ChandrasekharSieve class with the given limit.\n        :param n: int, the upper limit for generating prime numbers\n        \"\"\"\n        self.n = n\n\n        # Generate prime numbers using the generate_primes class method\n        self.primes = self.generate_primes()\n\n    def generate_primes(self):\n        \"\"\"\n        Generate prime numbers up to the specified limit using the Chandrasekhar sieve algorithm.\n        :return: list, a list of prime numbers\n        >>> cs = ChandrasekharSieve(20)\n        >>> cs.generate_primes()\n        [2, 3, 5, 7, 11, 13, 17, 19]\n\n        \"\"\"\n\n        # If the limit is less than 2, return an empty list\n        if self.n < 2:\n            return []\n\n        # Create a boolean array \"sieve[0..n]\" where a value will be True if the index is a prime\n        sieve = [True] * (self.n + 1)\n        sieve[0] = sieve[1] = False\n\n        p = 2\n\n        # Iterate through the sieve list while p^2 is less than or equal to the limit\n        while p * p <= self.n:\n\n            # If p is a prime number, mark all its multiples as non-prime\n            if sieve[p]:\n                for i in range(p * p, self.n + 1, p):\n                    sieve[i] = False\n            \n            # Move p to the next number\n            p += 1\n\n        # Collect all prime numbers from the sieve list\n        primes = []\n        for i in range(2, self.n + 1):\n            if sieve[i]:\n                primes.append(i)\n\n        # Return the list of prime numbers generated\n        return primes\n\n    def get_primes(self):\n        \"\"\"\n        Get the list of generated prime numbers.\n        :return: list, a list of prime numbers\n        >>> cs = ChandrasekharSieve(20)\n        >>> cs.get_primes()\n        [2, 3, 5, 7, 11, 13, 17, 19]\n\n        \"\"\"\n\n        # Return the list of prime numbers generated\n        return self.primes"
    },
    {
        "id" : "20",
        "code" : "from datetime import datetime\n\nclass Chat:\n    \"\"\"\n    This is a chat class with the functions of adding users, removing users, sending messages, and obtaining messages.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the Chat with an attribute users, which is an empty dictionary.\n        \"\"\"\n        self.users = {}\n\n    def add_user(self, username):\n        \"\"\"\n        Add a new user to the Chat.\n        :param username: The user's name, str.\n        :return: If the user is already in the Chat, returns False, otherwise, returns True.\n        >>> chat = Chat()\n        >>> chat.add_user('John')\n        True\n        self.users = {'John': []}\n        >>> chat.add_user('John')\n        False\n\n        \"\"\"\n\n        if username in self.users:\n            return False\n        else:\n            self.users[username] = []\n            return True\n\n    def remove_user(self, username):\n        \"\"\"\n        Remove a user from the Chat.\n        :param username: The user's name, str.\n        :return: If the user is already in the Chat, returns True, otherwise, returns False.\n        >>> chat = Chat()\n        >>> chat.users = {'John': []}\n        >>> chat.remove_user('John')\n        True\n        >>> chat.remove_user('John')\n        False\n\n        \"\"\"\n\n        if username in self.users:\n            del self.users[username]\n            return True\n        else:\n            return False\n\n    def send_message(self, sender, receiver, message):\n        \"\"\"\n        Send a message from a user to another user.\n        :param sender: The sender's name, str.\n        :param receiver: The receiver's name, str.\n        :param message: The message, str.\n        :return: If the sender or the receiver is not in the Chat, returns False, otherwise, returns True.\n        >>> chat = Chat()\n        >>> chat.users = {'John': [], 'Mary': []}\n        >>> chat.send_message('John', 'Mary', 'Hello')\n        True\n        >>> chat.send_message('John', 'Tom', 'Hello')\n        False\n\n        \"\"\"\n\n        if sender not in self.users or receiver not in self.users:\n            return False\n\n        timestamp = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n        message_info = {\n            'sender': sender,\n            'receiver': receiver,\n            'message': message,\n            'timestamp': timestamp\n        }\n\n        self.users[sender].append(message_info)\n        self.users[receiver].append(message_info)\n        return True\n\n    def get_messages(self, username):\n        \"\"\"\n        Get all the messages of a user from the Chat.\n        :param username: The user's name, str.\n        :return: A list of messages, each message is a dictionary with keys 'sender', 'receiver', 'message', 'timestamp'.\n        >>> chat = Chat()\n        >>> chat.users = {'John': [{'sender': 'John', 'receiver': 'Mary', 'message': 'Hello', 'timestamp': '2023-01-01 00:00:00'}]}\n        >>> chat.get_messages('John')\n        [{'sender': 'John', 'receiver': 'Mary', 'message': 'Hello', 'timestamp': '2023-01-01 00:00:00'}]\n        >>> chat.get_messages('Mary')\n        []\n\n        \"\"\"\n\n        if username not in self.users:\n            return []\n        \n        return self.users[username]",
        "annotated_code" : "from datetime import datetime\n\nclass Chat:\n    \"\"\"\n    This is a chat class with the functions of adding users, removing users, sending messages, and obtaining messages.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the Chat with an attribute users, which is an empty dictionary.\n        \"\"\"\n        self.users = {}\n\n    def add_user(self, username):\n        \"\"\"\n        Add a new user to the Chat.\n        :param username: The user's name, str.\n        :return: If the user is already in the Chat, returns False, otherwise, returns True.\n        >>> chat = Chat()\n        >>> chat.add_user('John')\n        True\n        self.users = {'John': []}\n        >>> chat.add_user('John')\n        False\n\n        \"\"\"\n\n        # If the user is already in the Chat, return False\n        if username in self.users:\n            return False\n        # If the user is not in the Chat, add the user and return True\n        else:\n            self.users[username] = []\n            return True\n\n    def remove_user(self, username):\n        \"\"\"\n        Remove a user from the Chat.\n        :param username: The user's name, str.\n        :return: If the user is already in the Chat, returns True, otherwise, returns False.\n        >>> chat = Chat()\n        >>> chat.users = {'John': []}\n        >>> chat.remove_user('John')\n        True\n        >>> chat.remove_user('John')\n        False\n\n        \"\"\"\n\n        # If the user is is already in the Chat, remove the user and return True\n        if username in self.users:\n            del self.users[username]\n            return True\n        # If the user is not in the Chat, return False\n        else:\n            return False\n\n    def send_message(self, sender, receiver, message):\n        \"\"\"\n        Send a message from a user to another user.\n        :param sender: The sender's name, str.\n        :param receiver: The receiver's name, str.\n        :param message: The message, str.\n        :return: If the sender or the receiver is not in the Chat, returns False, otherwise, returns True.\n        >>> chat = Chat()\n        >>> chat.users = {'John': [], 'Mary': []}\n        >>> chat.send_message('John', 'Mary', 'Hello')\n        True\n        >>> chat.send_message('John', 'Tom', 'Hello')\n        False\n\n        \"\"\"\n\n        # If the sender or the receiver is not in the Chat, return False\n        if sender not in self.users or receiver not in self.users:\n            return False\n\n        # Send the message as a dictionary with the sender, receiver, message, and the current timestamp\n        # Use the datetime.now().strftime method to generate the current timestamp in the \"%Y-%m-%d %H:%M:%S\" format\n        timestamp = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n        message_info = {\n            'sender': sender,\n            'receiver': receiver,\n            'message': message,\n            'timestamp': timestamp\n        }\n\n        # Append the message to the sender and receiver's list of messages and return True\n        self.users[sender].append(message_info)\n        self.users[receiver].append(message_info)\n        return True\n\n    def get_messages(self, username):\n        \"\"\"\n        Get all the messages of a user from the Chat.\n        :param username: The user's name, str.\n        :return: A list of messages, each message is a dictionary with keys 'sender', 'receiver', 'message', 'timestamp'.\n        >>> chat = Chat()\n        >>> chat.users = {'John': [{'sender': 'John', 'receiver': 'Mary', 'message': 'Hello', 'timestamp': '2023-01-01 00:00:00'}]}\n        >>> chat.get_messages('John')\n        [{'sender': 'John', 'receiver': 'Mary', 'message': 'Hello', 'timestamp': '2023-01-01 00:00:00'}]\n        >>> chat.get_messages('Mary')\n        []\n\n        \"\"\"\n\n        # If the user is not in the Chat, return an empty list\n        if username not in self.users:\n            return []\n        \n        # Return the user's list of messages\n        return self.users[username]"
    },
    {
        "id" : "21",
        "code" : "from datetime import datetime\n\nclass Classroom:\n    \"\"\"\n    This is a class representing a classroom, capable of adding and removing courses, checking availability at a given time, and detecting conflicts when scheduling new courses.\n    \"\"\"\n\n    def __init__(self, id):\n        \"\"\"\n        Initialize the classroom management system.\n        :param id: int, the id of classroom\n        \"\"\"\n        self.id = id\n        self.courses = []\n\n    def add_course(self, course):\n        \"\"\"\n        Add course to self.courses list if the course wasn't in it.\n        :param course: dict, information of the course, including 'start_time', 'end_time' and 'name'\n        >>> classroom = Classroom(1)\n        >>> classroom.add_course({'name': 'math', 'start_time': '8:00', 'end_time': '9:40'})\n        \"\"\"\n\n        if course not in self.courses:\n            self.courses.append(course)\n\n    def remove_course(self, course):\n        \"\"\"\n        Remove course from self.courses list if the course was in it.\n        :param course: dict, information of the course, including 'start_time', 'end_time' and 'name'\n        >>> classroom = Classroom(1)\n        >>> classroom.add_course({'name': 'math', 'start_time': '8:00', 'end_time': '9:40'})\n        >>> classroom.remove_course({'name': 'math', 'start_time': '8:00', 'end_time': '9:40'})\n        \"\"\"\n\n        if course in self.courses:\n            self.courses.remove(course)\n\n    def is_free_at(self, check_time):\n        \"\"\"\n        change the time format as '%H:%M' and check the time is free or not in the classroom.\n        :param check_time: str, the time need to be checked\n        :return: True if the check_time does not conflict with every course time, or False otherwise.\n        >>> classroom = Classroom(1)\n        >>> classroom.add_course({'name': 'math', 'start_time': '8:00', 'end_time': '9:40'})\n        >>> classroom.is_free_at('10:00')\n        True\n        >>> classroom.is_free_at('9:00')\n        False\n        \"\"\"\n\n        check_time = datetime.strptime(check_time, '%H:%M')\n\n        for course in self.courses:\n            if datetime.strptime(course['start_time'], '%H:%M') <= check_time <= datetime.strptime(course['end_time'],\n                                                                                                   '%H:%M'):\n                return False\n        \n        return True\n\n    def check_course_conflict(self, new_course):\n        \"\"\"\n        Before adding a new course, check if the new course time conflicts with any other course.\n        :param new_course: dict, information of the course, including 'start_time', 'end_time' and 'name'\n        :return: False if the new course time conflicts(including two courses have the same boundary time) with other courses, or True otherwise.\n        >>> classroom = Classroom(1)\n        >>> classroom.add_course({'name': 'math', 'start_time': '8:00', 'end_time': '9:40'})\n        >>> classroom.check_course_conflict({'name': 'SE', 'start_time': '9:40', 'end_time': '10:40'})\n        False\n        \"\"\"\n\n        new_start_time = datetime.strptime(new_course['start_time'], '%H:%M')\n        new_end_time = datetime.strptime(new_course['end_time'], '%H:%M')\n\n        flag = True\n        for course in self.courses:\n            start_time = datetime.strptime(course['start_time'], '%H:%M')\n            end_time = datetime.strptime(course['end_time'], '%H:%M')\n\n            if start_time <= new_start_time and end_time >= new_start_time:\n                flag = False\n            if start_time <= new_end_time and end_time >= new_end_time:\n                flag = False\n\n        return flag",
        "annotated_code" : "from datetime import datetime\n\nclass Classroom:\n    \"\"\"\n    This is a class representing a classroom, capable of adding and removing courses, checking availability at a given time, and detecting conflicts when scheduling new courses.\n    \"\"\"\n\n    def __init__(self, id):\n        \"\"\"\n        Initialize the classroom management system.\n        :param id: int, the id of classroom\n        \"\"\"\n        self.id = id\n        self.courses = []\n\n    def add_course(self, course):\n        \"\"\"\n        Add course to self.courses list if the course wasn't in it.\n        :param course: dict, information of the course, including 'start_time', 'end_time' and 'name'\n        >>> classroom = Classroom(1)\n        >>> classroom.add_course({'name': 'math', 'start_time': '8:00', 'end_time': '9:40'})\n        \"\"\"\n\n        # If the course is not already in the courses list, add it\n        if course not in self.courses:\n            self.courses.append(course)\n\n    def remove_course(self, course):\n        \"\"\"\n        Remove course from self.courses list if the course was in it.\n        :param course: dict, information of the course, including 'start_time', 'end_time' and 'name'\n        >>> classroom = Classroom(1)\n        >>> classroom.add_course({'name': 'math', 'start_time': '8:00', 'end_time': '9:40'})\n        >>> classroom.remove_course({'name': 'math', 'start_time': '8:00', 'end_time': '9:40'})\n        \"\"\"\n\n        # If the course is in the courses list, remove it\n        if course in self.courses:\n            self.courses.remove(course)\n\n    def is_free_at(self, check_time):\n        \"\"\"\n        change the time format as '%H:%M' and check the time is free or not in the classroom.\n        :param check_time: str, the time need to be checked\n        :return: True if the check_time does not conflict with every course time, or False otherwise.\n        >>> classroom = Classroom(1)\n        >>> classroom.add_course({'name': 'math', 'start_time': '8:00', 'end_time': '9:40'})\n        >>> classroom.is_free_at('10:00')\n        True\n        >>> classroom.is_free_at('9:00')\n        False\n        \"\"\"\n\n        # Use the datetime.strptime function to convert the check_time to a datetime object in the format '%H:%M' for comparison\n        check_time = datetime.strptime(check_time, '%H:%M')\n\n        # Iterate through the courses and check if the check_time falls within any course's time range\n        for course in self.courses:\n\n            # Use the datetime.strptime function to convert the course's start and end times to datetime objects in the format '%H:%M' for comparison\n            # If the check_time falls within the start and end time of any course, return False\n            if datetime.strptime(course['start_time'], '%H:%M') <= check_time <= datetime.strptime(course['end_time'],\n                                                                                                   '%H:%M'):\n                return False\n        \n        # If the check_time does not fall within any course's time range, return True\n        return True\n\n    def check_course_conflict(self, new_course):\n        \"\"\"\n        Before adding a new course, check if the new course time conflicts with any other course.\n        :param new_course: dict, information of the course, including 'start_time', 'end_time' and 'name'\n        :return: False if the new course time conflicts(including two courses have the same boundary time) with other courses, or True otherwise.\n        >>> classroom = Classroom(1)\n        >>> classroom.add_course({'name': 'math', 'start_time': '8:00', 'end_time': '9:40'})\n        >>> classroom.check_course_conflict({'name': 'SE', 'start_time': '9:40', 'end_time': '10:40'})\n        False\n        \"\"\"\n\n        # Use the datetime.strptime function to convert the new course's start and end times to datetime objects in the format '%H:%M' for comparison\n        new_start_time = datetime.strptime(new_course['start_time'], '%H:%M')\n        new_end_time = datetime.strptime(new_course['end_time'], '%H:%M')\n\n        flag = True\n\n        # Iterate through the existing courses\n        for course in self.courses:\n\n            # Use the datetime.strptime function to convert the existing course's start and end times to datetime objects in the format '%H:%M' for comparison\n            start_time = datetime.strptime(course['start_time'], '%H:%M')\n            end_time = datetime.strptime(course['end_time'], '%H:%M')\n\n            # If the new course's time range overlaps with the existing course's time range, set flag to False\n            if start_time <= new_start_time and end_time >= new_start_time:\n                flag = False\n            if start_time <= new_end_time and end_time >= new_end_time:\n                flag = False\n\n        # Return the flag indicating whether there is a conflict or not\n        return flag"
    },
    {
        "id" : "22",
        "code" : "class ClassRegistrationSystem:\n\n    \"\"\"\n    This is a class as a class registration system, allowing to register students, register them for classes, retrieve students by major, get a list of all majors, and determine the most popular class within a specific major.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the registration system with the attribute students and students_registration_class.\n        students is a list of student dictionaries, each student dictionary has the key of name and major.\n        students_registration_classes is a dictionary, key is the student name, value is a list of class names\n        \"\"\"\n        self.students = []\n        self.students_registration_classes = {}\n\n    def register_student(self, student):\n        \"\"\"\n        register a student to the system, add the student to the students list, if the student is already registered, return 0, else return 1\n        :param student: dict\n        :return 0 if the student is already registered, else return 1\n        >>> registration_system = ClassRegistrationSystem()\n        >>> student1 = {\"name\": \"John\", \"major\": \"Computer Science\"}\n        >>> registration_system.register_student(student1)\n        1\n        \"\"\"\n\n        if student in self.students:\n            return 0\n        else:\n            self.students.append(student)\n            return 1\n\n    def register_class(self, student_name, class_name):\n        \"\"\"\n        register a class to the student.\n        :param student_name: str\n        :param class_name: str\n        :return a list of class names that the student has registered\n        >>> registration_system = ClassRegistrationSystem()\n        >>> registration_system.register_class(student_name=\"John\", class_name=\"CS101\")\n        >>> registration_system.register_class(student_name=\"John\", class_name=\"CS102\")\n        [\"CS101\", \"CS102\"]\n        \"\"\"\n\n        if student_name in self.students_registration_classes:\n            self.students_registration_classes[student_name].append(class_name)\n        else:\n            self.students_registration_classes[student_name] = [class_name]\n        return self.students_registration_classes[student_name]\n\n    def get_students_by_major(self, major):\n        \"\"\"\n        get all students in the major\n        :param major: str\n        :return a list of student name\n        >>> registration_system = ClassRegistrationSystem()\n        >>> student1 = {\"name\": \"John\", \"major\": \"Computer Science\"}\n        >>> registration_system.register_student(student1)\n        >>> registration_system.get_students_by_major(\"Computer Science\")\n        [\"John\"]\n        \"\"\"\n\n        student_list = []\n        for student in self.students:\n            if student[\"major\"] == major:\n                student_list.append(student[\"name\"])\n        \n        return student_list\n\n    def get_all_major(self):\n        \"\"\"\n        get all majors in the system\n        :return a list of majors\n        >>> registration_system = ClassRegistrationSystem()\n        >>> registration_system.students = [{\"name\": \"John\", \"major\": \"Computer Science\"}],\n        >>> registration_system.get_all_major(student1)\n        [\"Computer Science\"]\n        \"\"\"\n\n        major_list = []\n        for student in self.students:\n            if student[\"major\"] not in major_list:\n                major_list.append(student[\"major\"])\n            \n        return major_list\n\n    def get_most_popular_class_in_major(self, major):\n        \"\"\"\n        get the class with the highest enrollment in the major.\n        :return  a string of the most popular class in this major\n        >>> registration_system = ClassRegistrationSystem()\n        >>> registration_system.students = [{\"name\": \"John\", \"major\": \"Computer Science\"},\n                                             {\"name\": \"Bob\", \"major\": \"Computer Science\"},\n                                             {\"name\": \"Alice\", \"major\": \"Computer Science\"}]\n        >>> registration_system.students_registration_classes = {\"John\": [\"Algorithms\", \"Data Structures\"],\n                                            \"Bob\": [\"Operating Systems\", \"Data Structures\", \"Algorithms\"]}\n        >>> registration_system.get_most_popular_class_in_major(\"Computer Science\")\n        \"Data Structures\"\n        \"\"\"\n\n        class_list = []\n        for student in self.students:\n            if student[\"major\"] == major:\n                class_list += self.students_registration_classes[student[\"name\"]]\n        \n        most_popular_class = max(set(class_list), key=class_list.count)\n        return most_popular_class",
        "annotated_code" : "class ClassRegistrationSystem:\n\n    \"\"\"\n    This is a class as a class registration system, allowing to register students, register them for classes, retrieve students by major, get a list of all majors, and determine the most popular class within a specific major.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the registration system with the attribute students and students_registration_class.\n        students is a list of student dictionaries, each student dictionary has the key of name and major.\n        students_registration_classes is a dictionary, key is the student name, value is a list of class names\n        \"\"\"\n        self.students = []\n        self.students_registration_classes = {}\n\n    def register_student(self, student):\n        \"\"\"\n        register a student to the system, add the student to the students list, if the student is already registered, return 0, else return 1\n        :param student: dict\n        :return 0 if the student is already registered, else return 1\n        >>> registration_system = ClassRegistrationSystem()\n        >>> student1 = {\"name\": \"John\", \"major\": \"Computer Science\"}\n        >>> registration_system.register_student(student1)\n        1\n        \"\"\"\n\n        # If the student is already registered, return 0\n        if student in self.students:\n            return 0\n        # If the student is not registered, add the student to the students list and return 1\n        else:\n            self.students.append(student)\n            return 1\n\n    def register_class(self, student_name, class_name):\n        \"\"\"\n        register a class to the student.\n        :param student_name: str\n        :param class_name: str\n        :return a list of class names that the student has registered\n        >>> registration_system = ClassRegistrationSystem()\n        >>> registration_system.register_class(student_name=\"John\", class_name=\"CS101\")\n        >>> registration_system.register_class(student_name=\"John\", class_name=\"CS102\")\n        [\"CS101\", \"CS102\"]\n        \"\"\"\n\n        # If the student's name exists in the students_registration_classes dictionary, append the class name to the list of class names for the student\n        if student_name in self.students_registration_classes:\n            self.students_registration_classes[student_name].append(class_name)\n        # If the student's name does not exist in the students_registration_classes dictionary, create a new list of class names for the student\n        else:\n            self.students_registration_classes[student_name] = [class_name]\n        \n        # Return the new list of class names for the student\n        return self.students_registration_classes[student_name]\n\n    def get_students_by_major(self, major):\n        \"\"\"\n        get all students in the major\n        :param major: str\n        :return a list of student name\n        >>> registration_system = ClassRegistrationSystem()\n        >>> student1 = {\"name\": \"John\", \"major\": \"Computer Science\"}\n        >>> registration_system.register_student(student1)\n        >>> registration_system.get_students_by_major(\"Computer Science\")\n        [\"John\"]\n        \"\"\"\n\n        student_list = []\n\n        # Iterate through the students list and check if the major of each student matches the input major\n        for student in self.students:\n\n            # If the major matches, append the student's name to the student_list\n            if student[\"major\"] == major:\n                student_list.append(student[\"name\"])\n        \n        # Return the list of student names in the specified major\n        return student_list\n\n    def get_all_major(self):\n        \"\"\"\n        get all majors in the system\n        :return a list of majors\n        >>> registration_system = ClassRegistrationSystem()\n        >>> registration_system.students = [{\"name\": \"John\", \"major\": \"Computer Science\"}],\n        >>> registration_system.get_all_major(student1)\n        [\"Computer Science\"]\n        \"\"\"\n\n        major_list = []\n\n        # Iterate through the students list and check if the major of each student is already in the major_list\n        for student in self.students:\n\n            # If the student's major is not already in the major_list, append it to the major_list\n            if student[\"major\"] not in major_list:\n                major_list.append(student[\"major\"])\n            \n        # Return the list of all majors in the system\n        return major_list\n\n    def get_most_popular_class_in_major(self, major):\n        \"\"\"\n        get the class with the highest enrollment in the major.\n        :return  a string of the most popular class in this major\n        >>> registration_system = ClassRegistrationSystem()\n        >>> registration_system.students = [{\"name\": \"John\", \"major\": \"Computer Science\"},\n                                             {\"name\": \"Bob\", \"major\": \"Computer Science\"},\n                                             {\"name\": \"Alice\", \"major\": \"Computer Science\"}]\n        >>> registration_system.students_registration_classes = {\"John\": [\"Algorithms\", \"Data Structures\"],\n                                            \"Bob\": [\"Operating Systems\", \"Data Structures\", \"Algorithms\"]}\n        >>> registration_system.get_most_popular_class_in_major(\"Computer Science\")\n        \"Data Structures\"\n        \"\"\"\n\n        class_list = []\n\n        # Iterate through the students list and check if the major of each student matches the input major\n        for student in self.students:\n\n            # If the major matches, append the student's registered classes to the class_list\n            if student[\"major\"] == major:\n                class_list += self.students_registration_classes[student[\"name\"]]\n        \n        # Find the most popular class in the class_list by counting the occurrences of each class\n        most_popular_class = max(set(class_list), key=class_list.count)\n\n        # Return the most popular class in the specified major\n        return most_popular_class"
    },
    {
        "id" : "23",
        "code" : "import math\nfrom typing import List\n\nclass CombinationCalculator:\n    \"\"\"\n    This is a class that provides methods to calculate the number of combinations for a specific count, calculate all possible combinations, and generate combinations with a specified number of elements.\n    \"\"\"\n\n    def __init__(self, datas: List[str]):\n        \"\"\"\n        Initialize the calculator with a list of data.\n        \"\"\"\n        self.datas = datas\n\n    @staticmethod\n    def count(n: int, m: int) -> int:\n        \"\"\"\n        Calculate the number of combinations for a specific count.\n        :param n: The total number of elements,int.\n        :param m: The number of elements in each combination,int.\n        :return: The number of combinations,int.\n        >>> CombinationCalculator.count(4, 2)\n        6\n        \"\"\"\n\n        if m == 0 or n == m:\n            return 1\n        return math.factorial(n) // (math.factorial(n - m) * math.factorial(m))\n\n    @staticmethod\n    def count_all(n: int) -> int:\n        \"\"\"\n        Calculate the number of all possible combinations.\n        :param n: The total number of elements,int.\n        :return: The number of all possible combinations,int,if the number of combinations is greater than 2^63-1,return float(\"inf\").\n        >>> CombinationCalculator.count_all(4)\n        15\n        \"\"\"\n\n        if n < 0 or n > 63:\n            return False\n        return (2 ** n) - 1 if n != 63 else float(\"inf\")\n\n    def select(self, m: int) -> List[List[str]]:\n        \"\"\"\n        Generate combinations with a specified number of elements.\n        :param m: The number of elements in each combination,int.\n        :return: A list of combinations,List[List[str]].\n        >>> calc = CombinationCalculator([\"A\", \"B\", \"C\", \"D\"])\n        >>> calc.select(2)\n        [['A', 'B'], ['A', 'C'], ['A', 'D'], ['B', 'C'], ['B', 'D'], ['C', 'D']]\n\n        \"\"\"\n\n        result = []\n        self._select(0, [None] * m, 0, result)\n        return result\n\n    def select_all(self) -> List[List[str]]:\n        \"\"\"\n        Generate all possible combinations of  selecting elements from the given data list,and it uses the select method.\n        :return: A list of combinations,List[List[str]].\n        >>> calc = CombinationCalculator([\"A\", \"B\", \"C\", \"D\"])\n        >>> calc.select_all()\n        [['A'], ['B'], ['C'], ['D'], ['A', 'B'], ['A', 'C'], ['A', 'D'], ['B', 'C'], ['B', 'D'], ['C', 'D'], ['A', 'B', 'C'], ['A', 'B', 'D'], ['A', 'C', 'D'], ['B', 'C', 'D'], ['A', 'B', 'C', 'D']]\n\n        \"\"\"\n\n        result = []\n        for i in range(1, len(self.datas) + 1):\n            result.extend(self.select(i))\n        return result\n\n    def _select(self, dataIndex: int, resultList: List[str], resultIndex: int, result: List[List[str]]):\n        \"\"\"\n        Generate combinations with a specified number of elements by recursion.\n        :param dataIndex: The index of the data to be selected,int.\n        :param resultList: The list of elements in the combination,List[str].\n        :param resultIndex: The index of the element in the combination,int.\n        :param result: The list of combinations,List[List[str]].\n        :return: None.\n        >>> calc = CombinationCalculator([\"A\", \"B\", \"C\", \"D\"])\n        >>> result = []\n        >>> calc._select(0, [None] * 2, 0, result)\n        >>> result\n        [['A', 'B'], ['A', 'C'], ['A', 'D'], ['B', 'C'], ['B', 'D'], ['C', 'D']]\n\n        \"\"\"\n\n        resultLen = len(resultList)\n        resultCount = resultIndex + 1\n        if resultCount > resultLen:\n            result.append(resultList.copy())\n            return\n\n        for i in range(dataIndex, len(self.datas) + resultCount - resultLen):\n            resultList[resultIndex] = self.datas[i]\n            self._select(i + 1, resultList, resultIndex + 1, result)",
        "annotated_code" : "import math\nfrom typing import List\n\nclass CombinationCalculator:\n    \"\"\"\n    This is a class that provides methods to calculate the number of combinations for a specific count, calculate all possible combinations, and generate combinations with a specified number of elements.\n    \"\"\"\n\n    def __init__(self, datas: List[str]):\n        \"\"\"\n        Initialize the calculator with a list of data.\n        \"\"\"\n        self.datas = datas\n\n    @staticmethod\n    def count(n: int, m: int) -> int:\n        \"\"\"\n        Calculate the number of combinations for a specific count.\n        :param n: The total number of elements,int.\n        :param m: The number of elements in each combination,int.\n        :return: The number of combinations,int.\n        >>> CombinationCalculator.count(4, 2)\n        6\n        \"\"\"\n\n        # If m equals 0 or n equals m, return 1\n        if m == 0 or n == m:\n            return 1\n\n        # Use the math.factorial function to return the number of combinations using the formula n! / ((n - m)! * m!)\n        return math.factorial(n) // (math.factorial(n - m) * math.factorial(m))\n\n    @staticmethod\n    def count_all(n: int) -> int:\n        \"\"\"\n        Calculate the number of all possible combinations.\n        :param n: The total number of elements,int.\n        :return: The number of all possible combinations,int,if the number of combinations is greater than 2^63-1,return float(\"inf\").\n        >>> CombinationCalculator.count_all(4)\n        15\n        \"\"\"\n        # If n is less than 0 or greater than 63, return False\n        if n < 0 or n > 63:\n            return False\n        \n        # Return the number of combinations using the formula 2^n - 1 if n is less than or equal to 63, else return float(\"inf\")\n        return (2 ** n) - 1 if n <= 63 else float(\"inf\")\n\n    def select(self, m: int) -> List[List[str]]:\n        \"\"\"\n        Generate combinations with a specified number of elements.\n        :param m: The number of elements in each combination,int.\n        :return: A list of combinations,List[List[str]].\n        >>> calc = CombinationCalculator([\"A\", \"B\", \"C\", \"D\"])\n        >>> calc.select(2)\n        [['A', 'B'], ['A', 'C'], ['A', 'D'], ['B', 'C'], ['B', 'D'], ['C', 'D']]\n\n        \"\"\"\n\n        result = []\n\n        # Use the _select class method to generate combinations with m elements\n        self._select(0, [None] * m, 0, result)\n\n        # Return the list of combinations\n        return result\n\n    def select_all(self) -> List[List[str]]:\n        \"\"\"\n        Generate all possible combinations of  selecting elements from the given data list,and it uses the select method.\n        :return: A list of combinations,List[List[str]].\n        >>> calc = CombinationCalculator([\"A\", \"B\", \"C\", \"D\"])\n        >>> calc.select_all()\n        [['A'], ['B'], ['C'], ['D'], ['A', 'B'], ['A', 'C'], ['A', 'D'], ['B', 'C'], ['B', 'D'], ['C', 'D'], ['A', 'B', 'C'], ['A', 'B', 'D'], ['A', 'C', 'D'], ['B', 'C', 'D'], ['A', 'B', 'C', 'D']]\n\n        \"\"\"\n\n        result = []\n\n        # Iterate through the range of 1 to the length of the data list\n        for i in range(1, len(self.datas) + 1):\n            # Use the select class method to generate combinations with i elements and extend the result list\n            result.extend(self.select(i))\n        \n        # Return the list of all combinations\n        return result\n\n    def _select(self, dataIndex: int, resultList: List[str], resultIndex: int, result: List[List[str]]):\n        \"\"\"\n        Generate combinations with a specified number of elements by recursion.\n        :param dataIndex: The index of the data to be selected,int.\n        :param resultList: The list of elements in the combination,List[str].\n        :param resultIndex: The index of the element in the combination,int.\n        :param result: The list of combinations,List[List[str]].\n        :return: None.\n        >>> calc = CombinationCalculator([\"A\", \"B\", \"C\", \"D\"])\n        >>> result = []\n        >>> calc._select(0, [None] * 2, 0, result)\n        >>> result\n        [['A', 'B'], ['A', 'C'], ['A', 'D'], ['B', 'C'], ['B', 'D'], ['C', 'D']]\n\n        \"\"\"\n\n        # If the resultIndex is greater than or equal to the length of the resultList, append the resultList to result and return\n        resultLen = len(resultList)\n        resultCount = resultIndex + 1\n        if resultCount > resultLen:\n            result.append(resultList.copy())\n            return\n\n        # Iterate through the data list and generate combinations recursively\n        for i in range(dataIndex, len(self.datas) + resultCount - resultLen):\n            # Set the current index of the resultList to the current data\n            resultList[resultIndex] = self.datas[i]\n\n            # Recursively call the _select class method to generate combinations\n            self._select(i + 1, resultList, resultIndex + 1, result)"
    },
    {
        "id" : "24",
        "code" : "class ComplexCalculator:\n\n    \"\"\"\n    This is a class that implements addition, subtraction, multiplication, and division operations for complex numbers.\n    \"\"\"\n\n    def __init__(self):\n        pass\n\n    @staticmethod\n    def add(c1, c2):\n        \"\"\"\n        Adds two complex numbers.\n        :param c1: The first complex number,complex.\n        :param c2: The second complex number,complex.\n        :return: The sum of the two complex numbers,complex.\n        >>> complexCalculator = ComplexCalculator()\n        >>> complexCalculator.add(1+2j, 3+4j)\n        (4+6j)\n\n        \"\"\"\n\n        real = c1.real + c2.real\n        imaginary = c1.imag + c2.imag\n        answer = complex(real, imaginary)\n        return answer\n\n    @staticmethod\n    def subtract(c1, c2):\n        \"\"\"\n        Subtracts two complex numbers.\n        :param c1: The first complex number,complex.\n        :param c2: The second complex number,complex.\n        :return: The difference of the two complex numbers,complex.\n        >>> complexCalculator = ComplexCalculator()\n        >>> complexCalculator.subtract(1+2j, 3+4j)\n        (-2-2j)\n\n        \"\"\"\n\n        real = c1.real - c2.real\n        imaginary = c1.imag - c2.imag\n        return complex(real, imaginary)\n\n    @staticmethod\n    def multiply(c1, c2):\n        \"\"\"\n        Multiplies two complex numbers.\n        :param c1: The first complex number,complex.\n        :param c2: The second complex number,complex.\n        :return: The product of the two complex numbers,complex.\n        >>> complexCalculator = ComplexCalculator()\n        >>> complexCalculator.multiply(1+2j, 3+4j)\n        (-5+10j)\n\n        \"\"\"\n\n        real = c1.real * c2.real - c1.imag * c2.imag\n        imaginary = c1.real * c2.imag + c1.imag * c2.real\n        return complex(real, imaginary)\n\n    @staticmethod\n    def divide(c1, c2):\n        \"\"\"\n        Divides two complex numbers.\n        :param c1: The first complex number,complex.\n        :param c2: The second complex number,complex.\n        :return: The quotient of the two complex numbers,complex.\n        >>> complexCalculator = ComplexCalculator()\n        >>> complexCalculator.divide(1+2j, 3+4j)\n        (0.44+0.08j)\n\n        \"\"\"\n\n        denominator = c2.real**2 + c2.imag**2\n        real = (c1.real * c2.real + c1.imag * c2.imag) / denominator\n        imaginary = (c1.imag * c2.real - c1.real * c2.imag) / denominator\n        return complex(real, imaginary)",
        "annotated_code" : "class ComplexCalculator:\n\n    \"\"\"\n    This is a class that implements addition, subtraction, multiplication, and division operations for complex numbers.\n    \"\"\"\n\n    def __init__(self):\n        pass\n\n    @staticmethod\n    def add(c1, c2):\n        \"\"\"\n        Adds two complex numbers.\n        :param c1: The first complex number,complex.\n        :param c2: The second complex number,complex.\n        :return: The sum of the two complex numbers,complex.\n        >>> complexCalculator = ComplexCalculator()\n        >>> complexCalculator.add(1+2j, 3+4j)\n        (4+6j)\n\n        \"\"\"\n\n        # Add the real parts and the imaginary parts separately\n        real = c1.real + c2.real\n        imaginary = c1.imag + c2.imag\n\n        # Create a new complex number with the sum of the real and imaginary parts\n        answer = complex(real, imaginary)\n\n        # Return the resulting complex number\n        return answer\n\n    @staticmethod\n    def subtract(c1, c2):\n        \"\"\"\n        Subtracts two complex numbers.\n        :param c1: The first complex number,complex.\n        :param c2: The second complex number,complex.\n        :return: The difference of the two complex numbers,complex.\n        >>> complexCalculator = ComplexCalculator()\n        >>> complexCalculator.subtract(1+2j, 3+4j)\n        (-2-2j)\n\n        \"\"\"\n\n        # Subtract the real parts and the imaginary parts separately\n        real = c1.real - c2.real\n        imaginary = c1.imag - c2.imag\n\n        # Create a new complex number with the difference of the real and imaginary parts and return it\n        return complex(real, imaginary)\n\n    @staticmethod\n    def multiply(c1, c2):\n        \"\"\"\n        Multiplies two complex numbers.\n        :param c1: The first complex number,complex.\n        :param c2: The second complex number,complex.\n        :return: The product of the two complex numbers,complex.\n        >>> complexCalculator = ComplexCalculator()\n        >>> complexCalculator.multiply(1+2j, 3+4j)\n        (-5+10j)\n\n        \"\"\"\n\n        # Multiply the complex numbers using the formula (a + bi)(c + di) = (ac - bd) + (ad + bc)i\n        real = c1.real * c2.real - c1.imag * c2.imag\n        imaginary = c1.real * c2.imag + c1.imag * c2.real\n\n        # Create a new complex number with the product of the real and imaginary parts and return it\n        return complex(real, imaginary)\n\n    @staticmethod\n    def divide(c1, c2):\n        \"\"\"\n        Divides two complex numbers.\n        :param c1: The first complex number,complex.\n        :param c2: The second complex number,complex.\n        :return: The quotient of the two complex numbers,complex.\n        >>> complexCalculator = ComplexCalculator()\n        >>> complexCalculator.divide(1+2j, 3+4j)\n        (0.44+0.08j)\n\n        \"\"\"\n\n        # Divide the complex numbers using the formula (a + bi)/(c + di) = ((ac + bd)/(c^2 + d^2)) + ((bc - ad)/(c^2 + d^2))i\n        denominator = c2.real**2 + c2.imag**2\n        real = (c1.real * c2.real + c1.imag * c2.imag) / denominator\n        imaginary = (c1.imag * c2.real - c1.real * c2.imag) / denominator\n\n        # Create a new complex number with the real and imaginary parts and return it\n        return complex(real, imaginary)"
    },
    {
        "id" : "25",
        "code" : "import json\n\nclass CookiesUtil:\n    \"\"\"\n    This is a class as utility for managing and manipulating Cookies, including methods for retrieving, saving, and setting Cookies data.\n    \"\"\"\n\n    def __init__(self, cookies_file):\n        \"\"\"\n        Initializes the CookiesUtil with the specified cookies file.\n        :param cookies_file: The cookies file to use, str.\n        \"\"\"\n        self.cookies_file = cookies_file\n        self.cookies = None\n\n    def get_cookies(self, reponse):\n        \"\"\"\n        Gets the cookies from the specified response,and save it to cookies_file.\n        :param reponse: The response to get cookies from, dict.\n        >>> cookies_util = CookiesUtil('cookies.json')\n        >>> cookies_util.get_cookies({'cookies': {'key1': 'value1', 'key2': 'value2'}})\n        >>> cookies_util.cookies\n        {'key1': 'value1', 'key2': 'value2'}\n\n        \"\"\"\n\n        self.cookies = reponse['cookies']\n        self._save_cookies()\n\n    def load_cookies(self):\n        \"\"\"\n        Loads the cookies from the cookies_file to the cookies data.\n        :return: The cookies data, dict.\n        >>> cookies_util = CookiesUtil('cookies.json')\n        >>> cookies_util.load_cookies()\n        {'key1': 'value1', 'key2': 'value2'}\n\n        \"\"\"\n\n        try:\n            with open(self.cookies_file, 'r') as file:\n                cookies_data = json.load(file)\n                return cookies_data\n        except FileNotFoundError:\n            return {}\n\n    def _save_cookies(self):\n        \"\"\"\n        Saves the cookies to the cookies_file, and returns True if successful, False otherwise.\n        :return: True if successful, False otherwise.\n        >>> cookies_util = CookiesUtil('cookies.json')\n        >>> cookies_util.cookies = {'key1': 'value1', 'key2': 'value2'}\n        >>> cookies_util._save_cookies()\n        True\n\n        \"\"\"\n\n        try:\n            with open(self.cookies_file, 'w') as file:\n                json.dump(self.cookies, file)\n            return True\n        except:\n            return False",
        "annotated_code" : "import json\n\nclass CookiesUtil:\n    \"\"\"\n    This is a class as utility for managing and manipulating Cookies, including methods for retrieving, saving, and setting Cookies data.\n    \"\"\"\n\n    def __init__(self, cookies_file):\n        \"\"\"\n        Initializes the CookiesUtil with the specified cookies file.\n        :param cookies_file: The cookies file to use, str.\n        \"\"\"\n        self.cookies_file = cookies_file\n        self.cookies = None\n\n    def get_cookies(self, reponse):\n        \"\"\"\n        Gets the cookies from the specified response,and save it to cookies_file.\n        :param reponse: The response to get cookies from, dict.\n        >>> cookies_util = CookiesUtil('cookies.json')\n        >>> cookies_util.get_cookies({'cookies': {'key1': 'value1', 'key2': 'value2'}})\n        >>> cookies_util.cookies\n        {'key1': 'value1', 'key2': 'value2'}\n\n        \"\"\"\n\n        # Get the cookies from the response and use the _save_cookies class method to save the cookies to the cookies_file\n        self.cookies = reponse['cookies']\n        self._save_cookies()\n\n    def load_cookies(self):\n        \"\"\"\n        Loads the cookies from the cookies_file to the cookies data.\n        :return: The cookies data, dict.\n        >>> cookies_util = CookiesUtil('cookies.json')\n        >>> cookies_util.load_cookies()\n        {'key1': 'value1', 'key2': 'value2'}\n\n        \"\"\"\n\n        # Use the json.load() function to load the cookies data from the cookies_file and return the cookies data\n        try:\n            with open(self.cookies_file, 'r') as file:\n                cookies_data = json.load(file)\n                return cookies_data\n        # If the cookies_file does not exist, return an empty dictionary\n        except FileNotFoundError:\n            return {}\n\n    def _save_cookies(self):\n        \"\"\"\n        Saves the cookies to the cookies_file, and returns True if successful, False otherwise.\n        :return: True if successful, False otherwise.\n        >>> cookies_util = CookiesUtil('cookies.json')\n        >>> cookies_util.cookies = {'key1': 'value1', 'key2': 'value2'}\n        >>> cookies_util._save_cookies()\n        True\n\n        \"\"\"\n\n        # Use the json.dump() function to save the cookies data to the cookies_file and return True if successful\n        try:\n            with open(self.cookies_file, 'w') as file:\n                json.dump(self.cookies, file)\n            return True\n        # If an error occurs, return False\n        except:\n            return False"
    },
    {
        "id" : "26",
        "code" : "import csv\n\nclass CSVProcessor:\n\n    \"\"\"\n    This is a class for processing CSV files, including reading and writing CSV data, as well as processing specific operations and saving as a new CSV file.\n    \"\"\"\n\n    def __init__(self):\n        pass\n\n    def read_csv(self, file_name):\n        \"\"\"\n        Read the csv file by file_name, get the title and data from it\n        :param file_name: str, name of the csv file\n        :return title, data: (list, list), first row is title, the rest is data\n        >>> csvProcessor = CSVProcessor()\n        >>> csvProcessor.read_csv('read_test.csv')\n        (['a', 'b', 'c', 'd'], [['hElLo', 'YoU', 'ME', 'LoW']])\n        \"\"\"\n\n        data = []\n        with open(file_name, 'r') as file:\n            reader = csv.reader(file)\n            title = next(reader)\n            for row in reader:\n                data.append(row)\n        return title, data\n\n    def write_csv(self, data, file_name):\n        \"\"\"\n        Write data into a csv file.\n        :param file_name: str, name of the csv file\n        :return:int, if success return 1, or 0 otherwise\n        >>> csvProcessor = CSVProcessor()\n        >>> csvProcessor.write_csv([['a', 'b', 'c', 'd'], ['1', '2', '3', '4']], 'write_test.csv')\n        1\n        \"\"\"\n\n        try:\n            with open(file_name, 'w', newline='') as file:\n                writer = csv.writer(file)\n                writer.writerows(data)\n            return 1\n        except:\n            return 0\n\n    def process_csv_data(self, N, save_file_name):\n        \"\"\"\n        Read a csv file into variable title and data.\n        Only remain the N th (from 0) column data and Capitalize them, store the title and new data into a new csv file.\n        Add '_process' suffix after old file name, as a new file name.\n        :param N: int, the N th column(from 0)\n        :param save_file_name, the name of file that needs to be processed.\n        :return:int, if success return 1, or 0 otherwise\n        >>> csvProcessor = CSVProcessor()\n        >>> csvProcessor.read_csv('read_test.csv')\n        (['a', 'b', 'c', 'd'], [['hElLo', 'YoU', 'ME', 'LoW']])\n        >>> csvProcessor.process_csv_data(0, 'read_test.csv')\n        1\n        >>> csvProcessor.read_csv('read_test_process.csv')\n        (['a', 'b', 'c', 'd'], [['HELLO']])\n        \"\"\"\n\n        title, data = self.read_csv(save_file_name)\n        column_data = [row[N] for row in data]\n        column_data = [row.upper() for row in column_data]\n        new_data = [title, column_data]\n        return self.write_csv(new_data, save_file_name.split('.')[0] + '_process.csv')",
        "annotated_code" : "import csv\n\nclass CSVProcessor:\n\n    \"\"\"\n    This is a class for processing CSV files, including reading and writing CSV data, as well as processing specific operations and saving as a new CSV file.\n    \"\"\"\n\n    def __init__(self):\n        pass\n\n    def read_csv(self, file_name):\n        \"\"\"\n        Read the csv file by file_name, get the title and data from it\n        :param file_name: str, name of the csv file\n        :return title, data: (list, list), first row is title, the rest is data\n        >>> csvProcessor = CSVProcessor()\n        >>> csvProcessor.read_csv('read_test.csv')\n        (['a', 'b', 'c', 'd'], [['hElLo', 'YoU', 'ME', 'LoW']])\n        \"\"\"\n\n        data = []\n\n        # Open the CSV file file_name in read mode\n        with open(file_name, 'r') as file:\n\n            # Use the csv.reader function to read the CSV file\n            reader = csv.reader(file)\n\n            # Read the first row of the CSV file as the title\n            title = next(reader)\n\n            # Iterate through the remaining rows of the CSV file and append them to the data list\n            for row in reader:\n                data.append(row)\n        \n        # Return the title and data list as a tuple\n        return title, data\n\n    def write_csv(self, data, file_name):\n        \"\"\"\n        Write data into a csv file.\n        :param file_name: str, name of the csv file\n        :return:int, if success return 1, or 0 otherwise\n        >>> csvProcessor = CSVProcessor()\n        >>> csvProcessor.write_csv([['a', 'b', 'c', 'd'], ['1', '2', '3', '4']], 'write_test.csv')\n        1\n        \"\"\"\n\n        try:\n            # Open the CSV file file_name in write mode\n            with open(file_name, 'w', newline='') as file:\n                # Use the csv.writer function to get the writer object for the file\n                writer = csv.writer(file)\n\n                # Use the writer.writerows function to write the data to the file\n                writer.writerows(data)\n            \n            # Return 1 if the write operation is successful\n            return 1\n        except:\n\n            # Return 0 if there is an error during the write operation\n            return 0\n\n    def process_csv_data(self, N, save_file_name):\n        \"\"\"\n        Read a csv file into variable title and data.\n        Only remain the N th (from 0) column data and Capitalize them, store the title and new data into a new csv file.\n        Add '_process' suffix after old file name, as a new file name.\n        :param N: int, the N th column(from 0)\n        :param save_file_name, the name of file that needs to be processed.\n        :return:int, if success return 1, or 0 otherwise\n        >>> csvProcessor = CSVProcessor()\n        >>> csvProcessor.read_csv('read_test.csv')\n        (['a', 'b', 'c', 'd'], [['hElLo', 'YoU', 'ME', 'LoW']])\n        >>> csvProcessor.process_csv_data(0, 'read_test.csv')\n        1\n        >>> csvProcessor.read_csv('read_test_process.csv')\n        (['a', 'b', 'c', 'd'], [['HELLO']])\n        \"\"\"\n\n        # Use the read_csv class method to read the CSV file and get the title and data\n        title, data = self.read_csv(save_file_name)\n\n        # Use a list comprehension to extract the Nth column data from the data list\n        column_data = [row[N] for row in data]\n\n        # Use a list comprehension to capitalize each element in the column_data list\n        column_data = [row.upper() for row in column_data]\n\n        # Create a new list called new_data that contains the title and the processed column data\n        new_data = [title, column_data]\n\n        # Use the write_csv class method to write the new_data list to a new CSV file\n        return self.write_csv(new_data, save_file_name.split('.')[0] + '_process.csv')"
    },
    {
        "id" : "27",
        "code" : "class CurrencyConverter:\n\n    \"\"\"\n    This is a class for currency conversion, which supports to convert amounts between different currencies, retrieve supported currencies, add new currency rates, and update existing currency rates.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the exchange rate of the US dollar against various currencies\n        \"\"\"\n        self.rates = {\n            'USD': 1.0,\n            'EUR': 0.85,\n            'GBP': 0.72,\n            'JPY': 110.15,\n            'CAD': 1.23,\n            'AUD': 1.34,\n            'CNY': 6.40,\n        }\n\n    def convert(self, amount, from_currency, to_currency):\n        \"\"\"\n        Convert the value of a given currency to another currency type\n        :param amount: float, The value of a given currency\n        :param from_currency: string, source currency type\n        :param to_currency: string, target currency type\n        :return: float, value converted to another currency type\n        >>> cc = CurrencyConverter()\n        >>> cc.convert(64, 'CNY','USD')\n        10.0\n        \"\"\"\n\n        if from_currency == to_currency:\n            return amount\n        if from_currency not in self.rates or to_currency not in self.rates:\n            return False\n        from_rate = self.rates[from_currency]\n        to_rate = self.rates[to_currency]\n        converted_amount = (amount / from_rate) * to_rate\n        return converted_amount\n\n\n    def get_supported_currencies(self):\n        \"\"\"\n        Returns a list of supported currency types\n        :return:list, All supported currency types\n        >>> cc = CurrencyConverter()\n        >>> cc.get_supported_currencies()\n        ['USD','EUR','GBP','JPY','CAD','AUD','CNY']\n        \"\"\"\n\n        return list(self.rates.keys())\n\n\n    def add_currency_rate(self, currency, rate):\n        \"\"\"\n        Add a new supported currency type, return False if the currency type is already in the support list\n        :param currency:string, currency type to be added\n        :param rate:float, exchange rate for this type of currency\n        :return:If successful, returns None; if unsuccessful, returns False\n        >>> cc = CurrencyConverter()\n        >>> cc.add_currency_rate('KRW', 1308.84)\n        self.rates['KRW'] = 1308.84\n        \"\"\"\n\n        if currency in self.rates:\n            return False\n        self.rates[currency] = rate\n\n\n    def update_currency_rate(self, currency, new_rate):\n        \"\"\"\n        Update the exchange rate for a certain currency\n        :param currency:string\n        :param new_rate:float\n        :return:If successful, returns None; if unsuccessful, returns False\n        >>> cc = CurrencyConverter()\n        >>> cc.update_currency_rate('CNY', 7.18)\n        self.rates['CNY'] = 7.18\n        \"\"\"\n\n        if currency not in self.rates:\n            return False\n        self.rates[currency] = new_rate",
        "annotated_code" : "class CurrencyConverter:\n\n    \"\"\"\n    This is a class for currency conversion, which supports to convert amounts between different currencies, retrieve supported currencies, add new currency rates, and update existing currency rates.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the exchange rate of the US dollar against various currencies\n        \"\"\"\n        self.rates = {\n            'USD': 1.0,\n            'EUR': 0.85,\n            'GBP': 0.72,\n            'JPY': 110.15,\n            'CAD': 1.23,\n            'AUD': 1.34,\n            'CNY': 6.40,\n        }\n\n    def convert(self, amount, from_currency, to_currency):\n        \"\"\"\n        Convert the value of a given currency to another currency type\n        :param amount: float, The value of a given currency\n        :param from_currency: string, source currency type\n        :param to_currency: string, target currency type\n        :return: float, value converted to another currency type\n        >>> cc = CurrencyConverter()\n        >>> cc.convert(64, 'CNY','USD')\n        10.0\n        \"\"\"\n\n        # If the from currency and to currency are the same, return the amount\n        if from_currency == to_currency:\n            return amount\n\n        # If the from currency or to currency are not supported, return False\n        if from_currency not in self.rates or to_currency not in self.rates:\n            return False\n\n        # Get the exchange rates for the from and to currencies\n        from_rate = self.rates[from_currency]\n        to_rate = self.rates[to_currency]\n\n        # Convert the amount to the target currency using the exchange rates\n        converted_amount = (amount / from_rate) * to_rate\n\n        # Return the converted amount\n        return converted_amount\n\n\n    def get_supported_currencies(self):\n        \"\"\"\n        Returns a list of supported currency types\n        :return:list, All supported currency types\n        >>> cc = CurrencyConverter()\n        >>> cc.get_supported_currencies()\n        ['USD','EUR','GBP','JPY','CAD','AUD','CNY']\n        \"\"\"\n\n        # Get the list of supported currencies\n        return list(self.rates.keys())\n\n\n    def add_currency_rate(self, currency, rate):\n        \"\"\"\n        Add a new supported currency type, return False if the currency type is already in the support list\n        :param currency:string, currency type to be added\n        :param rate:float, exchange rate for this type of currency\n        :return:If successful, returns None; if unsuccessful, returns False\n        >>> cc = CurrencyConverter()\n        >>> cc.add_currency_rate('KRW', 1308.84)\n        self.rates['KRW'] = 1308.84\n        \"\"\"\n\n        # If the currency type is already in the supported list, return False\n        if currency in self.rates:\n            return False\n        \n        # Add the new currency type and its exchange rate to the supported list\n        self.rates[currency] = rate\n\n\n    def update_currency_rate(self, currency, new_rate):\n        \"\"\"\n        Update the exchange rate for a certain currency\n        :param currency:string\n        :param new_rate:float\n        :return:If successful, returns None; if unsuccessful, returns False\n        >>> cc = CurrencyConverter()\n        >>> cc.update_currency_rate('CNY', 7.18)\n        self.rates['CNY'] = 7.18\n        \"\"\"\n\n        # If the currency type is not in the supported list, return False\n        if currency not in self.rates:\n            return False\n        \n        # Update the exchange rate for the specified currency\n        self.rates[currency] = new_rate"
    },
    {
        "id" : "28",
        "code" : "import sqlite3\n\nclass DatabaseProcessor:\n\n    \"\"\"\n    This is a class for processing a database, supporting to create tables, insert data into the database, search for data based on name, and delete data from the database.\n    \"\"\"\n\n    def __init__(self, database_name):\n        \"\"\"\n        Initialize database name of database processor\n        \"\"\"\n        self.database_name = database_name\n\n\n    def create_table(self, table_name, key1, key2):\n        \"\"\"\n        Create a new table in the database if it doesn't exist.\n        And make id (INTEGER) as PRIMARY KEY, make key1 as TEXT, key2 as INTEGER\n        :param table_name: str, the name of the table to create.\n        :param key1: str, the name of the first column in the table.\n        :param key2: str, the name of the second column in the table.\n        >>> db.create_table('user', 'name', 'age')\n        \"\"\"\n\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        create_table_query = f\"CREATE TABLE IF NOT EXISTS {table_name} (id INTEGER PRIMARY KEY, {key1} TEXT, {key2} INTEGER)\"\n        cursor.execute(create_table_query)\n        conn.commit()\n        conn.close()\n\n\n    def insert_into_database(self, table_name, data):\n        \"\"\"\n        Insert data into the specified table in the database.\n        :param table_name: str, the name of the table to insert data into.\n        :param data: list, a list of dictionaries where each dictionary represents a row of data.\n        >>> db.insert_into_database('user', [\n                {'name': 'John', 'age': 25},\n                {'name': 'Alice', 'age': 30}\n            ])\n        \"\"\"\n\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        for item in data:\n            insert_query = f\"INSERT INTO {table_name} (name, age) VALUES (?, ?)\"\n            cursor.execute(insert_query, (item['name'], item['age']))\n        conn.commit()\n        conn.close()\n\n    def search_database(self, table_name, name):\n        \"\"\"\n        Search the specified table in the database for rows with a matching name.\n        :param table_name: str, the name of the table to search.\n        :param name: str, the name to search for.\n        :return: list, a list of tuples representing the rows with matching name, if any;\n                    otherwise, returns None.\n        >>> db.search_database('user', 'John')\n        [(1, 'John', 25)]\n        \"\"\"\n\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        select_query = f\"SELECT * FROM {table_name} WHERE name = ?\"\n        cursor.execute(select_query, (name,))\n        result = cursor.fetchall()\n        if result:\n            return result\n        else:\n            return None\n\n\n    def delete_from_database(self, table_name, name):\n        \"\"\"\n        Delete rows from the specified table in the database with a matching name.\n        :param table_name: str, the name of the table to delete rows from.\n        :param name: str, the name to match for deletion.\n        >>> db.delete_from_database('user', 'John')\n        \"\"\"\n\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        delete_query = f\"DELETE FROM {table_name} WHERE name = ?\"\n        cursor.execute(delete_query, (name,))\n        conn.commit()\n        conn.close()",
        "annotated_code" : "import sqlite3\n\nclass DatabaseProcessor:\n\n    \"\"\"\n    This is a class for processing a database, supporting to create tables, insert data into the database, search for data based on name, and delete data from the database.\n    \"\"\"\n\n    def __init__(self, database_name):\n        \"\"\"\n        Initialize database name of database processor\n        \"\"\"\n        self.database_name = database_name\n\n\n    def create_table(self, table_name, key1, key2):\n        \"\"\"\n        Create a new table in the database if it doesn't exist.\n        And make id (INTEGER) as PRIMARY KEY, make key1 as TEXT, key2 as INTEGER\n        :param table_name: str, the name of the table to create.\n        :param key1: str, the name of the first column in the table.\n        :param key2: str, the name of the second column in the table.\n        >>> db.create_table('user', 'name', 'age')\n        \"\"\"\n\n        # Use the sqlite3.connect function to create a connection to the SQLite database specified in database_name\n        conn = sqlite3.connect(self.database_name)\n\n        # Use the cursor function to create a cursor object from the connection to execute SQL commands\n        cursor = conn.cursor()\n\n        # Use the execute method of the cursor to execute a SQL command that creates the table table_name with the specified schema if it does not exist\n        create_table_query = f\"CREATE TABLE IF NOT EXISTS {table_name} (id INTEGER PRIMARY KEY, {key1} TEXT, {key2} INTEGER)\"\n        cursor.execute(create_table_query)\n\n        # Use the commit method of the connection to save the changes made to the database\n        conn.commit()\n\n        # Use the close method of the connection to close the connection to the database\n        conn.close()\n\n\n    def insert_into_database(self, table_name, data):\n        \"\"\"\n        Insert data into the specified table in the database.\n        :param table_name: str, the name of the table to insert data into.\n        :param data: list, a list of dictionaries where each dictionary represents a row of data.\n        >>> db.insert_into_database('user', [\n                {'name': 'John', 'age': 25},\n                {'name': 'Alice', 'age': 30}\n            ])\n        \"\"\"\n\n        # Use the sqlite3.connect function to create a connection to the SQLite database specified in database_name\n        conn = sqlite3.connect(self.database_name)\n\n        # Use the cursor function to create a cursor object from the connection to execute SQL commands\n        cursor = conn.cursor()\n\n        # Iterate through the list of items in data and insert each item into the specified table\n        for item in data:\n            # Use the execute method of the cursor to execute a SQL command that inserts a new row into the table with the specified values\n            insert_query = f\"INSERT INTO {table_name} (name, age) VALUES (?, ?)\"\n            cursor.execute(insert_query, (item['name'], item['age']))\n\n        # Use the commit method of the connection to save the changes made to the database\n        conn.commit()\n\n        # Use the close method of the connection to close the connection to the database\n        conn.close()\n\n    def search_database(self, table_name, name):\n        \"\"\"\n        Search the specified table in the database for rows with a matching name.\n        :param table_name: str, the name of the table to search.\n        :param name: str, the name to search for.\n        :return: list, a list of tuples representing the rows with matching name, if any;\n                    otherwise, returns None.\n        >>> db.search_database('user', 'John')\n        [(1, 'John', 25)]\n        \"\"\"\n\n        # Use the sqlite3.connect function to create a connection to the SQLite database specified in database_name\n        conn = sqlite3.connect(self.database_name)\n\n        # Use the cursor function to create a cursor object from the connection to execute SQL commands\n        cursor = conn.cursor()\n\n        # Use the execute method of the cursor to execute a SQL command that selects all columns from the rows with the spefied value for name\n        select_query = f\"SELECT * FROM {table_name} WHERE name = ?\"\n        cursor.execute(select_query, (name,))\n\n        # Use the fetchall method of the cursor to fetch all results from the executed query\n        result = cursor.fetchall()\n\n        # If there are results, return the list of tuples representing the rows with matching name; otherwise, return None\n        if result:\n            return result\n        else:\n            return None\n\n\n    def delete_from_database(self, table_name, name):\n        \"\"\"\n        Delete rows from the specified table in the database with a matching name.\n        :param table_name: str, the name of the table to delete rows from.\n        :param name: str, the name to match for deletion.\n        >>> db.delete_from_database('user', 'John')\n        \"\"\"\n\n        # Use the sqlite3.connect function to create a connection to the SQLite database specified in database_name\n        conn = sqlite3.connect(self.database_name)\n\n        # Use the cursor function to create a cursor object from the connection to execute SQL commands\n        cursor = conn.cursor()\n\n        # Use the execute method of the cursor to execute a SQL command that deletes the rows with the specified value for the name field\n        delete_query = f\"DELETE FROM {table_name} WHERE name = ?\"\n        cursor.execute(delete_query, (name,))\n\n        # Use the commit method of the connection to save the changes made to the database\n        conn.commit()\n\n        # Use the close method of the connection to close the connection to the database\n        conn.close()"
    },
    {
        "id" : "29",
        "code" : "from collections import Counter\n\nclass DataStatistics:\n    \n    \"\"\"\n    This is a class for performing data statistics, supporting to calculate the mean, median, and mode of a given data set.\n    \"\"\"\n\n    def mean(self, data):\n        \"\"\"\n        Calculate the average value of a group of data, accurate to two digits after the Decimal separator\n        :param data:list, data list\n        :return:float, the mean value\n        >>> ds = DataStatistics()\n        >>> ds.mean([1, 2, 3, 4, 5])\n        3.00\n        \"\"\"\n\n        return round(sum(data) / len(data), 2)\n\n    def median(self, data):\n        \"\"\"\n        Calculate the median of a group of data, accurate to two digits after the Decimal separator\n        :param data:list, data list\n        :return:float, the median value\n        >>> ds = DataStatistics()\n        >>> ds.median([2, 5, 1, 3, 4])\n        3.00\n        \"\"\"\n\n        sorted_data = sorted(data)\n\n        n = len(sorted_data)\n        if n % 2 == 0:\n            middle = n // 2\n            return round((sorted_data[middle - 1] + sorted_data[middle]) / 2, 2)\n        else:\n            middle = n // 2\n            return sorted_data[middle]\n\n    def mode(self, data):\n        \"\"\"\n        Calculate the mode of a set of data\n        :param data:list, data list\n        :return:float, the mode\n        >>> ds = DataStatistics()\n        >>> ds.mode([2, 2, 3, 3, 4])\n        [2, 3]\n        \"\"\"\n\n        counter = Counter(data)\n        mode_count = max(counter.values())\n        mode = [x for x, count in counter.items() if count == mode_count]\n        return mode",
        "annotated_code" : "from collections import Counter\n\nclass DataStatistics:\n    \n    \"\"\"\n    This is a class for performing data statistics, supporting to calculate the mean, median, and mode of a given data set.\n    \"\"\"\n\n    def mean(self, data):\n        \"\"\"\n        Calculate the average value of a group of data, accurate to two digits after the Decimal separator\n        :param data:list, data list\n        :return:float, the mean value\n        >>> ds = DataStatistics()\n        >>> ds.mean([1, 2, 3, 4, 5])\n        3.00\n        \"\"\"\n\n        # Calculate the mean of the list of numbers in data and return it rounded to 2 decimal places.\n        return round(sum(data) / len(data), 2)\n\n    def median(self, data):\n        \"\"\"\n        Calculate the median of a group of data, accurate to two digits after the Decimal separator\n        :param data:list, data list\n        :return:float, the median value\n        >>> ds = DataStatistics()\n        >>> ds.median([2, 5, 1, 3, 4])\n        3.00\n        \"\"\"\n\n        # Sort data with the sorted function\n        sorted_data = sorted(data)\n\n        n = len(sorted_data)\n        if n % 2 == 0:\n            # If the number of elements is even, return the average of the two middle elements rounded to 2 decimal places.\n            middle = n // 2\n            return round((sorted_data[middle - 1] + sorted_data[middle]) / 2, 2)\n        else:\n            # If the number of elements is odd, return the middle element.\n            middle = n // 2\n            return sorted_data[middle]\n\n    def mode(self, data):\n        \"\"\"\n        Calculate the mode of a set of data\n        :param data:list, data list\n        :return:float, the mode\n        >>> ds = DataStatistics()\n        >>> ds.mode([2, 2, 3, 3, 4])\n        [2, 3]\n        \"\"\"\n\n        # Initialize a Counter object to count the occurrences of each element in data.\n        counter = Counter(data)\n\n        # Find the maximum count of occurrences of an element in the counter.\n        mode_count = max(counter.values())\n\n        # Create a list of elements that have the same count as mode_count and return it.\n        mode = [x for x, count in counter.items() if count == mode_count]\n        return mode"
    },
    {
        "id" : "30",
        "code" : "import numpy as np\n\nclass DataStatistics2:\n\n    \"\"\"\n    This is a class for performing data statistics, supporting to get the sum, minimum, maximum, variance, standard deviation, and correlation of a given dataset.\n    \"\"\"\n\n    def __init__(self, data):\n        \"\"\"\n        Initialize Data List\n        :param data:list\n        \"\"\"\n\n        self.data = np.array(data)\n\n    def get_sum(self):\n        \"\"\"\n        Calculate the sum of data\n        :return:float\n        >>> ds2 = DataStatistics2([1, 2, 3, 4])\n        >>> ds2.get_sum()\n        10\n        \"\"\"\n\n        return np.sum(self.data)\n\n    def get_min(self):\n        \"\"\"\n        Calculate the minimum value in the data\n        :return:float\n        >>> ds2 = DataStatistics2([1, 2, 3, 4])\n        >>> ds2.get_min()\n        1\n        \"\"\"\n\n        return np.min(self.data)\n\n    def get_max(self):\n        \"\"\"\n        Calculate the maximum value in the data\n        :return:float\n        >>> ds2 = DataStatistics2([1, 2, 3, 4])\n        >>> ds2.get_max()\n        4\n        \"\"\"\n\n        return np.max(self.data)\n\n    def get_variance(self):\n        \"\"\"\n        Calculate variance, accurate to two digits after the Decimal separator\n        :return:float\n        >>> ds2 = DataStatistics2([1, 2, 3, 4])\n        >>> ds2.get_variance()\n        1.25\n        \"\"\"\n\n        return round(np.var(self.data), 2)\n\n    def get_std_deviation(self):\n        \"\"\"\n        Calculate standard deviation, accurate to two digits after the Decimal separator\n        :return:float\n        >>> ds2 = DataStatistics2([1, 2, 3, 4])\n        >>> ds2.get_std_deviation()\n        1.12\n        \"\"\"\n\n        return round(np.std(self.data), 2)\n\n    def get_correlation(self):\n        \"\"\"\n        Calculate correlation\n        :return:float\n        >>> ds2 = DataStatistics2([1, 2, 3, 4])\n        >>> ds2.get_correlation()\n        1.0\n        \"\"\"\n\n        return np.corrcoef(self.data, rowvar=False)",
        "annotated_code" : "import numpy as np\n\nclass DataStatistics2:\n\n    \"\"\"\n    This is a class for performing data statistics, supporting to get the sum, minimum, maximum, variance, standard deviation, and correlation of a given dataset.\n    \"\"\"\n\n    def __init__(self, data):\n        \"\"\"\n        Initialize Data List\n        :param data:list\n        \"\"\"\n\n        # Initialize data as a numpy array with the np.array function\n        self.data = np.array(data)\n\n    def get_sum(self):\n        \"\"\"\n        Calculate the sum of data\n        :return:float\n        >>> ds2 = DataStatistics2([1, 2, 3, 4])\n        >>> ds2.get_sum()\n        10\n        \"\"\"\n\n        # Use the np.sum function to calculate the sum of the data and return it\n        return np.sum(self.data)\n\n    def get_min(self):\n        \"\"\"\n        Calculate the minimum value in the data\n        :return:float\n        >>> ds2 = DataStatistics2([1, 2, 3, 4])\n        >>> ds2.get_min()\n        1\n        \"\"\"\n\n        # Use the np.min function to calculate the minimum value in the data and return it\n        return np.min(self.data)\n\n    def get_max(self):\n        \"\"\"\n        Calculate the maximum value in the data\n        :return:float\n        >>> ds2 = DataStatistics2([1, 2, 3, 4])\n        >>> ds2.get_max()\n        4\n        \"\"\"\n\n        # Use the np.max function to calculate the maximum value in the data and return it\n        return np.max(self.data)\n\n    def get_variance(self):\n        \"\"\"\n        Calculate variance, accurate to two digits after the Decimal separator\n        :return:float\n        >>> ds2 = DataStatistics2([1, 2, 3, 4])\n        >>> ds2.get_variance()\n        1.25\n        \"\"\"\n\n        # Use the np.var function to calculate the variance of the data and return it rounded to two decimal places\n        return round(np.var(self.data), 2)\n\n    def get_std_deviation(self):\n        \"\"\"\n        Calculate standard deviation, accurate to two digits after the Decimal separator\n        :return:float\n        >>> ds2 = DataStatistics2([1, 2, 3, 4])\n        >>> ds2.get_std_deviation()\n        1.12\n        \"\"\"\n\n        # Use the np.std function to calculate the standard deviation of the data and return it rounded to two decimal places\n        return round(np.std(self.data), 2)\n\n    def get_correlation(self):\n        \"\"\"\n        Calculate correlation\n        :return:float\n        >>> ds2 = DataStatistics2([1, 2, 3, 4])\n        >>> ds2.get_correlation()\n        1.0\n        \"\"\"\n\n        # Use the np.corrcoef function to calculate the correlation of the data and return it\n        return np.corrcoef(self.data, rowvar=False)"
    },
    {
        "id" : "31",
        "code" : "import math\n\nclass DataStatistics4:\n\n    \"\"\"\n    This is a class that performs advanced mathematical calculations and statistics, including correlation coefficient, skewness, kurtosis, and probability density function (PDF) for a normal distribution.\n    \"\"\"\n\n    @staticmethod\n    def correlation_coefficient(data1, data2):\n        \"\"\"\n        Calculate the correlation coefficient of two sets of data.\n        :param data1: The first set of data,list.\n        :param data2: The second set of data,list.\n        :return: The correlation coefficient, float.\n        >>> DataStatistics4.correlation_coefficient([1, 2, 3], [4, 5, 6])\n        0.9999999999999998\n\n        \"\"\"\n\n        n = len(data1)\n        mean1 = sum(data1) / n\n        mean2 = sum(data2) / n\n        numerator = sum((data1[i] - mean1) * (data2[i] - mean2) for i in range(n))\n        denominator = math.sqrt(sum((data1[i] - mean1) ** 2 for i in range(n))) * math.sqrt(sum((data2[i] - mean2) ** 2 for i in range(n)))\n\n        return numerator / denominator if denominator != 0 else 0\n\n    @staticmethod\n    def skewness(data):\n        \"\"\"\n        Calculate the skewness of a set of data.\n        :param data: The input data list, list.\n        :return: The skewness, float.\n        >>> DataStatistics4.skewness([1, 2, 5])\n        2.3760224064818463\n\n        \"\"\"\n\n        n = len(data)\n        mean = sum(data) / n\n        variance = sum((x - mean) ** 2 for x in data) / n\n        std_deviation = math.sqrt(variance)\n        skewness = sum((x - mean) ** 3 for x in data) * n / ((n - 1) * (n - 2) * std_deviation ** 3) if std_deviation != 0 else 0\n\n        return skewness\n\n    @staticmethod\n    def kurtosis(data):\n        \"\"\"\n        Calculate the kurtosis of a set of data.\n        :param data: The input data list, list.\n        :return: The kurtosis, float.\n        >>> DataStatistics4.kurtosis([1, 20,100])\n        -1.5000000000000007\n\n        \"\"\"\n\n        n = len(data)\n        mean = sum(data) / n\n        std_dev = math.sqrt(sum((x - mean) ** 2 for x in data) / n)\n\n        if std_dev == 0:\n            return math.nan\n\n        centered_data = [(x - mean) for x in data]\n        fourth_moment = sum(x ** 4 for x in centered_data) / n\n        kurtosis_value = (fourth_moment / std_dev ** 4) - 3\n        return kurtosis_value\n\n    @staticmethod\n    def pdf(data, mu, sigma):\n        \"\"\"\n        Calculate the probability density function (PDF) of a set of data under a normal distribution.\n        :param data: The input data list, list.\n        :param mu: The mean of the normal distribution, float.\n        :param sigma: The standard deviation of the normal distribution, float.\n        :return: The probability density function (PDF), list.\n        >>> DataStatistics4.pdf([1, 2, 3], 1, 1)\n        [0.3989422804014327, 0.24197072451914337, 0.05399096651318806]\n\n        \"\"\"\n\n        pdf_values = [1 / (sigma * math.sqrt(2 * math.pi)) * math.exp(-0.5 * ((x - mu) / sigma) ** 2) for x in data]\n        return pdf_values",
        "annotated_code" : "import math\n\nclass DataStatistics4:\n\n    \"\"\"\n    This is a class that performs advanced mathematical calculations and statistics, including correlation coefficient, skewness, kurtosis, and probability density function (PDF) for a normal distribution.\n    \"\"\"\n\n    @staticmethod\n    def correlation_coefficient(data1, data2):\n        \"\"\"\n        Calculate the correlation coefficient of two sets of data.\n        :param data1: The first set of data,list.\n        :param data2: The second set of data,list.\n        :return: The correlation coefficient, float.\n        >>> DataStatistics4.correlation_coefficient([1, 2, 3], [4, 5, 6])\n        0.9999999999999998\n\n        \"\"\"\n\n        n = len(data1)\n\n        # Calculate the mean of each dataset\n        mean1 = sum(data1) / n\n        mean2 = sum(data2) / n\n\n        # Calculate the numerator and denominator for the correlation coefficient\n        # Use the math.sqrt function for square root\n        numerator = sum((data1[i] - mean1) * (data2[i] - mean2) for i in range(n))\n        denominator = math.sqrt(sum((data1[i] - mean1) ** 2 for i in range(n))) * math.sqrt(sum((data2[i] - mean2) ** 2 for i in range(n)))\n\n        # Return the correlation coefficient if the denominator is not zero\n        # If the denominator is zero, return 0\n        return numerator / denominator if denominator != 0 else 0\n\n    @staticmethod\n    def skewness(data):\n        \"\"\"\n        Calculate the skewness of a set of data.\n        :param data: The input data list, list.\n        :return: The skewness, float.\n        >>> DataStatistics4.skewness([1, 2, 5])\n        2.3760224064818463\n\n        \"\"\"\n\n        n = len(data)\n\n        # Calculate the mean, variance, and standard deviation of the data\n        # Use the math.sqrt function for square root\n        mean = sum(data) / n\n        variance = sum((x - mean) ** 2 for x in data) / n\n        std_deviation = math.sqrt(variance)\n\n        # Calculate the skewness using the mean and standard deviation\n        # If the standard deviation is zero, return 0 to avoid division by zero\n        skewness = sum((x - mean) ** 3 for x in data) * n / ((n - 1) * (n - 2) * std_deviation ** 3) if std_deviation != 0 else 0\n\n        # Return the skewness value\n        return skewness\n\n    @staticmethod\n    def kurtosis(data):\n        \"\"\"\n        Calculate the kurtosis of a set of data.\n        :param data: The input data list, list.\n        :return: The kurtosis, float.\n        >>> DataStatistics4.kurtosis([1, 20,100])\n        -1.5000000000000007\n\n        \"\"\"\n\n        n = len(data)\n\n        # Calculate the mean and standard deviation of the data\n        # Use the math.sqrt function for square root\n        mean = sum(data) / n\n        std_dev = math.sqrt(sum((x - mean) ** 2 for x in data) / n)\n\n        # If the standard deviation is zero, return NaN to avoid division by zero\n        if std_dev == 0:\n            return math.nan\n\n        # Calculate the centered data using the mean\n        centered_data = [(x - mean) for x in data]\n\n        # Calculate the fourth moment using the centered data\n        fourth_moment = sum(x ** 4 for x in centered_data) / n\n\n        # Calculate the kurtosis using the fourth moment and standard deviation\n        kurtosis_value = (fourth_moment / std_dev ** 4) - 3\n\n        # Return the kurtosis value\n        return kurtosis_value\n\n    @staticmethod\n    def pdf(data, mu, sigma):\n        \"\"\"\n        Calculate the probability density function (PDF) of a set of data under a normal distribution.\n        :param data: The input data list, list.\n        :param mu: The mean of the normal distribution, float.\n        :param sigma: The standard deviation of the normal distribution, float.\n        :return: The probability density function (PDF), list.\n        >>> DataStatistics4.pdf([1, 2, 3], 1, 1)\n        [0.3989422804014327, 0.24197072451914337, 0.05399096651318806]\n\n        \"\"\"\n\n        # Calculate the PDF values for each data point using the normal distribution formula\n        # Use the math.exp function for exponentiation\n        # Use the math.sqrt function for square root\n        # Use the math.pi function for pi\n        pdf_values = [1 / (sigma * math.sqrt(2 * math.pi)) * math.exp(-0.5 * ((x - mu) / sigma) ** 2) for x in data]\n\n        # Return the PDF values as a list\n        return pdf_values"
    },
    {
        "id" : "32",
        "code" : "class DecryptionUtils:\n\n    \"\"\"\n    This is a class that provides methods for decryption, including the Caesar cipher, Vigenere cipher, and Rail Fence cipher.\n    \"\"\"\n\n    def __init__(self, key):\n        \"\"\"\n        Initializes the decryption utility with a key.\n        :param key: The key to use for decryption,str.\n        \"\"\"\n        self.key = key\n\n    def caesar_decipher(self, ciphertext, shift):\n        \"\"\"\n        Deciphers the given ciphertext using the Caesar cipher\n        :param ciphertext: The ciphertext to decipher,str.\n        :param shift: The shift to use for decryption,int.\n        :return: The deciphered plaintext,str.\n        >>> d = DecryptionUtils('key')\n        >>> d.caesar_decipher('ifmmp', 1)\n        'hello'\n\n        \"\"\"\n\n        plaintext = \"\"\n\n        # Loop through each character in the ciphertext\n        for char in ciphertext:\n\n            if char.isalpha():\n                # If the character is an uppercase letter set the ascii offset to 65\n                # If the character is a lowercase letter set the ascii offset to 97\n                if char.isupper():\n                    ascii_offset = 65\n                else:\n                    ascii_offset = 97\n                # Calculate the shifted character\n                shifted_char = chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n\n                # Add the shifted character to the plaintext\n                plaintext += shifted_char\n            else:\n                # If the character is not a letter, add it to the plaintext as is\n                plaintext += char\n\n        # Return the deciphered plaintext\n        return plaintext\n\n    def vigenere_decipher(self, ciphertext):\n        \"\"\"\n        Deciphers the given ciphertext using the Vigenere cipher\n        :param ciphertext: The ciphertext to decipher,str.\n        :return: The deciphered plaintext,str.\n        >>> d = DecryptionUtils('key')\n        >>> d.vigenere_decipher('ifmmp')\n        'ybocl'\n\n        \"\"\"\n\n        decrypted_text = \"\"\n        key_index = 0\n\n        # Loop through each character in the ciphertext\n        for char in ciphertext:\n\n            if char.isalpha():\n\n                # Calculate the shift based on the character at key_index in the key\n                shift = ord(self.key[key_index % len(self.key)].lower()) - ord('a')\n\n                # Calculate the decrypted character\n                decrypted_char = chr((ord(char.lower()) - ord('a') - shift) % 26 + ord('a'))\n\n                # If the character was uppercase, convert the decrypted character to uppercase\n                # Add the decrypted character to the deciphered text\n                decrypted_text += decrypted_char.upper() if char.isupper() else decrypted_char\n\n                # Move to the next character in the key\n                key_index += 1\n            else:\n                # If the character is not a letter, add it to the decrypted text as is\n                decrypted_text += char\n\n        # Return the deciphered text\n        return decrypted_text\n\n    def rail_fence_decipher(self, encrypted_text, rails):\n        \"\"\"\n        Deciphers the given ciphertext using the Rail Fence cipher\n        :param encrypted_text: The ciphertext to decipher,str.\n        :param rails: The number of rails to use for decryption,int.\n        :return: The deciphered plaintext,str.\n        >>> d = DecryptionUtils('key')\n        >>> d.rail_fence_decipher('Hoo!el,Wrdl l', 3)\n        'Hello, World!'\n\n        \"\"\"\n\n        # Create a fence with new line characters that has dimensions rails x len(encrypted_text)\n        fence = [['\n' for _ in range(len(encrypted_text))] for _ in range(rails)]\n        direction = -1\n        row, col = 0, 0\n\n        # Loop through each character in the encrypted text\n        for _ in range(len(encrypted_text)):\n\n            # Change direction when reaching the top or bottom rail\n            if row == 0 or row == rails - 1:\n                direction = -direction\n\n            # Mark the position in the fence with an empty string\n            fence[row][col] = ''\n\n            # Move to the next column and row\n            col += 1\n            row += direction\n\n        index = 0\n        for i in range(rails):\n            for j in range(len(encrypted_text)):\n                if fence[i][j] == '':\n                    fence[i][j] = encrypted_text[index]\n                    index += 1\n\n        plain_text = ''\n        direction = -1\n        row, col = 0, 0\n        for _ in range(len(encrypted_text)):\n            if row == 0 or row == rails - 1:\n                direction = -direction\n            plain_text += fence[row][col]\n            col += 1\n            row += direction\n        return plain_text",
        "annotated_code" : "class DecryptionUtils:\n\n    \"\"\"\n    This is a class that provides methods for decryption, including the Caesar cipher, Vigenere cipher, and Rail Fence cipher.\n    \"\"\"\n\n    def __init__(self, key):\n        \"\"\"\n        Initializes the decryption utility with a key.\n        :param key: The key to use for decryption,str.\n        \"\"\"\n        self.key = key\n\n    def caesar_decipher(self, ciphertext, shift):\n        \"\"\"\n        Deciphers the given ciphertext using the Caesar cipher\n        :param ciphertext: The ciphertext to decipher,str.\n        :param shift: The shift to use for decryption,int.\n        :return: The deciphered plaintext,str.\n        >>> d = DecryptionUtils('key')\n        >>> d.caesar_decipher('ifmmp', 1)\n        'hello'\n\n        \"\"\"\n\n        plaintext = \"\"\n\n        # Loop through each character in the ciphertext\n        for char in ciphertext:\n\n            if char.isalpha():\n                # If the character is an uppercase letter set the ascii offset to 65\n                # If the character is a lowercase letter set the ascii offset to 97\n                if char.isupper():\n                    ascii_offset = 65\n                else:\n                    ascii_offset = 97\n                # Calculate the shifted character\n                shifted_char = chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)\n\n                # Add the shifted character to the plaintext\n                plaintext += shifted_char\n            else:\n                # If the character is not a letter, add it to the plaintext as is\n                plaintext += char\n\n        # Return the deciphered plaintext\n        return plaintext\n\n    def vigenere_decipher(self, ciphertext):\n        \"\"\"\n        Deciphers the given ciphertext using the Vigenere cipher\n        :param ciphertext: The ciphertext to decipher,str.\n        :return: The deciphered plaintext,str.\n        >>> d = DecryptionUtils('key')\n        >>> d.vigenere_decipher('ifmmp')\n        'ybocl'\n\n        \"\"\"\n\n        decrypted_text = \"\"\n        key_index = 0\n\n        # Loop through each character in the ciphertext\n        for char in ciphertext:\n\n            if char.isalpha():\n\n                # Calculate the shift based on the character at key_index in the key\n                shift = ord(self.key[key_index % len(self.key)].lower()) - ord('a')\n\n                # Calculate the decrypted character\n                decrypted_char = chr((ord(char.lower()) - ord('a') - shift) % 26 + ord('a'))\n\n                # If the character was uppercase, convert the decrypted character to uppercase\n                # Add the decrypted character to the deciphered text\n                decrypted_text += decrypted_char.upper() if char.isupper() else decrypted_char\n\n                # Move to the next character in the key\n                key_index += 1\n            else:\n                # If the character is not a letter, add it to the decrypted text as is\n                decrypted_text += char\n\n        # Return the deciphered text\n        return decrypted_text\n\n    def rail_fence_decipher(self, encrypted_text, rails):\n        \"\"\"\n        Deciphers the given ciphertext using the Rail Fence cipher\n        :param encrypted_text: The ciphertext to decipher,str.\n        :param rails: The number of rails to use for decryption,int.\n        :return: The deciphered plaintext,str.\n        >>> d = DecryptionUtils('key')\n        >>> d.rail_fence_decipher('Hoo!el,Wrdl l', 3)\n        'Hello, World!'\n\n        \"\"\"\n\n        # Create a fence with new line characters that has dimensions rails x len(encrypted_text)\n        fence = [['\n' for _ in range(len(encrypted_text))] for _ in range(rails)]\n        direction = -1\n        row, col = 0, 0\n\n        # Loop through each character in the encrypted text\n        for _ in range(len(encrypted_text)):\n\n            # Change direction when reaching the top or bottom rail\n            if row == 0 or row == rails - 1:\n                direction = -direction\n\n            # Mark the position in the fence with an empty string\n            fence[row][col] = ''\n\n            # Move to the next column and row\n            col += 1\n            row += direction\n\n        index = 0\n        # Fill the fence with characters from the encrypted text\n        for i in range(rails):\n            for j in range(len(encrypted_text)):\n                if fence[i][j] == '':\n                    fence[i][j] = encrypted_text[index]\n                    index += 1\n\n        plain_text = ''\n        direction = -1\n        row, col = 0, 0\n\n        # Read the fence in a zigzag pattern to get the plaintext\n        for _ in range(len(encrypted_text)):\n\n            # Change direction when reaching the top or bottom rail\n            if row == 0 or row == rails - 1:\n                direction = -direction\n\n            # Add the character at the current position to the plaintext\n            plain_text += fence[row][col]\n\n            # Move to the next column and row\n            col += 1\n            row += direction\n\n        # Return the deciphered plaintext\n        return plain_text"
    },
    {
        "id" : "33",
        "code" : "class DiscountStrategy:\n\n    \"\"\"\n    This is a class that allows to use different discount strategy based on shopping credit or shopping cart in supermarket.\n    \"\"\"\n\n    def __init__(self, customer, cart, promotion=None):\n        \"\"\"\n        Initialize the DiscountStrategy with customer information, a cart of items, and an optional promotion.\n        :param customer: dict, customer information\n        :param cart: list of dicts, a cart of items with details\n        :param promotion: function, optional promotion applied to the order\n        >>> customer = {'name': 'John Doe', 'fidelity': 1200}\n        >>> cart = [{'product': 'product', 'quantity': 14, 'price': 23.5}]\n        >>> DiscountStrategy(customer, cart, DiscountStrategy.FidelityPromo)\n\n        \"\"\"\n\n        self.customer = customer\n        self.cart = cart\n        self.promotion = promotion\n        self.__total = self.total()\n\n    def total(self):\n        \"\"\"\n        Calculate the total cost of items in the cart.\n        :return: float, total cost of items\n        >>> customer = {'name': 'John Doe', 'fidelity': 1200}\n        >>> cart = [{'product': 'product', 'quantity': 14, 'price': 23.5}]\n        >>> ds = DiscountStrategy(customer, cart)\n        >>> ds.total()\n        329.0\n\n        \"\"\"\n\n        self.__total = sum(item['quantity'] * item['price'] for item in self.cart)\n        return self.__total\n\n\n    def due(self):\n        \"\"\"\n        Calculate the final amount to be paid after applying the discount.\n        :return: float, final amount to be paid\n        >>> customer = {'name': 'John Doe', 'fidelity': 1200}\n        >>> cart = [{'product': 'product', 'quantity': 14, 'price': 23.5}]\n        >>> ds = DiscountStrategy(customer, cart, DiscountStrategy.FidelityPromo)\n        >>> ds.due()\n        312.55\n\n        \"\"\"\n\n        if self.promotion is None:\n            discount = 0\n        else:\n            discount = self.promotion(self)\n        \n        return self.__total - discount\n\n\n    @staticmethod\n    def FidelityPromo(order):\n        \"\"\"\n        Calculate the discount based on the fidelity points of the customer.Customers with over 1000 points can enjoy a 5% discount on the entire order.\n        :param order: object, the order to apply the discount to\n        :return: float, discount amount\n        >>> customer = {'name': 'John Doe', 'fidelity': 1200}\n        >>> cart = [{'product': 'product', 'quantity': 14, 'price': 23.5}]\n        >>> order = DiscountStrategy(customer, cart, DiscountStrategy.FidelityPromo)\n        >>> DiscountStrategy.FidelityPromo(order)\n        16.45\n\n        \"\"\"\n\n        return order.total() * 0.05 if order.customer['fidelity'] >= 1000 else 0\n\n\n    @staticmethod\n    def BulkItemPromo(order):\n        \"\"\"\n        Calculate the discount based on bulk item quantity in the order.In the same order, if the quantity of a single item reaches 20 or more, each item will enjoy a 10% discount.\n        :param order: object, the order to apply the discount to\n        :return: float, discount amount\n        >>> customer = {'name': 'John Doe', 'fidelity': 1200}\n        >>> cart = [{'product': 'product', 'quantity': 20, 'price': 23.5}]\n        >>> order = DiscountStrategy(customer, cart, DiscountStrategy.BulkItemPromo)\n        >>> DiscountStrategy.BulkItemPromo(order)\n        47.0\n\n        \"\"\"\n\n        discount = 0\n        for item in order.cart:\n            if item['quantity'] >= 20:\n                discount += item['quantity'] * item['price'] * 0.1\n        return discount\n\n\n    @staticmethod\n    def LargeOrderPromo(order):\n        \"\"\"\n        Calculate the discount based on the number of different products in the order.If the quantity of different products in the order reaches 10 or more, the entire order will enjoy a 7% discount.\n        :param order: object, the order to apply the discount to\n        :return: float, discount amount\n        >>> customer = {'name': 'John Doe', 'fidelity': 1200}\n        >>> cart = [{'product': 'product', 'quantity': 14, 'price': 23.5}]\n        >>> order = DiscountStrategy(customer, cart, DiscountStrategy.LargeOrderPromo)\n        >>> DiscountStrategy.LargeOrderPromo(order)\n        0.0\n\n        \"\"\"\n\n        return order.total() * 0.07 if len({item['product'] for item in order.cart}) >= 10 else 0",
        "annotated_code" : "class DiscountStrategy:\n\n    \"\"\"\n    This is a class that allows to use different discount strategy based on shopping credit or shopping cart in supermarket.\n    \"\"\"\n\n    def __init__(self, customer, cart, promotion=None):\n        \"\"\"\n        Initialize the DiscountStrategy with customer information, a cart of items, and an optional promotion.\n        :param customer: dict, customer information\n        :param cart: list of dicts, a cart of items with details\n        :param promotion: function, optional promotion applied to the order\n        >>> customer = {'name': 'John Doe', 'fidelity': 1200}\n        >>> cart = [{'product': 'product', 'quantity': 14, 'price': 23.5}]\n        >>> DiscountStrategy(customer, cart, DiscountStrategy.FidelityPromo)\n\n        \"\"\"\n\n        self.customer = customer\n        self.cart = cart\n        self.promotion = promotion\n\n        # Calculate the total cost of items in the cart and store it in self.__total\n        self.__total = self.total()\n\n    def total(self):\n        \"\"\"\n        Calculate the total cost of items in the cart.\n        :return: float, total cost of items\n        >>> customer = {'name': 'John Doe', 'fidelity': 1200}\n        >>> cart = [{'product': 'product', 'quantity': 14, 'price': 23.5}]\n        >>> ds = DiscountStrategy(customer, cart)\n        >>> ds.total()\n        329.0\n\n        \"\"\"\n\n        # Calculate the total cost of items in the cart\n        self.__total = sum(item['quantity'] * item['price'] for item in self.cart)\n\n        # Return the total cost\n        return self.__total\n\n\n    def due(self):\n        \"\"\"\n        Calculate the final amount to be paid after applying the discount.\n        :return: float, final amount to be paid\n        >>> customer = {'name': 'John Doe', 'fidelity': 1200}\n        >>> cart = [{'product': 'product', 'quantity': 14, 'price': 23.5}]\n        >>> ds = DiscountStrategy(customer, cart, DiscountStrategy.FidelityPromo)\n        >>> ds.due()\n        312.55\n\n        \"\"\"\n\n        # Calculate the discount based on the promotion\n        if self.promotion is None:\n            discount = 0\n        else:\n            discount = self.promotion(self)\n        \n        # Return the final amount to be paid after applying the discount\n        return self.__total - discount\n\n\n    @staticmethod\n    def FidelityPromo(order):\n        \"\"\"\n        Calculate the discount based on the fidelity points of the customer.Customers with over 1000 points can enjoy a 5% discount on the entire order.\n        :param order: object, the order to apply the discount to\n        :return: float, discount amount\n        >>> customer = {'name': 'John Doe', 'fidelity': 1200}\n        >>> cart = [{'product': 'product', 'quantity': 14, 'price': 23.5}]\n        >>> order = DiscountStrategy(customer, cart, DiscountStrategy.FidelityPromo)\n        >>> DiscountStrategy.FidelityPromo(order)\n        16.45\n\n        \"\"\"\n\n        # If the fidelity points are over 1000, apply a 5% discount on the total order\n        # Otherwise, no discount is applied\n        # Return the discount amount\n        return order.total() * 0.05 if order.customer['fidelity'] >= 1000 else 0\n\n\n    @staticmethod\n    def BulkItemPromo(order):\n        \"\"\"\n        Calculate the discount based on bulk item quantity in the order.In the same order, if the quantity of a single item reaches 20 or more, each item will enjoy a 10% discount.\n        :param order: object, the order to apply the discount to\n        :return: float, discount amount\n        >>> customer = {'name': 'John Doe', 'fidelity': 1200}\n        >>> cart = [{'product': 'product', 'quantity': 20, 'price': 23.5}]\n        >>> order = DiscountStrategy(customer, cart, DiscountStrategy.BulkItemPromo)\n        >>> DiscountStrategy.BulkItemPromo(order)\n        47.0\n\n        \"\"\"\n\n        discount = 0\n\n        # Iterate through each item in the cart\n        for item in order.cart:\n            # If the quantity of a single item is 20 or more, apply a 10% discount\n            if item['quantity'] >= 20:\n                discount += item['quantity'] * item['price'] * 0.1\n\n        # Return the total discount amount\n        return discount\n\n\n    @staticmethod\n    def LargeOrderPromo(order):\n        \"\"\"\n        Calculate the discount based on the number of different products in the order.If the quantity of different products in the order reaches 10 or more, the entire order will enjoy a 7% discount.\n        :param order: object, the order to apply the discount to\n        :return: float, discount amount\n        >>> customer = {'name': 'John Doe', 'fidelity': 1200}\n        >>> cart = [{'product': 'product', 'quantity': 14, 'price': 23.5}]\n        >>> order = DiscountStrategy(customer, cart, DiscountStrategy.LargeOrderPromo)\n        >>> DiscountStrategy.LargeOrderPromo(order)\n        0.0\n\n        \"\"\"\n\n        # If the number of different products in the order is 10 or more, apply a 7% discount on the total order\n        # Otherwise, no discount is applied\n        # Return the discount amount\n        return order.total() * 0.07 if len({item['product'] for item in order.cart}) >= 10 else 0"
    },
    {
        "id" : "34",
        "code" : "from docx import Document\nfrom docx.shared import Pt\nfrom docx.enum.text import WD_PARAGRAPH_ALIGNMENT\n\nclass DocFileHandler:\n\n    \"\"\"\n    This is a class that handles Word documents and provides functionalities for reading, writing, and modifying the content of Word documents.\n    \"\"\"\n\n    def __init__(self, file_path):\n        \"\"\"\n        Initializes the DocFileHandler object with the specified file path.\n        :param file_path: str, the path to the Word document file.\n        \"\"\"\n        self.file_path = file_path\n\n    def read_text(self):\n        \"\"\"\n        Reads the content of a Word document and returns it as a string.\n        :return: str, the content of the Word document.\n        \"\"\"\n \n        doc = Document(self.file_path)\n        text = []\n        for paragraph in doc.paragraphs:\n            text.append(paragraph.text)\n        return \"\n\".join(text)\n\n    def write_text(self, content, font_size=12, alignment='left'):\n        \"\"\"\n        Writes the specified content to a Word document.\n        :param content: str, the text content to write.\n        :param font_size: int, optional, the font size of the text (default is 12).\n        :param alignment: str, optional, the alignment of the text ('left', 'center', or 'right'; default is 'left').\n        :return: bool, True if the write operation is successful, False otherwise.\n        \"\"\"\n\n        try:\n            doc = Document()\n            paragraph = doc.add_paragraph()\n            run = paragraph.add_run(content)\n            font = run.font\n            font.size = Pt(font_size)\n            alignment_value = self._get_alignment_value(alignment)\n            paragraph.alignment = alignment_value\n            doc.save(self.file_path)\n            return True\n        except:\n            return False\n\n    def add_heading(self, heading, level=1):\n        \"\"\"\n        Adds a heading to the Word document.\n        :param heading: str, the text of the heading.\n        :param level: int, optional, the level of the heading (1, 2, 3, etc.; default is 1).\n        :return: bool, True if the heading is successfully added, False otherwise.\n        \"\"\"\n\n        try:\n            doc = Document(self.file_path)\n            doc.add_heading(heading, level)\n            doc.save(self.file_path)\n            return True\n        except:\n            return False\n\n    def add_table(self, data):\n        \"\"\"\n        Adds a table to the Word document with the specified data.\n        :param data: list of lists, the data to populate the table.\n        :return: bool, True if the table is successfully added, False otherwise.\n        \"\"\"\n\n        try:\n            doc = Document(self.file_path)\n            table = doc.add_table(rows=len(data), cols=len(data[0]))\n            for i, row in enumerate(data):\n                for j, cell_value in enumerate(row):\n                    table.cell(i, j).text = str(cell_value)\n            doc.save(self.file_path)\n            return True\n        except:\n            return False\n\n    def _get_alignment_value(self, alignment):\n        \"\"\"\n        Returns the alignment value corresponding to the given alignment string.\n        :param alignment: str, the alignment string ('left', 'center', or 'right').\n        :return: int, the alignment value.\n        \"\"\"\n\n        alignment_options = {\n            'left': WD_PARAGRAPH_ALIGNMENT.LEFT,\n            'center': WD_PARAGRAPH_ALIGNMENT.CENTER,\n            'right': WD_PARAGRAPH_ALIGNMENT.RIGHT\n        }\n        return alignment_options.get(alignment.lower(), WD_PARAGRAPH_ALIGNMENT.LEFT)",
        "annotated_code" : "from docx import Document\nfrom docx.shared import Pt\nfrom docx.enum.text import WD_PARAGRAPH_ALIGNMENT\n\nclass DocFileHandler:\n\n    \"\"\"\n    This is a class that handles Word documents and provides functionalities for reading, writing, and modifying the content of Word documents.\n    \"\"\"\n\n    def __init__(self, file_path):\n        \"\"\"\n        Initializes the DocFileHandler object with the specified file path.\n        :param file_path: str, the path to the Word document file.\n        \"\"\"\n        self.file_path = file_path\n\n    def read_text(self):\n        \"\"\"\n        Reads the content of a Word document and returns it as a string.\n        :return: str, the content of the Word document.\n        \"\"\"\n \n        # Use the Document constructor to store the file at file_path as a Document object.\n        doc = Document(self.file_path)\n\n        text = []\n\n        # Iterate through the paragraphs in the document and append their text to the text list.\n        for paragraph in doc.paragraphs:\n            text.append(paragraph.text)\n        \n        # Join the list of strings into a single string with newline characters separating each paragraph and return it.\n        return \"\n\".join(text)\n\n    def write_text(self, content, font_size=12, alignment='left'):\n        \"\"\"\n        Writes the specified content to a Word document.\n        :param content: str, the text content to write.\n        :param font_size: int, optional, the font size of the text (default is 12).\n        :param alignment: str, optional, the alignment of the text ('left', 'center', or 'right'; default is 'left').\n        :return: bool, True if the write operation is successful, False otherwise.\n        \"\"\"\n\n        try:\n            # Use the Document constructor to create a new document.\n            doc = Document()\n\n            # Use the add_paragraph function to add a new paragraph to the document.\n            paragraph = doc.add_paragraph()\n\n            # Use the add_run function to add a new run to the paragraph with the specified content.\n            run = paragraph.add_run(content)\n\n            # Use the Pt constructor to set the font size of the run.\n            font = run.font\n            font.size = Pt(font_size)\n\n            # Use the _get_alignment_value class method to get the alignment value based on the specified alignment.\n            alignment_value = self._get_alignment_value(alignment)\n\n            # Set the alignment of the paragraph to the alignment value.\n            paragraph.alignment = alignment_value\n\n            # Use the save function to save the document to the specified file path.\n            doc.save(self.file_path)\n\n            # Return True to indicate that the write operation was successful.\n            return True\n        except:\n            # If an exception occurs, return False.\n            return False\n\n    def add_heading(self, heading, level=1):\n        \"\"\"\n        Adds a heading to the Word document.\n        :param heading: str, the text of the heading.\n        :param level: int, optional, the level of the heading (1, 2, 3, etc.; default is 1).\n        :return: bool, True if the heading is successfully added, False otherwise.\n        \"\"\"\n\n        try:\n            # Use the Document constructor to store the file at file_path as a Document object.\n            doc = Document(self.file_path)\n\n            # Use the add_heading function to add the heading to the document at the specified level.\n            doc.add_heading(heading, level)\n\n            # Use the save function to save the document to the specified file path.\n            doc.save(self.file_path)\n\n            # Return True to indicate that the heading was successfully added.\n            return True\n        except:\n            # If an exception occurs, return False.\n            return False\n\n    def add_table(self, data):\n        \"\"\"\n        Adds a table to the Word document with the specified data.\n        :param data: list of lists, the data to populate the table.\n        :return: bool, True if the table is successfully added, False otherwise.\n        \"\"\"\n\n        try:\n            # Use the Document constructor to store the file at file_path as a Document object.\n            doc = Document(self.file_path)\n\n            # Use the add_table function to create a new table with the specified number of rows and columns in data.\n            table = doc.add_table(rows=len(data), cols=len(data[0]))\n\n            # Iterate through the data and populate the table cells text with the corresponding cell values in data.\n            for i, row in enumerate(data):\n                for j, cell_value in enumerate(row):\n                    table.cell(i, j).text = str(cell_value)\n            \n            # Use the save function to save the document to the specified file path.\n            doc.save(self.file_path)\n\n            # Return True to indicate that the table was successfully added.\n            return True\n        except:\n            # If an exception occurs, return False.\n            return False\n\n    def _get_alignment_value(self, alignment):\n        \"\"\"\n        Returns the alignment value corresponding to the given alignment string.\n        :param alignment: str, the alignment string ('left', 'center', or 'right').\n        :return: int, the alignment value.\n        \"\"\"\n\n        # Define a dictionary mapping alignment strings to their corresponding alignment values.\n        alignment_options = {\n            'left': WD_PARAGRAPH_ALIGNMENT.LEFT,\n            'center': WD_PARAGRAPH_ALIGNMENT.CENTER,\n            'right': WD_PARAGRAPH_ALIGNMENT.RIGHT\n        }\n\n        # Return the alignment value corresponding to the given alignment string, defaulting to left alignment if not found.\n        return alignment_options.get(alignment.lower(), WD_PARAGRAPH_ALIGNMENT.LEFT)"
    },
    {
        "id" : "35",
        "code" : "class EightPuzzle:\n\n    \"\"\"\n    This class is an implementation of the classic 8-puzzle game, including methods for finding the blank tile, making moves, getting possible moves, and solving the puzzle using a breadth-first search algorithm.\n    \"\"\"\n\n    def __init__(self, initial_state):\n        \"\"\"\n        Initializing the initial state of Eight Puzzle Game, stores in attribute self.initial_state.\n        And set the goal state of this game, stores in self.goal_state. In this case, set the size as 3*3\n        :param initial_state: a 3*3 size list of Integer, stores the initial state\n        \"\"\"\n        self.initial_state = initial_state\n        self.goal_state = [[1, 2, 3], [4, 5, 6], [7, 8, 0]]\n\n    def find_blank(self, state):\n        \"\"\"\n        Find the blank position of current state, which is the 0 element.\n        :param state: a 3*3 size list of Integer, stores the current state.\n        :return i, j: two Integers, represent the coordinate of the blank block.\n        >>> eightPuzzle = EightPuzzle([[2, 3, 4], [5, 8, 1], [6, 0, 7]])\n        >>> eightPuzzle.find_blank([[2, 3, 4], [5, 8, 1], [6, 0, 7]])\n        (2, 1)\n        \"\"\"\n\n        for i in range(3):\n            for j in range(3):\n                if state[i][j] == 0:\n                    return i, j\n\n    def move(self, state, direction):\n        \"\"\"\n        Find the blank block, then makes the board moves forward the given direction.\n        :param state: a 3*3 size list of Integer, stores the state before moving.\n        :param direction: str, only has 4 direction 'up', 'down', 'left', 'right'\n        :return new_state: a 3*3 size list of Integer, stores the state after moving.\n        >>> eightPuzzle.move([[2, 3, 4], [5, 8, 1], [6, 0, 7]], 'left')\n        [[2, 3, 4], [5, 8, 1], [0, 6, 7]]\n        \"\"\"\n\n        i, j = self.find_blank(state)\n        new_state = [row[:] for row in state]\n        if direction == 'up':\n            new_state[i][j], new_state[i - 1][j] = new_state[i - 1][j], new_state[i][j]\n        elif direction == 'down':\n            new_state[i][j], new_state[i + 1][j] = new_state[i + 1][j], new_state[i][j]\n        elif direction == 'left':\n            new_state[i][j], new_state[i][j - 1] = new_state[i][j - 1], new_state[i][j]\n        elif direction == 'right':\n            new_state[i][j], new_state[i][j + 1] = new_state[i][j + 1], new_state[i][j]\n\n        return new_state\n\n    def get_possible_moves(self, state):\n        \"\"\"\n        According the current state, find all the possible moving directions. Only has 4 direction 'up', 'down', 'left', 'right'.\n        :param state: a 3*3 size list of Integer, stores the current state.\n        :return moves: a list of str, store all the possible moving directions according to the current state.\n        >>> eightPuzzle.get_possible_moves([[2, 3, 4], [5, 8, 1], [6, 0, 7]])\n        ['up', 'left', 'right']\n        \"\"\"\n\n        moves = []\n        i, j = self.find_blank(state)\n        if i > 0:\n            moves.append('up')\n        if i < 2:\n            moves.append('down')\n        if j > 0:\n            moves.append('left')\n        if j < 2:\n            moves.append('right')\n        return moves\n\n    def solve(self):\n        \"\"\"\n        Use BFS algorithm to find the path solution which makes the initial state to the goal method.\n        Maintain a list as a queue, named as open_list, append the initial state.\n        Always visit and pop the 0 index element, invoke get_possible_moves method find all the possible directions.\n        Traversal the possible_moves list and invoke move method to get several new states.Then append them.\n        redo the above steps until the open_list is empty or the state has changed to the goal state.\n        :return path: list of str, the solution to the goal state.\n        >>> eightPuzzle = EightPuzzle([[1, 2, 3], [4, 5, 6], [7, 0, 8]])\n        >>> eightPuzzle.solve()\n        ['right']\n        \"\"\"\n\n        open_list = [(self.initial_state, [])]\n        closed_list = []\n        while open_list:\n            current_state, path = open_list.pop(0)\n            closed_list.append(current_state)\n            if current_state == self.goal_state:\n                return path\n            for move in self.get_possible_moves(current_state):\n                new_state = self.move(current_state, move)\n                if new_state not in closed_list:\n                    open_list.append((new_state, path + [move]))\n\n        return None",
        "annotated_code" : "class EightPuzzle:\n\n    \"\"\"\n    This class is an implementation of the classic 8-puzzle game, including methods for finding the blank tile, making moves, getting possible moves, and solving the puzzle using a breadth-first search algorithm.\n    \"\"\"\n\n    def __init__(self, initial_state):\n        \"\"\"\n        Initializing the initial state of Eight Puzzle Game, stores in attribute self.initial_state.\n        And set the goal state of this game, stores in self.goal_state. In this case, set the size as 3*3\n        :param initial_state: a 3*3 size list of Integer, stores the initial state\n        \"\"\"\n        self.initial_state = initial_state\n        self.goal_state = [[1, 2, 3], [4, 5, 6], [7, 8, 0]]\n\n    def find_blank(self, state):\n        \"\"\"\n        Find the blank position of current state, which is the 0 element.\n        :param state: a 3*3 size list of Integer, stores the current state.\n        :return i, j: two Integers, represent the coordinate of the blank block.\n        >>> eightPuzzle = EightPuzzle([[2, 3, 4], [5, 8, 1], [6, 0, 7]])\n        >>> eightPuzzle.find_blank([[2, 3, 4], [5, 8, 1], [6, 0, 7]])\n        (2, 1)\n        \"\"\"\n\n        # Iterate through the 3*3 grid state to find the blank tile (0) and return the coordinates of it\n        for i in range(3):\n            for j in range(3):\n                if state[i][j] == 0:\n                    return i, j\n\n    def move(self, state, direction):\n        \"\"\"\n        Find the blank block, then makes the board moves forward the given direction.\n        :param state: a 3*3 size list of Integer, stores the state before moving.\n        :param direction: str, only has 4 direction 'up', 'down', 'left', 'right'\n        :return new_state: a 3*3 size list of Integer, stores the state after moving.\n        >>> eightPuzzle.move([[2, 3, 4], [5, 8, 1], [6, 0, 7]], 'left')\n        [[2, 3, 4], [5, 8, 1], [0, 6, 7]]\n        \"\"\"\n\n        # Use the find_blank class method to find the coordinates of the blank tile in state\n        i, j = self.find_blank(state)\n\n        # Create a new state by copying the current state\n        new_state = [row[:] for row in state]\n\n        # Move the blank tile in the specified direction\n        if direction == 'up':\n            new_state[i][j], new_state[i - 1][j] = new_state[i - 1][j], new_state[i][j]\n        elif direction == 'down':\n            new_state[i][j], new_state[i + 1][j] = new_state[i + 1][j], new_state[i][j]\n        elif direction == 'left':\n            new_state[i][j], new_state[i][j - 1] = new_state[i][j - 1], new_state[i][j]\n        elif direction == 'right':\n            new_state[i][j], new_state[i][j + 1] = new_state[i][j + 1], new_state[i][j]\n\n        # Return the new state after the move\n        return new_state\n\n    def get_possible_moves(self, state):\n        \"\"\"\n        According the current state, find all the possible moving directions. Only has 4 direction 'up', 'down', 'left', 'right'.\n        :param state: a 3*3 size list of Integer, stores the current state.\n        :return moves: a list of str, store all the possible moving directions according to the current state.\n        >>> eightPuzzle.get_possible_moves([[2, 3, 4], [5, 8, 1], [6, 0, 7]])\n        ['up', 'left', 'right']\n        \"\"\"\n\n        moves = []\n\n        # Use the find_blank class method to find the coordinates of the blank tile in state\n        i, j = self.find_blank(state)\n\n        # Add the possible moves based on the position of the blank tile\n        if i > 0:\n            # If the blank tile is not in the first row, it can move up so add it\n            moves.append('up')\n        if i < 2:\n            # If the blank tile is not in the last row, it can move down so add it\n            moves.append('down')\n        if j > 0:\n            # If the blank tile is not in the first column, it can move left so add it\n            moves.append('left')\n        if j < 2:\n            # If the blank tile is not in the last column, it can move right so add it\n            moves.append('right')\n\n        # Return the list of possible moves\n        return moves\n\n    def solve(self):\n        \"\"\"\n        Use BFS algorithm to find the path solution which makes the initial state to the goal method.\n        Maintain a list as a queue, named as open_list, append the initial state.\n        Always visit and pop the 0 index element, invoke get_possible_moves method find all the possible directions.\n        Traversal the possible_moves list and invoke move method to get several new states.Then append them.\n        redo the above steps until the open_list is empty or the state has changed to the goal state.\n        :return path: list of str, the solution to the goal state.\n        >>> eightPuzzle = EightPuzzle([[1, 2, 3], [4, 5, 6], [7, 0, 8]])\n        >>> eightPuzzle.solve()\n        ['right']\n        \"\"\"\n\n        # Initialize the open list with the initial state and an empty path\n        # Initialize the closed list to keep track of visited states\n        open_list = [(self.initial_state, [])]\n        closed_list = []\n\n        # While there are state, path tuples in the open list, continue searching for a solution\n        while open_list:\n\n            # Pop the first state and path from the open list and add the state to the closed list\n            current_state, path = open_list.pop(0)\n            closed_list.append(current_state)\n\n            # If the current state is the goal state, return the path taken to reach it\n            if current_state == self.goal_state:\n                return path\n\n            # Use the get_possible_moves class method to iterate through all possible moves from the current state\n            for move in self.get_possible_moves(current_state):\n                # Use the move class method to get the new state after making the move\n                new_state = self.move(current_state, move)\n\n                # If the new state has not been visited yet, add it to the open list with the updated path\n                if new_state not in closed_list:\n                    open_list.append((new_state, path + [move]))\n\n        # If no solution is found, return None\n        return None"
    },
    {
        "id" : "36",
        "code" : "from datetime import datetime\n\nclass EmailClient:\n\n    \"\"\"\n    This is a class that serves as an email client, implementing functions such as checking emails, determining whether there is sufficient space, and cleaning up space\n    \"\"\"\n\n    def __init__(self, addr, capacity) -> None:\n        \"\"\"\n        Initializes the EmailClient class with the email address and the capacity of the email box.\n        :param addr: The email address, str.\n        :param capacity: The capacity of the email box, float.\n        \"\"\"\n        self.addr = addr\n        self.capacity = capacity\n        self.inbox = []\n\n    def send_to(self, recv, content, size):\n        \"\"\"\n        Sends an email to the given email address.\n        :param recv: The email address of the receiver, str.\n        :param content: The content of the email, str.\n        :param size: The size of the email, float.\n        :return: True if the email is sent successfully, False if the receiver's email box is full.\n        >>> sender = EmailClient('sender@example.com', 100)\n        >>> receiver = EmailClient('receiver@example.com', 50)\n        >>> sender.send_to(receiver, 'Hello', 10)\n        True\n        >>> receiver.inbox\n        {'sender': 'sender@example.com', 'receiver': 'receiver@example.com', 'content': 'Hello', 'size': 10, 'time': '2023-07-13 11:36:40', 'state': 'unread'}\n\n        \"\"\"\n\n        if not recv.is_full_with_one_more_email(size):\n            timestamp = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n            email = {\n                \"sender\": self.addr,\n                \"receiver\": recv.addr,\n                \"content\": content,\n                \"size\": size,\n                \"time\": timestamp,\n                \"state\": \"unread\"\n            }\n            recv.inbox.append(email)\n            return True\n        else:\n            self.clear_inbox(size)\n            return False\n\n    def fetch(self):\n        \"\"\"\n        Retrieves the first unread email in the email box and marks it as read.\n        :return: The first unread email in the email box, dict.\n        >>> sender = EmailClient('sender@example.com', 100)\n        >>> receiver = EmailClient('receiver@example.com', 50)\n        >>> receiver.inbox = [{'sender': 'sender@example.com', 'receiver': 'receiver@example.com', 'content': 'Hello', 'size': 10, 'time': '2023-07-13 11:36:40', 'state': 'unread'}]\n        >>> receiver.fetch()\n        {'sender': 'sender@example.com', 'receiver': 'receiver@example.com', 'content': 'Hello', 'size': 10, 'time': '2023-07-13 11:36:40', 'state': 'read'}\n\n        \"\"\"\n\n        if len(self.inbox) == 0:\n            return None\n        for i in range(len(self.inbox)):\n            if self.inbox[i]['state'] == \"unread\":\n                self.inbox[i]['state'] = \"read\"\n                return self.inbox[i]\n        return None\n\n    def is_full_with_one_more_email(self, size):\n        \"\"\"\n        Determines whether the email box is full after adding an email of the given size.\n        :param size: The size of the email, float.\n        :return: True if the email box is full, False otherwise.\n        >>> sender = EmailClient('sender@example.com', 100)\n        >>> receiver = EmailClient('receiver@example.com', 50)\n        >>> receiver.is_full_with_one_more_email(10)\n        False\n\n        \"\"\"\n\n        occupied_size = self.get_occupied_size()\n        return True if occupied_size + size > self.capacity else False\n\n    def get_occupied_size(self):\n        \"\"\"\n        Gets the total size of the emails in the email box.\n        :return: The total size of the emails in the email box, float.\n        >>> sender = EmailClient('sender@example.com', 100)\n        >>> receiver = EmailClient('receiver@example.com', 50)\n        >>> sender.inbox = [{'sender': 'sender@example.com', 'receiver': 'receiver@example.com', 'content': 'Hello', 'size': 10, 'time': datetime.now, 'state': 'unread'}]\n        >>> sender.get_occupied_size()\n        10\n\n        \"\"\"\n\n        occupied_size = 0\n        for email in self.inbox:\n            occupied_size += email[\"size\"]\n        return occupied_size\n\n    def clear_inbox(self, size):\n        \"\"\"\n        Clears the email box by deleting the oldest emails until the email box has enough space to accommodate the given size.\n        :param size: The size of the email, float.\n        >>> sender = EmailClient('sender@example.com', 100)\n        >>> receiver = EmailClient('receiver@example.com', 50)\n        >>> receiver.inbox = [{'size': 10},{'size': 20},{'size': 15}]\n        >>> receiver.clear_inbox(30)\n        >>> receiver.inbox\n        [{'size': 15}]\n\n        \"\"\"\n\n        if len(self.addr) == 0:\n            return\n        freed_space = 0\n        while freed_space < size and self.inbox:\n            email = self.inbox[0]\n            freed_space += email['size']\n            del self.inbox[0]",
        "annotated_code" : "from datetime import datetime\n\nclass EmailClient:\n\n    \"\"\"\n    This is a class that serves as an email client, implementing functions such as checking emails, determining whether there is sufficient space, and cleaning up space\n    \"\"\"\n\n    def __init__(self, addr, capacity) -> None:\n        \"\"\"\n        Initializes the EmailClient class with the email address and the capacity of the email box.\n        :param addr: The email address, str.\n        :param capacity: The capacity of the email box, float.\n        \"\"\"\n        self.addr = addr\n        self.capacity = capacity\n        self.inbox = []\n\n    def send_to(self, recv, content, size):\n        \"\"\"\n        Sends an email to the given email address.\n        :param recv: The email address of the receiver, str.\n        :param content: The content of the email, str.\n        :param size: The size of the email, float.\n        :return: True if the email is sent successfully, False if the receiver's email box is full.\n        >>> sender = EmailClient('sender@example.com', 100)\n        >>> receiver = EmailClient('receiver@example.com', 50)\n        >>> sender.send_to(receiver, 'Hello', 10)\n        True\n        >>> receiver.inbox\n        {'sender': 'sender@example.com', 'receiver': 'receiver@example.com', 'content': 'Hello', 'size': 10, 'time': '2023-07-13 11:36:40', 'state': 'unread'}\n\n        \"\"\"\n\n        # Use the is_full_with_one_more_email class method to check if the receiver's inbox is full after adding the email with the specified size\n        if not recv.is_full_with_one_more_email(size):\n            # If it's not full after adding the email, create the email and add it to the receiver's inbox\n            # Use the datetime.now().strftime function to get the current timestamp in the \"%Y-%m-%d %H:%M:%S\" format\n            timestamp = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n            email = {\n                \"sender\": self.addr,\n                \"receiver\": recv.addr,\n                \"content\": content,\n                \"size\": size,\n                \"time\": timestamp,\n                \"state\": \"unread\"\n            }\n            recv.inbox.append(email)\n\n            # Return True to indicate that the email was sent successfully\n            return True\n        else:\n            # If the inbox is full after adding the email, use the clear_inbox class method to free up enough space\n            self.clear_inbox(size)\n\n            # Return False to indicate that the email was not sent successfully\n            return False\n\n    def fetch(self):\n        \"\"\"\n        Retrieves the first unread email in the email box and marks it as read.\n        :return: The first unread email in the email box, dict.\n        >>> sender = EmailClient('sender@example.com', 100)\n        >>> receiver = EmailClient('receiver@example.com', 50)\n        >>> receiver.inbox = [{'sender': 'sender@example.com', 'receiver': 'receiver@example.com', 'content': 'Hello', 'size': 10, 'time': '2023-07-13 11:36:40', 'state': 'unread'}]\n        >>> receiver.fetch()\n        {'sender': 'sender@example.com', 'receiver': 'receiver@example.com', 'content': 'Hello', 'size': 10, 'time': '2023-07-13 11:36:40', 'state': 'read'}\n\n        \"\"\"\n\n        # If the inbox is empty, return None\n        if len(self.inbox) == 0:\n            return None\n        \n        # Iterate through the inbox and find the first unread email\n        for i in range(len(self.inbox)):\n            if self.inbox[i]['state'] == \"unread\":\n                # Mark the email as read and return it\n                self.inbox[i]['state'] = \"read\"\n                return self.inbox[i]\n\n        # If no unread email is found, return None\n        return None\n\n    def is_full_with_one_more_email(self, size):\n        \"\"\"\n        Determines whether the email box is full after adding an email of the given size.\n        :param size: The size of the email, float.\n        :return: True if the email box is full, False otherwise.\n        >>> sender = EmailClient('sender@example.com', 100)\n        >>> receiver = EmailClient('receiver@example.com', 50)\n        >>> receiver.is_full_with_one_more_email(10)\n        False\n\n        \"\"\"\n\n        # Use the get_occupied_size class method to get the occupied size\n        occupied_size = self.get_occupied_size()\n\n        # Return True if adding an email with the given size would exceed the capacity, otherwise return False\n        return True if occupied_size + size > self.capacity else False\n\n    def get_occupied_size(self):\n        \"\"\"\n        Gets the total size of the emails in the email box.\n        :return: The total size of the emails in the email box, float.\n        >>> sender = EmailClient('sender@example.com', 100)\n        >>> receiver = EmailClient('receiver@example.com', 50)\n        >>> sender.inbox = [{'sender': 'sender@example.com', 'receiver': 'receiver@example.com', 'content': 'Hello', 'size': 10, 'time': datetime.now, 'state': 'unread'}]\n        >>> sender.get_occupied_size()\n        10\n\n        \"\"\"\n\n        occupied_size = 0\n\n        # Iterate through the inbox and sum up the size of each email\n        for email in self.inbox:\n            occupied_size += email[\"size\"]\n        \n        # Return the total size of the emails in the inbox\n        return occupied_size\n\n    def clear_inbox(self, size):\n        \"\"\"\n        Clears the email box by deleting the oldest emails until the email box has enough space to accommodate the given size.\n        :param size: The size of the email, float.\n        >>> sender = EmailClient('sender@example.com', 100)\n        >>> receiver = EmailClient('receiver@example.com', 50)\n        >>> receiver.inbox = [{'size': 10},{'size': 20},{'size': 15}]\n        >>> receiver.clear_inbox(30)\n        >>> receiver.inbox\n        [{'size': 15}]\n\n        \"\"\"\n\n        # If the address is empty, return\n        if len(self.addr) == 0:\n            return\n        \n        freed_space = 0\n\n        # Delete the oldest email until size amount of space is freed up or the inbox is empty\n        while freed_space < size and self.inbox:\n            email = self.inbox[0]\n\n            # Add the size of the email to the freed space\n            freed_space += email['size']\n\n            # Delete the email from the inbox\n            del self.inbox[0]"
    },
    {
        "id" : "37",
        "code" : "class EncryptionUtils:\n\n    \"\"\"\n    This is a class that provides methods for encryption, including the Caesar cipher, Vigenere cipher, and Rail Fence cipher.\n    \"\"\"\n\n    def __init__(self, key):\n        \"\"\"\n        Initializes the class with a key.\n        :param key: The key to use for encryption, str.\n        \"\"\"\n        self.key = key\n\n    def caesar_cipher(self, plaintext, shift):\n        \"\"\"\n        Encrypts the plaintext using the Caesar cipher.\n        :param plaintext: The plaintext to encrypt, str.\n        :param shift: The number of characters to shift each character in the plaintext, int.\n        :return: The ciphertext, str.\n        >>> e = EncryptionUtils(\"key\")\n        >>> e.caesar_cipher(\"abc\", 1)\n        'bcd'\n\n        \"\"\"\n\n        ciphertext = \"\"\n        for char in plaintext:\n            if char.isalpha():\n                if char.isupper():\n                    ascii_offset = 65\n                else:\n                    ascii_offset = 97\n                shifted_char = chr((ord(char) - ascii_offset + shift) % 26 + ascii_offset)\n                ciphertext += shifted_char\n            else:\n                ciphertext += char\n        return ciphertext\n\n    def vigenere_cipher(self, plaintext):\n        \"\"\"\n        Encrypts the plaintext using the Vigenere cipher.\n        :param plaintext: The plaintext to encrypt, str.\n        :return: The ciphertext, str.\n        >>> e = EncryptionUtils(\"key\")\n        >>> e.vigenere_cipher(\"abc\")\n        'kfa'\n\n        \"\"\"\n\n        encrypted_text = \"\"\n        key_index = 0\n        for char in plaintext:\n            if char.isalpha():\n                shift = ord(self.key[key_index % len(self.key)].lower()) - ord('a')\n                encrypted_char = chr((ord(char.lower()) - ord('a') + shift) % 26 + ord('a'))\n                encrypted_text += encrypted_char.upper() if char.isupper() else encrypted_char\n                key_index += 1\n            else:\n                encrypted_text += char\n        return encrypted_text\n\n    def rail_fence_cipher(self,plain_text, rails):\n        \"\"\"\n        Encrypts the plaintext using the Rail Fence cipher.\n        :param plaintext: The plaintext to encrypt, str.\n        :return: The ciphertext, str.\n        >>> e = EncryptionUtils(\"key\")\n        >>> e.rail_fence_cipher(\"abc\", 2)\n        'acb'\n\n        \"\"\"\n\n        fence = [['\n' for _ in range(len(plain_text))] for _ in range(rails)]\n        direction = -1\n        row, col = 0, 0\n\n        for char in plain_text:\n            if row == 0 or row == rails-1:\n                direction = -direction\n            fence[row][col] = char\n            col += 1\n            row += direction\n\n        encrypted_text = ''\n        for i in range(rails):\n            for j in range(len(plain_text)):\n                if fence[i][j] != '\n':\n                    encrypted_text += fence[i][j]\n        return encrypted_text",
        "annotated_code" : "class EncryptionUtils:\n\n    \"\"\"\n    This is a class that provides methods for encryption, including the Caesar cipher, Vigenere cipher, and Rail Fence cipher.\n    \"\"\"\n\n    def __init__(self, key):\n        \"\"\"\n        Initializes the class with a key.\n        :param key: The key to use for encryption, str.\n        \"\"\"\n        self.key = key\n\n    def caesar_cipher(self, plaintext, shift):\n        \"\"\"\n        Encrypts the plaintext using the Caesar cipher.\n        :param plaintext: The plaintext to encrypt, str.\n        :param shift: The number of characters to shift each character in the plaintext, int.\n        :return: The ciphertext, str.\n        >>> e = EncryptionUtils(\"key\")\n        >>> e.caesar_cipher(\"abc\", 1)\n        'bcd'\n\n        \"\"\"\n\n        ciphertext = \"\"\n\n        # Iterate through each character in the plaintext\n        for char in plaintext:\n            if char.isalpha():\n                # If the character is an uppercase letter, set the ASCII offset to 65\n                # If the character is a lowercase letter, set the ASCII offset to 97\n                if char.isupper():\n                    ascii_offset = 65\n                else:\n                    ascii_offset = 97\n                \n                # Generate the shifted character using the ASCII offset and the provided shift value\n                shifted_char = chr((ord(char) - ascii_offset + shift) % 26 + ascii_offset)\n\n                # Append the shifted character to the ciphertext\n                ciphertext += shifted_char\n            else:\n                # If the character is not a letter, append it unchanged to the ciphertext\n                ciphertext += char\n\n        # Return the final ciphertext\n        return ciphertext\n\n    def vigenere_cipher(self, plaintext):\n        \"\"\"\n        Encrypts the plaintext using the Vigenere cipher.\n        :param plaintext: The plaintext to encrypt, str.\n        :return: The ciphertext, str.\n        >>> e = EncryptionUtils(\"key\")\n        >>> e.vigenere_cipher(\"abc\")\n        'kfa'\n\n        \"\"\"\n\n        encrypted_text = \"\"\n        key_index = 0\n\n        # Iterate through each character in the plaintext\n        for char in plaintext:\n            if char.isalpha():\n                # If the character is a letter, calculate the shift based on the character in the key at key_index\n                shift = ord(self.key[key_index % len(self.key)].lower()) - ord('a')\n\n                # Generate the encrypted character using the calculated shift\n                encrypted_char = chr((ord(char.lower()) - ord('a') + shift) % 26 + ord('a'))\n\n                # Append the encrypted character to the encrypted ciphertext, preserving the case of the original character\n                encrypted_text += encrypted_char.upper() if char.isupper() else encrypted_char\n\n                # Increment the key_index for the next character\n                key_index += 1\n            else:\n                # If the character is not a letter, append it unchanged to the encrypted ciphertext\n                encrypted_text += char\n        \n        # Return the final encrypted ciphertext\n        return encrypted_text\n\n    def rail_fence_cipher(self,plain_text, rails):\n        \"\"\"\n        Encrypts the plaintext using the Rail Fence cipher.\n        :param plaintext: The plaintext to encrypt, str.\n        :return: The ciphertext, str.\n        >>> e = EncryptionUtils(\"key\")\n        >>> e.rail_fence_cipher(\"abc\", 2)\n        'acb'\n\n        \"\"\"\n\n        # Create a fence with new line characters that has dimensions rails x len(plain_text)\n        fence = [['\n' for _ in range(len(plain_text))] for _ in range(rails)]\n        direction = -1\n        row, col = 0, 0\n\n        # Loop through each character in the plain_text\n        for char in plain_text:\n\n            # Change direction when reaching the top or bottom rail\n            if row == 0 or row == rails-1:\n                direction = -direction\n\n            # Place the current character at the current row and column in the fence\n            fence[row][col] = char\n\n            # Move to the next column and row\n            col += 1\n            row += direction\n\n        encrypted_text = ''\n\n        # Iterate through the fence to create the encrypted text\n        for i in range(rails):\n            for j in range(len(plain_text)):\n                if fence[i][j] != '\n':\n                    # If the character in the fence is not a new line, append it to the encrypted text\n                    encrypted_text += fence[i][j]\n        \n        # Return the final encrypted text\n        return encrypted_text"
    },
    {
        "id" : "38",
        "code" : "import openpyxl\n\nclass ExcelProcessor:\n\n    \"\"\"\n    This is a class for processing excel files, including readring and writing excel data, as well as processing specific operations and saving as a new excel file.\n    \"\"\"\n\n    def __init__(self):\n        pass\n\n    def read_excel(self, file_name):\n        \"\"\"\n        Reading data from Excel files\n        :param file_name:str, Excel file name to read\n        :return:list of data, Data in Excel\n        \"\"\"\n\n        data = []\n        try:\n            workbook = openpyxl.load_workbook(file_name)\n            sheet = workbook.active\n            for row in sheet.iter_rows(values_only=True):\n                data.append(row)\n            workbook.close()\n            return data\n        except:\n            return None\n\n\n    def write_excel(self, data, file_name):\n        \"\"\"\n        Write data to the specified Excel file\n        :param data: list, Data to be written\n        :param file_name: str, Excel file name to write to\n        :return: 0 or 1, 1 represents successful writing, 0 represents failed writing\n        >>> processor = ExcelProcessor()\n        >>> new_data = [\n        >>>     ('Name', 'Age', 'Country'),\n        >>>     ('John', 25, 'USA'),\n        >>>     ('Alice', 30, 'Canada'),\n        >>>     ('Bob', 35, 'Australia'),\n        >>>     ('Julia', 28, 'Germany')\n        >>> ]\n        >>> data = processor.write_excel(new_data, 'test_data.xlsx')\n        \"\"\"\n\n        try:\n            workbook = openpyxl.Workbook()\n            sheet = workbook.active\n            for row in data:\n                sheet.append(row)\n            workbook.save(file_name)\n            workbook.close()\n            return 1\n        except:\n            return 0\n\n\n    def process_excel_data(self, N, save_file_name):\n        \"\"\"\n        Change the specified column in the Excel file to uppercase\n        :param N: int, The serial number of the column that want to change\n        :param save_file_name: str, source file name\n        :return:(int, str), The former is the return value of write_excel, while the latter is the saved file name of the processed data\n        >>> processor = ExcelProcessor()\n        >>> success, output_file = processor.process_excel_data(1, 'test_data.xlsx')\n        \"\"\"\n\n        data = self.read_excel(save_file_name)\n        if data is None or N >= len(data[0]):\n            return 0\n        \n        new_data = []\n        for row in data:\n            new_row = list(row[:])\n            if not str(row[N]).isdigit():\n                new_row.append(str(row[N]).upper())\n            else:\n                new_row.append(row[N])\n            new_data.append(new_row)\n        new_file_name = save_file_name.split('.')[0] + '_process.xlsx'\n        success = self.write_excel(new_data, new_file_name)\n        return success, new_file_name",
        "annotated_code" : "import openpyxl\n\nclass ExcelProcessor:\n\n    \"\"\"\n    This is a class for processing excel files, including readring and writing excel data, as well as processing specific operations and saving as a new excel file.\n    \"\"\"\n\n    def __init__(self):\n        pass\n\n    def read_excel(self, file_name):\n        \"\"\"\n        Reading data from Excel files\n        :param file_name:str, Excel file name to read\n        :return:list of data, Data in Excel\n        \"\"\"\n\n        data = []\n        try:\n            # Use the load_workbook function from openpyxl to load the Excel file as a Workbook object\n            workbook = openpyxl.load_workbook(file_name)\n\n            # Use the active property of the Workbook object to get the active worksheet\n            sheet = workbook.active\n\n            # Use the iter_rows method of the Worksheet object to iterate through the rows of the worksheet\n            for row in sheet.iter_rows(values_only=True):\n\n                # Append the values of each row to the data list\n                data.append(row)\n            \n            # Use the close function to close the workbook\n            workbook.close()\n\n            # Return the data list\n            return data\n        except:\n            # If an error occurs, return None\n            return None\n\n\n    def write_excel(self, data, file_name):\n        \"\"\"\n        Write data to the specified Excel file\n        :param data: list, Data to be written\n        :param file_name: str, Excel file name to write to\n        :return: 0 or 1, 1 represents successful writing, 0 represents failed writing\n        >>> processor = ExcelProcessor()\n        >>> new_data = [\n        >>>     ('Name', 'Age', 'Country'),\n        >>>     ('John', 25, 'USA'),\n        >>>     ('Alice', 30, 'Canada'),\n        >>>     ('Bob', 35, 'Australia'),\n        >>>     ('Julia', 28, 'Germany')\n        >>> ]\n        >>> data = processor.write_excel(new_data, 'test_data.xlsx')\n        \"\"\"\n\n        try:\n            # Use the Workbook function from openpyxl to create a new Workbook object\n            workbook = openpyxl.Workbook()\n\n            # Use the active property of the Workbook object to get the active worksheet\n            sheet = workbook.active\n\n            # Iterate through the data list and append each row to the worksheet\n            for row in data:\n                sheet.append(row)\n            \n            # Use the save function to save the workbook to the specified file name\n            workbook.save(file_name)\n\n            # Use the close function to close the workbook\n            workbook.close()\n\n            # Return 1 to indicate successful writing\n            return 1\n        except:\n            # If an error occurs, return 0 to indicate failed writing\n            return 0\n\n\n    def process_excel_data(self, N, save_file_name):\n        \"\"\"\n        Change the specified column in the Excel file to uppercase\n        :param N: int, The serial number of the column that want to change\n        :param save_file_name: str, source file name\n        :return:(int, str), The former is the return value of write_excel, while the latter is the saved file name of the processed data\n        >>> processor = ExcelProcessor()\n        >>> success, output_file = processor.process_excel_data(1, 'test_data.xlsx')\n        \"\"\"\n\n        # Use the read_excel class method to read the data from the specified Excel file\n        data = self.read_excel(save_file_name)\n\n        # If the data is None or N is out of range, return 0\n        if data is None or N >= len(data[0]):\n            return 0\n        \n        new_data = []\n\n        # Iterate through the data list and process each row\n        for row in data:\n\n            # Convert the row to a list\n            new_row = list(row[:])\n\n            # If the Nth value in the row is not a digit, append it's uppercase string value to new_row\n            # Otherwise, just append the value to new_row\n            if not str(row[N]).isdigit():\n                new_row.append(str(row[N]).upper())\n            else:\n                new_row.append(row[N])\n\n            # Append the updated new_row to new_data\n            new_data.append(new_row)\n        \n        # Generate a new file name for the processed data\n        new_file_name = save_file_name.split('.')[0] + '_process.xlsx'\n\n        # Use the write_excel class method to write and save the new_data to the new_file_name\n        success = self.write_excel(new_data, new_file_name)\n\n        # Return whether the creation of the new file was a success along with the new file's name\n        return success, new_file_name"
    },
    {
        "id" : "39",
        "code" : "import re\nfrom collections import deque\nfrom decimal import Decimal\n\nclass ExpressionCalculator:\n\n    \"\"\"\n    This is a class in Python that can perform calculations with basic arithmetic operations, including addition, subtraction, multiplication, division, and modulo.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the expression calculator\n        \"\"\"\n        self.postfix_stack = deque()\n        self.operat_priority = [0, 3, 2, 1, -1, 1, 0, 2]\n\n    def calculate(self, expression):\n        \"\"\"\n        Calculate the result of the given postfix expression\n        :param expression: string, the postfix expression to be calculated\n        :return: float, the calculated result\n        >>> expression_calculator = ExpressionCalculator()\n        >>> expression_calculator.calculate(\"2 + 3 * 4\")\n        14.0\n\n        \"\"\"\n        self.prepare(self.transform(expression))\n        result_stack = deque()\n        self.postfix_stack.reverse()\n\n        while self.postfix_stack:\n            current_op = self.postfix_stack.pop()\n\n            if not self.is_operator(current_op):\n                current_op = current_op.replace(\"~\", \"-\")\n                result_stack.append(current_op)\n            else:\n                second_value = result_stack.pop()\n                first_value = result_stack.pop()\n\n                first_value = first_value.replace(\"~\", \"-\")\n                second_value = second_value.replace(\"~\", \"-\")\n\n                temp_result = self._calculate(first_value, second_value, current_op)\n                result_stack.append(str(temp_result))\n\n        return float(eval(\"*\".join(result_stack)))\n\n\n    def prepare(self, expression):\n        \"\"\"\n        Prepare the infix expression for conversion to postfix notation\n        :param expression: string, the infix expression to be prepared\n        >>> expression_calculator = ExpressionCalculator()\n        >>> expression_calculator.prepare(\"2+3*4\")\n\n        expression_calculator.postfix_stack = ['2', '3', '4', '*', '+']\n        \"\"\"\n\n        op_stack = deque([','])\n        arr = list(expression)\n\n        current_index = 0\n        count = 0\n\n        for i, current_op in enumerate(arr):\n\n            if self.is_operator(current_op):\n                if count > 0:\n                    self.postfix_stack.append(\"\".join(arr[current_index: current_index + count]))\n                \n                peek_op = op_stack[-1]\n                if current_op == ')':\n                    while op_stack[-1] != '(':\n                        self.postfix_stack.append(str(op_stack.pop()))\n                    op_stack.pop()\n                else:\n                    while current_op != '(' and peek_op != ',' and self.compare(current_op, peek_op):\n                        self.postfix_stack.append(str(op_stack.pop()))\n\n                        peek_op = op_stack[-1]\n                    \n                    op_stack.append(current_op)\n\n                count = 0\n\n                current_index = i + 1\n            else:\n                count += 1\n\n        if count > 1 or (count == 1 and not self.is_operator(arr[current_index])):\n            self.postfix_stack.append(\"\".join(arr[current_index: current_index + count]))\n\n        while op_stack[-1] != ',':\n            self.postfix_stack.append(str(op_stack.pop()))\n\n\n    @staticmethod\n    def is_operator(c):\n        \"\"\"\n        Check if a character is an operator in {'+', '-', '*', '/', '(', ')', '%'}\n        :param c: string, the character to be checked\n        :return: bool, True if the character is an operator, False otherwise\n        >>> expression_calculator = ExpressionCalculator()\n        >>> expression_calculator.is_operator(\"+\")\n        True\n\n        \"\"\"\n\n        return c in {'+', '-', '*', '/', '(', ')', '%'}\n\n\n    def compare(self, cur, peek):\n        \"\"\"\n        Compare the precedence of two operators\n        :param cur: string, the current operator\n        :param peek: string, the operator at the top of the operator stack\n        :return: bool, True if the current operator has higher or equal precedence, False otherwise\n        >>> expression_calculator = ExpressionCalculator()\n        >>> expression_calculator.compare(\"+\", \"-\")\n        True\n\n        \"\"\"\n\n        if cur == '%':\n            cur = '/'\n        if peek == '%':\n            peek = '/'\n        \n        return self.operat_priority[ord(peek) - 40] >= self.operat_priority[ord(cur) - 40]\n\n\n    @staticmethod\n    def _calculate(first_value, second_value, current_op):\n        \"\"\"\n        Perform the mathematical calculation based on the given operands and operator\n        :param first_value: string, the first operand\n        :param second_value: string, the second operand\n        :param current_op: string, the operator\n        :return: decimal.Decimal, the calculated result\n        >>> expression_calculator = ExpressionCalculator()\n        >>> expression_calculator._calculate(\"2\", \"3\", \"+\")\n        5.0\n\n        \"\"\"\n\n        if current_op == '+':\n            return Decimal(first_value) + Decimal(second_value)\n        elif current_op == '-':\n            return Decimal(first_value) - Decimal(second_value)\n        elif current_op == '*':\n            return Decimal(first_value) * Decimal(second_value)\n        elif current_op == '/':\n            return Decimal(first_value) / Decimal(second_value)\n        elif current_op == '%':\n            return Decimal(first_value) % Decimal(second_value)\n        else:\n            raise ValueError(\"Unexpected operator: {}\".format(current_op))\n\n\n    @staticmethod\n    def transform(expression):\n        \"\"\"\n        Transform the infix expression to a format suitable for conversion\n        :param expression: string, the infix expression to be transformed\n        :return: string, the transformed expression\n        >>> expression_calculator = ExpressionCalculator()\n        >>> expression_calculator.transform(\"2 + 3 * 4\")\n        \"2+3*4\"\n\n        \"\"\"\n\n        expression = re.sub(r\"\\s+\", \"\", expression)\n        expression = re.sub(r\"=$\", \"\", expression)\n        arr = list(expression)\n\n        for i, c in enumerate(arr):\n            if c == '-':\n                if i == 0:\n                    arr[i] = '~'\n                else:\n                    prev_c = arr[i - 1]\n                    if prev_c in {'+', '-', '*', '/', '(', 'E', 'e'}:\n                        arr[i] = '~'\n\n        if arr[0] == '~' and (len(arr) > 1 and arr[1] == '('):\n            arr[0] = '-'\n            return \"0\" + \"\".join(arr)\n        else:\n            return \"\".join(arr)",
        "annotated_code" : "import re\nfrom collections import deque\nfrom decimal import Decimal\n\nclass ExpressionCalculator:\n\n    \"\"\"\n    This is a class in Python that can perform calculations with basic arithmetic operations, including addition, subtraction, multiplication, division, and modulo.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the expression calculator\n        \"\"\"\n        self.postfix_stack = deque()\n        self.operat_priority = [0, 3, 2, 1, -1, 1, 0, 2]\n\n    def calculate(self, expression):\n        \"\"\"\n        Calculate the result of the given postfix expression\n        :param expression: string, the postfix expression to be calculated\n        :return: float, the calculated result\n        >>> expression_calculator = ExpressionCalculator()\n        >>> expression_calculator.calculate(\"2 + 3 * 4\")\n        14.0\n\n        \"\"\"\n        # Transform and convert to postfix\n        self.prepare(self.transform(expression))\n\n        # Stack to hold operands during evaluation\n        result_stack = deque()\n\n        # Reverse for left-to-right processing\n        self.postfix_stack.reverse()\n\n        while self.postfix_stack:\n            # Get the next token\n            current_op = self.postfix_stack.pop()\n\n            # Check if token is a number\n            if not self.is_operator(current_op):\n                # Convert '~' back to '-' for negative numbers\n                current_op = current_op.replace(\"~\", \"-\")\n                result_stack.append(current_op)\n            else:\n                # Token is an operator; pop two operands from the result stack\n                second_value = result_stack.pop()\n                first_value = result_stack.pop()\n\n                # Normalize negative signs\n                first_value = first_value.replace(\"~\", \"-\")\n                second_value = second_value.replace(\"~\", \"-\")\n\n                # Perform the operation and push result\n                temp_result = self._calculate(first_value, second_value, current_op)\n                result_stack.append(str(temp_result))\n\n        # Evaluate the final result (concatenated with '*' to force eval of a single number)\n        return float(eval(\"*\".join(result_stack)))\n\n\n    def prepare(self, expression):\n        \"\"\"\n        Prepare the infix expression for conversion to postfix notation\n        :param expression: string, the infix expression to be prepared\n        >>> expression_calculator = ExpressionCalculator()\n        >>> expression_calculator.prepare(\"2+3*4\")\n\n        expression_calculator.postfix_stack = ['2', '3', '4', '*', '+']\n        \"\"\"\n\n        # Create a stack to hold operators; ',' is a dummy base element\n        op_stack = deque([','])\n        # Convert expression to a list of characters\n        arr = list(expression)\n\n        current_index = 0\n        count = 0\n\n        # Iterate through the characters in arr\n        for i, current_op in enumerate(arr):\n\n            # Check if current_op is an operator\n            if self.is_operator(current_op):\n                if count > 0:\n                    # Append operand to postfix stack\n                    self.postfix_stack.append(\"\".join(arr[current_index: current_index + count]))\n                \n                # Peek top operator\n                peek_op = op_stack[-1]\n                if current_op == ')':\n                    # Pop operators until matching '(' is found\n                    while op_stack[-1] != '(':\n                        self.postfix_stack.append(str(op_stack.pop()))\n                    # Remove the '('\n                    op_stack.pop()\n                else:\n                    # While operator precedence condition holds, pop to postfix\n                    while current_op != '(' and peek_op != ',' and self.compare(current_op, peek_op):\n                        self.postfix_stack.append(str(op_stack.pop()))\n\n                        # Update peek\n                        peek_op = op_stack[-1]\n                    \n                    # Push current operator to stack\n                    op_stack.append(current_op)\n\n                # Reset operand length\n                count = 0\n\n                # Set new operand start\n                current_index = i + 1\n            else:\n                # Accumulate operand characters\n                count += 1\n\n        # Append the last operand if it exists\n        if count > 1 or (count == 1 and not self.is_operator(arr[current_index])):\n            self.postfix_stack.append(\"\".join(arr[current_index: current_index + count]))\n\n        # Pop remaining operators from stack to postfix\n        while op_stack[-1] != ',':\n            self.postfix_stack.append(str(op_stack.pop()))\n\n\n    @staticmethod\n    def is_operator(c):\n        \"\"\"\n        Check if a character is an operator in {'+', '-', '*', '/', '(', ')', '%'}\n        :param c: string, the character to be checked\n        :return: bool, True if the character is an operator, False otherwise\n        >>> expression_calculator = ExpressionCalculator()\n        >>> expression_calculator.is_operator(\"+\")\n        True\n\n        \"\"\"\n\n        # Return True if the character c is one of the following operators\n        return c in {'+', '-', '*', '/', '(', ')', '%'}\n\n\n    def compare(self, cur, peek):\n        \"\"\"\n        Compare the precedence of two operators\n        :param cur: string, the current operator\n        :param peek: string, the operator at the top of the operator stack\n        :return: bool, True if the current operator has higher or equal precedence, False otherwise\n        >>> expression_calculator = ExpressionCalculator()\n        >>> expression_calculator.compare(\"+\", \"-\")\n        True\n\n        \"\"\"\n\n        # Normalize modulo to have same precedence as division\n        if cur == '%':\n            cur = '/'\n        if peek == '%':\n            peek = '/'\n        \n        # Compare precedence using ASCII offset and return the appropriate boolean\n        return self.operat_priority[ord(peek) - 40] >= self.operat_priority[ord(cur) - 40]\n\n\n    @staticmethod\n    def _calculate(first_value, second_value, current_op):\n        \"\"\"\n        Perform the mathematical calculation based on the given operands and operator\n        :param first_value: string, the first operand\n        :param second_value: string, the second operand\n        :param current_op: string, the operator\n        :return: decimal.Decimal, the calculated result\n        >>> expression_calculator = ExpressionCalculator()\n        >>> expression_calculator._calculate(\"2\", \"3\", \"+\")\n        5.0\n\n        \"\"\"\n\n        # Convert both operand strings to Decimal for high-precision arithmetic\n        # Perform and return the appropriate operation based on the operator\n        if current_op == '+':\n            return Decimal(first_value) + Decimal(second_value)\n        elif current_op == '-':\n            return Decimal(first_value) - Decimal(second_value)\n        elif current_op == '*':\n            return Decimal(first_value) * Decimal(second_value)\n        elif current_op == '/':\n            return Decimal(first_value) / Decimal(second_value)\n        elif current_op == '%':\n            return Decimal(first_value) % Decimal(second_value)\n        else:\n            # If the operator is unrecognized, raise a ValueError\n            raise ValueError(\"Unexpected operator: {}\".format(current_op))\n\n\n    @staticmethod\n    def transform(expression):\n        \"\"\"\n        Transform the infix expression to a format suitable for conversion\n        :param expression: string, the infix expression to be transformed\n        :return: string, the transformed expression\n        >>> expression_calculator = ExpressionCalculator()\n        >>> expression_calculator.transform(\"2 + 3 * 4\")\n        \"2+3*4\"\n\n        \"\"\"\n\n        # Use re.sub function to remove spaces and optional trailing equals from the expression\n        expression = re.sub(r\"\\s+\", \"\", expression)\n        expression = re.sub(r\"=$\", \"\", expression)\n        arr = list(expression)\n\n        for i, c in enumerate(arr):\n            if c == '-':\n                # Add unary at the start as first character is a negative sign\n                if i == 0:\n                    arr[i] = '~'\n                else:\n                    # If previous character is an operation or left paranthesis, treat '-' as unary\n                    prev_c = arr[i - 1]\n                    if prev_c in {'+', '-', '*', '/', '(', 'E', 'e'}:\n                        arr[i] = '~'\n\n        # Special case for negative paratheses e.g. -(4+2) -> 0-(4+2)\n        if arr[0] == '~' and (len(arr) > 1 and arr[1] == '('):\n            # Convert '~' back to '-'\n            arr[0] = '-'\n            # Add leading 0 for unary minus\n            return \"0\" + \"\".join(arr)\n        else:\n            # Return cleaned expression\n            return \"\".join(arr)"
    },
    {
        "id" : "40",
        "code" : "class FitnessTracker:\n\n    \"\"\"\n    This is a class as fitness tracker that implements to calculate BMI (Body Mass Index) and calorie intake based on the user's height, weight, age, and sex.\n    \"\"\"\n\n    def __init__(self, height, weight, age, sex) -> None:\n        \"\"\"\n        Initialize the class with height, weight, age, and sex, and calculate the BMI standard based on sex, and male is 20-25, female is 19-24.\n        \"\"\"\n        self.height = height\n        self.weight = weight\n        self.age = age\n        self.sex = sex\n        self.BMI_std = [\n            {\"male\": [20, 25]},\n            {\"female\": [19, 24]}\n        ]\n\n    def get_BMI(self):\n        \"\"\"\n        Calculate the BMI based on the height and weight.\n        :return: BMI,which is the weight divide by the square of height, float.\n        >>> fitnessTracker = FitnessTracker(1.8, 70, 20, \"male\")\n        >>> fitnessTracker.get_BMI()\n        21.604938271604937\n\n        \"\"\"\n\n        return self.weight / self.height ** 2\n\n    def condition_judge(self):\n        \"\"\"\n        Judge the condition of the user based on the BMI standard.\n        :return: 1 if the user is too fat, -1 if the user is too thin, 0 if the user is normal, int.\n        >>> fitnessTracker = FitnessTracker(1.8, 70, 20, \"male\")\n        >>> fitnessTracker.condition_judge()\n        -1\n\n        \"\"\"\n\n        BMI = self.get_BMI()\n        if self.sex == \"male\":\n            BMI_range = self.BMI_std[0][\"male\"]\n        else:\n            BMI_range = self.BMI_std[1][\"female\"]\n        \n        if BMI > BMI_range[1]:\n            # too fat\n            return 1\n        elif BMI < BMI_range[0]:\n            # too thin\n            return -1\n        else:\n            # normal\n            return 0\n\n    def calculate_calorie_intake(self):\n        \"\"\"\n        Calculate the calorie intake based on the user's condition and BMR (Basal Metabolic Rate),BMR is calculated based on the user's height, weight, age, and sex,male is10 * self.weight + 6.25 * self.height - 5 * self.age + 5,female is 10 * self.weight + 6.25 * self.height - 5 * self.age - 161, and the calorie intake is calculated based on the BMR and the user's condition,if the user is too fat, the calorie intake is BMR * 1.2, if the user is too thin, the calorie intake is BMR * 1.6, if the user is normal, the calorie intake is BMR * 1.4.\n        :return: calorie intake, float.\n        >>> fitnessTracker = FitnessTracker(1.8, 70, 20, \"male\")\n        >>> fitnessTracker.calculate_calorie_intake()\n        986.0\n\n        \"\"\"\n\n        if self.sex == \"male\":\n            BMR = 10 * self.weight + 6.25 * self.height - 5 * self.age + 5\n        else:\n            BMR = 10 * self.weight + 6.25 * self.height - 5 * self.age - 161\n\n        if self.condition_judge() == 1:\n            calorie_intake = BMR * 1.2  # Sedentary lifestyle\n        elif self.condition_judge() == -1:\n            calorie_intake = BMR * 1.6  # Active lifestyle\n        else:\n            calorie_intake = BMR * 1.4  # Moderate lifestyle\n        return calorie_intake",
        "annotated_code" : "class FitnessTracker:\n\n    \"\"\"\n    This is a class as fitness tracker that implements to calculate BMI (Body Mass Index) and calorie intake based on the user's height, weight, age, and sex.\n    \"\"\"\n\n    def __init__(self, height, weight, age, sex) -> None:\n        \"\"\"\n        Initialize the class with height, weight, age, and sex, and calculate the BMI standard based on sex, and male is 20-25, female is 19-24.\n        \"\"\"\n        self.height = height\n        self.weight = weight\n        self.age = age\n        self.sex = sex\n        self.BMI_std = [\n            {\"male\": [20, 25]},\n            {\"female\": [19, 24]}\n        ]\n\n    def get_BMI(self):\n        \"\"\"\n        Calculate the BMI based on the height and weight.\n        :return: BMI,which is the weight divide by the square of height, float.\n        >>> fitnessTracker = FitnessTracker(1.8, 70, 20, \"male\")\n        >>> fitnessTracker.get_BMI()\n        21.604938271604937\n\n        \"\"\"\n\n        # Calculate the BMI based on the height and weight and return it\n        return self.weight / self.height ** 2\n\n    def condition_judge(self):\n        \"\"\"\n        Judge the condition of the user based on the BMI standard.\n        :return: 1 if the user is too fat, -1 if the user is too thin, 0 if the user is normal, int.\n        >>> fitnessTracker = FitnessTracker(1.8, 70, 20, \"male\")\n        >>> fitnessTracker.condition_judge()\n        -1\n\n        \"\"\"\n\n        # Use the get_BMI class method to get the individual's BMI\n        BMI = self.get_BMI()\n\n        # Set the BMI standard range based on the sex \n        if self.sex == \"male\":\n            BMI_range = self.BMI_std[0][\"male\"]\n        else:\n            BMI_range = self.BMI_std[1][\"female\"]\n        \n        # If the BMI is greater than the latter value in the BMI range return 1 indicating the individual is too fat\n        if BMI > BMI_range[1]:\n            # too fat\n            return 1\n        # If the BMI is lower than the first value in the BMI range return -1 indicating the individual is too thin\n        elif BMI < BMI_range[0]:\n            # too thin\n            return -1\n        else:\n        # Otherwise, return 0 indicating a normal BMI\n            # normal\n            return 0\n\n    def calculate_calorie_intake(self):\n        \"\"\"\n        Calculate the calorie intake based on the user's condition and BMR (Basal Metabolic Rate),BMR is calculated based on the user's height, weight, age, and sex,male is10 * self.weight + 6.25 * self.height - 5 * self.age + 5,female is 10 * self.weight + 6.25 * self.height - 5 * self.age - 161, and the calorie intake is calculated based on the BMR and the user's condition,if the user is too fat, the calorie intake is BMR * 1.2, if the user is too thin, the calorie intake is BMR * 1.6, if the user is normal, the calorie intake is BMR * 1.4.\n        :return: calorie intake, float.\n        >>> fitnessTracker = FitnessTracker(1.8, 70, 20, \"male\")\n        >>> fitnessTracker.calculate_calorie_intake()\n        986.0\n\n        \"\"\"\n\n        # Calculate the BMR based on the individual's sex\n        if self.sex == \"male\":\n            BMR = 10 * self.weight + 6.25 * self.height - 5 * self.age + 5\n        else:\n            BMR = 10 * self.weight + 6.25 * self.height - 5 * self.age - 161\n\n        # Use the condition_judge class method to see whether the user is too thin, too fat, or has a normal BMI\n        if self.condition_judge() == 1:\n            # If the individual is too fat, calculate the expected calorie intake like this\n            calorie_intake = BMR * 1.2  # Sedentary lifestyle\n        elif self.condition_judge() == -1:\n            # If the individual is too thin, calculate the expected calorie intake like this\n            calorie_intake = BMR * 1.6  # Active lifestyle\n        else:\n            # If the individual has a normal BMI, calculate the expected calorie intake like this\n            calorie_intake = BMR * 1.4  # Moderate lifestyle\n        \n        # Return the calorie intake calculated\n        return calorie_intake"
    },
    {
        "id" : "41",
        "code" : "class GomokuGame:\n\n    \"\"\"\n    This class is an implementation of a Gomoku game, supporting for making moves, checking for a winner, and checking if there are five consecutive symbols on the game board.\n    \"\"\"\n\n    def __init__(self, board_size):\n        \"\"\"\n        Initializes the game with a given board size.\n        It initializes the board with empty spaces and sets the current player symble as 'X'.\n        \"\"\"\n        self.board_size = board_size\n        self.board = [[' ' for _ in range(board_size)] for _ in range(board_size)]\n        self.current_player = 'X'\n\n    def make_move(self, row, col):\n        \"\"\"\n        Makes a move at the given row and column.\n        If the move is valid, it places the current player's symbol on the board\n        and changes the current player to the other player (if the current player is 'X', then it becomes 'O' and vice versa).\n        :param row: int, the row index of this move\n        :param col: int, the column index\n        return: True if the move is valid, or False otherwise.\n        >>> gomokuGame = GomokuGame(10)\n        >>> gomokuGame.make_move(5, 5)\n        True\n        >>> gomokuGame.make_move(5, 5)\n        False\n        \"\"\"\n\n        if self.board[row][col] == ' ':\n            self.board[row][col] = self.current_player\n            self.current_player = 'O' if self.current_player == 'X' else 'X'\n            return True\n        return False\n\n    def check_winner(self):\n        \"\"\"\n        Checks if there is a winner by looking for five in a row in all directions (horizontal, vertical, diagonal).\n        return: the symbol of the winning player (either 'X' or 'O') if there is a winner, or None otherwise.\n        >>> gomokuGame = GomokuGame(10)\n        >>> moves = [(5, 5), (0, 0), (5, 4), (0, 1), (5, 3), (0, 2), (5, 2), (0, 3), (5, 1)]\n        >>> for move in moves:\n        ...     gomokuGame.make_move(move[0], move[1])\n        >>> gomokuGame.check_winner()\n        'X'\n        \"\"\"\n\n        directions = [(0, 1), (1, 0), (1, 1), (1, -1)]\n        for row in range(self.board_size):\n            for col in range(self.board_size):\n                if self.board[row][col] != ' ':\n                    for direction in directions:\n                        if self._check_five_in_a_row(row, col, direction):\n                            return self.board[row][col]\n        return None\n\n    def _check_five_in_a_row(self, row, col, direction):\n        \"\"\"\n        checks if there are five consecutive symbols of the same player in a row starting from a given cell in a given direction (horizontal, vertical, diagonal).\n        Counts the number of consecutive symbols in that direction starting from the given cell,\n        :param row: int, row of the given cell\n        :param col: int, column of the given cell\n        :param direction: tuple, (int, int), named as (dx, dy). Row and col will plus several dx and dy repectively.\n        :return: True if there are five consecutive symbols of the same player, and False otherwise.\n        >>> gomokuGame = GomokuGame(10)\n        >>> moves = [(5, 5), (0, 0), (5, 4), (0, 1), (5, 3), (0, 2), (5, 2), (0, 3), (5, 1)]\n        >>> for move in moves:\n        ...     gomokuGame.make_move(move[0], move[1])\n        >>> gomokuGame._check_five_in_a_row(5, 1, (0, 1))\n        True\n        >>> gomokuGame._check_five_in_a_row(5, 1, (1, 1))\n        False\n        \"\"\"\n\n        dx, dy = direction\n        count = 1\n        symbol = self.board[row][col]\n        for i in range(1, 5):\n            new_row = row + dx * i\n            new_col = col + dy * i\n            if not (0 <= new_row < self.board_size and 0 <= new_col < self.board_size):\n                return False\n            if self.board[new_row][new_col] != symbol:\n                return False\n            count += 1\n        return count == 5",
        "annotated_code" : "class GomokuGame:\n\n    \"\"\"\n    This class is an implementation of a Gomoku game, supporting for making moves, checking for a winner, and checking if there are five consecutive symbols on the game board.\n    \"\"\"\n\n    def __init__(self, board_size):\n        \"\"\"\n        Initializes the game with a given board size.\n        It initializes the board with empty spaces and sets the current player symble as 'X'.\n        \"\"\"\n        self.board_size = board_size\n        self.board = [[' ' for _ in range(board_size)] for _ in range(board_size)]\n        self.current_player = 'X'\n\n    def make_move(self, row, col):\n        \"\"\"\n        Makes a move at the given row and column.\n        If the move is valid, it places the current player's symbol on the board\n        and changes the current player to the other player (if the current player is 'X', then it becomes 'O' and vice versa).\n        :param row: int, the row index of this move\n        :param col: int, the column index\n        return: True if the move is valid, or False otherwise.\n        >>> gomokuGame = GomokuGame(10)\n        >>> gomokuGame.make_move(5, 5)\n        True\n        >>> gomokuGame.make_move(5, 5)\n        False\n        \"\"\"\n\n        # If the specified position in the board is empty, mark the position in the board with the current player\n        if self.board[row][col] == ' ':\n            self.board[row][col] = self.current_player\n\n            # Alternate the current player\n            self.current_player = 'O' if self.current_player == 'X' else 'X'\n\n            # Return True indicating that the move is valid\n            return True\n        \n        # Return False indicating that the move is invalid\n        return False\n\n    def check_winner(self):\n        \"\"\"\n        Checks if there is a winner by looking for five in a row in all directions (horizontal, vertical, diagonal).\n        return: the symbol of the winning player (either 'X' or 'O') if there is a winner, or None otherwise.\n        >>> gomokuGame = GomokuGame(10)\n        >>> moves = [(5, 5), (0, 0), (5, 4), (0, 1), (5, 3), (0, 2), (5, 2), (0, 3), (5, 1)]\n        >>> for move in moves:\n        ...     gomokuGame.make_move(move[0], move[1])\n        >>> gomokuGame.check_winner()\n        'X'\n        \"\"\"\n\n        directions = [(0, 1), (1, 0), (1, 1), (1, -1)]\n\n        # Iterate through all positions in the board\n        for row in range(self.board_size):\n            for col in range(self.board_size):\n                if self.board[row][col] != ' ':\n                    # If the current position in the board is not empty\n                    # Iterate through all the directions and use the _check_five_in_a_row class method to check if there's 5 consecutive symbols of the same player in any direction\n                    for direction in directions:\n                        if self._check_five_in_a_row(row, col, direction):\n                            # If the _check_five_in_a_row class method returns true for direction, return the symbol of the winning player\n                            return self.board[row][col]\n        \n        # Return None indicating a player hasn't won yet\n        return None\n\n    def _check_five_in_a_row(self, row, col, direction):\n        \"\"\"\n        checks if there are five consecutive symbols of the same player in a row starting from a given cell in a given direction (horizontal, vertical, diagonal).\n        Counts the number of consecutive symbols in that direction starting from the given cell,\n        :param row: int, row of the given cell\n        :param col: int, column of the given cell\n        :param direction: tuple, (int, int), named as (dx, dy). Row and col will plus several dx and dy repectively.\n        :return: True if there are five consecutive symbols of the same player, and False otherwise.\n        >>> gomokuGame = GomokuGame(10)\n        >>> moves = [(5, 5), (0, 0), (5, 4), (0, 1), (5, 3), (0, 2), (5, 2), (0, 3), (5, 1)]\n        >>> for move in moves:\n        ...     gomokuGame.make_move(move[0], move[1])\n        >>> gomokuGame._check_five_in_a_row(5, 1, (0, 1))\n        True\n        >>> gomokuGame._check_five_in_a_row(5, 1, (1, 1))\n        False\n        \"\"\"\n\n        # Unpack the direction tuple into x and y steps\n        dx, dy = direction\n\n        # Initialize the current count of the symbol as 1\n        count = 1\n\n        # Initialize the symbol to the current player marked in the provided position\n        symbol = self.board[row][col]\n\n        # Check the next 4 symbols in the given direction\n        for i in range(1, 5):\n\n            # Calculate the coordinates of the next cell in the given direction\n            new_row = row + dx * i\n            new_col = col + dy * i\n\n            # If the next cell is not in bounds, return False\n            if not (0 <= new_row < self.board_size and 0 <= new_col < self.board_size):\n                return False\n            \n            # If the next cell doesn't match the symbol, return False\n            if self.board[new_row][new_col] != symbol:\n                return False\n\n            # Increment the count by 1\n            count += 1\n        \n        # Return True if count is equal to 5\n        return count == 5"
    },
    {
        "id" : "42",
        "code" : "class Hotel:\n\n    \"\"\"\n    This is a class as hotel management system, managing the booking, check-in, check-out, and availability of rooms in a hotel with different room types.\n    \"\"\"\n\n    def __init__(self, name, rooms):\n        \"\"\"\n        Initialize the three fields in Hotel System.\n        name is the hotel name.\n        available_rooms stores the remaining rooms in the hotel\n        booked_rooms stores the rooms that have been booked and the person's name who booked rooms.\n        >>> hotel.name\n        'peace hotel'\n        >>> hotel.available_rooms\n        available_rooms = {'single': 5, 'double': 3}\n        >>> hotel.booked_rooms\n        {'single': {'guest 1': 2, 'guest 2':1}, 'double': {'guest1': 1}}\n        \"\"\"\n        self.name = name\n        self.available_rooms = rooms\n        self.booked_rooms = {}\n\n    def book_room(self, room_type, room_number, name):\n        \"\"\"\n        Check if there are any rooms of the specified type available.\n        if rooms are adequate, modify available_rooms and booked_rooms and finish booking, or fail to book otherwise.\n        :param room_type: str\n        :param room_number: int, the expected number of specified type rooms to be booked\n        :param name: str, guest name\n        :return: if number of rooms about to be booked doesn't exceed the remaining rooms, return str 'Success!'\n                if exceeds but quantity of available rooms is not equal to zero, return int(the remaining quantity of this room type).\n                if exceeds and quantity is zero or the room_type isn't in available_room, return False.\n        >>> hotel = Hotel('peace hotel', {'single': 5, 'double': 3})\n        >>> hotel.book_room('single', 1, 'guest 1')\n        'Success!'\n        >>> hotel.book_room('single', 5, 'guest 1')\n        4\n        >>> hotel.book_room('single', 4, 'guest 1')\n        'Success!'\n        >>> hotel.book_room('single', 1, 'guest 1')\n        False\n        >>> hotel.book_room('triple', 1, 'guest 1')\n        False\n        \"\"\"\n\n        if room_type not in self.available_rooms.keys():\n            return False\n        if room_number <= self.available_rooms[room_type]:\n            if room_type not in self.booked_rooms.keys():\n                self.booked_rooms[room_type] = {}\n            self.booked_rooms[room_type][name] = room_number\n            self.available_rooms[room_type] -= room_number\n            return \"Success!\"\n        elif self.available_rooms[room_type] != 0:\n            return self.available_rooms[room_type]\n        else:\n            return False\n    \n    def check_in(self, room_type, room_number, name):\n        \"\"\"\n        Check if the room of the specified type and number is booked by the person named name.\n        Remove this name when check in successfuly(room_number is equal to specific person's booked_rooms. When the actual check in quantity (room_number) is less than the booked quantity, number in booked_rooms will be booked quantity minus actual quantity\n        :param room_type: str, check in room type\n        :param room_number: int, check in room number\n        :param name: str, person name\n        :return False: only if the room_type is not in the booked_rooms or room_number is higher than quantity in booked rooms.\n        >>> hotel = Hotel('peace hotel', {'single': 5, 'double': 3})\n        >>> hotel.book_room('single', 1, 'guest 1')\n        'Success!'\n        >>> hotel.check_in('single', 2, 'guest 1')\n        False\n        >>> hotel.check_in('single', 1, 'guest 1')\n        >>> hotel.booked_rooms\n        {'single': {}}\n        \"\"\"\n\n        if room_type not in self.booked_rooms.keys():\n            return False\n        if name in self.booked_rooms[room_type]:\n            if room_number > self.booked_rooms[room_type][name]:\n                return False\n            elif room_number == self.booked_rooms[room_type][name]:\n                self.booked_rooms[room_type].pop(name)\n            else:\n                self.booked_rooms[room_type][name] -= room_number\n\n    def check_out(self, room_type, room_number):\n        \"\"\"\n        Check out rooms, add number for specific type in available_rooms.\n        If room_type is new, add new type in available_rooms.\n        :param room_type: str, check out room type\n        :param room_number: int, check out room number\n        >>> hotel = Hotel('peace hotel', {'single': 5, 'double': 3})\n        >>> hotel.check_out('single', 2)\n        >>> hotel.available_rooms\n        {'single': 7, 'double': 3}\n        >>> hotel.check_out('triple', 2)\n        >>> hotel.available_rooms\n        {'single': 7, 'double': 3, 'triple': 2}\n        \"\"\"\n\n        if room_type in self.available_rooms:\n            self.available_rooms[room_type] += room_number\n        else:\n            self.available_rooms[room_type] = room_number\n\n    def get_available_rooms(self, room_type):\n        \"\"\"\n        Get the number of specific type of available rooms.\n        :param room_type: str, the room type that want to know\n        :return: int, the remaining number of this type rooms.\n        >>> hotel = Hotel('peace hotel', {'single': 5, 'double': 3})\n        >>> hotel.get_available_rooms('single')\n        5\n        \"\"\"\n\n        return self.available_rooms[room_type]",
        "annotated_code" : "class Hotel:\n\n    \"\"\"\n    This is a class as hotel management system, managing the booking, check-in, check-out, and availability of rooms in a hotel with different room types.\n    \"\"\"\n\n    def __init__(self, name, rooms):\n        \"\"\"\n        Initialize the three fields in Hotel System.\n        name is the hotel name.\n        available_rooms stores the remaining rooms in the hotel\n        booked_rooms stores the rooms that have been booked and the person's name who booked rooms.\n        >>> hotel.name\n        'peace hotel'\n        >>> hotel.available_rooms\n        available_rooms = {'single': 5, 'double': 3}\n        >>> hotel.booked_rooms\n        {'single': {'guest 1': 2, 'guest 2':1}, 'double': {'guest1': 1}}\n        \"\"\"\n        self.name = name\n        self.available_rooms = rooms\n        self.booked_rooms = {}\n\n    def book_room(self, room_type, room_number, name):\n        \"\"\"\n        Check if there are any rooms of the specified type available.\n        if rooms are adequate, modify available_rooms and booked_rooms and finish booking, or fail to book otherwise.\n        :param room_type: str\n        :param room_number: int, the expected number of specified type rooms to be booked\n        :param name: str, guest name\n        :return: if number of rooms about to be booked doesn't exceed the remaining rooms, return str 'Success!'\n                if exceeds but quantity of available rooms is not equal to zero, return int(the remaining quantity of this room type).\n                if exceeds and quantity is zero or the room_type isn't in available_room, return False.\n        >>> hotel = Hotel('peace hotel', {'single': 5, 'double': 3})\n        >>> hotel.book_room('single', 1, 'guest 1')\n        'Success!'\n        >>> hotel.book_room('single', 5, 'guest 1')\n        4\n        >>> hotel.book_room('single', 4, 'guest 1')\n        'Success!'\n        >>> hotel.book_room('single', 1, 'guest 1')\n        False\n        >>> hotel.book_room('triple', 1, 'guest 1')\n        False\n        \"\"\"\n\n        # If the room_type is not available, return False\n        if room_type not in self.available_rooms.keys():\n            return False\n\n        # Check if enough rooms are available to fulfill the request\n        if room_number <= self.available_rooms[room_type]:\n\n            # If this is the first time someone is booking this type of room, initialize the inner dict for the booked rooms of this room type\n            if room_type not in self.booked_rooms.keys():\n                self.booked_rooms[room_type] = {}\n            \n            # Record the booking under the provided guest's name\n            self.booked_rooms[room_type][name] = room_number\n\n            # Decrease the count of available rooms for this room_type accordingly\n            self.available_rooms[room_type] -= room_number\n\n            # Return \"Success!\" indicating that the room was successfully booked\n            return \"Success!\"\n        # Check if not enough rooms are available but some still remain\n        elif self.available_rooms[room_type] != 0:\n            # Return the number of available rooms for this room type\n            return self.available_rooms[room_type]\n        else:\n            # Otherwise return False indicating that there's no available rooms for this room type\n            return False\n    \n    def check_in(self, room_type, room_number, name):\n        \"\"\"\n        Check if the room of the specified type and number is booked by the person named name.\n        Remove this name when check in successfuly(room_number is equal to specific person's booked_rooms. When the actual check in quantity (room_number) is less than the booked quantity, number in booked_rooms will be booked quantity minus actual quantity\n        :param room_type: str, check in room type\n        :param room_number: int, check in room number\n        :param name: str, person name\n        :return False: only if the room_type is not in the booked_rooms or room_number is higher than quantity in booked rooms.\n        >>> hotel = Hotel('peace hotel', {'single': 5, 'double': 3})\n        >>> hotel.book_room('single', 1, 'guest 1')\n        'Success!'\n        >>> hotel.check_in('single', 2, 'guest 1')\n        False\n        >>> hotel.check_in('single', 1, 'guest 1')\n        >>> hotel.booked_rooms\n        {'single': {}}\n        \"\"\"\n\n        # Return False if the specified room type does not exist in the booked rooms dictionary\n        if room_type not in self.booked_rooms.keys():\n            return False\n\n        # Check if the guest has a booking for the specified room type\n        if name in self.booked_rooms[room_type]:\n\n            # If the amount of rooms specified is more than what was booked, return False\n            if room_number > self.booked_rooms[room_type][name]:\n                return False\n            # Check if the amount of rooms specified is exactly the number booked\n            elif room_number == self.booked_rooms[room_type][name]:\n                # Check in the room by removing it from the booked_rooms dictionary\n                self.booked_rooms[room_type].pop(name)\n            else:\n                # Otherwise if the amount of rooms specified is less than what was booked, update the booked rooms count\n                self.booked_rooms[room_type][name] -= room_number\n\n    def check_out(self, room_type, room_number):\n        \"\"\"\n        Check out rooms, add number for specific type in available_rooms.\n        If room_type is new, add new type in available_rooms.\n        :param room_type: str, check out room type\n        :param room_number: int, check out room number\n        >>> hotel = Hotel('peace hotel', {'single': 5, 'double': 3})\n        >>> hotel.check_out('single', 2)\n        >>> hotel.available_rooms\n        {'single': 7, 'double': 3}\n        >>> hotel.check_out('triple', 2)\n        >>> hotel.available_rooms\n        {'single': 7, 'double': 3, 'triple': 2}\n        \"\"\"\n\n        # If the room type is available, add the specified amount of rooms to the existing number of available rooms for the room type\n        if room_type in self.available_rooms:\n            self.available_rooms[room_type] += room_number\n        else:\n        # Otherwise, create a new entry in the available rooms dictionary for the room type \n            self.available_rooms[room_type] = room_number\n\n    def get_available_rooms(self, room_type):\n        \"\"\"\n        Get the number of specific type of available rooms.\n        :param room_type: str, the room type that want to know\n        :return: int, the remaining number of this type rooms.\n        >>> hotel = Hotel('peace hotel', {'single': 5, 'double': 3})\n        >>> hotel.get_available_rooms('single')\n        5\n        \"\"\"\n\n        # Get the number of available rooms for the specified room type and return it\n        return self.available_rooms[room_type]"
    },
    {
        "id" : "43",
        "code" : "class HRManagementSystem:\n\n    \"\"\"\n    This is a class as personnel management system that implements functions such as adding, deleting, querying, and updating employees\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the HRManagementSystem withan attribute employees, which is an empty dictionary.\n        \"\"\"\n        self.employees = {}\n\n    def add_employee(self, employee_id, name, position, department, salary):\n        \"\"\"\n        Add a new employee to the HRManagementSystem.\n        :param employee_id: The employee's id, int.\n        :param name: The employee's name, str.\n        :param position: The employee's position, str.\n        :param department: The employee's department, str.\n        :param salary: The employee's salary, int.\n        :return: If the employee is already in the HRManagementSystem, returns False, otherwise, returns True.\n        >>> hrManagementSystem = HRManagementSystem()\n        >>> hrManagementSystem.add_employee(1, 'John', 'Manager', 'Sales', 100000)\n        True\n        >>> hrManagementSystem.add_employee(1, 'John', 'Manager', 'Sales', 100000)\n        False\n\n        \"\"\"\n\n        if employee_id in self.employees:\n            return False\n        else:\n            self.employees[employee_id] = {\n                'name': name,\n                'position': position,\n                'department': department,\n                'salary': salary\n            }\n            return True\n\n    def remove_employee(self, employee_id):\n        \"\"\"\n        Remove an employee from the HRManagementSystem.\n        :param employee_id: The employee's id, int.\n        :return: If the employee is already in the HRManagementSystem, returns True, otherwise, returns False.\n        >>> hrManagementSystem = HRManagementSystem()\n        >>> hrManagementSystem.employees = {1: {'name': 'John', 'position': 'Manager', 'department': 'Sales', 'salary': 100000}}\n        >>> hrManagementSystem.remove_employee(1)\n        True\n        >>> hrManagementSystem.remove_employee(2)\n        False\n\n        \"\"\"\n\n        if employee_id in self.employees:\n            del self.employees[employee_id]\n            return True\n        else:\n            return False\n\n    def update_employee(self, employee_id: int, employee_info: dict):\n        \"\"\"\n        Update an employee's information in the HRManagementSystem.\n        :param employee_id: The employee's id, int.\n        :param employee_info: The employee's information, dict.\n        :return: If the employee is already in the HRManagementSystem, returns True, otherwise, returns False.\n        >>> hrManagementSystem = HRManagementSystem()\n        >>> hrManagementSystem.employees = {1: {'name': 'John', 'position': 'Manager', 'department': 'Sales', 'salary': 100000}}\n        >>> hrManagementSystem.update_employee(1, {'name': 'John', 'position': 'Manager', 'department': 'Sales', 'salary': 20000})\n        True\n        >>> hrManagementSystem.update_employee(2, {'name': 'John', 'position': 'Manager', 'department': 'Sales', 'salary': 20000})\n        False\n\n        \"\"\"\n\n        employee = self.get_employee(employee_id)\n        if employee == False:\n            return False\n        else:\n            for key, value in employee_info.items():\n                if key not in employee:\n                    return False\n            for key, value in employee_info.items():\n                employee[key] = value\n            return True\n\n    def get_employee(self, employee_id):\n        \"\"\"\n        Get an employee's information from the HRManagementSystem.\n        :param employee_id: The employee's id, int.\n        :return: If the employee is already in the HRManagementSystem, returns the employee's information, otherwise, returns False.\n        >>> hrManagementSystem = HRManagementSystem()\n        >>> hrManagementSystem.employees = {1: {'name': 'John', 'position': 'Manager', 'department': 'Sales', 'salary': 100000}}\n        >>> hrManagementSystem.get_employee(1)\n        {'name': 'John', 'position': 'Manager', 'department': 'Sales', 'salary': 100000}\n        >>> hrManagementSystem.get_employee(2)\n        False\n\n        \"\"\"\n\n        if employee_id in self.employees:\n            return self.employees[employee_id]\n        else:\n            return False\n\n    def list_employees(self):\n        \"\"\"\n        List all employees' information in the HRManagementSystem.\n        :return: A list of all employees' information,dict.\n        >>> hrManagementSystem = HRManagementSystem()\n        >>> hrManagementSystem.employees = {1: {'name': 'John', 'position': 'Manager', 'department': 'Sales', 'salary': 100000}}\n        >>> hrManagementSystem.list_employees()\n        {1: {'employee_ID': 1, 'name': 'John', 'position': 'Manager', 'department': 'Sales', 'salary': 100000}}\n\n        \"\"\"\n\n        employee_data = {}\n        if self.employees:\n            for employee_id, employee_info in self.employees.items():\n                employee_details = {}\n                employee_details[\"employee_ID\"] = employee_id\n                for key, value in employee_info.items():\n                    employee_details[key] = value\n                employee_data[employee_id] = employee_details\n        return employee_data",
        "annotated_code" : "class HRManagementSystem:\n\n    \"\"\"\n    This is a class as personnel management system that implements functions such as adding, deleting, querying, and updating employees\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the HRManagementSystem withan attribute employees, which is an empty dictionary.\n        \"\"\"\n        self.employees = {}\n\n    def add_employee(self, employee_id, name, position, department, salary):\n        \"\"\"\n        Add a new employee to the HRManagementSystem.\n        :param employee_id: The employee's id, int.\n        :param name: The employee's name, str.\n        :param position: The employee's position, str.\n        :param department: The employee's department, str.\n        :param salary: The employee's salary, int.\n        :return: If the employee is already in the HRManagementSystem, returns False, otherwise, returns True.\n        >>> hrManagementSystem = HRManagementSystem()\n        >>> hrManagementSystem.add_employee(1, 'John', 'Manager', 'Sales', 100000)\n        True\n        >>> hrManagementSystem.add_employee(1, 'John', 'Manager', 'Sales', 100000)\n        False\n\n        \"\"\"\n\n        # Return False if the employee_id already exists in the employees dictionary\n        if employee_id in self.employees:\n            return False\n        else:\n        # Otherwise add the employee to the employees dictionary with the provided information and Return True\n            self.employees[employee_id] = {\n                'name': name,\n                'position': position,\n                'department': department,\n                'salary': salary\n            }\n            return True\n\n    def remove_employee(self, employee_id):\n        \"\"\"\n        Remove an employee from the HRManagementSystem.\n        :param employee_id: The employee's id, int.\n        :return: If the employee is already in the HRManagementSystem, returns True, otherwise, returns False.\n        >>> hrManagementSystem = HRManagementSystem()\n        >>> hrManagementSystem.employees = {1: {'name': 'John', 'position': 'Manager', 'department': 'Sales', 'salary': 100000}}\n        >>> hrManagementSystem.remove_employee(1)\n        True\n        >>> hrManagementSystem.remove_employee(2)\n        False\n\n        \"\"\"\n\n        # If the employee_id exists in the employees dictionary, delete that entry for the employee and return True\n        if employee_id in self.employees:\n            del self.employees[employee_id]\n            return True\n        else:\n        # Otherwise return False if the employee_id doesn't exist in the employees dictionary\n            return False\n\n    def update_employee(self, employee_id: int, employee_info: dict):\n        \"\"\"\n        Update an employee's information in the HRManagementSystem.\n        :param employee_id: The employee's id, int.\n        :param employee_info: The employee's information, dict.\n        :return: If the employee is already in the HRManagementSystem, returns True, otherwise, returns False.\n        >>> hrManagementSystem = HRManagementSystem()\n        >>> hrManagementSystem.employees = {1: {'name': 'John', 'position': 'Manager', 'department': 'Sales', 'salary': 100000}}\n        >>> hrManagementSystem.update_employee(1, {'name': 'John', 'position': 'Manager', 'department': 'Sales', 'salary': 20000})\n        True\n        >>> hrManagementSystem.update_employee(2, {'name': 'John', 'position': 'Manager', 'department': 'Sales', 'salary': 20000})\n        False\n\n        \"\"\"\n\n        # Use the get_employee class method to get the employee information for the employee_id\n        employee = self.get_employee(employee_id)\n\n        # If the employee is False or doesn't exist, return False\n        if employee == False:\n            return False\n        else:\n        # Otherwise, update the existing employee with the provided employee info\n            # Return False if any key in the employee info is not also present in the original employee dictionary\n            for key, value in employee_info.items():\n                if key not in employee:\n                    return False\n            # Update the employee dictionary with the information provided in the employee_info dictionary\n            for key, value in employee_info.items():\n                employee[key] = value\n            # Return True indicating the update was successful\n            return True\n\n    def get_employee(self, employee_id):\n        \"\"\"\n        Get an employee's information from the HRManagementSystem.\n        :param employee_id: The employee's id, int.\n        :return: If the employee is already in the HRManagementSystem, returns the employee's information, otherwise, returns False.\n        >>> hrManagementSystem = HRManagementSystem()\n        >>> hrManagementSystem.employees = {1: {'name': 'John', 'position': 'Manager', 'department': 'Sales', 'salary': 100000}}\n        >>> hrManagementSystem.get_employee(1)\n        {'name': 'John', 'position': 'Manager', 'department': 'Sales', 'salary': 100000}\n        >>> hrManagementSystem.get_employee(2)\n        False\n\n        \"\"\"\n\n        # If the employee_id exists in the employees dictionary, return the information for that employee\n        if employee_id in self.employees:\n            return self.employees[employee_id]\n        else:\n        # Otherwise return False if the employee_id doesn't exist in the employees dictionary \n            return False\n\n    def list_employees(self):\n        \"\"\"\n        List all employees' information in the HRManagementSystem.\n        :return: A list of all employees' information,dict.\n        >>> hrManagementSystem = HRManagementSystem()\n        >>> hrManagementSystem.employees = {1: {'name': 'John', 'position': 'Manager', 'department': 'Sales', 'salary': 100000}}\n        >>> hrManagementSystem.list_employees()\n        {1: {'employee_ID': 1, 'name': 'John', 'position': 'Manager', 'department': 'Sales', 'salary': 100000}}\n\n        \"\"\"\n\n        employee_data = {}\n\n        # Check if there are any employees present in the employees dictionary\n        if self.employees:\n            # Iterate through all the employee entries in the employees dictionary\n            for employee_id, employee_info in self.employees.items():\n                # For each employee entry, create an employee details dictionary that stores all the information for the employee in a separate dictionary\n                employee_details = {}\n                employee_details[\"employee_ID\"] = employee_id\n                for key, value in employee_info.items():\n                    employee_details[key] = value\n                # Add the employee details dictionary as an entry in the employee_data dictionary\n                employee_data[employee_id] = employee_details\n        \n        # Return the employee data dictionary\n        return employee_data"
    },
    {
        "id" : "44",
        "code" : "import re\nimport string\nimport gensim\nfrom bs4 import BeautifulSoup\n\nclass HtmlUtil:\n\n    \"\"\"\n    This is a class as util for html, supporting for formatting and extracting code from HTML text, including cleaning up the text and converting certain elements into specific marks.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize a series of labels\n        \"\"\"\n        self.SPACE_MARK = '-SPACE-'\n        self.JSON_MARK = '-JSON-'\n        self.MARKUP_LANGUAGE_MARK = '-MARKUP_LANGUAGE-'\n        self.URL_MARK = '-URL-'\n        self.NUMBER_MARK = '-NUMBER-'\n        self.TRACE_MARK = '-TRACE-'\n        self.COMMAND_MARK = '-COMMAND-'\n        self.COMMENT_MARK = '-COMMENT-'\n        self.CODE_MARK = '-CODE-'\n\n    @staticmethod\n    def __format_line_feed(text):\n        \"\"\"\n        Replace consecutive line breaks with a single line break\n        :param text: string with consecutive line breaks\n        :return:string, replaced text with single line break\n        \"\"\"\n        \n        return re.sub(re.compile(r'\n+'), '\n', text)\n\n    def format_line_html_text(self, html_text):\n        \"\"\"\n        get the html text without the code, and add the code tag -CODE- where the code is\n        :param html_text:string\n        :return:string\n        >>>htmlutil = HtmlUtil()\n        >>>htmlutil.format_line_html_text(<html>\n        >>> <body>\n        >>>    <h1>Title</h1>\n        >>>    <p>This is a paragraph.</p>\n        >>>    <pre>print('Hello, world!')</pre>\n        >>>    <p>Another paragraph.</p>\n        >>>    <pre><code>for i in range(5):\n        >>>    print(i)</code></pre>\n        >>>    </body>\n        >>>    </html>)\n        Title\n        This is a paragraph.\n        -CODE-\n        Another paragraph.\n        -CODE-\n        \"\"\"\n\n        if html_text is None or len(html_text) == 0:\n            return ''\n        soup = BeautifulSoup(html_text, 'lxml')\n        code_tag = soup.find_all(name=['pre', 'blockquote'])\n        for tag in code_tag:\n            tag.string = self.CODE_MARK\n        ul_ol_group = soup.find_all(name=['ul', 'ol'])\n        for ul_ol_item in ul_ol_group:\n            li_group = ul_ol_item.find_all('li')\n            for li_item in li_group:\n                li_item_text = li_item.get_text().strip()\n                if len(li_item_text) == 0:\n                    continue\n                if li_item_text[-1] in string.punctuation:\n                    li_item.string = '[{0}]{1}'.format('-', li_item_text)\n                    continue\n                li_item.string = '[{0}]{1}.'.format('-', li_item_text)\n\n        p_group = soup.find_all(name=['p'])\n        for p_item in p_group:\n            p_item_text = p_item.get_text().strip()\n            if p_item_text:\n                if p_item_text[-1] in string.punctuation:\n                    p_item.string = p_item_text\n                    continue\n                next_sibling = p_item.find_next_sibling()\n                if next_sibling and self.CODE_MARK in next_sibling.get_text():\n                    p_item.string = p_item_text + ':'\n                    continue\n                p_item.string = p_item_text + '.'\n\n        clean_text = gensim.utils.decode_htmlentities(soup.get_text())\n        return self.__format_line_feed(clean_text)\n\n    def extract_code_from_html_text(self, html_text):\n        \"\"\"\n        extract codes from the html body\n        :param html_text: string, html text\n        :return: the list of code\n        >>>htmlutil = HtmlUtil()\n        >>>htmlutil.extract_code_from_html_text(<html>\n        >>> <body>\n        >>>    <h1>Title</h1>\n        >>>    <p>This is a paragraph.</p>\n        >>>    <pre>print('Hello, world!')</pre>\n        >>>    <p>Another paragraph.</p>\n        >>>    <pre><code>for i in range(5):\n        >>>    print(i)</code></pre>\n        >>>    </body>\n        >>>    </html>)\n        [\"print('Hello, world!')\", 'for i in range(5):\n                print(i)']\n        \"\"\"\n\n        text_with_code_tag = self.format_line_html_text(html_text)\n        if self.CODE_MARK not in text_with_code_tag:\n            return []\n\n        code_index_start = 0\n        soup = BeautifulSoup(html_text, 'lxml')\n        code_tag = soup.find_all(name=['pre', 'blockquote'])\n        code_count = text_with_code_tag.count(self.CODE_MARK)\n        code_list = []\n\n        for code_index in range(code_index_start, code_index_start + code_count):\n            code = code_tag[code_index].get_text()\n            if code:\n                code_list.append(code)\n        return code_list",
        "annotated_code" : "import re\nimport string\nimport gensim\nfrom bs4 import BeautifulSoup\n\nclass HtmlUtil:\n\n    \"\"\"\n    This is a class as util for html, supporting for formatting and extracting code from HTML text, including cleaning up the text and converting certain elements into specific marks.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize a series of labels\n        \"\"\"\n        self.SPACE_MARK = '-SPACE-'\n        self.JSON_MARK = '-JSON-'\n        self.MARKUP_LANGUAGE_MARK = '-MARKUP_LANGUAGE-'\n        self.URL_MARK = '-URL-'\n        self.NUMBER_MARK = '-NUMBER-'\n        self.TRACE_MARK = '-TRACE-'\n        self.COMMAND_MARK = '-COMMAND-'\n        self.COMMENT_MARK = '-COMMENT-'\n        self.CODE_MARK = '-CODE-'\n\n    @staticmethod\n    def __format_line_feed(text):\n        \"\"\"\n        Replace consecutive line breaks with a single line break\n        :param text: string with consecutive line breaks\n        :return:string, replaced text with single line break\n        \"\"\"\n        \n        # Use re.sub and re.compile to find one or more \n characters (\n+) and replace them with a single \n\n        return re.sub(re.compile(r'\n+'), '\n', text)\n\n    def format_line_html_text(self, html_text):\n        \"\"\"\n        get the html text without the code, and add the code tag -CODE- where the code is\n        :param html_text:string\n        :return:string\n        >>>htmlutil = HtmlUtil()\n        >>>htmlutil.format_line_html_text(<html>\n        >>> <body>\n        >>>    <h1>Title</h1>\n        >>>    <p>This is a paragraph.</p>\n        >>>    <pre>print('Hello, world!')</pre>\n        >>>    <p>Another paragraph.</p>\n        >>>    <pre><code>for i in range(5):\n        >>>    print(i)</code></pre>\n        >>>    </body>\n        >>>    </html>)\n        Title\n        This is a paragraph.\n        -CODE-\n        Another paragraph.\n        -CODE-\n        \"\"\"\n\n        # Return an empty string if the html_text is None or empty\n        if html_text is None or len(html_text) == 0:\n            return ''\n        \n        # Parse the HTML content using BeautifulSoup\n        soup = BeautifulSoup(html_text, 'lxml')\n\n        # Replace all <pre> and <blockquote> tags (which often contain code) with the CODE_MARK symbol\n        code_tag = soup.find_all(name=['pre', 'blockquote'])\n        for tag in code_tag:\n            tag.string = self.CODE_MARK\n\n        # Process unordered and ordered lists (<ul> and <ol>)\n        ul_ol_group = soup.find_all(name=['ul', 'ol'])\n        for ul_ol_item in ul_ol_group:\n            # Get list items\n            li_group = ul_ol_item.find_all('li')\n\n            # Iterate through all the list items\n            for li_item in li_group:\n                li_item_text = li_item.get_text().strip()\n                if len(li_item_text) == 0:\n                    continue\n                \n                # Format list item as: [-]text.\n                if li_item_text[-1] in string.punctuation:\n                    li_item.string = '[{0}]{1}'.format('-', li_item_text)\n                    continue\n                li_item.string = '[{0}]{1}.'.format('-', li_item_text)\n\n        # Process paragraph elements <p>\n        p_group = soup.find_all(name=['p'])\n        for p_item in p_group:\n            p_item_text = p_item.get_text().strip()\n            if p_item_text:\n                # If already ends in punctuation, leave it as is\n                if p_item_text[-1] in string.punctuation:\n                    p_item.string = p_item_text\n                    continue\n                # If the next sibling contains code, treat this paragraph like a header\n                next_sibling = p_item.find_next_sibling()\n                if next_sibling and self.CODE_MARK in next_sibling.get_text():\n                    p_item.string = p_item_text + ':'\n                    continue\n                p_item.string = p_item_text + '.'\n\n        # Convert HTML entities to unicode and get raw text\n        clean_text = gensim.utils.decode_htmlentities(soup.get_text())\n\n        # Clean up line breaks and return final formatted text\n        return self.__format_line_feed(clean_text)\n\n    def extract_code_from_html_text(self, html_text):\n        \"\"\"\n        extract codes from the html body\n        :param html_text: string, html text\n        :return: the list of code\n        >>>htmlutil = HtmlUtil()\n        >>>htmlutil.extract_code_from_html_text(<html>\n        >>> <body>\n        >>>    <h1>Title</h1>\n        >>>    <p>This is a paragraph.</p>\n        >>>    <pre>print('Hello, world!')</pre>\n        >>>    <p>Another paragraph.</p>\n        >>>    <pre><code>for i in range(5):\n        >>>    print(i)</code></pre>\n        >>>    </body>\n        >>>    </html>)\n        [\"print('Hello, world!')\", 'for i in range(5):\n                print(i)']\n        \"\"\"\n\n        # First, format the HTML to identify where code blocks exist\n        text_with_code_tag = self.format_line_html_text(html_text)\n\n        # If no code markers are found, return empty list\n        if self.CODE_MARK not in text_with_code_tag:\n            return []\n\n        code_index_start = 0\n\n        # Parse the HTML again to locate actual code content\n        soup = BeautifulSoup(html_text, 'lxml')\n        code_tag = soup.find_all(name=['pre', 'blockquote'])\n\n        # Count how many code blocks were marked\n        code_count = text_with_code_tag.count(self.CODE_MARK)\n        code_list = []\n\n        # Extract actual code content from the original HTML\n        for code_index in range(code_index_start, code_index_start + code_count):\n            code = code_tag[code_index].get_text()\n            if code:\n                code_list.append(code)\n        return code_list"
    },
    {
        "id" : "45",
        "code" : "from PIL import Image, ImageEnhance\n\nclass ImageProcessor:\n\n    \"\"\"\n    This is a class to process image, including loading, saving, resizing, rotating, and adjusting the brightness of images.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize self.image\n        \"\"\"\n        self.image = None\n\n    def load_image(self, image_path):\n        \"\"\"\n        Use Image util in PIL to open a image\n        :param image_path: str, path of image that is to be\n        >>> processor.load_image('test.jpg')\n        >>> processor.image\n        <PIL.JpegImagePlugin.JpegImageFile image mode=RGB size=3072x4096 at 0x194F2412A48>\n        \"\"\"\n\n        self.image = Image.open(image_path)\n\n    def save_image(self, save_path):\n        \"\"\"\n        Save image to a path if image has opened\n        :param save_path: str, the path that the image will be saved\n        >>> processor.load_image('test.jpg')\n        >>> processor.save_image('test2.jpg')\n        \"\"\"\n\n        if self.image:\n            self.image.save(save_path)\n\n    def resize_image(self, width, height):\n        \"\"\"\n        Risize the image if image has opened.\n        :param width: int, the target width of image\n        :param height: int, the target height of image\n        >>> processor.load_image('test.jpg')\n        >>> processor.resize_image(300, 300)\n        >>> processor.image.width\n        300\n        >>> processor.image.height\n        300\n        \"\"\"\n\n        if self.image:\n            self.image = self.image.resize((width, height))\n\n    def rotate_image(self, degrees):\n        \"\"\"\n        rotate image if image has opened\n        :param degrees: float, the degrees that the image will be rotated\n        >>> processor.load_image('test.jpg')\n        >>> processor.resize_image(90)\n        \"\"\"\n\n        if self.image:\n            self.image = self.image.rotate(degrees)\n\n    def adjust_brightness(self, factor):\n        \"\"\"\n        Adjust the brightness of image if image has opened.\n        :param factor: float, brightness of an image. A factor of 0.0 gives a black image. A factor of 1.0 gives the original image.\n        >>> processor.load_image('test.jpg')\n        >>> processor.adjust_brightness(0.5)\n        \"\"\"\n\n        if self.image:\n            enhancer = ImageEnhance.Brightness(self.image)\n            self.image = enhancer.enhance(factor)",
        "annotated_code" : "from PIL import Image, ImageEnhance\n\nclass ImageProcessor:\n\n    \"\"\"\n    This is a class to process image, including loading, saving, resizing, rotating, and adjusting the brightness of images.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize self.image\n        \"\"\"\n        self.image = None\n\n    def load_image(self, image_path):\n        \"\"\"\n        Use Image util in PIL to open a image\n        :param image_path: str, path of image that is to be\n        >>> processor.load_image('test.jpg')\n        >>> processor.image\n        <PIL.JpegImagePlugin.JpegImageFile image mode=RGB size=3072x4096 at 0x194F2412A48>\n        \"\"\"\n\n        # Use the Image.open function to open the image at the specified path and initialize the image class attribute\n        self.image = Image.open(image_path)\n\n    def save_image(self, save_path):\n        \"\"\"\n        Save image to a path if image has opened\n        :param save_path: str, the path that the image will be saved\n        >>> processor.load_image('test.jpg')\n        >>> processor.save_image('test2.jpg')\n        \"\"\"\n\n        # If the image class attribute is not None, use the image's save function to save the image to the specified path\n        if self.image:\n            self.image.save(save_path)\n\n    def resize_image(self, width, height):\n        \"\"\"\n        Risize the image if image has opened.\n        :param width: int, the target width of image\n        :param height: int, the target height of image\n        >>> processor.load_image('test.jpg')\n        >>> processor.resize_image(300, 300)\n        >>> processor.image.width\n        300\n        >>> processor.image.height\n        300\n        \"\"\"\n\n        # If the image class attribute is not None, use the image's resize function to resize the image to the specified width and height\n        if self.image:\n            self.image = self.image.resize((width, height))\n\n    def rotate_image(self, degrees):\n        \"\"\"\n        rotate image if image has opened\n        :param degrees: float, the degrees that the image will be rotated\n        >>> processor.load_image('test.jpg')\n        >>> processor.resize_image(90)\n        \"\"\"\n\n        # If the image class attribute is not None, use the image's rotate function to rotate the image by the specified number of degrees\n        if self.image:\n            self.image = self.image.rotate(degrees)\n\n    def adjust_brightness(self, factor):\n        \"\"\"\n        Adjust the brightness of image if image has opened.\n        :param factor: float, brightness of an image. A factor of 0.0 gives a black image. A factor of 1.0 gives the original image.\n        >>> processor.load_image('test.jpg')\n        >>> processor.adjust_brightness(0.5)\n        \"\"\"\n\n        # If the image class attribute is not None, adjust the brighness of the image\n        if self.image:\n            # Use the ImageEnhance.Brightness constructor to create an enhancer for the image that can adjust the image brightness\n            enhancer = ImageEnhance.Brightness(self.image)\n            # Use the enhancer's enhance function to adjust the brightness for the image by the specified factor\n            self.image = enhancer.enhance(factor)"
    },
    {
        "id" : "46",
        "code" : "class Interpolation:\n\n    \"\"\"\n    This is a class that implements the Linear interpolation operation of one-dimensional and two-dimensional data\n    \"\"\"\n\n    def __init__(self):\n        pass\n\n    @staticmethod\n    def interpolate_1d(x, y, x_interp):\n        \"\"\"\n        Linear interpolation of one-dimensional data\n        :param x: The x-coordinate of the data point, list.\n        :param y: The y-coordinate of the data point, list.\n        :param x_interp: The x-coordinate of the interpolation point, list.\n        :return: The y-coordinate of the interpolation point, list.\n        >>> interpolation = Interpolation()\n        >>> interpolation.interpolate_1d([1, 2, 3], [1, 2, 3], [1.5, 2.5])\n        [1.5, 2.5]\n\n        \"\"\"\n\n        y_interp = []\n\n        for xi in x_interp:\n            for i in range(len(x) - 1):\n                if x[i] <= xi <= x[i+1]:\n                    yi = y[i] + (y[i+1] - y[i]) * (xi - x[i]) / (x[i+1] - x[i])\n                    y_interp.append(yi)\n                    break\n        return y_interp\n\n    @staticmethod\n    def interpolate_2d(x, y, z, x_interp, y_interp):\n        \"\"\"\n        Linear interpolation of two-dimensional data\n        :param x: The x-coordinate of the data point, list.\n        :param y: The y-coordinate of the data point, list.\n        :param z: The z-coordinate of the data point, list.\n        :param x_interp: The x-coordinate of the interpolation point, list.\n        :param y_interp: The y-coordinate of the interpolation point, list.\n        :return: The z-coordinate of the interpolation point, list.\n        >>> interpolation = Interpolation()\n        >>> interpolation.interpolate_2d([1, 2, 3], [1, 2, 3], [[1, 2, 3], [4, 5, 6], [7, 8, 9]], [1.5, 2.5], [1.5, 2.5])\n        [3.0, 7.0]\n\n        \"\"\"\n\n        z_interp = []\n\n        for xi, yi in zip(x_interp, y_interp):\n            for i in range(len(x) - 1):\n                if x[i] <= xi <= x[i+1]:\n                    for j in range(len(y) - 1):\n                        if y[j] <= yi <= y[j+1]:\n                            z00 = z[i][j]\n                            z01 = z[i][j+1]\n                            z10 = z[i+1][j]\n                            z11 = z[i+1][j+1]\n\n                            zi = (z00 * (x[i+1] - xi) * (y[j+1] - yi) +\n                                  z10 * (xi - x[i]) * (y[j+1] - yi) +\n                                  z01 * (x[i+1] - xi) * (yi - y[j]) +\n                                  z11 * (xi - x[i]) * (yi - y[j])) / ((x[i+1] - x[i]) * (y[j+1] - y[j]))\n                            \n                            z_interp.append(zi)\n                            break\n                    break\n        return z_interp",
        "annotated_code" : "class Interpolation:\n\n    \"\"\"\n    This is a class that implements the Linear interpolation operation of one-dimensional and two-dimensional data\n    \"\"\"\n\n    def __init__(self):\n        pass\n\n    @staticmethod\n    def interpolate_1d(x, y, x_interp):\n        \"\"\"\n        Linear interpolation of one-dimensional data\n        :param x: The x-coordinate of the data point, list.\n        :param y: The y-coordinate of the data point, list.\n        :param x_interp: The x-coordinate of the interpolation point, list.\n        :return: The y-coordinate of the interpolation point, list.\n        >>> interpolation = Interpolation()\n        >>> interpolation.interpolate_1d([1, 2, 3], [1, 2, 3], [1.5, 2.5])\n        [1.5, 2.5]\n\n        \"\"\"\n\n        y_interp = []\n\n        for xi in x_interp:\n            # For each xi in x_interp find the interval [x[i], x[i+1]] that contains xi\n            for i in range(len(x) - 1):\n                if x[i] <= xi <= x[i+1]:\n\n                    # Use the linear interpolation formula to calculate yi and append yi to the interpolated list\n                    yi = y[i] + (y[i+1] - y[i]) * (xi - x[i]) / (x[i+1] - x[i])\n                    y_interp.append(yi)\n\n                    # Exit the inner loop once the interval is found\n                    break\n        \n        # Return y_interp which contains the result\n        return y_interp\n\n    @staticmethod\n    def interpolate_2d(x, y, z, x_interp, y_interp):\n        \"\"\"\n        Linear interpolation of two-dimensional data\n        :param x: The x-coordinate of the data point, list.\n        :param y: The y-coordinate of the data point, list.\n        :param z: The z-coordinate of the data point, list.\n        :param x_interp: The x-coordinate of the interpolation point, list.\n        :param y_interp: The y-coordinate of the interpolation point, list.\n        :return: The z-coordinate of the interpolation point, list.\n        >>> interpolation = Interpolation()\n        >>> interpolation.interpolate_2d([1, 2, 3], [1, 2, 3], [[1, 2, 3], [4, 5, 6], [7, 8, 9]], [1.5, 2.5], [1.5, 2.5])\n        [3.0, 7.0]\n\n        \"\"\"\n\n        z_interp = []\n\n        # Iterate through each interpolation point (xi, yi)\n        for xi, yi in zip(x_interp, y_interp):\n\n            # Find the interval [x[i], x[i+1]] that contains xi\n            for i in range(len(x) - 1):\n                if x[i] <= xi <= x[i+1]:\n\n                    # Find the appropriate y-interval [y[j], y[j+1]] that contains yi\n                    for j in range(len(y) - 1):\n                        if y[j] <= yi <= y[j+1]:\n\n                            # Retrieve the four surrounding z-values:\n                            z00 = z[i][j]\n                            z01 = z[i][j+1]\n                            z10 = z[i+1][j]\n                            z11 = z[i+1][j+1]\n\n                            # Apply bilinear interpolation formula to get zi\n                            zi = (z00 * (x[i+1] - xi) * (y[j+1] - yi) +\n                                  z10 * (xi - x[i]) * (y[j+1] - yi) +\n                                  z01 * (x[i+1] - xi) * (yi - y[j]) +\n                                  z11 * (xi - x[i]) * (yi - y[j])) / ((x[i+1] - x[i]) * (y[j+1] - y[j]))\n                            \n                            # Append zi to the interpolated list\n                            z_interp.append(zi)\n\n                            # Stop searching y-interval once match is found\n                            break\n                    \n                    # Stop searching x-interval once match is found\n                    break\n\n        # Return z_interp which contains the result\n        return z_interp"
    },
    {
        "id" : "47",
        "code" : "class IPAddress:\n\n    \"\"\"\n    This is a class to process IP Address, including validating, getting the octets and obtaining the binary representation of a valid IP address.\n    \"\"\"\n\n    def __init__(self, ip_address):\n        \"\"\"\n        Initialize the IP address to the specified address\n        :param ip_address:string\n        \"\"\"\n        self.ip_address = ip_address\n\n\n    def is_valid(self):\n        \"\"\"\n        Judge whether the IP address is valid, that is, whether the IP address is composed of four Decimal digits separated by '.'. Each digit is greater than or equal to 0 and less than or equal to 255\n        :return: bool\n        >>> ipaddress = IPAddress(\"10.10.10.10\")\n        >>> ipaddress.is_valid()\n        True\n        \"\"\"\n\n        octets = self.ip_address.split('.')\n        if len(octets) != 4:\n            return False\n        for octet in octets:\n            if not octet.isdigit() or int(octet) < 0 or int(octet) > 255:\n                return False    \n        return True\n\n\n    def get_octets(self):\n        \"\"\"\n        If the IP address is valid, the list of four decimal numbers separated by \".\" constituting the IP address is returned; otherwise, an empty list is returned\n        :return: list\n        >>> ipaddress = IPAddress(\"10.10.10.10\")\n        >>> ipaddress.get_octets()\n        [\"10\", \"10\", \"10\", \"10\"]\n        \"\"\"\n\n        if self.is_valid():\n            return self.ip_address.split('.')\n        else:\n            return []\n\n\n    def get_binary(self):\n        \"\"\"\n        If the IP address is valid, return the binary form of the IP address; otherwise, return ''\n        :return: string\n        >>> ipaddress = IPAddress(\"10.10.10.10\")\n        >>> ipaddress.get_binary()\n        \"00001010.00001010.00001010.00001010\"\n        \"\"\"\n\n        if self.is_valid():\n            binary_octets = []\n            for octet in self.get_octets():\n                binary_octets.append(format(int(octet), '08b'))\n            return '.'.join(binary_octets)\n        else:\n            return \"\"",
        "annotated_code" : "class IPAddress:\n\n    \"\"\"\n    This is a class to process IP Address, including validating, getting the octets and obtaining the binary representation of a valid IP address.\n    \"\"\"\n\n    def __init__(self, ip_address):\n        \"\"\"\n        Initialize the IP address to the specified address\n        :param ip_address:string\n        \"\"\"\n        self.ip_address = ip_address\n\n\n    def is_valid(self):\n        \"\"\"\n        Judge whether the IP address is valid, that is, whether the IP address is composed of four Decimal digits separated by '.'. Each digit is greater than or equal to 0 and less than or equal to 255\n        :return: bool\n        >>> ipaddress = IPAddress(\"10.10.10.10\")\n        >>> ipaddress.is_valid()\n        True\n        \"\"\"\n\n        # Split the IP address string by '.'\n        octets = self.ip_address.split('.')\n\n        # If the length of octets is not 4 return False\n        if len(octets) != 4:\n            return False\n\n        # Loop through each string in octets \n        for octet in octets:\n            # If octet is not a digit or is a number less than 0 or is a number greater than 255, return False\n            if not octet.isdigit() or int(octet) < 0 or int(octet) > 255:\n                return False\n            \n        # Return True indicating that the ip address is valid\n        return True\n\n\n    def get_octets(self):\n        \"\"\"\n        If the IP address is valid, the list of four decimal numbers separated by \".\" constituting the IP address is returned; otherwise, an empty list is returned\n        :return: list\n        >>> ipaddress = IPAddress(\"10.10.10.10\")\n        >>> ipaddress.get_octets()\n        [\"10\", \"10\", \"10\", \"10\"]\n        \"\"\"\n\n        # Use the is_valid class method to check if the ip address is valid\n        if self.is_valid():\n            # If the ip address is valid, return the 4 decimal numbers of the ip address as a list\n            return self.ip_address.split('.')\n        else:\n            # Otherwise return an empty list\n            return []\n\n\n    def get_binary(self):\n        \"\"\"\n        If the IP address is valid, return the binary form of the IP address; otherwise, return ''\n        :return: string\n        >>> ipaddress = IPAddress(\"10.10.10.10\")\n        >>> ipaddress.get_binary()\n        \"00001010.00001010.00001010.00001010\"\n        \"\"\"\n\n        # Use the is_valid class method to check if the ip address is valid\n        if self.is_valid():\n            # If the ip address is valid, use the get_octets class method to loop through the 4 decimal numbers in the ip address\n            # Convert each octet to binary format and append the binary versions of the octets to the binary_octets list\n            binary_octets = []\n            for octet in self.get_octets():\n                binary_octets.append(format(int(octet), '08b'))\n            # Return the binary octets as a string where each octet is seprated with '.'\n            return '.'.join(binary_octets)\n        else:\n            # Return an empty string if the ip address is not valid\n            return \"\""
    },
    {
        "id" : "48",
        "code" : "import socket\n\nclass IpUtil:\n\n    \"\"\"\n    This is a class as tool for ip that can be used to obtain the local IP address, validate its validity, and also provides the functionality to retrieve the corresponding hostname.\n    \"\"\"\n\n    @staticmethod\n    def is_valid_ipv4(ip_address):\n        \"\"\"\n        Check if the given IP address is a valid IPv4 address.\n        :param ip_address: string, the IP address to check\n        :return: bool, True if the IP address is valid, False otherwise\n        >>> IpUtil.is_valid_ipv4('192.168.0.123')\n        True\n        >>> IpUtil.is_valid_ipv4('256.0.0.0')\n        False\n\n        \"\"\"\n\n        try:\n            socket.inet_pton(socket.AF_INET, ip_address)\n            return True\n        except socket.error:\n            return False\n\n    @staticmethod\n    def is_valid_ipv6(ip_address):\n        \"\"\"\n        Check if the given IP address is a valid IPv6 address.\n        :param ip_address:string, the IP address to check\n        :return:bool, True if the IP address is valid, False otherwise\n        >>> IpUtil.is_valid_ipv6('2001:0db8:85a3:0000:0000:8a2e:0370:7334')\n        True\n        >>> IpUtil.is_valid_ipv6('2001:0db8:85a3:::8a2e:0370:7334')\n        False\n\n        \"\"\"\n\n        try:\n            socket.inet_pton(socket.AF_INET6, ip_address)\n            return True\n        except socket.error:\n            return False\n\n\n    @staticmethod\n    def get_hostname(ip_address):\n        \"\"\"\n        Get the hostname associated with the given IP address.\n        :param ip_address:string, the IP address to get the hostname for\n        :return: string, the hostname associated with the IP address\n        >>> IpUtil.get_hostname('110.242.68.3')\n        'www.baidu.com'\n        >>> IpUtil.get_hostname('10.0.0.1')\n\n        \"\"\"\n\n        try:\n            hostname = socket.gethostbyaddr(ip_address)[0]\n            return hostname\n        except socket.herror:\n            return None",
        "annotated_code" : "import socket\n\nclass IpUtil:\n\n    \"\"\"\n    This is a class as tool for ip that can be used to obtain the local IP address, validate its validity, and also provides the functionality to retrieve the corresponding hostname.\n    \"\"\"\n\n    @staticmethod\n    def is_valid_ipv4(ip_address):\n        \"\"\"\n        Check if the given IP address is a valid IPv4 address.\n        :param ip_address: string, the IP address to check\n        :return: bool, True if the IP address is valid, False otherwise\n        >>> IpUtil.is_valid_ipv4('192.168.0.123')\n        True\n        >>> IpUtil.is_valid_ipv4('256.0.0.0')\n        False\n\n        \"\"\"\n\n        try:\n            # Use the socket.inet_pton function to check if the given ip address is a valid IPv4 address\n            # Provide socket.AF_INET as the first parameter to specify to check for valid IPv4 address\n            socket.inet_pton(socket.AF_INET, ip_address)\n\n            # Return True if no error occurs indicating that ip_address is a valid IPv4 address\n            return True\n        except socket.error:\n            # Return False if a socket.error occurs indicating that ip_address is not a valid IPv4 address\n            return False\n\n    @staticmethod\n    def is_valid_ipv6(ip_address):\n        \"\"\"\n        Check if the given IP address is a valid IPv6 address.\n        :param ip_address:string, the IP address to check\n        :return:bool, True if the IP address is valid, False otherwise\n        >>> IpUtil.is_valid_ipv6('2001:0db8:85a3:0000:0000:8a2e:0370:7334')\n        True\n        >>> IpUtil.is_valid_ipv6('2001:0db8:85a3:::8a2e:0370:7334')\n        False\n\n        \"\"\"\n\n        try:\n            # Use the socket.inet_pton function to check if the given ip address is a valid IPv6 address\n            # Provide socket.AF_INET6 as the first parameter to specify to check for valid IPv6 address\n            socket.inet_pton(socket.AF_INET6, ip_address)\n\n            # Return True if no error occurs indicating that ip_address is a valid IPv6 address\n            return True\n        except socket.error:\n            # Return False if a socket.error occurs indicating that ip_address is not a valid IPv6 address\n            return False\n\n\n    @staticmethod\n    def get_hostname(ip_address):\n        \"\"\"\n        Get the hostname associated with the given IP address.\n        :param ip_address:string, the IP address to get the hostname for\n        :return: string, the hostname associated with the IP address\n        >>> IpUtil.get_hostname('110.242.68.3')\n        'www.baidu.com'\n        >>> IpUtil.get_hostname('10.0.0.1')\n\n        \"\"\"\n\n        try:\n            # Use the socket.gethostbyaddr function to get the hostname for the ip address\n            hostname = socket.gethostbyaddr(ip_address)[0]\n\n            # Return the hostname\n            return hostname\n        except socket.herror:\n            # Return None if a socket.herror occurs\n            return None"
    },
    {
        "id" : "49",
        "code" : "class JobMarketplace:\n\n    \"\"\"\n    This is a class that provides functionalities to publish positions, remove positions, submit resumes, withdraw resumes, search for positions, and obtain candidate information.\n    \"\"\"\n\n    def __init__(self):\n        self.job_listings = []\n        self.resumes = []\n\n    def post_job(self, job_title, company, requirements):\n        \"\"\"\n        This function is used to publish positions,and add the position information to the job_listings list.\n        :param job_title: The title of the position,str.\n        :param company: The company of the position,str.\n        :param requirements: The requirements of the position,list.\n        :return: None\n        >>> jobMarketplace = JobMarketplace()\n        >>> jobMarketplace.post_job(\"Software Engineer\", \"ABC Company\", ['requirement1', 'requirement2'])\n        >>> jobMarketplace.job_listings\n        [{'job_title': 'Software Engineer', 'company': 'ABC Company', 'requirements': ['requirement1', 'requirement2']}]\n\n        \"\"\"\n\n        job = {\"job_title\": job_title, \"company\": company, \"requirements\": requirements}\n        self.job_listings.append(job)\n\n    def remove_job(self, job):\n        \"\"\"\n        This function is used to remove positions,and remove the position information from the job_listings list.\n        :param job: The position information to be removed,dict.\n        :return: None\n        >>> jobMarketplace = JobMarketplace()\n        >>> jobMarketplace.job_listings = [{\"job_title\": \"Software Engineer\", \"company\": \"ABC Company\", \"requirements\": ['requirement1', 'requirement2']}]\n        >>> jobMarketplace.remove_job(jobMarketplace.job_listings[0])\n        >>> jobMarketplace.job_listings\n        []\n\n        \"\"\"\n\n        self.job_listings.remove(job)\n\n    def submit_resume(self, name, skills, experience):\n        \"\"\"\n        This function is used to submit resumes,and add the resume information to the resumes list.\n        :param name: The name of the resume,str.\n        :param skills: The skills of the resume,list.\n        :param experience: The experience of the resume,str.\n        :return: None\n        >>> jobMarketplace = JobMarketplace()\n        >>> jobMarketplace.submit_resume(\"Tom\", ['skill1', 'skill2'], \"experience\")\n        >>> jobMarketplace.resumes\n        [{'name': 'Tom', 'skills': ['skill1', 'skill2'], 'experience': 'experience'}]\n\n        \"\"\"\n\n        resume = {\"name\": name, \"skills\": skills, \"experience\": experience}\n        self.resumes.append(resume)\n\n    def withdraw_resume(self, resume):\n        \"\"\"\n        This function is used to withdraw resumes,and remove the resume information from the resumes list.\n        :param resume: The resume information to be removed,dict.\n        :return: None\n        >>> jobMarketplace = JobMarketplace()\n        >>> jobMarketplace.resumes = [{\"name\": \"Tom\", \"skills\": ['skill1', 'skill2'], \"experience\": \"experience\"}]\n        >>> jobMarketplace.withdraw_resume(jobMarketplace.resumes[0])\n        >>> jobMarketplace.resumes\n        []\n\n        \"\"\"\n\n        self.resumes.remove(resume)\n\n    def search_jobs(self, criteria):\n        \"\"\"\n        This function is used to search for positions,and return the position information that meets the requirements.\n        :param criteria: The requirements of the position,str.\n        :return: The position information that meets the requirements,list.\n        >>> jobMarketplace = JobMarketplace()\n        >>> jobMarketplace.job_listings = [{\"job_title\": \"Software Engineer\", \"company\": \"ABC Company\", \"requirements\": ['skill1', 'skill2']}]\n        >>> jobMarketplace.search_jobs(\"skill1\")\n        [{'job_title': 'Software Engineer', 'company': 'ABC Company', 'requirements': ['skill1', 'skill2']}]\n\n        \"\"\"\n\n        matching_jobs = []\n        for job_listing in self.job_listings:\n            if criteria.lower() in job_listing[\"job_title\"].lower() or criteria.lower() in [r.lower() for r in job_listing[\"requirements\"]]:\n                matching_jobs.append(job_listing)\n        return matching_jobs\n\n    @staticmethod\n    def matches_requirements(resume, requirements):\n        \"\"\"\n        This function is used to check whether all the skills in the provided resume exist in the provided requirements for a job.\n        :param resume: The resume information,dict.\n        :param requirements: The requirements of some position,str.\n        :return: Whether all the skills in the resume exists in the requirements,boolean.\n\n        \"\"\"\n\n        for skill in resume[\"skills\"]:\n            if skill not in requirements:\n                return False\n        return True\n\n    def get_job_applicants(self, job):\n        \"\"\"\n        This function is used to obtain candidate information,and return the candidate information that meets the requirements by calling the matches_requirements function.\n        :param job: The position information,dict.\n        :return: The candidate information that meets the requirements,list.\n        >>> jobMarketplace = JobMarketplace()\n        >>> jobMarketplace.resumes = [{\"name\": \"Tom\", \"skills\": ['skill1', 'skill2'], \"experience\": \"experience\"}]\n        >>> jobMarketplace.job_listings = [{\"job_title\": \"Software Engineer\", \"company\": \"ABC Company\", \"requirements\": ['skill1', 'skill2']}]\n        >>> jobMarketplace.get_job_applicants(jobMarketplace.job_listings[0])\n        [{'name': 'Tom', 'skills': ['skill1', 'skill2'], 'experience': 'experience'}]\n\n        \"\"\"\n\n        applicants = []\n        for resume in self.resumes:\n            if self.matches_requirements(resume, job[\"requirements\"]):\n                applicants.append(resume)\n        return applicants",
        "annotated_code" : "class JobMarketplace:\n\n    \"\"\"\n    This is a class that provides functionalities to publish positions, remove positions, submit resumes, withdraw resumes, search for positions, and obtain candidate information.\n    \"\"\"\n\n    def __init__(self):\n        self.job_listings = []\n        self.resumes = []\n\n    def post_job(self, job_title, company, requirements):\n        \"\"\"\n        This function is used to publish positions,and add the position information to the job_listings list.\n        :param job_title: The title of the position,str.\n        :param company: The company of the position,str.\n        :param requirements: The requirements of the position,list.\n        :return: None\n        >>> jobMarketplace = JobMarketplace()\n        >>> jobMarketplace.post_job(\"Software Engineer\", \"ABC Company\", ['requirement1', 'requirement2'])\n        >>> jobMarketplace.job_listings\n        [{'job_title': 'Software Engineer', 'company': 'ABC Company', 'requirements': ['requirement1', 'requirement2']}]\n\n        \"\"\"\n\n        # Create a job dictionary with the provided job_title, company, and requirements entries\n        job = {\"job_title\": job_title, \"company\": company, \"requirements\": requirements}\n\n        # Append the job to the job listings\n        self.job_listings.append(job)\n\n    def remove_job(self, job):\n        \"\"\"\n        This function is used to remove positions,and remove the position information from the job_listings list.\n        :param job: The position information to be removed,dict.\n        :return: None\n        >>> jobMarketplace = JobMarketplace()\n        >>> jobMarketplace.job_listings = [{\"job_title\": \"Software Engineer\", \"company\": \"ABC Company\", \"requirements\": ['requirement1', 'requirement2']}]\n        >>> jobMarketplace.remove_job(jobMarketplace.job_listings[0])\n        >>> jobMarketplace.job_listings\n        []\n\n        \"\"\"\n\n        # Remove the provided job from the job listings\n        self.job_listings.remove(job)\n\n    def submit_resume(self, name, skills, experience):\n        \"\"\"\n        This function is used to submit resumes,and add the resume information to the resumes list.\n        :param name: The name of the resume,str.\n        :param skills: The skills of the resume,list.\n        :param experience: The experience of the resume,str.\n        :return: None\n        >>> jobMarketplace = JobMarketplace()\n        >>> jobMarketplace.submit_resume(\"Tom\", ['skill1', 'skill2'], \"experience\")\n        >>> jobMarketplace.resumes\n        [{'name': 'Tom', 'skills': ['skill1', 'skill2'], 'experience': 'experience'}]\n\n        \"\"\"\n\n        # Create a resume dictionary with the provided name, skills, and experience entries\n        resume = {\"name\": name, \"skills\": skills, \"experience\": experience}\n\n        # Append the resume to the resumes list\n        self.resumes.append(resume)\n\n    def withdraw_resume(self, resume):\n        \"\"\"\n        This function is used to withdraw resumes,and remove the resume information from the resumes list.\n        :param resume: The resume information to be removed,dict.\n        :return: None\n        >>> jobMarketplace = JobMarketplace()\n        >>> jobMarketplace.resumes = [{\"name\": \"Tom\", \"skills\": ['skill1', 'skill2'], \"experience\": \"experience\"}]\n        >>> jobMarketplace.withdraw_resume(jobMarketplace.resumes[0])\n        >>> jobMarketplace.resumes\n        []\n\n        \"\"\"\n\n        # Remove the provided resume from the resumes list\n        self.resumes.remove(resume)\n\n    def search_jobs(self, criteria):\n        \"\"\"\n        This function is used to search for positions,and return the position information that meets the requirements.\n        :param criteria: The requirements of the position,str.\n        :return: The position information that meets the requirements,list.\n        >>> jobMarketplace = JobMarketplace()\n        >>> jobMarketplace.job_listings = [{\"job_title\": \"Software Engineer\", \"company\": \"ABC Company\", \"requirements\": ['skill1', 'skill2']}]\n        >>> jobMarketplace.search_jobs(\"skill1\")\n        [{'job_title': 'Software Engineer', 'company': 'ABC Company', 'requirements': ['skill1', 'skill2']}]\n\n        \"\"\"\n\n        matching_jobs = []\n\n        # Iterate through each job listing in the job listings list\n        for job_listing in self.job_listings:\n            # If the provided criteria exists in the job title or the requirements for the job listing, append the job listing to the matching jobs list\n            if criteria.lower() in job_listing[\"job_title\"].lower() or criteria.lower() in [r.lower() for r in job_listing[\"requirements\"]]:\n                matching_jobs.append(job_listing)\n        # Return the matching jobs list\n        return matching_jobs\n\n    @staticmethod\n    def matches_requirements(resume, requirements):\n        \"\"\"\n        This function is used to check whether all the skills in the provided resume exist in the provided requirements for a job.\n        :param resume: The resume information,dict.\n        :param requirements: The requirements of some position,str.\n        :return: Whether all the skills in the resume exists in the requirements,boolean.\n\n        \"\"\"\n\n        # Loop through all the skills for the provided resume\n        for skill in resume[\"skills\"]:\n            # If any skill doesn't exist in the provided requirements, return False\n            if skill not in requirements:\n                return False\n        # Return True indicating that all the skills in the provided resume exist in the provided requirements as well\n        return True\n\n    def get_job_applicants(self, job):\n        \"\"\"\n        This function is used to obtain candidate information,and return the candidate information that meets the requirements by calling the matches_requirements function.\n        :param job: The position information,dict.\n        :return: The candidate information that meets the requirements,list.\n        >>> jobMarketplace = JobMarketplace()\n        >>> jobMarketplace.resumes = [{\"name\": \"Tom\", \"skills\": ['skill1', 'skill2'], \"experience\": \"experience\"}]\n        >>> jobMarketplace.job_listings = [{\"job_title\": \"Software Engineer\", \"company\": \"ABC Company\", \"requirements\": ['skill1', 'skill2']}]\n        >>> jobMarketplace.get_job_applicants(jobMarketplace.job_listings[0])\n        [{'name': 'Tom', 'skills': ['skill1', 'skill2'], 'experience': 'experience'}]\n\n        \"\"\"\n\n        applicants = []\n\n        # Iterate through each resume in the resumes list\n        for resume in self.resumes:\n            # Use the matches_requirements class method to check if the resume matches the requirements for the provided job\n            if self.matches_requirements(resume, job[\"requirements\"]):\n                # Append the resume to the applicants list\n                applicants.append(resume)\n        \n        # Return the applicants list\n        return applicants"
    },
    {
        "id" : "50",
        "code" : "\nimport json\nimport os\n\nclass JSONProcessor:\n    \"\"\"\n    This is a class to process JSON file, including reading and writing JSON files, as well as processing JSON data by removing a specified key from the JSON object.\n    \"\"\"\n\n    def read_json(self, file_path):\n        \"\"\"\n        Read a JSON file and return the data.\n        :param file_path: str, the path of the JSON file.\n        :return: dict, the data from the JSON file if read successfully, or return -1 if an error occurs during the reading process.\n                    return 0 if the file does not exist.\n        >>> json.read_json('test.json')\n        {'name': 'test', 'age': 14}\n        \"\"\"\n        if not os.path.exists(file_path):\n            return 0\n        try:\n            with open(file_path, 'r') as file:\n                data = json.load(file)\n            return data\n        except:\n            return -1\n\n    def write_json(self, data, file_path):\n        \"\"\"\n        Write data to a JSON file and save it to the given path.\n\n        :param data: dict, the data to be written to the JSON file.\n        :param file_path: str, the path of the JSON file.\n        :return: 1 if the writing process is successful, or -1, if an error occurs during the writing process.\n        >>> json.write_json({'key1': 'value1', 'key2': 'value2'}, 'test.json')\n        1\n        >>> json.read_json('test.json')\n        {'key1': 'value1', 'key2': 'value2'}\n        \"\"\"\n        try:\n            with open(file_path, 'w') as file:\n                json.dump(data, file)\n  return 1\n        except:\n            return -1\n\n    def process_json(self, file_path, remove_key):\n        \"\"\"\n        read a JSON file and process the data by removing a specified key and rewrite the modified data back to the file.\n\n        :param file_path: str, the path of the JSON file.\n        :param remove_key: str, the key to be removed.\n        :return: 1, if the specified key is successfully removed and the data is written back.\n                    0, if the file does not exist or the specified key does not exist in the data.\n        >>> json.read_json('test.json')\n        {'key1': 'value1', 'key2': 'value2'}\n        >>> json.process_json('test.json', 'key1')\n        1\n        >>> json.read_json('test.json')\n        {'key2': 'value2'}\n        \"\"\"\n        data = self.read_json(file_path)\n        if data == 0 or data == -1:\n            return 0\n        if remove_key in data:\n            del data[remove_key]\n            self.write_json(data, file_path)\n   return 1\n        else:\n            return 0\n",
        "annotated_code" : "\nimport json\nimport os\n\nclass JSONProcessor:\n    \"\"\"\n    This is a class to process JSON file, including reading and writing JSON files, as well as processing JSON data by removing a specified key from the JSON object.\n    \"\"\"\n\n    def read_json(self, file_path):\n        \"\"\"\n        Read a JSON file and return the data.\n        :param file_path: str, the path of the JSON file.\n        :return: dict, the data from the JSON file if read successfully, or return -1 if an error occurs during the reading process.\n                    return 0 if the file does not exist.\n        >>> json.read_json('test.json')\n        {'name': 'test', 'age': 14}\n        \"\"\"\n        # Check if the file exists\n        if not os.path.exists(file_path):\n            return 0\n        try:\n            with open(file_path, 'r') as file:\n                data = json.load(file)\n            return data\n        except:\n            return -1\n\n    def write_json(self, data, file_path):\n        \"\"\"\n        Write data to a JSON file and save it to the given path.\n\n        :param data: dict, the data to be written to the JSON file.\n        :param file_path: str, the path of the JSON file.\n        :return: 1 if the writing process is successful, or -1, if an error occurs during the writing process.\n        >>> json.write_json({'key1': 'value1', 'key2': 'value2'}, 'test.json')\n        1\n        >>> json.read_json('test.json')\n        {'key1': 'value1', 'key2': 'value2'}\n        \"\"\"\n        # Open the file in write mode and write the data to it\n        # If the file does not exist, it will be created.\n        try:\n            with open(file_path, 'w') as file:\n                json.dump(data, file)\n            return 1\n        except:\n            return -1\n\n    def process_json(self, file_path, remove_key):\n        \"\"\"\n        read a JSON file and process the data by removing a specified key and rewrite the modified data back to the file.\n\n        :param file_path: str, the path of the JSON file.\n        :param remove_key: str, the key to be removed.\n        :return: 1, if the specified key is successfully removed and the data is written back.\n                    0, if the file does not exist or the specified key does not exist in the data.\n        >>> json.read_json('test.json')\n        {'key1': 'value1', 'key2': 'value2'}\n        >>> json.process_json('test.json', 'key1')\n        1\n        >>> json.read_json('test.json')\n        {'key2': 'value2'}\n        \"\"\"\n        # Read the JSON file\n        # If the file does not exist, return 0\n        # If the file exists, read the data and remove the specified key\n        data = self.read_json(file_path)\n        if data == 0 or data == -1:\n            return 0\n        if remove_key in data:\n            del data[remove_key]\n            self.write_json(data, file_path)\n            return 1\n        else:\n            return 0\n"
    },
    {
        "id" : "51",
        "code" : "\nimport numpy as np\n\nclass KappaCalculator:\n    \"\"\"\n    This is a class as KappaCalculator, supporting to calculate Cohen's and Fleiss' kappa coefficient.\n    \"\"\"\n\n\n    @staticmethod\n    def kappa(testData, k):\n        \"\"\"\n        Calculate the cohens kappa value of a k-dimensional matrix\n        :param testData: The k-dimensional matrix that needs to calculate the cohens kappa value\n        :param k: int, Matrix dimension\n        :return:float, the cohens kappa value of the matrix\n        >>> KappaCalculator.kappa([[2, 1, 1], [1, 2, 1], [1, 1, 2]], 3)\n        0.25\n        \"\"\"\n        dataMat = np.mat(testData)\n        P0 = 0.0\n        for i in range(k):\n            P0 += dataMat[i, i] * 1.0\n        xsum = np.sum(dataMat, axis=1)\n        ysum = np.sum(dataMat, axis=0)\n        sum = np.sum(dataMat)\n        Pe = float(ysum * xsum) / sum / sum\n        P0 = float(P0 / sum * 1.0)\n        cohens_coefficient = float((P0 - Pe) / (1 - Pe))\n        return cohens_coefficient\n\n    @staticmethod\n    def fleiss_kappa(testData, N, k, n):\n        \"\"\"\n        Calculate the fliss kappa value of an N * k matrix\n        :param testData: Input data matrix, N * k\n        :param N: int, Number of samples\n        :param k: int, Number of categories\n        :param k: int, Number of categories\n        :param k: int, Number of categories\n        :param n: int, Number of raters\n        :return: float, fleiss kappa value\n        >>> KappaCalculator.fleiss_kappa([[0, 0, 0, 0, 14],\n        >>>                              [0, 2, 6, 4, 2],\n        >>>                              [0, 0, 3, 5, 6],\n        >>>                              [0, 3, 9, 2, 0],\n        >>>            [2, 2, 8, 1, 1],\n        >>>                              [7, 7, 0, 0, 0],\n        >>>                              [3, 2, 6, 3, 0],\n        >>>                              [2, 5, 3, 2, 2],\n        >>>                              [6, 5, 2, 1, 0],\n        >>>                 [0, 2, 2, 3, 7]], 10, 5, 14)\n        0.20993070442195522\n        \"\"\"\n        dataMat = np.mat(testData, float)\n        oneMat = np.ones((k, 1))\n        sum = 0.0\n        P0 = 0.0\n        for i in range(N):\n            temp = 0.0\n            for j in range(k):\n                sum += dataMat[i, j]\n                temp += 1.0 * dataMat[i, j] ** 2\n            temp -= n\n            temp /= (n - 1) * n\n            P0 += temp\n        P0 = 1.0 * P0 / N\n        ysum = np.sum(dataMat, axis=0)\n        for i in range(k):\n            ysum[0, i] = (ysum[0, i] / sum) ** 2\n        Pe = ysum * oneMat * 1.0\n        ans = (P0 - Pe) / (1 - Pe)\n        return ans[0, 0]\n",
        "annotated_code" : "\nimport numpy as np\n\nclass KappaCalculator:\n    \"\"\"\n    This is a class as KappaCalculator, supporting to calculate Cohen's and Fleiss' kappa coefficient.\n    \"\"\"\n\n\n    @staticmethod\n    def kappa(testData, k):\n        \"\"\"\n        Calculate the cohens kappa value of a k-dimensional matrix\n        :param testData: The k-dimensional matrix that needs to calculate the cohens kappa value\n        :param k: int, Matrix dimension\n        :return:float, the cohens kappa value of the matrix\n        >>> KappaCalculator.kappa([[2, 1, 1], [1, 2, 1], [1, 1, 2]], 3)\n        0.25\n        \"\"\"\n        # Convert the input data to a numpy matrix\n        # and calculate the number of samples\n        # and calculate the cohens kappa value\n        # and return the result\n        dataMat = np.mat(testData)\n        P0 = 0.0\n        for i in range(k):\n            P0 += dataMat[i, i] * 1.0\n        xsum = np.sum(dataMat, axis=1)\n        ysum = np.sum(dataMat, axis=0)\n        sum = np.sum(dataMat)\n        Pe = float(ysum * xsum) / sum / sum\n        P0 = float(P0 / sum * 1.0)\n        cohens_coefficient = float((P0 - Pe) / (1 - Pe))\n        return cohens_coefficient\n\n    @staticmethod\n    def fleiss_kappa(testData, N, k, n):\n        \"\"\"\n        Calculate the fliss kappa value of an N * k matrix\n        :param testData: Input data matrix, N * k\n        :param N: int, Number of samples\n        :param k: int, Number of categories\n        :param k: int, Number of categories\n        :param k: int, Number of categories\n        :param n: int, Number of raters\n        :return: float, fleiss kappa value\n        >>> KappaCalculator.fleiss_kappa([[0, 0, 0, 0, 14],\n        >>>               [0, 2, 6, 4, 2],\n        >>>                              [0, 0, 3, 5, 6],\n        >>>                              [0, 3, 9, 2, 0],\n        >>>                              [2, 2, 8, 1, 1],\n        >>>                              [7, 7, 0, 0, 0],\n        >>>                    [3, 2, 6, 3, 0],\n        >>>                              [2, 5, 3, 2, 2],\n        >>>                              [6, 5, 2, 1, 0],\n        >>>                              [0, 2, 2, 3, 7]], 10, 5, 14)\n        0.20993070442195522\n        \"\"\"\n        # Convert the input data to a numpy matrix\n        # and calculate the number of samples\n        # and calculate the fliss kappa value\n        dataMat = np.mat(testData, float)\n        oneMat = np.ones((k, 1))\n        sum = 0.0\n        P0 = 0.0\n        for i in range(N):\n            temp = 0.0\n            for j in range(k):\n                sum += dataMat[i, j]\n                temp += 1.0 * dataMat[i, j] ** 2\n            temp -= n\n            temp /= (n - 1) * n\n            P0 += temp\n        P0 = 1.0 * P0 / N\n        ysum = np.sum(dataMat, axis=0)\n        for i in range(k):\n            ysum[0, i] = (ysum[0, i] / sum) ** 2\n        Pe = ysum * oneMat * 1.0\n        ans = (P0 - Pe) / (1 - Pe)\n        return ans[0, 0]\n"
    },
    {
        "id" : "52",
        "code" : "\nimport nltk\nfrom nltk.stem import WordNetLemmatizer\nfrom nltk import pos_tag, word_tokenize\nimport string\n\n\nnltk.download('averaged_perceptron_tagger')\nnltk.download('punkt')\nnltk.download('wordnet')\n\nclass Lemmatization:\n    \"\"\"\n    This is a class about Lemmatization, which utilizes the nltk library to perform lemmatization and part-of-speech tagging on sentences, as well as remove punctuation.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        creates a WordNetLemmatizer object and stores it in the self.lemmatizer member variable.\n        \"\"\"\n        self.lemmatizer = WordNetLemmatizer()\n\n    def lemmatize_sentence(self, sentence):\n        \"\"\"\n        Remove punctuations of the sentence and tokenizes the input sentence, mark the part of speech tag of each word,\n        lemmatizes the words with different parameters based on their parts of speech, and stores in a list.\n        :param sentence: a sentence str\n        :return: a list of words which have been lemmatized.\n        >>> lemmatization = Lemmatization()\n        >>> lemmatization.lemmatize_sentence(\"I am running in a race.\")\n        ['I', 'be', 'run', 'in', 'a', 'race']\n\n        \"\"\"\n        lemmatized_words = []\n        sentence = self.remove_punctuation(sentence)\n        words = word_tokenize(sentence)\n        tagged_words = pos_tag(words)\n        for word, tag in tagged_words:\n            if tag.startswith('V'):\n                lemmatized_word = self.lemmatizer.lemmatize(word, pos='v')\n            elif tag.startswith('J'):\n                lemmatized_word = self.lemmatizer.lemmatize(word, pos='a')\n            elif tag.startswith('R'):\n                lemmatized_word = self.lemmatizer.lemmatize(word, pos='r')\n            else:\n                lemmatized_word = self.lemmatizer.lemmatize(word)\n            lemmatized_words.append(lemmatized_word)\n        return lemmatized_words\n\n    def get_pos_tag(self, sentence):\n        \"\"\"\n        Remove punctuations of the sentence and tokenizes the input sentence, mark the part of speech tag of each word.\n        :param sentence: a sentence str\n        :return: list, part of speech tag of each word in the sentence.\n        >>> lemmatization = Lemmatization()\n        >>> lemmatization.get_pos_tag(\"I am running in a race.\")\n        ['PRP', 'VBP', 'VBG', 'IN', 'DT', 'NN']\n\n        \"\"\"\n        pos_tags = []\n        sentence = self.remove_punctuation(sentence)\n        words = word_tokenize(sentence)\n        tagged_words = pos_tag(words)\n        for tagged_word in tagged_words:\n            pos_tags.append(tagged_word[1])\n        return pos_tags\n\n    def remove_punctuation(self, sentence):\n        \"\"\"\n        Removes punctuation from the input text.\n        :param sentence: a sentence str\n        :return: str, sentence without any punctuation\n        >>> lemmatization = Lemmatization()\n        >>> lemmatization.remove_punctuation(\"I am running in a race.\")\n        'I am running in a race'\n\n        \"\"\"\n        return sentence.translate(str.maketrans('', '', string.punctuation))\n",
        "annotated_code" : "\nimport nltk\nfrom nltk.stem import WordNetLemmatizer\nfrom nltk import pos_tag, word_tokenize\nimport string\n\n\nnltk.download('averaged_perceptron_tagger')\nnltk.download('punkt')\nnltk.download('wordnet')\n\nclass Lemmatization:\n    \"\"\"\n    This is a class about Lemmatization, which utilizes the nltk library to perform lemmatization and part-of-speech tagging on sentences, as well as remove punctuation.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        creates a WordNetLemmatizer object and stores it in the self.lemmatizer member variable.\n        \"\"\"\n        self.lemmatizer = WordNetLemmatizer()\n\n    def lemmatize_sentence(self, sentence):\n        \"\"\"\n        Remove punctuations of the sentence and tokenizes the input sentence, mark the part of speech tag of each word,\n        lemmatizes the words with different parameters based on their parts of speech, and stores in a list.\n        :param sentence: a sentence str\n        :return: a list of words which have been lemmatized.\n        >>> lemmatization = Lemmatization()\n        >>> lemmatization.lemmatize_sentence(\"I am running in a race.\")\n        ['I', 'be', 'run', 'in', 'a', 'race']\n\n        \"\"\"\n        # Initialize the lemmatizer\n        # remove punctuation from the sentence and tokenize it\n        # tag each word with its part of speech\n        # lemmatize each word based on its part of speech\n        # store the lemmatized words in a list\n        lemmatized_words = []\n        sentence = self.remove_punctuation(sentence)\n        words = word_tokenize(sentence)\n        tagged_words = pos_tag(words)\n        for word, tag in tagged_words:\n            if tag.startswith('V'):\n                lemmatized_word = self.lemmatizer.lemmatize(word, pos='v')\n            elif tag.startswith('J'):\n                lemmatized_word = self.lemmatizer.lemmatize(word, pos='a')\n            elif tag.startswith('R'):\n                lemmatized_word = self.lemmatizer.lemmatize(word, pos='r')\n   else:\n                lemmatized_word = self.lemmatizer.lemmatize(word)\n            lemmatized_words.append(lemmatized_word)\n        return lemmatized_words\n\n    def get_pos_tag(self, sentence):\n        \"\"\"\n        Remove punctuations of the sentence and tokenizes the input sentence, mark the part of speech tag of each word.\n        :param sentence: a sentence str\n        :return: list, part of speech tag of each word in the sentence.\n        >>> lemmatization = Lemmatization()\n        >>> lemmatization.get_pos_tag(\"I am running in a race.\")\n        ['PRP', 'VBP', 'VBG', 'IN', 'DT', 'NN']\n\n        \"\"\"\n        # remove punctuation from the sentence and tokenize it\n        # tag each word with its part of speech\n        # store the part of speech tags in a list\n        # return the list of part of speech tags\n        pos_tags = []\n        sentence = self.remove_punctuation(sentence)\n        words = word_tokenize(sentence)\n        tagged_words = pos_tag(words)\n        for tagged_word in tagged_words:\n            pos_tags.append(tagged_word[1])\n        return pos_tags\n\n    def remove_punctuation(self, sentence):\n        \"\"\"\n        Removes punctuation from the input text.\n        :param sentence: a sentence str\n        :return: str, sentence without any punctuation\n        >>> lemmatization = Lemmatization()\n        >>> lemmatization.remove_punctuation(\"I am running in a race.\")\n        'I am running in a race'\n\n        \"\"\"\n        # remove punctuation from the input text\n        # return the text without punctuation\n        return sentence.translate(str.maketrans('', '', string.punctuation))\n"
    },
    {
        "id" : "53",
        "code" : "\nimport re\nimport string\n\nclass LongestWord:\n    \"\"\"\n    This is a class allows to add words to a list and find the longest word in a given sentence by comparing the words with the ones in the word list.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize a list of word.\n        \"\"\"\n        self.word_list = []\n\n    def add_word(self, word):\n        \"\"\"\n        append the input word into self.word_list\n        :param word: str, input word\n        \"\"\"\n        self.word_list.append(word)\n\n    def find_longest_word(self, sentence):\n        \"\"\"\n        Remove punctuation marks and split a sentence into a list of word. Find the longest splited word that is in the self.word_list.\n        Words are strictly case sensitive.\n        :param sentence: a sentence str\n        :return str: longest splited word that is in the self.word_list. return '' if self.word_list is empty.\n        >>> longestWord = LongestWord()\n        >>> longestWord.add_word('A')\n        >>> longestWord.add_word('aM')\n        >>> longestWord.find_longest_word('I am a student.')\n        'a'\n        \"\"\"\n        longest_word = \"\"\n        sentence = sentence.lower()\n        sentence = re.sub('[%s]' % re.escape(string.punctuation), '', sentence)\n        sentence = re.split(' ', sentence)\n        for word in sentence:\n            if word in self.word_list and len(word) > len(longest_word):\n                longest_word = word\n        return longest_word\n",
        "annotated_code" : "\nimport re\nimport string\n\nclass LongestWord:\n    \"\"\"\n    This is a class allows to add words to a list and find the longest word in a given sentence by comparing the words with the ones in the word list.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize a list of word.\n        \"\"\"\n        self.word_list = []\n\n    def add_word(self, word):\n        \"\"\"\n        append the input word into self.word_list\n        :param word: str, input word\n        \"\"\"\n        # Add a word to the word list\n        self.word_list.append(word)\n\n    def find_longest_word(self, sentence):\n        \"\"\"\n        Remove punctuation marks and split a sentence into a list of word. Find the longest splited word that is in the self.word_list.\n        Words are strictly case sensitive.\n        :param sentence: a sentence str\n        :return str: longest splited word that is in the self.word_list. return '' if self.word_list is empty.\n        >>> longestWord = LongestWord()\n        >>> longestWord.add_word('A')\n        >>> longestWord.add_word('aM')\n        >>> longestWord.find_longest_word('I am a student.')\n        'a'\n        \"\"\"\n        # Find the longest word in a sentence that is in the word list\n        # after removing punctuation marks and splitting the sentence into words\n        longest_word = \"\"\n        sentence = sentence.lower()\n        sentence = re.sub('[%s]' % re.escape(string.punctuation), '', sentence)\n        sentence = re.split(' ', sentence)\n        for word in sentence:\n            if word in self.word_list and len(word) > len(longest_word):\n                longest_word = word\n        return longest_word\n"
    },
    {
        "id" : "54",
        "code" : "\nimport random\n\nclass MahjongConnect:\n    \"\"\"\n    MahjongConnect is a class representing a game board for Mahjong Connect with features like creating the board, checking valid moves, finding paths, removing icons, and checking if the game \nis over.\n    \"\"\"\n\n    def __init__(self, BOARD_SIZE, ICONS):\n        \"\"\"\n        initialize the board size and the icon list, create the game board\n        :param BOARD_SIZE: list of two integer numbers, representing the number of rows and columns of the game board\n        :param ICONS: list of string, representing the icons\n        >>>mc = MahjongConnect([4, 4], ['a', 'b', 'c'])\n        mc.BOARD_SIZE = [4, 4]\n        mc.ICONS = ['a', 'b', 'c']\n        mc.board = mc.create_board()\n        \"\"\"\n        self.BOARD_SIZE = BOARD_SIZE\n        self.ICONS = ICONS\n        self.board = self.create_board()\n\n    def create_board(self):\n        \"\"\"\n        create the game board with the given board size and icons\n        :return: 2-dimensional list, the game board\n        >>> mc = MahjongConnect([4, 4], ['a', 'b', 'c'])\n        >>> mc.create_board()\n        mc.board = [['a', 'b', 'c', 'a'],\n                    ['a', 'b', 'c', 'a'],\n                    ['a', 'b', 'c', 'a'],\n                    ['a', 'b', 'c', 'a']]\n        \"\"\"\n        board = [[random.choice(self.ICONS) for _ in range(self.BOARD_SIZE[1])] for _ in range(self.BOARD_SIZE[0])]\n        return board\n\n    def is_valid_move(self, pos1, pos2):\n        \"\"\"\n        check if the move of two icons is valid (i.e. positions are within the game board range, the two positions are not the same, the two positions have the same icon, and there is a valid path between the two positions)\n        :param pos1: position tuple(x, y) of the first icon\n        :param pos2: position tuple(x, y) of the second icon\n        :return:True or False ,representing whether the move of two icons is valid\n        >>> mc = MahjongConnect([4, 4], ['a', 'b', 'c'])\n        mc.board = [['a', 'b', 'c', 'a'],\n                    ['a', 'b', 'c', 'a'],\n                    ['a', 'b', 'c', 'a'],\n                    ['a', 'b', 'c', 'a']]\n        >>> mc.is_valid_move((0, 0), (1, 0))\n        True\n        \"\"\"\n        x1, y1 = pos1\n        x2, y2 = pos2\n\n        # Check if positions are within the game board range\n        if not (0 <= x1 < self.BOARD_SIZE[0] and 0 <= y1 < self.BOARD_SIZE[1] and 0 <= x2 < self.BOARD_SIZE[\n            0] and 0 <= y2 <\n                self.BOARD_SIZE[1]):\n            return False\n\n        # Check if the two positions are the same\n        if pos1 == pos2:\n            return False\n\n        # Check if the two positions have the same icon\n        if self.board[x1][y1] != self.board[x2][y2]:\n            return False\n\n        # Check if there is a valid path between the two positions\n        if not self.has_path(pos1, pos2):\n            return False\n\n        return True\n\n\n    def has_path(self, pos1, pos2):\n        \"\"\"\n        check if there is a path between two icons\n        :param pos1: position tuple(x, y) of the first icon\n        :param pos2: position tuple(x, y) of the second icon\n        :return: True or False ,representing whether there is a path between two icons\n        >>> mc = MahjongConnect([4, 4], ['a', 'b', 'c'])\n        mc.board = [['a', 'b', 'c', 'a'],\n                    ['a', 'b', 'c', 'a'],\n                    ['a', 'b', 'c', 'a'],\n                    ['a', 'b', 'c', 'a']]\n        >>> mc.is_valid_move((0, 0), (1, 0))\n        True\n        \"\"\"\n        visited = set()\n        stack = [pos1]\n\n        while stack:\n            current_pos = stack.pop()\n            if current_pos == pos2:\n                return True\n\n            if current_pos in visited:\n                continue\n\n            visited.add(current_pos)\n            x, y = current_pos\n\n            # Check adjacent positions (up, down, left, right)\n            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                new_x, new_y = x + dx, y + dy\n                if 0 <= new_x < self.BOARD_SIZE[0] and 0 <= new_y < self.BOARD_SIZE[1]:\n                    if (new_x, new_y) not in visited and self.board[new_x][new_y] == self.board[x][y]:\n                        stack.append((new_x, new_y))\n\n        return False\n\n\n    def remove_icons(self, pos1, pos2):\n        \"\"\"\n        remove the connected icons on the game board\n        :param pos1: position tuple(x, y) of the first icon to be removed\n        :param pos2: position tuple(x, y) of the second icon to be removed\n        :return: None\n        >>> mc = MahjongConnect([4, 4], ['a', 'b', 'c'])\n        mc.board = [['a', 'b', 'c', 'a'],\n                    ['a', 'b', 'c', 'a'],\n                    ['a', 'b', 'c', 'a'],\n                    ['a', 'b', 'c', 'a']]\n        >>> mc.remove_icons((0, 0), (1, 0))\n        mc.board = [[' ', 'b', 'c', 'a'],\n                    [' ', 'b', 'c', 'a'],\n                    ['a', 'b', 'c', 'a'],\n                    ['a', 'b', 'c', 'a']]\n        \"\"\"\n        x1, y1 = pos1\n        x2, y2 = pos2\n        self.board[x1][y1] = ' '\n        self.board[x2][y2] = ' '\n\n\n    def is_game_over(self):\n        \"\"\"\n        Check if the game is over (i.e., if there are no more icons on the game board)\n        :return: True or False ,representing whether the game is over\n        >>> mc = MahjongConnect([4, 4] ['a', 'b', 'c'])\n        >>> mc.board = [[' ', ' ', ' ', ' '],\n        >>>         [' ', ' ', ' ', ' '],\n        >>>         [' ', ' ', ' ', ' '],\n        >>>         [' ', ' ', ' ', ' ']]\n        >>> mc.is_game_over()\n        True\n        \"\"\"\n        for row in self.board:\n            if any(icon != ' ' for icon in row):\n                return False\n        return True\n",
        "annotated_code" : "\nimport random\n\nclass MahjongConnect:\n    \"\"\"\n    MahjongConnect is a class representing a game board for Mahjong Connect with features like creating the board, checking valid moves, finding paths, removing icons, and checking if the game \nis over.\n    \"\"\"\n\n    def __init__(self, BOARD_SIZE, ICONS):\n        \"\"\"\n        initialize the board size and the icon list, create the game board\n        :param BOARD_SIZE: list of two integer numbers, representing the number of rows and columns of the game board\n        :param ICONS: list of string, representing the icons\n        >>>mc = MahjongConnect([4, 4], ['a', 'b', 'c'])\n        mc.BOARD_SIZE = [4, 4]\n        mc.ICONS = ['a', 'b', 'c']\n        mc.board = mc.create_board()\n        \"\"\"\n        self.BOARD_SIZE = BOARD_SIZE\n        self.ICONS = ICONS\n        self.board = self.create_board()\n\n    def create_board(self):\n        \"\"\"\n        create the game board with the given board size and icons\n        :return: 2-dimensional list, the game board\n        >>> mc = MahjongConnect([4, 4], ['a', 'b', 'c'])\n        >>> mc.create_board()\n        mc.board = [['a', 'b', 'c', 'a'],\n                    ['a', 'b', 'c', 'a'],\n                    ['a', 'b', 'c', 'a'],\n                    ['a', 'b', 'c', 'a']]\n        \"\"\"\n        # Create a list of icons for the board\n        board = [[random.choice(self.ICONS) for _ in range(self.BOARD_SIZE[1])] for _ in range(self.BOARD_SIZE[0])]\n        return board\n\n    def is_valid_move(self, pos1, pos2):\n        \"\"\"\n        check if the move of two icons is valid (i.e. positions are within the game board range, the two positions are not the same, the two positions have the same icon, and there is a valid path between the two positions)\n        :param pos1: position tuple(x, y) of the first icon\n        :param pos2: position tuple(x, y) of the second icon\n        :return:True or False ,representing whether the move of two icons is valid\n        >>> mc = MahjongConnect([4, 4], ['a', 'b', 'c'])\n        mc.board = [['a', 'b', 'c', 'a'],\n                    ['a', 'b', 'c', 'a'],\n                    ['a', 'b', 'c', 'a'],\n                    ['a', 'b', 'c', 'a']]\n        >>> mc.is_valid_move((0, 0), (1, 0))\n        True\n        \"\"\"\n        # Check if the positions are within the game board range\n        # Check if the two positions are the same\n        # Check if the two positions have the same icon\n        # Check if there is a valid path between the two positions\n        # Check if the two positions are valid\n        x1, y1 = pos1\n        x2, y2 = pos2\n\n        # Check if positions are within the game board range\n        if not (0 <= x1 < self.BOARD_SIZE[0] and 0 <= y1 < self.BOARD_SIZE[1] and 0 <= x2 < self.BOARD_SIZE[\n            0] and 0 <= y2 <\n                self.BOARD_SIZE[1]):\n return False\n\n        # Check if the two positions are the same\n        if pos1 == pos2:\n            return False\n\n        # Check if the two positions have the same icon\n        if self.board[x1][y1] != self.board[x2][y2]:\n            return False\n\n        # Check if there is a valid path between the two positions\n        if not self.has_path(pos1, pos2):\n            return False\n\n        return True\n\n\n    def has_path(self, pos1, pos2):\n        \"\"\"\n        check if there is a path between two icons\n        :param pos1: position tuple(x, y) of the first icon\n        :param pos2: position tuple(x, y) of the second icon\n        :return: True or False ,representing whether there is a path between two icons\n        >>> mc = MahjongConnect([4, 4], ['a', 'b', 'c'])\n        mc.board = [['a', 'b', 'c', 'a'],\n                    ['a', 'b', 'c', 'a'],\n                    ['a', 'b', 'c', 'a'],\n                    ['a', 'b', 'c', 'a']]\n        >>> mc.is_valid_move((0, 0), (1, 0))\n        True\n        \"\"\"\n        # Check if the two positions are valid\n        # Check if the two positions are the same\n        # Check if the two positions have the same icon\n        # Check if there is a valid path between the two positions\n        visited = set()\n        stack = [pos1]\n\n        while stack:\n            current_pos = stack.pop()\n            if current_pos == pos2:\n                return True\n\n            if current_pos in visited:\n                continue\n\n            visited.add(current_pos)\n            x, y = current_pos\n\n            # Check adjacent positions (up, down, left, right)\n            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                new_x, new_y = x + dx, y + dy\n                if 0 <= new_x < self.BOARD_SIZE[0] and 0 <= new_y < self.BOARD_SIZE[1]:\n                    if (new_x, new_y) not in visited and self.board[new_x][new_y] == self.board[x][y]:\n                        stack.append((new_x, new_y))\n\n        return False\n\n\n    def remove_icons(self, pos1, pos2):\n        \"\"\"\n        remove the connected icons on the game board\n        :param pos1: position tuple(x, y) of the first icon to be removed\n        :param pos2: position tuple(x, y) of the second icon to be removed\n        :return: None\n        >>> mc = MahjongConnect([4, 4], ['a', 'b', 'c'])\n        mc.board = [['a', 'b', 'c', 'a'],\n                    ['a', 'b', 'c', 'a'],\n                    ['a', 'b', 'c', 'a'],\n                    ['a', 'b', 'c', 'a']]\n        >>> mc.remove_icons((0, 0), (1, 0))\n        mc.board = [[' ', 'b', 'c', 'a'],\n                    [' ', 'b', 'c', 'a'],\n    ['a', 'b', 'c', 'a'],\n                    ['a', 'b', 'c', 'a']]\n        \"\"\"\n        # Remove the icons from the game board\n        x1, y1 = pos1\n        x2, y2 = pos2\n        self.board[x1][y1] = ' '\n        self.board[x2][y2] = ' '\n\n\n    def is_game_over(self):\n        \"\"\"\n        Check if the game is over (i.e., if there are no more icons on the game board)\n        :return: True or False ,representing whether the game is over\n        >>> mc = MahjongConnect([4, 4] ['a', 'b', 'c'])\n        >>> mc.board = [[' ', ' ', ' ', ' '],\n        >>>         [' ', ' ', ' ', ' '],\n        >>>         [' ', ' ', ' ', ' '],\n        >>>         [' ', ' ', ' ', ' ']]\n        >>> mc.is_game_over()\n        True\n        \"\"\"\n        # Check if there are no more icons on the game board\n        # Check if the game board is empty\n        for row in self.board:\n            if any(icon != ' ' for icon in row):\n                return False\n        return True\n"
    },
    {
        "id" : "55",
        "code" : "\nclass Manacher:\n    \"\"\"\n    his is a class that implements a manacher algorithm to find the Longest palindromic substring in a given string.\n    \"\"\"\n\n    def __init__(self, input_string) -> None:\n        \"\"\"\n        Initializes the Manacher class with the given input_string.\n        :param input_string: The input_string to be searched, str.\n        \"\"\"\n        self.input_string = input_string\n\n    def palindromic_length(self, center, diff, string):\n        \"\"\"\n        Recursively calculates the length of the palindromic substring based on a given center, difference value, and input string.\n        :param center: The center of the palindromic substring, int.\n        :param diff: The difference between the center and the current position, int.\n        :param string: The string to be searched, str.\n        :return: The length of the palindromic substring, int.\n        >>> manacher = Manacher('ababa')\n        >>> manacher.palindromic_length(2, 1, 'a|b|a|b|a')\n        2\n\n        \"\"\"\n        if (center - diff == -1 or center + diff == len(string)\n                or string[center - diff] != string[center + diff]):\n            return 0\n        return 1 + self.palindromic_length(center, diff + 1, string)\n\n    def palindromic_string(self):\n        \"\"\"\n        Finds the longest palindromic substring in the given string.\n        :return: The longest palindromic substring, str.\n        >>> manacher = Manacher('ababaxse')\n        >>> manacher.palindromic_string()\n        'ababa'\n\n        \"\"\"\n        max_length = 0\n\n        new_input_string = \"\"\n        output_string = \"\"\n\n        for i in self.input_string[:len(self.input_string) - 1]:\n            new_input_string += i + \"|\"\n        new_input_string += self.input_string[-1]\n\n        for i in range(len(new_input_string)):\n\n            length =self.palindromic_length(i, 1, new_input_string)\n\n            if max_length < length:\n                max_length = length\n                start = i\n\n        for i in new_input_string[start - max_length:start + max_length + 1]:\n            if i != \"|\":\n                output_string += i\n\n        return output_string\n",
        "annotated_code" : "\nclass Manacher:\n    \"\"\"\n    his is a class that implements a manacher algorithm to find the Longest palindromic substring in a given string.\n    \"\"\"\n\n    def __init__(self, input_string) -> None:\n        \"\"\"\n        Initializes the Manacher class with the given input_string.\n        :param input_string: The input_string to be searched, str.\n        \"\"\"\n        self.input_string = input_string\n\n    def palindromic_length(self, center, diff, string):\n        \"\"\"\n        Recursively calculates the length of the palindromic substring based on a given center, difference value, and input string.\n        :param center: The center of the palindromic substring, int.\n        :param diff: The difference between the center and the current position, int.\n        :param string: The string to be searched, str.\n        :return: The length of the palindromic substring, int.\n        >>> manacher = Manacher('ababa')\n        >>> manacher.palindromic_length(2, 1, 'a|b|a|b|a')\n        2\n\n        \"\"\"\n        # Base case: if the center is at the beginning or end of the string, or if the characters at the current\n        # position are not equal, return 0.\n        # Otherwise, recursively call the function with an incremented difference value.\n        if (center - diff == -1 or center + diff == len(string)\n                or string[center - diff] != string[center + diff]):\n            return 0\n        return 1 + self.palindromic_length(center, diff + 1, string)\n\n    def palindromic_string(self):\n        \"\"\"\n        Finds the longest palindromic substring in the given string.\n        :return: The longest palindromic substring, str.\n        >>> manacher = Manacher('ababaxse')\n        >>> manacher.palindromic_string()\n        'ababa'\n\n        \"\"\"\n        # Initialize variables to keep track of the start index and maximum length of the palindromic substring.\n        # find the longest palindromic substring in the given string.\n        max_length = 0\n\n        new_input_string = \"\"\n        output_string = \"\"\n\n        for i in self.input_string[:len(self.input_string) - 1]:\n            new_input_string += i + \"|\"\n        new_input_string += self.input_string[-1]\n\n        for i in range(len(new_input_string)):\n\nlength =self.palindromic_length(i, 1, new_input_string)\n\n            if max_length < length:\n                max_length = length\n                start = i\n\n        for i in new_input_string[start - max_length:start + max_length + 1]:\n            if i != \"|\":\n                output_string += i\n\n        return output_string\n"
    },
    {
        "id" : "56",
        "code" : "\nclass MetricsCalculator:\n    \"\"\"\n    The class calculates precision, recall, F1 score, and accuracy based on predicted and true labels.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the number of all four samples to 0\n        \"\"\"\n        self.true_positives = 0\n        self.false_positives = 0\n        self.false_negatives = 0\n        self.true_negatives = 0\n\n\n    def update(self, predicted_labels, true_labels):\n        \"\"\"\n        Update the number of all four samples(true_positives, false_positives, false_negatives, true_negatives)\n        :param predicted_labels: list, predicted results\n        :param true_labels: list, true labels\n        :return: None, change the number of corresponding samples\n        >>> mc = MetricsCalculator()\n        >>> mc.update([1, 1, 0, 0], [1, 0, 0, 1])\n        (self.true_positives, self.false_positives, self.false_negatives, self.true_negatives) = (1, 1, 1, 1)\n        \"\"\"\n        for predicted, true in zip(predicted_labels, true_labels):\n            if predicted == 1 and true == 1:\n                self.true_positives += 1\n            elif predicted == 1 and true == 0:\n                self.false_positives += 1\n            elif predicted == 0 and true == 1:\n                self.false_negatives += 1\n            elif predicted == 0 and true == 0:\n                self.true_negatives += 1\n\n\n    def precision(self, predicted_labels, true_labels):\n        \"\"\"\n        Calculate precision\n        :param predicted_labels: list, predicted results\n        :param true_labels: list, true labels\n        :return: float\n        >>> mc = MetricsCalculator()\n        >>> mc.precision([1, 1, 0, 0], [1, 0, 0, 1])\n        0.5\n        \"\"\"\n        self.update(predicted_labels, true_labels)\n        if self.true_positives + self.false_positives == 0:\n            return 0.0\n        return self.true_positives / (self.true_positives + self.false_positives)\n\n\n    def recall(self, predicted_labels, true_labels):\n        \"\"\"\n        Calculate recall\n        :param predicted_labels: list, predicted results\n        :param true_labels: list, true labels\n        :return: float\n        >>> mc = MetricsCalculator()\n        >>> mc.recall([1, 1, 0, 0], [1, 0, 0, 1])\n        0.5\n        \"\"\"\n        self.update(predicted_labels, true_labels)\n        if self.true_positives + self.false_negatives == 0:\n            return 0.0\n        return self.true_positives / (self.true_positives + self.false_negatives)\n\n\n    def f1_score(self, predicted_labels, true_labels):\n        \"\"\"\n        Calculate f1 score, which is the harmonic mean of precision and recall\n        :param predicted_labels: list, predicted results\n        :param true_labels: list, true labels\n        :return: float\n        >>> mc = MetricsCalculator()\n        >>> mc.f1_score([1, 1, 0, 0], [1, 0, 0, 1])\n        0.5\n        \"\"\"\n        self.update(predicted_labels, true_labels)\n        precision = self.precision(predicted_labels, true_labels)\n        recall = self.recall(predicted_labels, true_labels)\n        if precision + recall == 0.0:\n            return 0.0\n        return (2 * precision * recall) / (precision + recall)\n\n\n    def accuracy(self, predicted_labels, true_labels):\n        \"\"\"\n        Calculate accuracy\n        :param predicted_labels: list, predicted results\n        :param true_labels: list, true labels\n        :return: float\n        >>> mc = MetricsCalculator()\n        >>>mc.accuracy([1, 1, 0, 0], [1, 0, 0, 1])\n        0.5\n        \"\"\"\n        self.update(predicted_labels, true_labels)\n        total = self.true_positives + self.true_negatives + self.false_positives + self.false_negatives\n        if total == 0:\n            return 0.0\n        return (self.true_positives + self.true_negatives) / total\n",
        "annotated_code" : "\nclass MetricsCalculator:\n    \"\"\"\n    The class calculates precision, recall, F1 score, and accuracy based on predicted and true labels.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the number of all four samples to 0\n        \"\"\"\n        self.true_positives = 0\n        self.false_positives = 0\n        self.false_negatives = 0\n        self.true_negatives = 0\n\n\n    def update(self, predicted_labels, true_labels):\n        \"\"\"\n        Update the number of all four samples(true_positives, false_positives, false_negatives, true_negatives)\n        :param predicted_labels: list, predicted results\n        :param true_labels: list, true labels\n        :return: None, change the number of corresponding samples\n        >>> mc = MetricsCalculator()\n        >>> mc.update([1, 1, 0, 0], [1, 0, 0, 1])\n        (self.true_positives, self.false_positives, self.false_negatives, self.true_negatives) = (1, 1, 1, 1)\n        \"\"\"\n        # Calculate the number of all four samples\n        # true_positives: predicted 1, true 1\n        # false_positives: predicted 1, true 0\n        # false_negatives: predicted 0, true 1\n        # true_negatives: predicted 0, true 0\n        for predicted, true in zip(predicted_labels, true_labels):\n            if predicted == 1 and true == 1:\n self.true_positives += 1\n            elif predicted == 1 and true == 0:\n                self.false_positives += 1\n            elif predicted == 0 and true == 1:\n                self.false_negatives += 1\n            elif predicted == 0 and true == 0:\n                self.true_negatives += 1\n\n\n    def precision(self, predicted_labels, true_labels):\n        \"\"\"\n        Calculate precision\n        :param predicted_labels: list, predicted results\n        :param true_labels: list, true labels\n        :return: float\n        >>> mc = MetricsCalculator()\n        >>> mc.precision([1, 1, 0, 0], [1, 0, 0, 1])\n        0.5\n        \"\"\"\n        # Calculate precision = TP / (TP + FP)\n        # Unless TP + FP == 0, return 0.0\n        self.update(predicted_labels, true_labels)\n        if self.true_positives + self.false_positives == 0:\n            return 0.0\n        return self.true_positives / (self.true_positives + self.false_positives)\n\n\n    def recall(self, predicted_labels, true_labels):\n        \"\"\"\n        Calculate recall\n        :param predicted_labels: list, predicted results\n        :param true_labels: list, true labels\n        :return: float\n        >>> mc = MetricsCalculator()\n        >>> mc.recall([1, 1, 0, 0], [1, 0, 0, 1])\n        0.5\n        \"\"\"\n        # Calculate recall = TP / (TP + FN)\n        # Unless TP + FN == 0, return 0.0\n        self.update(predicted_labels, true_labels)\n        if self.true_positives + self.false_negatives == 0:\n            return 0.0\n        return self.true_positives / (self.true_positives + self.false_negatives)\n\n\n    def f1_score(self, predicted_labels, true_labels):\n        \"\"\"\n        Calculate f1 score, which is the harmonic mean of precision and recall\n        :param predicted_labels: list, predicted results\n        :param true_labels: list, true labels\n        :return: float\n        >>> mc = MetricsCalculator()\n        >>> mc.f1_score([1, 1, 0, 0], [1, 0, 0, 1])\n        0.5\n        \"\"\"\n        # Calculate f1 score = 2 * (precision * recall) / (precision + recall)\n        # Unless precision + recall == 0, return 0.0\n        self.update(predicted_labels, true_labels)\n        precision = self.precision(predicted_labels, true_labels)\n        recall = self.recall(predicted_labels, true_labels)\n        if precision + recall == 0.0:\n            return 0.0\n        return (2 * precision * recall) / (precision + recall)\n\n\n    def accuracy(self, predicted_labels, true_labels):\n        \"\"\"\n        Calculate accuracy\n        :param predicted_labels: list, predicted results\n        :param true_labels: list, true labels\n        :return: float\n        >>> mc = MetricsCalculator()\n        >>>mc.accuracy([1, 1, 0, 0], [1, 0, 0, 1])\n        0.5\n        \"\"\"\n        # Calculate accuracy = (TP + TN) / (TP + TN + FP + FN)\n        # Unless TP + TN + FP + FN == 0, return 0.0\n        self.update(predicted_labels, true_labels)\n        total = self.true_positives + self.true_negatives + self.false_positives + self.false_negatives\n        if total == 0:\n            return 0.0\n        return (self.true_positives + self.true_negatives) / total\n"
    },
    {
        "id" : "57",
        "code" : "\nimport numpy as np\n\n\nclass MetricsCalculator2:\n    \"\"\"\n    The class provides to calculate Mean Reciprocal Rank (MRR) and Mean Average Precision (MAP) based on input data, where MRR measures the ranking quality and MAP measures the average precision.\n    \"\"\"\n\n    def __init__(self):\n        pass\n\n    @staticmethod\n    def mrr(data):\n        \"\"\"\n        compute the MRR of the input data. MRR is a widely used evaluation index. It is the mean of reciprocal rank.\n        :param data: the data must be a tuple, list 0,1,eg.([1,0,...],5).  In each tuple (actual result,ground truth num),ground truth num is the total ground num.\n         ([1,0,...],5),\n        or list of tuple eg. [([1,0,1,...],5),([1,0,...],6),([0,0,...],5)].\n        1 stands for a correct answer, 0 stands for a wrong answer.\n        :return: if input data is list, return the recall of this list. if the input data is list of list, return the\n        average recall on all list. The second return value is a list of precision for each input.\n        >>> MetricsCalculator2.mrr(([1, 0, 1, 0], 4))\n        >>> MetricsCalculator2.mrr([([1, 0, 1, 0], 4), ([0, 1, 0, 1], 4)])\n        1.0, [1.0]\n        0.75, [1.0, 0.5]\n        \"\"\"\n        if type(data) != list and type(data) != tuple:\n            raise Exception(\"the input must be a tuple([0,...,1,...],int) or a iteration of list of tuple\")\n\n        if len(data) == 0:\n            return 0.0, [0.0]\n        if type(data) == tuple:\n            (sub_list, total_num) = data\n            sub_list = np.array(sub_list)\n            if total_num == 0:\n                return 0.0, [0.0]\n            else:\n                ranking_array = 1.0 / (np.array(list(range(len(sub_list)))) + 1)\n                mr_np = sub_list * ranking_array\n\n                mr = 0.0\n                for team in mr_np:\n                    if team > 0:\n                        mr = team\n                        break\n                return mr, [mr]\n\n        if type(data) == list:\n            separate_result = []\n            for (sub_list, total_num) in data:\n                sub_list = np.array(sub_list)\n\n                if total_num == 0:\n                    mr = 0.0\n                else:\n                    ranking_array = 1.0 / (np.array(list(range(len(sub_list)))) + 1)\n                    mr_np = sub_list * ranking_array\n\n                    mr = 0.0\n                    for team in mr_np:\n                        if team > 0:\n                            mr = team\n                            break\n\n                separate_result.append(mr)\n            return np.mean(separate_result), separate_result\n\n\n    @staticmethod\n    def map(data):\n        \"\"\"\n        compute the MAP of the input data. MAP is a widely used evaluation index. It is the mean of AP (average precision).\n        :param data: the data must be a tuple, list 0,1,eg.([1,0,...],5).  In each tuple (actual result,ground truth num),ground truth num is the total ground num.\n         ([1,0,...],5),\n        or list of tuple eg. [([1,0,1,...],5),([1,0,...],6),([0,0,...],5)].\n        1 stands for a correct answer, 0 stands for a wrong answer.\n        :return: if input data is list, return the recall of this list. if the input data is list of list, return the\n        average recall on all list. The second return value is a list of precision for each input.\n        >>> MetricsCalculator2.map(([1, 0, 1, 0], 4))\n        >>> MetricsCalculator2.map([([1, 0, 1, 0], 4), ([0, 1, 0, 1], 4)])\n        0.41666666666666663, [0.41666666666666663]\n        0.3333333333333333, [0.41666666666666663, 0.25]\n        \"\"\"\n        if type(data) != list and type(data) != tuple:\n            raise Exception(\"the input must be a tuple([0,...,1,...],int) or a iteration of list of tuple\")\n\n        if len(data) == 0:\n            return 0.0, [0.0]\n        if type(data) == tuple:\n            (sub_list, total_num) = data\n            sub_list = np.array(sub_list)\n            if total_num == 0:\n                return 0.0, [0.0]\n            else:\n                ranking_array = 1.0 / (np.array(list(range(len(sub_list)))) + 1)\n\n                right_ranking_list = []\n       count = 1\n                for t in sub_list:\n                    if t == 0:\n                        right_ranking_list.append(0)\n                    else:\n                        right_ranking_list.append(count)\n                        count += 1\n\n                ap = np.sum(np.array(right_ranking_list) * ranking_array) / total_num\n                return ap, [ap]\n\n        if type(data) == list:\n            separate_result = []\n            for (sub_list, total_num) in data:\n                sub_list = np.array(sub_list)\n\n                if total_num == 0:\n                    ap = 0.0\n                else:\n                    ranking_array = 1.0 / (np.array(list(range(len(sub_list)))) + 1)\n\n                    right_ranking_list = []\n                    count = 1\n                    for t in sub_list:\n                        if t == 0:\n                            right_ranking_list.append(0)\n                        else:\n                            right_ranking_list.append(count)\n                            count += 1\n\n                    ap = np.sum(np.array(right_ranking_list) * ranking_array) / total_num\n\n                separate_result.append(ap)\n            return np.mean(separate_result), separate_result\n",
        "annotated_code" : "\nimport numpy as np\n\n\nclass MetricsCalculator2:\n    \"\"\"\n    The class provides to calculate Mean Reciprocal Rank (MRR) and Mean Average Precision (MAP) based on input data, where MRR measures the ranking quality and MAP measures the average precision.\n    \"\"\"\n\n    def __init__(self):\n        pass\n\n    @staticmethod\n    def mrr(data):\n        \"\"\"\n        compute the MRR of the input data. MRR is a widely used evaluation index. It is the mean of reciprocal rank.\n        :param data: the data must be a tuple, list 0,1,eg.([1,0,...],5).  In each tuple (actual result,ground truth num),ground truth num is the total ground num.\n         ([1,0,...],5),\n        or list of tuple eg. [([1,0,1,...],5),([1,0,...],6),([0,0,...],5)].\n        1 stands for a correct answer, 0 stands for a wrong answer.\n        :return: if input data is list, return the recall of this list. if the input data is list of list, return the\n        average recall on all list. The second return value is a list of precision for each input.\n        >>> MetricsCalculator2.mrr(([1, 0, 1, 0], 4))\n        >>> MetricsCalculator2.mrr([([1, 0, 1, 0], 4), ([0, 1, 0, 1], 4)])\n        1.0, [1.0]\n        0.75, [1.0, 0.5]\n        \"\"\"\n        # Check if the input is a list or tuple\n        # Check if the length of the input is 0\n        # If the input is a tuple, unpack it into sub_list and total_num\n        # Convert sub_list to a numpy array\n        # If total_num is 0, return 0.0 and a list with a single element 0.0\n        # Otherwise, create a ranking array and calculate the reciprocal rank\n        # If the input is a list, iterate through each tuple in the list\n        # Convert sub_list to a numpy array\n        # If total_num is 0, set mrr to 0.0\n        # Otherwise, create a ranking array and calculate the reciprocal rank\n        if type(data) != list and type(data) != tuple:\n            raise Exception(\"the input must be a tuple([0,...,1,...],int) or a iteration of list of tuple\")\n\n        if len(data) == 0:\n            return 0.0, [0.0]\n        if type(data) == tuple:\n            (sub_list, total_num) = data\n            sub_list = np.array(sub_list)\n            if total_num == 0:\n                return 0.0, [0.0]\n            else:\n                ranking_array = 1.0 / (np.array(list(range(len(sub_list)))) + 1)\n                mr_np = sub_list * ranking_array\n\n                mr = 0.0\n                for team in mr_np:\n                    if team > 0:\n                        mr = team\n                        break\n                return mr, [mr]\n\n        if type(data) == list:\n            separate_result = []\n            for (sub_list, total_num) in data:\n                sub_list = np.array(sub_list)\n\n                if total_num == 0:\n                    mr = 0.0\n                else:\n                    ranking_array = 1.0 / (np.array(list(range(len(sub_list)))) + 1)\n                    mr_np = sub_list * ranking_array\n\n                    mr = 0.0\n                    for team in mr_np:\n                        if team > 0:\n                            mr = team\n                            break\n\n                separate_result.append(mr)\n            return np.mean(separate_result), separate_result\n\n\n    @staticmethod\n    def map(data):\n        \"\"\"\n        compute the MAP of the input data. MAP is a widely used evaluation index. It is the mean of AP (average precision).\n        :param data: the data must be a tuple, list 0,1,eg.([1,0,...],5).  In each tuple (actual result,ground truth num),ground truth num is the total ground num.\n         ([1,0,...],5),\n        or list of tuple eg. [([1,0,1,...],5),([1,0,...],6),([0,0,...],5)].\n        1 stands for a correct answer, 0 stands for a wrong answer.\n        :return: if input data is list, return the recall of this list. if the input data is list of list, return the\n        average recall on all list. The second return value is a list of precision for each input.\n        >>> MetricsCalculator2.map(([1, 0, 1, 0], 4))\n        >>> MetricsCalculator2.map([([1, 0, 1, 0], 4), ([0, 1, 0, 1], 4)])\n        0.41666666666666663, [0.41666666666666663]\n        0.3333333333333333, [0.41666666666666663, 0.25]\n        \"\"\"\n        # Check if the input is a list or tuple\n        # Check if the length of the input is 0\n        # If the input is a tuple, unpack it into sub_list and total_num\n        # Convert sub_list to a numpy array\n        # If total_num is 0, return 0.0 and a list with a single element 0.0\n        # Otherwise, create a ranking array and calculate the average precision\n        # If the input is a list, iterate through each tuple in the list\n        # Convert sub_list to a numpy array\n        # If total_num is 0, set ap to 0.0\n        # Otherwise, create a ranking array and calculate the average precision\n        # Append the average precision to the separate_result list\n        if type(data) != list and type(data) != tuple:\n            raise Exception(\"the input must be a tuple([0,...,1,...],int) or a iteration of list of tuple\")\n\n        if len(data) == 0:\n            return 0.0, [0.0]\n        if type(data) == tuple:\n            (sub_list, total_num) = data\n            sub_list = np.array(sub_list)\n            if total_num == 0:\n                return 0.0, [0.0]\n            else:\n                ranking_array = 1.0 / (np.array(list(range(len(sub_list)))) + 1)\n\n                right_ranking_list = []\n                count = 1\n                for t in sub_list:\n                    if t == 0:\n                        right_ranking_list.append(0)\n                    else:\n                        right_ranking_list.append(count)\n          count += 1\n\n                ap = np.sum(np.array(right_ranking_list) * ranking_array) / total_num\n                return ap, [ap]\n\n        if type(data) == list:\n            separate_result = []\n            for (sub_list, total_num) in data:\n                sub_list = np.array(sub_list)\n\n                if total_num == 0:\n                    ap = 0.0\n     else:\n                    ranking_array = 1.0 / (np.array(list(range(len(sub_list)))) + 1)\n\n                    right_ranking_list = []\n                    count = 1\n   for t in sub_list:\n                        if t == 0:\n                            right_ranking_list.append(0)\n                        else:\n                            right_ranking_list.append(count)\n                            count += 1\n\n                    ap = np.sum(np.array(right_ranking_list) * ranking_array) / total_num\n\n                separate_result.append(ap)\n            return np.mean(separate_result), separate_result\n"
    },
    {
        "id" : "58",
        "code" : "\nimport random\n\nclass MinesweeperGame:\n    \"\"\"\n    This is a class that implements mine sweeping games including minesweeping and winning judgment.\n    \"\"\"\n\n    def __init__(self, n, k) -> None:\n        \"\"\"\n        Initializes the MinesweeperGame class with the size of the board and the number of mines.\n        :param n: The size of the board, int.\n        :param k: The number of mines, int.\n        \"\"\"\n        self.n = n\n        self.k = k\n        self.minesweeper_map = self.generate_mine_sweeper_map()\n        self.player_map = self.generate_playerMap()\n        self.score = 0\n\n    def generate_mine_sweeper_map(self):\n        \"\"\"\n        Generates a minesweeper map with the given size of the board and the number of mines,the given parameter n is the size of the board,the size of the board is n*n,the parameter k is the number of mines,'X' represents the mine,other numbers represent the number of mines around the position.\n        :return: The minesweeper map, list.\n        >>> minesweeper_game = MinesweeperGame(3, 1)\n        >>> minesweeper_game.generate_mine_sweeper_map()\n        [['X', 1, 0], [1, 1, 0], [0, 0, 0]]\n\n        \"\"\"\n        arr = [[0 for row in range(self.n)] for column in range(self.n)]\n        for num in range(self.k):\n            x = random.randint(0, self.n-1)\n            y = random.randint(0, self.n-1)\n            arr[y][x] = 'X'\n            if (x >=0 and x <= self.n-2) and (y >= 0 and y <= self.n-1):\n                if arr[y][x+1] != 'X':\n           arr[y][x+1] += 1\n            if (x >=1 and x <= self.n-1) and (y >= 0 and y <= self.n-1):\n                if arr[y][x-1] != 'X':\n                    arr[y][x-1] += 1\nif (x >= 1 and x <= self.n-1) and (y >= 1 and y <= self.n-1):\n                if arr[y-1][x-1] != 'X':\n                    arr[y-1][x-1] += 1\n\n            if (x >= 0 and x <= self.n-2) and (y >= 1 and y <= self.n-1):\n                if arr[y-1][x+1] != 'X':\n                    arr[y-1][x+1] += 1\n            if (x >= 0 and x <= self.n-1) and (y >= 1 and y <= self.n-1):\n                if arr[y-1][x] != 'X':\n                    arr[y-1][x] += 1\n\n            if (x >=0 and x <= self.n-2) and (y >= 0 and y <= self.n-2):\n                if arr[y+1][x+1] != 'X':\n                    arr[y+1][x+1] += 1\n            if (x >= 1 and x <= self.n-1) and (y >= 0 and y <= self.n-2):\n                if arr[y+1][x-1] != 'X':\n                    arr[y+1][x-1] += 1\n            if (x >= 0 and x <= self.n-1) and (y >= 0 and y <= self.n-2):\n                if arr[y+1][x] != 'X':\n                    arr[y+1][x] += 1\n        return arr\n\n    def generate_playerMap(self):\n        \"\"\"\n        Generates a player map with the given size of the board, the given parameter n is the size of the board,the size of the board is n*n,the parameter k is the number of mines,'-' represents the unknown position.\n        :return: The player map, list.\n        >>> minesweeper_game = MinesweeperGame(3, 1)\n        >>> minesweeper_game.generate_playerMap()\n        [['-', '-', '-'], ['-', '-', '-'], ['-', '-', '-']]\n\n        \"\"\"\n        arr = [['-' for row in range(self.n)] for column in range(self.n)]\n        return arr\n\n    def check_won(self,map):\n        \"\"\"\n        Checks whether the player has won the game,if there are just mines in the player map,return True,otherwise return False.\n        :return: True if the player has won the game, False otherwise.\n        >>> minesweeper_game = MinesweeperGame(3, 1)\n        >>> minesweeper_game.minesweeper_map = [['X', 1, 0], [1, 1, 0], [0, 0, 0]]\n        >>> minesweeper_game.player_map = [['-', '-', '-'], ['-', '-', '-'], ['-', '-', '-']]\n        >>> minesweeper_game.check_won(minesweeper_game.player_map)\n        False\n\n        \"\"\"\n        for i in range(self.n):\n            for j in range(self.n):\n                if map[i][j] == '-' and self.minesweeper_map[i][j] != 'X':\n                    return False\n        return True\n\n    def sweep(self, x, y):\n        \"\"\"\n        Sweeps the given position.\n        :param x: The x coordinate of the position, int.\n        :param y: The y coordinate of the position, int.\n        :return: True if the player has won the game, False otherwise,if the game still continues, return the player map, list.\n        >>> minesweeper_game = MinesweeperGame(3, 1)\n        >>> minesweeper_game.minesweeper_map = [['X', 1, 0], [1, 1, 0], [0, 0, 0]]\n        >>> minesweeper_game.player_map = [['-', '-', '-'], ['-', '-', '-'], ['-', '-', '-']]\n        >>> minesweeper_game.sweep(1, 1)\n        [['-', '-', '-'], ['-', 1, '-'], ['-', '-', '-']]\n\n        \"\"\"\n        if (self.minesweeper_map[x][y] == 'X'):\n            return False\n        else:\n            self.player_map[x][y] = self.minesweeper_map[x][y]\n            self.score += 1\n            if self.check_won(self.player_map) == True:\n                return True\n return self.player_map\n",
        "annotated_code" : "\nimport random\n\nclass MinesweeperGame:\n    \"\"\"\n    This is a class that implements mine sweeping games including minesweeping and winning judgment.\n    \"\"\"\n\n    def __init__(self, n, k) -> None:\n        \"\"\"\n        Initializes the MinesweeperGame class with the size of the board and the number of mines.\n        :param n: The size of the board, int.\n        :param k: The number of mines, int.\n        \"\"\"\n        self.n = n\n        self.k = k\n        self.minesweeper_map = self.generate_mine_sweeper_map()\n        self.player_map = self.generate_playerMap()\n        self.score = 0\n\n    def generate_mine_sweeper_map(self):\n        \"\"\"\n        Generates a minesweeper map with the given size of the board and the number of mines,the given parameter n is the size of the board,the size of the board is n*n,the parameter k is the number of mines,'X' represents the mine,other numbers represent the number of mines around the position.\n        :return: The minesweeper map, list.\n        >>> minesweeper_game = MinesweeperGame(3, 1)\n        >>> minesweeper_game.generate_mine_sweeper_map()\n        [['X', 1, 0], [1, 1, 0], [0, 0, 0]]\n\n        \"\"\"\n        # This function generates a minesweeper map with the given size of the board and the number of mines.\n        arr = [[0 for row in range(self.n)] for column in range(self.n)]\n        for num in range(self.k):\n            x = random.randint(0, self.n-1)\n            y = random.randint(0, self.n-1)\n            arr[y][x] = 'X'\nif (x >=0 and x <= self.n-2) and (y >= 0 and y <= self.n-1):\n                if arr[y][x+1] != 'X':\n                    arr[y][x+1] += 1\n            if (x >=1 and x <= self.n-1) and (y >= 0 and y <= self.n-1):\n                if arr[y][x-1] != 'X':\n                    arr[y][x-1] += 1\n            if (x >= 1 and x <= self.n-1) and (y >= 1 and y <= self.n-1):\n                if arr[y-1][x-1] != 'X':\n                    arr[y-1][x-1] += 1\n\n            if (x >= 0 and x <= self.n-2) and (y >= 1 and y <= self.n-1):\n                if arr[y-1][x+1] != 'X':\n         arr[y-1][x+1] += 1\n            if (x >= 0 and x <= self.n-1) and (y >= 1 and y <= self.n-1):\n                if arr[y-1][x] != 'X':\n                    arr[y-1][x] += 1\n\n   if (x >=0 and x <= self.n-2) and (y >= 0 and y <= self.n-2):\n                if arr[y+1][x+1] != 'X':\n                    arr[y+1][x+1] += 1\n            if (x >= 1 and x <= self.n-1) and (y >= 0 and y <= self.n-2):\n                if arr[y+1][x-1] != 'X':\n                    arr[y+1][x-1] += 1\n            if (x >= 0 and x <= self.n-1) and (y >= 0 and y <= self.n-2):\n                if arr[y+1][x] != 'X':\n                    arr[y+1][x] += 1\n        return arr\n\n    def generate_playerMap(self):\n        \"\"\"\n        Generates a player map with the given size of the board, the given parameter n is the size of the board,the size of the board is n*n,the parameter k is the number of mines,'-' represents the unknown position.\n        :return: The player map, list.\n        >>> minesweeper_game = MinesweeperGame(3, 1)\n        >>> minesweeper_game.generate_playerMap()\n        [['-', '-', '-'], ['-', '-', '-'], ['-', '-', '-']]\n\n        \"\"\"\n        # This function generates a player map with the given size of the board.\n        arr = [['-' for row in range(self.n)] for column in range(self.n)]\n        return arr\n\n    def check_won(self,map):\n        \"\"\"\n        Checks whether the player has won the game,if there are just mines in the player map,return True,otherwise return False.\n        :return: True if the player has won the game, False otherwise.\n        >>> minesweeper_game = MinesweeperGame(3, 1)\n        >>> minesweeper_game.minesweeper_map = [['X', 1, 0], [1, 1, 0], [0, 0, 0]]\n        >>> minesweeper_game.player_map = [['-', '-', '-'], ['-', '-', '-'], ['-', '-', '-']]\n        >>> minesweeper_game.check_won(minesweeper_game.player_map)\n        False\n\n        \"\"\"\n        # This function checks whether the player has won the game.\n        # If there are just mines in the player map, return True, otherwise return False.\n        for i in range(self.n):\n            for j in range(self.n):\n                if map[i][j] == '-' and self.minesweeper_map[i][j] != 'X':\n                    return False\n        return True\n\n    def sweep(self, x, y):\n        \"\"\"\n        Sweeps the given position.\n        :param x: The x coordinate of the position, int.\n        :param y: The y coordinate of the position, int.\n        :return: True if the player has won the game, False otherwise,if the game still continues, return the player map, list.\n        >>> minesweeper_game = MinesweeperGame(3, 1)\n        >>> minesweeper_game.minesweeper_map = [['X', 1, 0], [1, 1, 0], [0, 0, 0]]\n        >>> minesweeper_game.player_map = [['-', '-', '-'], ['-', '-', '-'], ['-', '-', '-']]\n        >>> minesweeper_game.sweep(1, 1)\n        [['-', '-', '-'], ['-', 1, '-'], ['-', '-', '-']]\n\n        \"\"\"\n        # This function sweeps the given position.\n        # If the player sweeps a mine, return False.\n        # If the player sweeps a number, increase the score by 1 and check whether the player has won the game.\n        # If the player has won the game, return True.\n        # If the player has not won the game, return the player map.\n        if (self.minesweeper_map[x][y] == 'X'):\n            return False\n        else:\n            self.player_map[x][y] = self.minesweeper_map[x][y]\n            self.score += 1\n            if self.check_won(self.player_map) == True:\n                return True\n            return self.player_map\n"
    },
    {
        "id" : "59",
        "code" : "\nfrom datetime import datetime\nimport numpy as np\n\nclass MovieBookingSystem:\n    \"\"\"\n    this is a class as movie booking system, which allows to add movies, book tickets and check the available movies within a given time range.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize movies contains the information about movies\n        >>> system.movies\n        [{'name': 'Batman', 'price': 49.9, 'start_time': datetime.datetime(1900, 1, 1, 17, 5), 'end_time': datetime.datetime(1900, 1, 1, 19, 25),\n        'seats': array([[0., 0., 0.],\n            [0., 0., 0.],\n            [0., 0., 0.]])}]\n        \"\"\"\n        self.movies = []\n\n    def add_movie(self, name, price, start_time, end_time, n):\n        \"\"\"\n        Add a new movie into self.movies\n        :param name: str, movie name\n        :param price: float, price for one ticket\n        :param start_time: str\n        :param end_time: str\n        :param n: int, the size of seats(n*n)\n        >>> system.add_movie('Batman', 49.9, '17:05', '19:25', 3)\n        >>> system.movies\n        [{'name': 'Batman', 'price': 49.9, 'start_time': datetime.datetime(1900, 1, 1, 17, 5), 'end_time': datetime.datetime(1900, 1, 1, 19, 25),\n        'seats': array([[0., 0., 0.],\n            [0., 0., 0.],\n            [0., 0., 0.]])}]\n        \"\"\"\n        movie = {\n            'name': name,\n            'price': price,\n            'start_time': datetime.strptime(start_time, '%H:%M'),\n            'end_time': datetime.strptime(end_time, '%H:%M'),\n            'seats': np.zeros((n, n))\n        }\n        self.movies.append(movie)\n\n    def book_ticket(self, name, seats_to_book):\n        \"\"\"\n        Book tickets for a movie. Change the seats value in self.movies if book successfully.\n        :param name: str, movie name\n        :param seats_to_book: list of tuples, representing seats to book [(row1, col1), (row2, col2), ...]\n        :return: str, booking status message. \"Movie not found.\" for no such movie.\n                \"Booking success.\" for successfully booking, or \"Booking failed.\" otherwise\n        >>> system.add_movie('Batman', 49.9, '17:05', '19:25', 3)\n        >>> system.book_ticket('Batman', [(0, 0), (0, 1)])\n        'Booking success.'\n        >>> system.book_ticket('Batman', [(0, 0)])\n        'Booking failed.'\n        >>> system.book_ticket('batman', [(0, 0)])\n        'Movie not found.'\n        \"\"\"\n        for movie in self.movies:\n            if movie['name'] == name:\n                for seat in seats_to_book:\n                    if movie['seats'][seat[0]][seat[1]] == 0:\n                        movie['seats'][seat[0]][seat[1]] = 1\n                    else:\n                        return \"Booking failed.\"\n                return \"Booking success.\"\n        return \"Movie not found.\"\n\n    def available_movies(self, start_time, end_time):\n        \"\"\"\n        Get a list of available movies within the specified time range\n        :param start_time: str, start time in HH:MM format\n        :param end_time: str, end time in HH:MM format\n        :return: list of str, names of available movies\n        >>> system.add_movie('Batman', 49.9, '17:05', '19:25', 3)\n        >>> system.available_movies('12:00', '22:00')\n        ['Batman']\n        \"\"\"\n        start_time = datetime.strptime(start_time, '%H:%M')\n        end_time = datetime.strptime(end_time, '%H:%M')\n\n        available_movies = []\n        for movie in self.movies:\n            if start_time <= movie['start_time'] and movie['end_time'] <= end_time:\n                available_movies.append(movie['name'])\n\n        return available_movies\n",
        "annotated_code" : "\nfrom datetime import datetime\nimport numpy as np\n\nclass MovieBookingSystem:\n    \"\"\"\n    this is a class as movie booking system, which allows to add movies, book tickets and check the available movies within a given time range.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize movies contains the information about movies\n        >>> system.movies\n        [{'name': 'Batman', 'price': 49.9, 'start_time': datetime.datetime(1900, 1, 1, 17, 5), 'end_time': datetime.datetime(1900, 1, 1, 19, 25),\n        'seats': array([[0., 0., 0.],\n            [0., 0., 0.],\n            [0., 0., 0.]])}]\n        \"\"\"\n        self.movies = []\n\n    def add_movie(self, name, price, start_time, end_time, n):\n        \"\"\"\n        Add a new movie into self.movies\n        :param name: str, movie name\n        :param price: float, price for one ticket\n        :param start_time: str\n        :param end_time: str\n        :param n: int, the size of seats(n*n)\n        >>> system.add_movie('Batman', 49.9, '17:05', '19:25', 3)\n        >>> system.movies\n        [{'name': 'Batman', 'price': 49.9, 'start_time': datetime.datetime(1900, 1, 1, 17, 5), 'end_time': datetime.datetime(1900, 1, 1, 19, 25),\n        'seats': array([[0., 0., 0.],\n            [0., 0., 0.],\n            [0., 0., 0.]])}]\n        \"\"\"\n        # Create a new movie dictionary and append it to the movies list\n        movie = {\n            'name': name,\n            'price': price,\n            'start_time': datetime.strptime(start_time, '%H:%M'),\n            'end_time': datetime.strptime(end_time, '%H:%M'),\n            'seats': np.zeros((n, n))\n        }\n        self.movies.append(movie)\n\n    def book_ticket(self, name, seats_to_book):\n        \"\"\"\n        Book tickets for a movie. Change the seats value in self.movies if book successfully.\n        :param name: str, movie name\n        :param seats_to_book: list of tuples, representing seats to book [(row1, col1), (row2, col2), ...]\n        :return: str, booking status message. \"Movie not found.\" for no such movie.\n                \"Booking success.\" for successfully booking, or \"Booking failed.\" otherwise\n        >>> system.add_movie('Batman', 49.9, '17:05', '19:25', 3)\n        >>> system.book_ticket('Batman', [(0, 0), (0, 1)])\n        'Booking success.'\n        >>> system.book_ticket('Batman', [(0, 0)])\n        'Booking failed.'\n        >>> system.book_ticket('batman', [(0, 0)])\n        'Movie not found.'\n        \"\"\"\n        # Check if the movie exists in the list\n        # Iterate through the movies list to find the movie by name\n        # If found, check if the seats are available and book them\n        # If seats are already booked, return \"Booking failed.\"\n        # If the movie is not found, return \"Movie not found.\"\n        for movie in self.movies:\n   if movie['name'] == name:\n                for seat in seats_to_book:\n                    if movie['seats'][seat[0]][seat[1]] == 0:\n                        movie['seats'][seat[0]][seat[1]] = 1\n                    else:\n                        return \"Booking failed.\"\n                return \"Booking success.\"\n        return \"Movie not found.\"\n\n    def available_movies(self, start_time, end_time):\n        \"\"\"\n        Get a list of available movies within the specified time range\n        :param start_time: str, start time in HH:MM format\n        :param end_time: str, end time in HH:MM format\n        :return: list of str, names of available movies\n        >>> system.add_movie('Batman', 49.9, '17:05', '19:25', 3)\n        >>> system.available_movies('12:00', '22:00')\n        ['Batman']\n        \"\"\"\n        # Convert start_time and end_time to datetime objects for comparison\n        # Iterate through the movies list and check if the movie's start and end times fall within the given range\n        # Return a list of movie names that are available within the specified time range\n        start_time = datetime.strptime(start_time, '%H:%M')\n        end_time = datetime.strptime(end_time, '%H:%M')\n\n        available_movies = []\n        for movie in self.movies:\n            if start_time <= movie['start_time'] and movie['end_time'] <= end_time:\n                available_movies.append(movie['name'])\n\n        return available_movies\n"
    },
    {
        "id" : "60",
        "code" : "\nimport sqlite3\n\nclass MovieTicketDB:\n    \"\"\"\n    This is a class for movie database operations, which allows for inserting movie information, searching for movie information by name, and deleting movie information by name.\n    \"\"\"\n\n    def __init__(self, db_name):\n        \"\"\"\n        Initializes the MovieTicketDB object with the specified database name.\n        :param db_name: str, the name of the SQLite database.\n        \"\"\"\n        self.connection = sqlite3.connect(db_name)\n        self.cursor = self.connection.cursor()\n        self.create_table()\n\n\n    def create_table(self):\n        \"\"\"\n        Creates a \"tickets\" table in the database if it does not exist already.Fields include ID of type int, movie name of type str, theater name of type str, seat number of type str, and customer name of type str\n        :return: None\n        \"\"\"\n        self.cursor.execute(\"\"\"\n            CREATE TABLE IF NOT EXISTS tickets (\n                id INTEGER PRIMARY KEY,\n                movie_name TEXT,\n                theater_name TEXT,\n                seat_number TEXT,\n                customer_name TEXT\n            )\n        \"\"\")\n        self.connection.commit()\n\n    def insert_ticket(self, movie_name, theater_name, seat_number, customer_name):\n        \"\"\"\n        Inserts a new ticket into the \"tickets\" table.\n        :param movie_name: str, the name of the movie.\n        :param theater_name: str, the name of the theater.\n        :param seat_number: str, the seat number.\n        :param customer_name: str, the name of the customer.\n        :return: None\n        \"\"\"\n        self.cursor.execute(\"\"\"\n            INSERT INTO tickets (movie_name, theater_name, seat_number, customer_name)\n            VALUES (?, ?, ?, ?)\n        \"\"\", (movie_name, theater_name, seat_number, customer_name))\n        self.connection.commit()\n\n    def search_tickets_by_customer(self, customer_name):\n        \"\"\"\n        Searches for tickets in the \"tickets\" table by customer name.\n        :param customer_name: str, the name of the customer to search for.\n        :return: list of tuples, the rows from the \"tickets\" table that match the search criteria.\n        >>> ticket_db = MovieTicketDB(\"ticket_database.db\")\n        >>> ticket_db.create_table()\n        >>> ticket_db.insert_ticket(\"Movie A\", \"Theater 1\", \"A1\", \"John Doe\")\n        >>> result = ticket_db.search_tickets_by_customer(\"John Doe\")\n        len(result) = 1\n        \"\"\"\n        self.cursor.execute(\"\"\"\n            SELECT * FROM tickets WHERE customer_name = ?\n        \"\"\", (customer_name,))\n        tickets = self.cursor.fetchall()\n        return tickets\n\n    def delete_ticket(self, ticket_id):\n        \"\"\"\n        Deletes a ticket from the \"tickets\" table by ticket ID.\n        :param ticket_id: int, the ID of the ticket to delete.\n        :return: None\n        \"\"\"\n        self.cursor.execute(\"\"\"\n            DELETE FROM tickets WHERE id = ?\n        \"\"\", (ticket_id,))\n        self.connection.commit()\n",
        "annotated_code" : "\nimport sqlite3\n\nclass MovieTicketDB:\n    \"\"\"\n    This is a class for movie database operations, which allows for inserting movie information, searching for movie information by name, and deleting movie information by name.\n    \"\"\"\n\n    def __init__(self, db_name):\n        \"\"\"\n        Initializes the MovieTicketDB object with the specified database name.\n        :param db_name: str, the name of the SQLite database.\n        \"\"\"\n        self.connection = sqlite3.connect(db_name)\n        self.cursor = self.connection.cursor()\n        self.create_table()\n\n\n    def create_table(self):\n        \"\"\"\n        Creates a \"tickets\" table in the database if it does not exist already.Fields include ID of type int, movie name of type str, theater name of type str, seat number of type str, and customer name of type str\n        :return: None\n        \"\"\"\n        # Create the \"tickets\" table if it does not exist using SQLite syntax.\n        # The table will have the following fields: ID (int), movie name (str), theater name (str), seat number (str), and customer name (str)\n        self.cursor.execute(\"\"\"\n            CREATE TABLE IF NOT EXISTS tickets (\n                id INTEGER PRIMARY KEY,\n                movie_name TEXT,\n                theater_name TEXT,\n                seat_number TEXT,\n                customer_name TEXT\n            )\n        \"\"\")\n        self.connection.commit()\n\n    def insert_ticket(self, movie_name, theater_name, seat_number, customer_name):\n        \"\"\"\n        Inserts a new ticket into the \"tickets\" table.\n        :param movie_name: str, the name of the movie.\n        :param theater_name: str, the name of the theater.\n        :param seat_number: str, the seat number.\n        :param customer_name: str, the name of the customer.\n        :return: None\n        \"\"\"\n        # Insert a new ticket into the \"tickets\" table using SQLite syntax.\n        # The ticket will include the following fields: movie name (str), theater name (str), seat number (str), and customer name (str)\n        self.cursor.execute(\"\"\"\n            INSERT INTO tickets (movie_name, theater_name, seat_number, customer_name)\n            VALUES (?, ?, ?, ?)\n        \"\"\", (movie_name, theater_name, seat_number, customer_name))\n        self.connection.commit()\n\n    def search_tickets_by_customer(self, customer_name):\n        \"\"\"\n        Searches for tickets in the \"tickets\" table by customer name.\n        :param customer_name: str, the name of the customer to search for.\n        :return: list of tuples, the rows from the \"tickets\" table that match the search criteria.\n        >>> ticket_db = MovieTicketDB(\"ticket_database.db\")\n        >>> ticket_db.create_table()\n        >>> ticket_db.insert_ticket(\"Movie A\", \"Theater 1\", \"A1\", \"John Doe\")\n        >>> result = ticket_db.search_tickets_by_customer(\"John Doe\")\n        len(result) = 1\n        \"\"\"\n        # Search for tickets in the \"tickets\" table by customer name using SQLite syntax.\n        # The search will return a list of tuples containing the rows that match the search criteria.\n        self.cursor.execute(\"\"\"\n            SELECT * FROM tickets WHERE customer_name = ?\n        \"\"\", (customer_name,))\n        tickets = self.cursor.fetchall()\n        return tickets\n\n    def delete_ticket(self, ticket_id):\n        \"\"\"\n        Deletes a ticket from the \"tickets\" table by ticket ID.\n        :param ticket_id: int, the ID of the ticket to delete.\n        :return: None\n        \"\"\"\n        # Delete a ticket from the \"tickets\" table by ticket ID using SQLite syntax.\n        # The ticket will be deleted from the table if it exists.\n        self.cursor.execute(\"\"\"\n            DELETE FROM tickets WHERE id = ?\n        \"\"\", (ticket_id,))\n        self.connection.commit()\n"
    },
    {
        "id" : "61",
        "code" : "\nclass MusicPlayer:\n    \"\"\"\n    This is a class as a music player that provides to play, stop, add songs, remove songs, set volume, shuffle, and switch to the next or previous song.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initializes the music player with an empty playlist, no current song, and a default volume of 50.\n        \"\"\"\n        self.playlist = []\n        self.current_song = None\n        self.volume = 50\n\n    def add_song(self, song):\n        \"\"\"\n        Adds a song to the playlist.\n        :param song: The song to add to the playlist, str.\n        >>> musicPlayer = MusicPlayer()\n        >>> musicPlayer.add_song(\"song1\")\n        >>> musicPlayer.playlist\n        ['song1']\n\n        \"\"\"\n        self.playlist.append(song)\n\n    def remove_song(self, song):\n        \"\"\"\n        Removes a song from the playlist.\n        :param song: The song to remove from the playlist, str.\n        >>> musicPlayer = MusicPlayer()\n        >>> musicPlayer.playlist = [\"song1\", \"song2\"]\n        >>> musicPlayer.remove_song(\"song1\")\n        >>> musicPlayer.playlist\n        ['song2']\n\n        \"\"\"\n        if song in self.playlist:\n            self.playlist.remove(song)\n            if self.current_song == song:\n                self.stop()\n\n    def play(self):\n        \"\"\"\n        Plays the current song in the playlist.\n        :return: The current song in the playlist, or False if there is no current song.\n        >>> musicPlayer = MusicPlayer()\n        >>> musicPlayer.playlist = [\"song1\", \"song2\"]\n        >>> musicPlayer.current_song = \"song1\"\n        >>> musicPlayer.play()\n        'song1'\n\n        \"\"\"\n        if self.playlist and self.current_song:\n            return self.playlist[0]\n        elif len(self.playlist):\n            return False\n\n    def stop(self):\n        \"\"\"\n        Stops the current song in the playlist.\n        :return: True if the current song was stopped, False if there was no current song.\n        >>> musicPlayer = MusicPlayer()\n        >>> musicPlayer.playlist = [\"song1\", \"song2\"]\n        >>> musicPlayer.current_song = \"song1\"\n        >>> musicPlayer.stop()\n        True\n\n        \"\"\"\n        if self.current_song:\n            self.current_song = None\n            return True\n        else:\n            return False\n\n    def switch_song(self):\n        \"\"\"\n        Switches to the next song in the playlist.\n        :return: True if the next song was switched to, False if there was no next song.\n        >>> musicPlayer = MusicPlayer()\n        >>> musicPlayer.playlist = [\"song1\", \"song2\"]\n        >>> musicPlayer.current_song = \"song1\"\n        >>> musicPlayer.switch_song()\n        True\n\n        \"\"\"\n        if self.current_song:\n            current_index = self.playlist.index(self.current_song)\n            if current_index < len(self.playlist) - 1:\n                self.current_song = self.playlist[current_index + 1]\n                return True\n            else:\n return False\n        else:\n            return False\n\n    def previous_song(self):\n        \"\"\"\n        Switches to the previous song in the playlist.\n        :return: True if the previous song was switched to, False if there was no previous song.\n        >>> musicPlayer = MusicPlayer()\n        >>> musicPlayer.playlist = [\"song1\", \"song2\"]\n        >>> musicPlayer.current_song = \"song2\"\n        >>> musicPlayer.previous_song()\n        True\n\n        \"\"\"\n        if self.current_song:\n            current_index = self.playlist.index(self.current_song)\n            if current_index > 0:\n                self.current_song = self.playlist[current_index - 1]\n                return True\n            else:\n                return False\n        else:\n            return False\n\n    def set_volume(self, volume):\n        \"\"\"\n        Sets the volume of the music player,ifthe volume is between 0 and 100 is valid.\n        :param volume: The volume to set the music player to,int.\n        :return: True if the volume was set, False if the volume was invalid.\n        >>> musicPlayer = MusicPlayer()\n        >>> musicPlayer.set_volume(50)\n        >>> musicPlayer.volume\n        50\n\n        \"\"\"\n        if 0 <= volume <= 100:\n            self.volume = volume\n        else:\n            return False\n\n    def shuffle(self):\n        \"\"\"\n        Shuffles the playlist.\n        :return: True if the playlist was shuffled, False if the playlist was empty.\n        >>> musicPlayer = MusicPlayer()\n        >>> musicPlayer.playlist = [\"song1\", \"song2\"]\n        >>> musicPlayer.shuffle()\n        True\n\n        \"\"\"\n        if self.playlist:\n            import random\n            random.shuffle(self.playlist)\n            return True\n        else:\n            return False\n",
        "annotated_code" : "\nclass MusicPlayer:\n    \"\"\"\n    This is a class as a music player that provides to play, stop, add songs, remove songs, set volume, shuffle, and switch to the next or previous song.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initializes the music player with an empty playlist, no current song, and a default volume of 50.\n        \"\"\"\n        self.playlist = []\n        self.current_song = None\n        self.volume = 50\n\n    def add_song(self, song):\n        \"\"\"\n        Adds a song to the playlist.\n        :param song: The song to add to the playlist, str.\n        >>> musicPlayer = MusicPlayer()\n        >>> musicPlayer.add_song(\"song1\")\n        >>> musicPlayer.playlist\n        ['song1']\n\n        \"\"\"\n        # Add a song to the playlist\n        self.playlist.append(song)\n\n    def remove_song(self, song):\n        \"\"\"\n        Removes a song from the playlist.\n        :param song: The song to remove from the playlist, str.\n        >>> musicPlayer = MusicPlayer()\n        >>> musicPlayer.playlist = [\"song1\", \"song2\"]\n        >>> musicPlayer.remove_song(\"song1\")\n        >>> musicPlayer.playlist\n        ['song2']\n\n        \"\"\"\n        # Remove a song from the playlist\n        # If the song is being played, stop it\n        if song in self.playlist:\n            self.playlist.remove(song)\n            if self.current_song == song:\n                self.stop()\n\n    def play(self):\n        \"\"\"\n        Plays the current song in the playlist.\n        :return: The current song in the playlist, or False if there is no current song.\n        >>> musicPlayer = MusicPlayer()\n        >>> musicPlayer.playlist = [\"song1\", \"song2\"]\n        >>> musicPlayer.current_song = \"song1\"\n        >>> musicPlayer.play()\n        'song1'\n\n        \"\"\"\n        # Play the current song in the playlist\n        # If there is no playlist, return False\n        if self.playlist and self.current_song:\n            return self.playlist[0]\n        elif len(self.playlist):\n            return False\n\n    def stop(self):\n        \"\"\"\n        Stops the current song in the playlist.\n        :return: True if the current song was stopped, False if there was no current song.\n        >>> musicPlayer = MusicPlayer()\n        >>> musicPlayer.playlist = [\"song1\", \"song2\"]\n        >>> musicPlayer.current_song = \"song1\"\n        >>> musicPlayer.stop()\n        True\n\n        \"\"\"\n        # Stop the current song\n        # If there is no current song, return False\n        # If there is a current song, set it to None and return True\n        if self.current_song:\n            self.current_song = None\n            return True\n        else:\n            return False\n\n    def switch_song(self):\n        \"\"\"\n        Switches to the next song in the playlist.\n        :return: True if the next song was switched to, False if there was no next song.\n        >>> musicPlayer = MusicPlayer()\n        >>> musicPlayer.playlist = [\"song1\", \"song2\"]\n        >>> musicPlayer.current_song = \"song1\"\n        >>> musicPlayer.switch_song()\n        True\n\n        \"\"\"\n        # Switches to the next song in the playlist\n        # If there is no current song, return False\n        # If there is a current song, set it to the next song in the playlist and return True\n        # If there is no next song, return False\n        if self.current_song:\n   current_index = self.playlist.index(self.current_song)\n            if current_index < len(self.playlist) - 1:\n                self.current_song = self.playlist[current_index + 1]\n                return True\n            else:\n                return False\n        else:\n            return False\n\n    def previous_song(self):\n        \"\"\"\n        Switches to the previous song in the playlist.\n        :return: True if the previous song was switched to, False if there was no previous song.\n        >>> musicPlayer = MusicPlayer()\n        >>> musicPlayer.playlist = [\"song1\", \"song2\"]\n        >>> musicPlayer.current_song = \"song2\"\n        >>> musicPlayer.previous_song()\n        True\n\n        \"\"\"\n        # Switches to the previous song in the playlist\n        # If there is no current song, return False\n        # If there is a current song, set it to the previous song in the playlist and return True\n        # If there is no previous song, return False\n        if self.current_song:\n            current_index = self.playlist.index(self.current_song)\n            if current_index > 0:\n                self.current_song = self.playlist[current_index - 1]\n                return True\n            else:\n                return False\n        else:\n            return False\n\n    def set_volume(self, volume):\n        \"\"\"\n        Sets the volume of the music player,ifthe volume is between 0 and 100 is valid.\n        :param volume: The volume to set the music player to,int.\n        :return: True if the volume was set, False if the volume was invalid.\n        >>> musicPlayer = MusicPlayer()\n        >>> musicPlayer.set_volume(50)\n        >>> musicPlayer.volume\n        50\n\n        \"\"\"\n        # Set the volume of the music player\n        # If the volume is between 0 and 100, set it and return True\n        # If the volume is not between 0 and 100, return False\n        if 0 <= volume <= 100:\n            self.volume = volume\n        else:\n            return False\n\n    def shuffle(self):\n        \"\"\"\n        Shuffles the playlist.\n        :return: True if the playlist was shuffled, False if the playlist was empty.\n        >>> musicPlayer = MusicPlayer()\n        >>> musicPlayer.playlist = [\"song1\", \"song2\"]\n        >>> musicPlayer.shuffle()\n        True\n\n        \"\"\"\n        # Shuffle the playlist\n        # If the playlist is empty, return False\n        # If the playlist is not empty, shuffle it and return True\n        if self.playlist:\n            import random\n            random.shuffle(self.playlist)\n            return True\n        else:\n            return False\n"
    },
    {
        "id" : "62",
        "code" : "\nclass NLPDataProcessor:\n    \"\"\"\n    The class processes NLP data by removing stop words from a list of strings using a pre-defined stop word list.\n    \"\"\"\n\n\n    def construct_stop_word_list(self):\n        \"\"\"\n        Construct a stop word list including 'a', 'an', 'the'.\n        :return: a list of stop words\n        >>> NLPDataProcessor.construct_stop_word_list()\n        ['a', 'an', 'the']\n        \"\"\"\n        stop_word_list = ['a', 'an', 'the']\n        return stop_word_list\n    def remove_stop_words(self, string_list, stop_word_list):\n        \"\"\"\n        Remove all the stop words from the list of strings.\n        :param string_list: a list of strings\n        :param stop_word_list: a list of stop words\n        :return: a list of words without stop words\n        >>> NLPDataProcessor.process(['This is a test.'])\n        [['This', 'is', 'test.']]\n        \"\"\"\n        answer = []\n        for string in string_list:\n            string_split = string.split()\n            for word in string_split:\n                if word in stop_word_list:\n                    string_split.remove(word)\n            answer.append(string_split)\n        return answer\n    def process(self, string_list):\n        \"\"\"\n        Construct a stop word list including 'a', 'an', 'the', and remove all the stop words from the list of strings.\n        :param string_list: a list of strings\n        :return: a list of words without stop words\n        >>> NLPDataProcessor.process(['This is a test.'])\n        [['This', 'is', 'test.']]\n        \"\"\"\n        stop_word_list = self.construct_stop_word_list()\n        words_list = self.remove_stop_words(string_list, stop_word_list)\n        return words_list\n",
        "annotated_code" : "\nclass NLPDataProcessor:\n    \"\"\"\n    The class processes NLP data by removing stop words from a list of strings using a pre-defined stop word list.\n    \"\"\"\n\n\n    def construct_stop_word_list(self):\n        \"\"\"\n        Construct a stop word list including 'a', 'an', 'the'.\n        :return: a list of stop words\n        >>> NLPDataProcessor.construct_stop_word_list()\n        ['a', 'an', 'the']\n        \"\"\"\n        # Create a stop word list with some common English stop words.\n        stop_word_list = ['a', 'an', 'the']\n        return stop_word_list\n    def remove_stop_words(self, string_list, stop_word_list):\n        \"\"\"\n        Remove all the stop words from the list of strings.\n        :param string_list: a list of strings\n        :param stop_word_list: a list of stop words\n        :return: a list of words without stop words\n        >>> NLPDataProcessor.process(['This is a test.'])\n        [['This', 'is', 'test.']]\n        \"\"\"\n        # Remove stop words from the list of strings.\n        # Split each string into words and remove stop words.\n        answer = []\n        for string in string_list:\n            string_split = string.split()\n            for word in string_split:\n                if word in stop_word_list:\n                    string_split.remove(word)\n            answer.append(string_split)\n        return answer\n    def process(self, string_list):\n        \"\"\"\n        Construct a stop word list including 'a', 'an', 'the', and remove all the stop words from the list of strings.\n        :param string_list: a list of strings\n        :return: a list of words without stop words\n        >>> NLPDataProcessor.process(['This is a test.'])\n        [['This', 'is', 'test.']]\n        \"\"\"\n        # Create a stop word list\n        # and remove stop words from the list of strings.\n        stop_word_list = self.construct_stop_word_list()\n        words_list = self.remove_stop_words(string_list, stop_word_list)\n        return words_list\n"
    },
    {
        "id" : "63",
        "code" : "\nimport re\nfrom collections import Counter\n\nclass NLPDataProcessor2:\n    \"\"\"\n    The class processes NLP data by extracting words from a list of strings, calculating the frequency of each word, and returning the top 5 most frequent words.\n    \"\"\"\n\n\n    def process_data(self, string_list):\n        \"\"\"\n        keep only English letters and spaces in the string, then convert the string to lower case, and then split the string into a list of words.\n        :param string_list: a list of strings\n        :return: words_list: a list of words lists\n        >>> NLPDataProcessor.process_data(['This is a test.'])\n        [['this', 'is', 'a', 'test']]\n        \"\"\"\n        words_list = []\n        for string in string_list:\n            # Remove non-English letters and convert to lowercase\n            processed_string = re.sub(r'[^a-zA-Z\\s]', '', string.lower())\n            # Split the string into words\n            words = processed_string.split()\n            words_list.append(words)\n        return words_list\n\n    def calculate_word_frequency(self, words_list):\n        \"\"\"\n        Calculate the word frequency of each word in the list of words list, and sort the word frequency dictionary by value in descending order.\n        :param words_list: a list of words lists\n        :return: top 5 word frequency dictionary, a dictionary of word frequency, key is word, value is frequency\n        >>> NLPDataProcessor.calculate_word_frequency([['this', 'is', 'a', 'test'], ['this', 'is', 'another', 'test']])\n        {'this': 2, 'is': 2, 'test': 2, 'a': 1, 'another': 1}\n        \"\"\"\n        word_frequency = Counter()\n        for words in words_list:\n            word_frequency.update(words)\n        sorted_word_frequency = dict(sorted(word_frequency.items(), key=lambda x: x[1], reverse=True))\n        top_5_word_frequency = dict(list(sorted_word_frequency.items())[:5])\n        return top_5_word_frequency\n\n    def process(self, string_list):\n        \"\"\"\n        keep only English letters and spaces in the string, then convert the string to lower case, and then split the string into a list of words. Calculate the word frequency of each word in the list of words list, and sort the word frequency dictionary by value in descending order.\n        :param string_list: a list of strings\n        :return: top 5 word frequency dictionary, a dictionary of word frequency, key is word, value is frequency\n        >>> NLPDataProcessor.process(['This is a test.', 'This is another test.'])\n        {'this': 2, 'is': 2, 'test': 2, 'a': 1, 'another': 1}\n        \"\"\"\n        words_list = self.process_data(string_list)\n        word_frequency_dict = self.calculate_word_frequency(words_list)\n        return word_frequency_dict\n",
        "annotated_code" : "\nimport re\nfrom collections import Counter\n\nclass NLPDataProcessor2:\n    \"\"\"\n    The class processes NLP data by extracting words from a list of strings, calculating the frequency of each word, and returning the top 5 most frequent words.\n    \"\"\"\n\n\n    def process_data(self, string_list):\n        \"\"\"\n        keep only English letters and spaces in the string, then convert the string to lower case, and then split the string into a list of words.\n        :param string_list: a list of strings\n        :return: words_list: a list of words lists\n        >>> NLPDataProcessor.process_data(['This is a test.'])\n        [['this', 'is', 'a', 'test']]\n        \"\"\"\n        # Initialize an empty list to store the processed words\n        # Remove non-English letters and convert to lowercase using regex\n        # Split the string into words using split() method\n        words_list = []\n        for string in string_list:\n            # Remove non-English letters and convert to lowercase\n            processed_string = re.sub(r'[^a-zA-Z\\s]', '', string.lower())\n            # Split the string into words\n            words = processed_string.split()\n            words_list.append(words)\n        return words_list\n\n    def calculate_word_frequency(self, words_list):\n        \"\"\"\n        Calculate the word frequency of each word in the list of words list, and sort the word frequency dictionary by value in descending order.\n        :param words_list: a list of words lists\n        :return: top 5 word frequency dictionary, a dictionary of word frequency, key is word, value is frequency\n        >>> NLPDataProcessor.calculate_word_frequency([['this', 'is', 'a', 'test'], ['this', 'is', 'another', 'test']])\n        {'this': 2, 'is': 2, 'test': 2, 'a': 1, 'another': 1}\n        \"\"\"\n        # Initialize an empty Counter object to store word frequencies\n        # Calculate the frequency of each word in the list of words lists using Counter\n        # Sort the word frequency dictionary by value in descending order\n        word_frequency = Counter()\n        for words in words_list:\n            word_frequency.update(words)\n        sorted_word_frequency = dict(sorted(word_frequency.items(), key=lambda x: x[1], reverse=True))\n        top_5_word_frequency = dict(list(sorted_word_frequency.items())[:5])\n        return top_5_word_frequency\n\n    def process(self, string_list):\n        \"\"\"\n        keep only English letters and spaces in the string, then convert the string to lower case, and then split the string into a list of words. Calculate the word frequency of each word in the list of words list, and sort the word frequency dictionary by value in descending order.\n        :param string_list: a list of strings\n        :return: top 5 word frequency dictionary, a dictionary of word frequency, key is word, value is frequency\n        >>> NLPDataProcessor.process(['This is a test.', 'This is another test.'])\n        {'this': 2, 'is': 2, 'test': 2, 'a': 1, 'another': 1}\n        \"\"\"\n        # Keep only English letters and spaces in the string, then convert the string to lower case, and then split the string into a list of words.\n        # Calculate the word frequency of each word in the list of words list, and sort the word frequency dictionary by value in descending order.\n        words_list = self.process_data(string_list)\n        word_frequency_dict = self.calculate_word_frequency(words_list)\n        return word_frequency_dict\n"
    },
    {
        "id" : "64",
        "code" : "\nclass NumberConverter:\n    \"\"\"\n    The class allows to convert  decimal to binary, octal and hexadecimal repectively and contrarily\n    \"\"\"\n\n    @staticmethod\n    def decimal_to_binary(decimal_num):\n        \"\"\"\n        Convert a number from decimal format to binary format.\n        :param decimal_num: int, decimal number\n        :return: str, the binary representation of an integer.\n        >>> NumberConverter.decimal_to_binary(42423)\n        '1010010110110111'\n        \"\"\"\n        binary_num = bin(decimal_num)[2:]\n        return binary_num\n\n    @staticmethod\n    def binary_to_decimal(binary_num):\n        \"\"\"\n        Convert a number from binary format to decimal format.\n        :param binary_num: str, binary number\n        :return: int, the decimal representation of binary number str.\n        >>> NumberConverter.binary_to_decimal('1010010110110111')\n        42423\n        \"\"\"\n        decimal_num = int(binary_num, 2)\n        return decimal_num\n\n\n    @staticmethod\n    def decimal_to_octal(decimal_num):\n        \"\"\"\n        Convert a number from decimal format to octal format.\n        :param decimal_num: int, decimal number\n        :return: str, the octal representation of an integer.\n        >>> NumberConverter.decimal_to_octal(42423)\n        '122667'\n        \"\"\"\n        octal_num = oct(decimal_num)[2:]\n        return octal_num\n\n    @staticmethod\n    def octal_to_decimal(octal_num):\n        \"\"\"\n        Convert a number from octal format to decimal format.\n        :param octal_num: str, octal num\n        :return: int, the decimal representation of octal number str.\n        >>> NumberConverter.octal_to_decimal('122667')\n        42423\n        \"\"\"\n        decimal_num = int(octal_num, 8)\n        return decimal_num\n\n    @staticmethod\n    def decimal_to_hex(decimal_num):\n        \"\"\"\n        Convert a number from decimal format to hex format.\n        :param decimal_num: int, decimal number\n        :return hex_num: str, the hex representation of an integer.\n        >>> NumberConverter.decimal_to_hex(42423)\n        'a5b7'\n        \"\"\"\n        hex_num = hex(decimal_num)[2:]\n        return hex_num\n\n    @staticmethod\n    def hex_to_decimal(hex_num):\n        \"\"\"\n        Convert a number from hex format to decimal format.\n        :param hex_num: str, hex num\n        :return: int, the decimal representation of hex number str.\n        >>> NumberConverter.hex_to_decimal('a5b7')\n        42423\n        \"\"\"\n        decimal_num = int(hex_num, 16)\n        return decimal_num\n",
        "annotated_code" : "\nclass NumberConverter:\n    \"\"\"\n    The class allows to convert  decimal to binary, octal and hexadecimal repectively and contrarily\n    \"\"\"\n\n    @staticmethod\n    def decimal_to_binary(decimal_num):\n        \"\"\"\n        Convert a number from decimal format to binary format.\n        :param decimal_num: int, decimal number\n        :return: str, the binary representation of an integer.\n        >>> NumberConverter.decimal_to_binary(42423)\n        '1010010110110111'\n        \"\"\"\n        # Convert decimal to binary using bin() function and remove the '0b' prefix\n        binary_num = bin(decimal_num)[2:]\n        return binary_num\n\n    @staticmethod\n    def binary_to_decimal(binary_num):\n        \"\"\"\n        Convert a number from binary format to decimal format.\n        :param binary_num: str, binary number\n        :return: int, the decimal representation of binary number str.\n        >>> NumberConverter.binary_to_decimal('1010010110110111')\n        42423\n        \"\"\"\n        # Convert binary to decimal using int() function with base 2\n        decimal_num = int(binary_num, 2)\n        return decimal_num\n\n\n    @staticmethod\n    def decimal_to_octal(decimal_num):\n        \"\"\"\n        Convert a number from decimal format to octal format.\n        :param decimal_num: int, decimal number\n        :return: str, the octal representation of an integer.\n        >>> NumberConverter.decimal_to_octal(42423)\n        '122667'\n        \"\"\"\n        # Convert decimal to octal using oct() function and remove the '0o' prefix\n        octal_num = oct(decimal_num)[2:]\n        return octal_num\n\n    @staticmethod\n    def octal_to_decimal(octal_num):\n        \"\"\"\n        Convert a number from octal format to decimal format.\n        :param octal_num: str, octal num\n        :return: int, the decimal representation of octal number str.\n        >>> NumberConverter.octal_to_decimal('122667')\n        42423\n        \"\"\"\n        # Convert octal to decimal using int() function with base 8\n        decimal_num = int(octal_num, 8)\n        return decimal_num\n\n    @staticmethod\n    def decimal_to_hex(decimal_num):\n        \"\"\"\n        Convert a number from decimal format to hex format.\n        :param decimal_num: int, decimal number\n        :return hex_num: str, the hex representation of an integer.\n        >>> NumberConverter.decimal_to_hex(42423)\n        'a5b7'\n        \"\"\"\n        # Convert decimal to hex using hex() function and remove the '0x' prefix\n        hex_num = hex(decimal_num)[2:]\n        return hex_num\n\n    @staticmethod\n    def hex_to_decimal(hex_num):\n        \"\"\"\n        Convert a number from hex format to decimal format.\n        :param hex_num: str, hex num\n        :return: int, the decimal representation of hex number str.\n        >>> NumberConverter.hex_to_decimal('a5b7')\n        42423\n        \"\"\"\n        # Convert hex to decimal using int() function with base 16\n        decimal_num = int(hex_num, 16)\n        return decimal_num\n"
    },
    {
        "id" : "65",
        "code" : "\nclass NumberWordFormatter:\n    \"\"\"\n    This is a class that provides to convert numbers into their corresponding English word representation, including handling the conversion of both the integer and decimal parts, and incorporating appropriate connectors and units.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize NumberWordFormatter object.\n        \"\"\"\n        self.NUMBER = [\"\", \"ONE\", \"TWO\", \"THREE\", \"FOUR\", \"FIVE\", \"SIX\", \"SEVEN\", \"EIGHT\", \"NINE\"]\n        self.NUMBER_TEEN = [\"TEN\", \"ELEVEN\", \"TWELVE\", \"THIRTEEN\", \"FOURTEEN\", \"FIFTEEN\", \"SIXTEEN\", \"SEVENTEEN\",\n                            \"EIGHTEEN\",\n                            \"NINETEEN\"]\n        self.NUMBER_TEN = [\"TEN\", \"TWENTY\", \"THIRTY\", \"FORTY\", \"FIFTY\", \"SIXTY\", \"SEVENTY\", \"EIGHTY\", \"NINETY\"]\n        self.NUMBER_MORE = [\"\", \"THOUSAND\", \"MILLION\", \"BILLION\"]\n        self.NUMBER_SUFFIX = [\"k\", \"w\", \"\", \"m\", \"\", \"\", \"b\", \"\", \"\", \"t\", \"\", \"\", \"p\", \"\", \"\", \"e\"]\n\n    def format(self, x):\n        \"\"\"\n        Converts a number into words format\n        :param x: int or float, the number to be converted into words format\n        :return: str, the number in words format\n        >>> formatter = NumberWordFormatter()\n        >>> formatter.format(123456)\n        \"ONE HUNDRED AND TWENTY THREE THOUSAND FOUR HUNDRED AND FIFTY SIX ONLY\"\n        \"\"\"\n        if x is not None:\n            return self.format_string(str(x))\n        else:\n            return \"\"\n\n\n    def format_string(self, x):\n        \"\"\"\n        Converts a string representation of a number into words format\n        :param x: str, the string representation of a number\n        :return: str, the number in words format\n        >>> formatter = NumberWordFormatter()\n        >>> formatter.format_string(\"123456\")\n        \"ONE HUNDRED AND TWENTY THREE THOUSAND FOUR HUNDRED AND FIFTY SIX ONLY\"\n        \"\"\"\n        lstr, rstr = (x.split('.') + [''])[:2]\n        lstrrev = lstr[::-1]\n        a = [''] * 5\n\n        if len(lstrrev) % 3 == 1:\n            lstrrev += \"00\"\n        elif len(lstrrev) % 3 == 2:\n            lstrrev += \"0\"\n\n        lm = \"\"\n        for i in range(len(lstrrev) // 3):\n            a[i] = lstrrev[3 * i:3 * i + 3][::-1]\n            if a[i] != \"000\":\n                lm = self.trans_three(a[i]) + \" \" + self.parse_more(i) + \" \" + lm\n            else:\n                lm += self.trans_three(a[i])\n\n        xs = f\"AND CENTS {self.trans_two(rstr)} \" if rstr else \"\"\n        if not lm.strip():\n            return \"ZERO ONLY\"\n        else:\n            return f\"{lm.strip()} {xs}ONLY\"\n\n\n    def trans_two(self, s):\n        \"\"\"\n        Converts a two-digit number into words format\n        :param s: str, the two-digit number\n        :return: str, the number in words format\n        >>> formatter = NumberWordFormatter()\n        >>> formatter.trans_two(\"23\")\n        \"TWENTY THREE\"\n        \"\"\"\n        s = s.zfill(2)\n        if s[0] == \"0\":\n            return self.NUMBER[int(s[-1])]\n        elif s[0] == \"1\":\n            return self.NUMBER_TEEN[int(s) - 10]\n        elif s[1] == \"0\":\n            return self.NUMBER_TEN[int(s[0]) - 1]\n        else:\n            return self.NUMBER_TEN[int(s[0]) - 1] + \" \" + self.NUMBER[int(s[-1])]\n\n\n    def trans_three(self, s):\n        \"\"\"\n        Converts a three-digit number into words format\n        :param s: str, the three-digit number\n        :return: str, the number in words format\n        >>> formatter = NumberWordFormatter()\n        >>> formatter.trans_three(\"123\")\n        \"ONE HUNDRED AND TWENTY THREE\"\n        \"\"\"\n        if s[0] == \"0\":\n            return self.trans_two(s[1:])\n        elif s[1:] == \"00\":\n            return f\"{self.NUMBER[int(s[0])]} HUNDRED\"\n        else:\n            return f\"{self.NUMBER[int(s[0])]} HUNDRED AND {self.trans_two(s[1:])}\"\n\n    def parse_more(self, i):\n        \"\"\"\n        Parses the thousand/million/billion suffix based on the index\n        :param i: int, the index representing the magnitude (thousand, million, billion)\n        :return: str, the corresponding suffix for the magnitude\n        >>> formatter = NumberWordFormatter()\n        >>> formatter.parse_more(1)\n        \"THOUSAND\"\n        \"\"\"\n        return self.NUMBER_MORE[i]\n",
        "annotated_code" : "\nclass NumberWordFormatter:\n    \"\"\"\n    This is a class that provides to convert numbers into their corresponding English word representation, including handling the conversion of both the integer and decimal parts, and incorporating appropriate connectors and units.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize NumberWordFormatter object.\n        \"\"\"\n        self.NUMBER = [\"\", \"ONE\", \"TWO\", \"THREE\", \"FOUR\", \"FIVE\", \"SIX\", \"SEVEN\", \"EIGHT\", \"NINE\"]\n        self.NUMBER_TEEN = [\"TEN\", \"ELEVEN\", \"TWELVE\", \"THIRTEEN\", \"FOURTEEN\", \"FIFTEEN\", \"SIXTEEN\", \"SEVENTEEN\",\n                            \"EIGHTEEN\",\n                            \"NINETEEN\"]\n        self.NUMBER_TEN = [\"TEN\", \"TWENTY\", \"THIRTY\", \"FORTY\", \"FIFTY\", \"SIXTY\", \"SEVENTY\", \"EIGHTY\", \"NINETY\"]\n        self.NUMBER_MORE = [\"\", \"THOUSAND\", \"MILLION\", \"BILLION\"]\n        self.NUMBER_SUFFIX = [\"k\", \"w\", \"\", \"m\", \"\", \"\", \"b\", \"\", \"\", \"t\", \"\", \"\", \"p\", \"\", \"\", \"e\"]\n\n    def format(self, x):\n        \"\"\"\n        Converts a number into words format\n        :param x: int or float, the number to be converted into words format\n        :return: str, the number in words format\n        >>> formatter = NumberWordFormatter()\n        >>> formatter.format(123456)\n        \"ONE HUNDRED AND TWENTY THREE THOUSAND FOUR HUNDRED AND FIFTY SIX ONLY\"\n        \"\"\"\n        # Convert the number to string and remove any leading/trailing whitespace\n        if x is not None:\n            return self.format_string(str(x))\n        else:\n            return \"\"\n\n\n    def format_string(self, x):\n        \"\"\"\n        Converts a string representation of a number into words format\n        :param x: str, the string representation of a number\n        :return: str, the number in words format\n        >>> formatter = NumberWordFormatter()\n        >>> formatter.format_string(\"123456\")\n        \"ONE HUNDRED AND TWENTY THREE THOUSAND FOUR HUNDRED AND FIFTY SIX ONLY\"\n        \"\"\"\n        # Converts a string representation of a number into words format\n        lstr, rstr = (x.split('.') + [''])[:2]\n        lstrrev = lstr[::-1]\n        a = [''] * 5\n\n        if len(lstrrev) % 3 == 1:\n            lstrrev += \"00\"\n        elif len(lstrrev) % 3 == 2:\n            lstrrev += \"0\"\n\n        lm = \"\"\n        for i in range(len(lstrrev) // 3):\n            a[i] = lstrrev[3 * i:3 * i + 3][::-1]\n            if a[i] != \"000\":\n                lm = self.trans_three(a[i]) + \" \" + self.parse_more(i) + \" \" + lm\n            else:\n                lm += self.trans_three(a[i])\n\n        xs = f\"AND CENTS {self.trans_two(rstr)} \" if rstr else \"\"\n        if not lm.strip():\n            return \"ZERO ONLY\"\n        else:\n            return f\"{lm.strip()} {xs}ONLY\"\n\n\n    def trans_two(self, s):\n        \"\"\"\n        Converts a two-digit number into words format\n        :param s: str, the two-digit number\n        :return: str, the number in words format\n        >>> formatter = NumberWordFormatter()\n        >>> formatter.trans_two(\"23\")\n        \"TWENTY THREE\"\n        \"\"\"\n        # Converts a two-digit number into words format\n        s = s.zfill(2)\n        if s[0] == \"0\":\n            return self.NUMBER[int(s[-1])]\n        elif s[0] == \"1\":\n            return self.NUMBER_TEEN[int(s) - 10]\n        elif s[1] == \"0\":\n            return self.NUMBER_TEN[int(s[0]) - 1]\n        else:\n            return self.NUMBER_TEN[int(s[0]) - 1] + \" \" + self.NUMBER[int(s[-1])]\n\n\n    def trans_three(self, s):\n        \"\"\"\n        Converts a three-digit number into words format\n        :param s: str, the three-digit number\n        :return: str, the number in words format\n        >>> formatter = NumberWordFormatter()\n        >>> formatter.trans_three(\"123\")\n        \"ONE HUNDRED AND TWENTY THREE\"\n        \"\"\"\n        # Converts a three-digit number into words format\n        if s[0] == \"0\":\n            return self.trans_two(s[1:])\n        elif s[1:] == \"00\":\n            return f\"{self.NUMBER[int(s[0])]} HUNDRED\"\n        else:\nreturn f\"{self.NUMBER[int(s[0])]} HUNDRED AND {self.trans_two(s[1:])}\"\n\n    def parse_more(self, i):\n        \"\"\"\n        Parses the thousand/million/billion suffix based on the index\n        :param i: int, the index representing the magnitude (thousand, million, billion)\n        :return: str, the corresponding suffix for the magnitude\n        >>> formatter = NumberWordFormatter()\n        >>> formatter.parse_more(1)\n        \"THOUSAND\"\n        \"\"\"\n        # Parses the thousand/million/billion suffix based on the index\n        return self.NUMBER_MORE[i]\n"
    },
    {
        "id" : "66",
        "code" : "\nclass NumericEntityUnescaper:\n    \"\"\"\n    This is a class that provides functionality to replace numeric entities with their corresponding characters in a given string.\n    \"\"\"\n\n    def __init__(self):\n        pass\n\n    def replace(self, string):\n        \"\"\"\n        Replaces numeric character references (HTML entities) in the input string with their corresponding Unicode characters.\n        :param string: str, the input string containing numeric character references.\n        :return: str, the input string with numeric character references replaced with their corresponding Unicode characters.\n        >>> unescaper = NumericEntityUnescaper()\n        >>> unescaper.replace(\"&#65;&#66;&#67;\")\n        'ABC'\n\n        \"\"\"\n        out = []\n        pos = 0\n        length = len(string)\n\n        while pos < length - 2:\n            if string[pos] == '&' and string[pos + 1] == '#':\n                start = pos + 2\n     is_hex = False\n                first_char = string[start]\n\n                if first_char == 'x' or first_char == 'X':\n                    start += 1\n                    is_hex = True\n\n                if start == length:\n                    return ''.join(out)\n\n                end = start\n                while end < length and self.is_hex_char(string[end]):\n          end += 1\n\n                if end < length and string[end] == ';':\n                    try:\n                        entity_value = int(string[start:end], 16 if is_hex else 10)\n                    except:\n                        return ''.join(out)\n\n                    out.append(chr(entity_value))\n                    pos = end + 1\n                    continue\n\n            out.append(string[pos])\n            pos += 1\n\n        return ''.join(out)\n\n\n    @staticmethod\n    def is_hex_char(char):\n        \"\"\"\n        Determines whether a given character is a hexadecimal digit.\n        :param char: str, the character to check.\n        :return: bool, True if the character is a hexadecimal digit, False otherwise.\n        >>> NumericEntityUnescaper.is_hex_char('a')\n        True\n\n        \"\"\"\n        return char.isdigit() or ('a' <= char.lower() <= 'f')\n",
        "annotated_code" : "\nclass NumericEntityUnescaper:\n    \"\"\"\n    This is a class that provides functionality to replace numeric entities with their corresponding characters in a given string.\n    \"\"\"\n\n    def __init__(self):\n        pass\n\n    def replace(self, string):\n        \"\"\"\n        Replaces numeric character references (HTML entities) in the input string with their corresponding Unicode characters.\n        :param string: str, the input string containing numeric character references.\n        :return: str, the input string with numeric character references replaced with their corresponding Unicode characters.\n        >>> unescaper = NumericEntityUnescaper()\n        >>> unescaper.replace(\"&#65;&#66;&#67;\")\n        'ABC'\n\n        \"\"\"\n        # Replaces numeric character references (HTML entities) in the input string with their corresponding Unicode characters.\n        # The function iterates through the string, looking for patterns that match numeric character references.\n        out = []\n        pos = 0\n        length = len(string)\n\n        while pos < length - 2:\n            if string[pos] == '&' and string[pos + 1] == '#':\n                start = pos + 2\n                is_hex = False\n                first_char = string[start]\n\n                if first_char == 'x' or first_char == 'X':\n      start += 1\n                    is_hex = True\n\n                if start == length:\n                    return ''.join(out)\n\n                end = start\n                while end < length and self.is_hex_char(string[end]):\n                    end += 1\n\n                if end < length and string[end] == ';':\n                    try:\n                        entity_value = int(string[start:end], 16 if is_hex else 10)\n                    except:\n                        return ''.join(out)\n\n                    out.append(chr(entity_value))\n   pos = end + 1\n                    continue\n\n            out.append(string[pos])\n            pos += 1\n\n        return ''.join(out)\n\n\n    @staticmethod\n    def is_hex_char(char):\n        \"\"\"\n        Determines whether a given character is a hexadecimal digit.\n        :param char: str, the character to check.\n        :return: bool, True if the character is a hexadecimal digit, False otherwise.\n        >>> NumericEntityUnescaper.is_hex_char('a')\n        True\n\n        \"\"\"\n        # Determines whether a given character is a hexadecimal digit.\n        # This function checks if the character is a digit or a letter between 'a' and 'f' (case insensitive).\n        return char.isdigit() or ('a' <= char.lower() <= 'f')\n"
    },
    {
        "id" : "67",
        "code" : "\nclass Order:\n    \"\"\"\n    The class manages restaurant orders by allowing the addition of dishes, calculation of the total cost, and checkout.\n    \"\"\"\n\n\n    def __init__(self):\n        \"\"\"\n        Initialize the order management system\n        self.menu stores the dishes of resturant inventory\n        menu = [{\"dish\": dish name, \"price\": price, \"count\": count}, ...]\n        self.selected_dishes stores the dished selected by customer\n        selected_dish = {\"dish\": dish name, \"count\": count, price: price}\n        self.sales stores the sales of each dish\n        sales = {dish name: sales}\n        \"\"\"\n        self.menu = []\n        self.selected_dishes = []\n        self.sales = {}\n\n\n    def add_dish(self, dish):\n        \"\"\"\n        Check the self.menu and add into self.selected_dish if the dish count is valid.\n        And if the dish has successfully been added, change the count in self.menu.\n        :param dish: dict, the information of dish. dish = {\"dish\": dish name, \"count\": count, price: price}\n        :return: True if successfully added, or False otherwise.\n        >>> order = Order()\n        >>> order.menu.append({\"dish\": \"dish1\", \"price\": 10, \"count\": 5})\n        >>> order.add_dish({\"dish\": \"dish1\", \"price\": 10, \"count\": 3})\n        True\n        \"\"\"\n        for menu_dish in self.menu:\n            if dish[\"dish\"] == menu_dish[\"dish\"]:\n                if menu_dish[\"count\"] < dish[\"count\"]:\n                    return False\n                else:\n                    menu_dish[\"count\"] -= dish[\"count\"]\n                    break\n        self.selected_dishes.append(dish)\n        return True\n\n    def calculate_total(self):\n        \"\"\"\n        Calculate the total price of dishes that have been ordered. Multiply the count, price and sales.\n        :return total: float, the final total price.\n        >>> order = Order()\n        >>> order.menu.append({\"dish\": \"dish1\", \"price\": 10, \"count\": 5})\n        >>> order.sales = {\"dish1\": 0.8}\n        >>> order.add_dish({\"dish\": \"dish1\", \"price\": 10, \"count\": 4})\n        True\n        >>> order.calculate_total()\n        32.0\n        \"\"\"\n        total = 0\n        for dish in self.selected_dishes:\n   total += dish[\"price\"] * dish[\"count\"] * self.sales[dish[\"dish\"]]\n        return total\n\n    def checkout(self):\n        \"\"\"\n        Check out the dished ordered. IF the self.selected_dishes is not empty, invoke the calculate_total\n        method to check out.\n        :return Flase if the self.selected_dishes is empty, or total(return value of calculate_total) otherwise.\n        >>> order = Order()\n        >>> order.menu.append({\"dish\": \"dish1\", \"price\": 10, \"count\": 5})\n        >>> order.sales = {\"dish1\": 0.8}\n        >>> order.add_dish({\"dish\": \"dish1\", \"price\": 10, \"count\": 4})\n        True\n        >>> order.checkout()\n        32.0\n        \"\"\"\n        if len(self.selected_dishes) == 0:\n            return False\n        total = self.calculate_total()\n        self.selected_dishes = []\n        return total\n",
        "annotated_code" : "\nclass Order:\n    \"\"\"\n    The class manages restaurant orders by allowing the addition of dishes, calculation of the total cost, and checkout.\n    \"\"\"\n\n\n    def __init__(self):\n        \"\"\"\n        Initialize the order management system\n        self.menu stores the dishes of resturant inventory\n        menu = [{\"dish\": dish name, \"price\": price, \"count\": count}, ...]\n        self.selected_dishes stores the dished selected by customer\n        selected_dish = {\"dish\": dish name, \"count\": count, price: price}\n        self.sales stores the sales of each dish\n        sales = {dish name: sales}\n        \"\"\"\n        self.menu = []\n        self.selected_dishes = []\n        self.sales = {}\n\n\n    def add_dish(self, dish):\n        \"\"\"\n        Check the self.menu and add into self.selected_dish if the dish count is valid.\n        And if the dish has successfully been added, change the count in self.menu.\n        :param dish: dict, the information of dish. dish = {\"dish\": dish name, \"count\": count, price: price}\n        :return: True if successfully added, or False otherwise.\n        >>> order = Order()\n        >>> order.menu.append({\"dish\": \"dish1\", \"price\": 10, \"count\": 5})\n        >>> order.add_dish({\"dish\": \"dish1\", \"price\": 10, \"count\": 3})\n        True\n        \"\"\"\n        # Check if the dish is in the menu and has enough count\n        # Append the dish to selected_dishes if valid\n        # Update the count in menu\n        for menu_dish in self.menu:\n            if dish[\"dish\"] == menu_dish[\"dish\"]:\n                if menu_dish[\"count\"] < dish[\"count\"]:\n                    return False\n                else:\n     menu_dish[\"count\"] -= dish[\"count\"]\n                    break\n        self.selected_dishes.append(dish)\n        return True\n\n    def calculate_total(self):\n        \"\"\"\n        Calculate the total price of dishes that have been ordered. Multiply the count, price and sales.\n        :return total: float, the final total price.\n        >>> order = Order()\n        >>> order.menu.append({\"dish\": \"dish1\", \"price\": 10, \"count\": 5})\n        >>> order.sales = {\"dish1\": 0.8}\n        >>> order.add_dish({\"dish\": \"dish1\", \"price\": 10, \"count\": 4})\n        True\n        >>> order.calculate_total()\n        32.0\n        \"\"\"\n        # Calculate the total price of selected dishes\n        # Multiply the count, price and sales\n        total = 0\n        for dish in self.selected_dishes:\n            total += dish[\"price\"] * dish[\"count\"] * self.sales[dish[\"dish\"]]\n        return total\n\n    def checkout(self):\n        \"\"\"\n        Check out the dished ordered. IF the self.selected_dishes is not empty, invoke the calculate_total\n        method to check out.\n        :return Flase if the self.selected_dishes is empty, or total(return value of calculate_total) otherwise.\n        >>> order = Order()\n        >>> order.menu.append({\"dish\": \"dish1\", \"price\": 10, \"count\": 5})\n        >>> order.sales = {\"dish1\": 0.8}\n        >>> order.add_dish({\"dish\": \"dish1\", \"price\": 10, \"count\": 4})\n        True\n        >>> order.checkout()\n        32.0\n        \"\"\"\n        # Check if selected_dishes is empty\n        # If not, calculate the total and clear selected_dishes\n        if len(self.selected_dishes) == 0:\n            return False\n        total = self.calculate_total()\n        self.selected_dishes = []\n        return total\n"
    },
    {
        "id" : "68",
        "code" : "\nclass PageUtil:\n    \"\"\"\n    PageUtil class is a versatile utility for handling pagination and search functionalities in an efficient and convenient manner.\n    \"\"\"\n\n    def __init__(self, data, page_size):\n        \"\"\"\n        Initialize the PageUtil object with the given data and page size.\n        :param data: list, the data to be paginated\n        :param page_size: int, the number of items per page\n        \"\"\"\n        self.data = data\n        self.page_size = page_size\n        self.total_items = len(data)\n        self.total_pages = (self.total_items + page_size - 1) // page_size\n\n    def get_page(self, page_number):\n        \"\"\"\n        Retrieve a specific page of data.\n        :param page_number: int, the page number to fetch\n        :return: list, the data on the specified page\n        >>> page_util = PageUtil([1, 2, 3, 4], 1)\n        >>> page_util.get_page(1)\n        [1]\n\n        \"\"\"\n        if page_number < 1 or page_number > self.total_pages:\n            return []\n\n        start_index = (page_number - 1) * self.page_size\n        end_index = start_index + self.page_size\n        return self.data[start_index:end_index]\n\n\n    def get_page_info(self, page_number):\n        \"\"\"\n        Retrieve information about a specific page.\n        :param page_number: int, the page number to fetch information about\n        :return: dict, containing page information such as current page number, total pages, etc.\n        >>> page_util = PageUtil([1, 2, 3, 4], 1)\n        >>> page_util.get_page_info(1)\n        >>> {\n        >>>     \"current_page\": 1,\n        >>>     \"per_page\": 1,\n        >>>     \"total_pages\": 4,\n        >>>     \"total_items\": 4,\n        >>>     \"has_previous\": False,\n        >>>     \"has_next\": True,\n        >>>     \"data\": [1]\n        >>> }\n\n        \"\"\"\n        if page_number < 1 or page_number > self.total_pages:\n            return {}\n\n        start_index = (page_number - 1) * self.page_size\n        end_index = min(start_index + self.page_size, self.total_items)\n        page_data = self.data[start_index:end_index]\n\n        page_info = {\n            \"current_page\": page_number,\n            \"per_page\": self.page_size,\n            \"total_pages\": self.total_pages,\n            \"total_items\": self.total_items,\n            \"has_previous\": page_number > 1,\n            \"has_next\": page_number < self.total_pages,\n            \"data\": page_data\n        }\n        return page_info\n\n\n    def search(self, keyword):\n        \"\"\"\n        Search for items in the data that contain the given keyword.\n        :param keyword: str, the keyword to search for\n        :return: dict, containing search information such as total results and matching items\n        >>> page_util = PageUtil([1, 2, 3, 4], 1)\n        >>> page_util.search(\"1\")\n        >>> search_info = {\n        >>>     \"keyword\": \"1\",\n        >>>     \"total_results\": 1,\n        >>>     \"total_pages\": 1,\n        >>>     \"results\": [1]\n        >>> }\n        \"\"\"\n        results = [item for item in self.data if keyword in str(item)]\n        num_results = len(results)\n        num_pages = (num_results + self.page_size - 1) // self.page_size\n\n        search_info = {\n            \"keyword\": keyword,\n            \"total_results\": num_results,\n            \"total_pages\": num_pages,\n            \"results\": results\n        }\n        return search_info\n",
        "annotated_code" : "\nclass PageUtil:\n    \"\"\"\n    PageUtil class is a versatile utility for handling pagination and search functionalities in an efficient and convenient manner.\n    \"\"\"\n\n    def __init__(self, data, page_size):\n        \"\"\"\n        Initialize the PageUtil object with the given data and page size.\n        :param data: list, the data to be paginated\n        :param page_size: int, the number of items per page\n        \"\"\"\n        self.data = data\n        self.page_size = page_size\n        self.total_items = len(data)\n        self.total_pages = (self.total_items + page_size - 1) // page_size\n\n    def get_page(self, page_number):\n        \"\"\"\n        Retrieve a specific page of data.\n        :param page_number: int, the page number to fetch\n        :return: list, the data on the specified page\n        >>> page_util = PageUtil([1, 2, 3, 4], 1)\n        >>> page_util.get_page(1)\n        [1]\n\n        \"\"\"\n        # Ensure the page number is within the valid range\n        # and return an empty list if it's not.\n        # Return the data for the specified page number.\n        if page_number < 1 or page_number > self.total_pages:\n            return []\n\n        start_index = (page_number - 1) * self.page_size\n        end_index = start_index + self.page_size\n        return self.data[start_index:end_index]\n\n\n    def get_page_info(self, page_number):\n        \"\"\"\n        Retrieve information about a specific page.\n        :param page_number: int, the page number to fetch information about\n        :return: dict, containing page information such as current page number, total pages, etc.\n        >>> page_util = PageUtil([1, 2, 3, 4], 1)\n        >>> page_util.get_page_info(1)\n        >>> {\n        >>>     \"current_page\": 1,\n        >>>     \"per_page\": 1,\n        >>>     \"total_pages\": 4,\n        >>>     \"total_items\": 4,\n        >>>     \"has_previous\": False,\n        >>>     \"has_next\": True,\n        >>>     \"data\": [1]\n        >>> }\n\n        \"\"\"\n        # Ensure the page number is within the valid range\n        # and return an empty dictionary if it's not.\n        # Return a dictionary containing information about the specified page.\n        # The dictionary includes the current page number, items per page, total pages,\n        if page_number < 1 or page_number > self.total_pages:\n            return {}\n\n        start_index = (page_number - 1) * self.page_size\n        end_index = min(start_index + self.page_size, self.total_items)\n        page_data = self.data[start_index:end_index]\n\n        page_info = {\n            \"current_page\": page_number,\n            \"per_page\": self.page_size,\n            \"total_pages\": self.total_pages,\n            \"total_items\": self.total_items,\n            \"has_previous\": page_number > 1,\n            \"has_next\": page_number < self.total_pages,\n            \"data\": page_data\n        }\n        return page_info\n\n\n    def search(self, keyword):\n        \"\"\"\n        Search for items in the data that contain the given keyword.\n        :param keyword: str, the keyword to search for\n        :return: dict, containing search information such as total results and matching items\n        >>> page_util = PageUtil([1, 2, 3, 4], 1)\n        >>> page_util.search(\"1\")\n        >>> search_info = {\n        >>>     \"keyword\": \"1\",\n        >>>     \"total_results\": 1,\n        >>>     \"total_pages\": 1,\n        >>>     \"results\": [1]\n        >>> }\n        \"\"\"\n        # Search for items in the data that contain the given keyword.\n        # Return a dictionary containing search information such as total results and matching items.\n        results = [item for item in self.data if keyword in str(item)]\n        num_results = len(results)\n        num_pages = (num_results + self.page_size - 1) // self.page_size\n\n        search_info = {\n            \"keyword\": keyword,\n            \"total_results\": num_results,\n            \"total_pages\": num_pages,\n            \"results\": results\n        }\n        return search_info\n"
    },
    {
        "id" : "69",
        "code" : "\nimport PyPDF2\n\nclass PDFHandler:\n    \"\"\"\n    The class allows merging multiple PDF files into one and extracting text from PDFs using PyPDF2 library.\n    \"\"\"\n\n    def __init__(self, filepaths):\n        \"\"\"\n        takes a list of file paths filepaths as a parameter.\n        It creates a list named readers using PyPDF2, where each reader opens a file from the given paths.\n        \"\"\"\n        self.filepaths = filepaths\n        self.readers = [PyPDF2.PdfFileReader(fp) for fp in filepaths]\n\n    def merge_pdfs(self, output_filepath):\n        \"\"\"\n        Read files in self.readers which stores handles to multiple PDF files.\n        Merge them to one pdf and update the page number, then save in disk.\n        :param output_filepath: str, ouput file path to save to\n        :return: str, \"Merged PDFs saved at {output_filepath}\" if successfully merged\n        >>> handler = PDFHandler(['a.pdf', 'b.pdf'])\n        >>> handler.merge_pdfs('out.pdf')\n        Merged PDFs saved at out.pdf\n        \"\"\"\n        pdf_writer = PyPDF2.PdfWriter()\n\n        for reader in self.readers:\n            # reader.getNumPages is deprecated and was removed in PyPDF2 3.0.0. Use len(reader.pages) instead.\n            for page_num in range(len(reader.pages)):\n                # reader.getPage(pageNumber) is deprecated and was removed in PyPDF2 3.0.0. Use reader.pages[page_number] instead.\n                page = reader.pages[page_num]\n                # addPage is deprecated and was removed in PyPDF2 3.0.0. Use add_page instead.\n                pdf_writer.add_page(page)\n\n        with open(output_filepath, 'wb') as out:\n            pdf_writer.write(out)\n        return f\"Merged PDFs saved at {output_filepath}\"\n\n    def extract_text_from_pdfs(self):\n        \"\"\"\n        Extract text from pdf files in self.readers\n        :return pdf_texts: list of str, each element is the text of one pdf file\n        >>> handler = PDFHandler(['a.pdf', 'b.pdf'])\n        >>> handler.extract_text_from_pdfs()\n        ['Test a.pdf', 'Test b.pdf']\n        \"\"\"\n        pdf_texts = []\n        for reader in self.readers:\n            for page_num in range(len(reader.pages)):\n                page = reader.pages[page_num]\n                pdf_texts.append(page.extract_text())\n        return pdf_texts\n",
        "annotated_code" : "\nimport PyPDF2\n\nclass PDFHandler:\n    \"\"\"\n    The class allows merging multiple PDF files into one and extracting text from PDFs using PyPDF2 library.\n    \"\"\"\n\n    def __init__(self, filepaths):\n        \"\"\"\n        takes a list of file paths filepaths as a parameter.\n        It creates a list named readers using PyPDF2, where each reader opens a file from the given paths.\n        \"\"\"\n        self.filepaths = filepaths\n        self.readers = [PyPDF2.PdfFileReader(fp) for fp in filepaths]\n\n    def merge_pdfs(self, output_filepath):\n        \"\"\"\n        Read files in self.readers which stores handles to multiple PDF files.\n        Merge them to one pdf and update the page number, then save in disk.\n        :param output_filepath: str, ouput file path to save to\n        :return: str, \"Merged PDFs saved at {output_filepath}\" if successfully merged\n        >>> handler = PDFHandler(['a.pdf', 'b.pdf'])\n        >>> handler.merge_pdfs('out.pdf')\n        Merged PDFs saved at out.pdf\n        \"\"\"\n        # Read files in self.readers which stores handles to multiple PDF files.\n        # Merge them to one pdf and update the page number, then save in disk.\n        pdf_writer = PyPDF2.PdfWriter()\n\n        for reader in self.readers:\n            # reader.getNumPages is deprecated and was removed in PyPDF2 3.0.0. Use len(reader.pages) instead.\n            for page_num in range(len(reader.pages)):\n                # reader.getPage(pageNumber) is deprecated and was removed in PyPDF2 3.0.0. Use reader.pages[page_number] instead.\n                page = reader.pages[page_num]\n                # addPage is deprecated and was removed in PyPDF2 3.0.0. Use add_page instead.\n       pdf_writer.add_page(page)\n\n        with open(output_filepath, 'wb') as out:\n            pdf_writer.write(out)\n        return f\"Merged PDFs saved at {output_filepath}\"\n\n    def extract_text_from_pdfs(self):\n        \"\"\"\n        Extract text from pdf files in self.readers\n        :return pdf_texts: list of str, each element is the text of one pdf file\n        >>> handler = PDFHandler(['a.pdf', 'b.pdf'])\n        >>> handler.extract_text_from_pdfs()\n        ['Test a.pdf', 'Test b.pdf']\n        \"\"\"\n        # Extract text from pdf files in self.readers\n        pdf_texts = []\n        for reader in self.readers:\n            for page_num in range(len(reader.pages)):\n                page = reader.pages[page_num]\n                pdf_texts.append(page.extract_text())\n        return pdf_texts\n"
    },
    {
        "id" : "70",
        "code" : "\nclass PersonRequest:\n    \"\"\"\n    This class validates input personal information data and sets invalid fields to None based to specific rules.\n    \"\"\"\n\n    def __init__(self, name: str, sex: str, phoneNumber: str):\n        \"\"\"\n        Initialize PersonRequest object with the provided information.\n        :param name: str, the name of the person\n        :param sex: str, the sex of the person\n        :param phoneNumber: str, the phone number of the person\n        \"\"\"\n        self.name = self._validate_name(name)\n        self.sex = self._validate_sex(sex)\n        self.phoneNumber = self._validate_phoneNumber(phoneNumber)\n\n\n    def _validate_name(self, name: str) -> str:\n        \"\"\"\n        Validate the name and return it. If name is empty or exceeds 33 characters in length, set to None.\n        :param name: str, the name to validate\n        :return: str, the validated name or None if invalid\n        \"\"\"\n        if not name:\n            return None\n        if len(name) > 33:\n            return None\n        return name\n\n\n    def _validate_sex(self, sex: str) -> str:\n        \"\"\"\n        Validate the sex and return it. If sex is not Man, Woman, or UGM, set to None.\n        :param sex: str, the sex to validate\n        :return: str, the validated sex or None if invalid\n        \"\"\"\n        if sex not in [\"Man\", \"Woman\", \"UGM\"]:\n            return None\n        return sex\n\n    def _validate_phoneNumber(self, phoneNumber: str) -> str:\n        \"\"\"\n        Validate the phone number and return it. If phoneNumber is empty or not an 11 digit number, set to None.\n        :param phoneNumber: str, the phone number to validate\n        :return: str, the validated phone number or None if invalid\n        \"\"\"\n        if not phoneNumber:\n            return None\n        if len(phoneNumber) != 11 or not phoneNumber.isdigit():\n            return None\n        return phoneNumber\n",
        "annotated_code" : "\nclass PersonRequest:\n    \"\"\"\n    This class validates input personal information data and sets invalid fields to None based to specific rules.\n    \"\"\"\n\n    def __init__(self, name: str, sex: str, phoneNumber: str):\n        \"\"\"\n        Initialize PersonRequest object with the provided information.\n        :param name: str, the name of the person\n        :param sex: str, the sex of the person\n        :param phoneNumber: str, the phone number of the person\n        \"\"\"\n        self.name = self._validate_name(name)\n        self.sex = self._validate_sex(sex)\n        self.phoneNumber = self._validate_phoneNumber(phoneNumber)\n\n\n    def _validate_name(self, name: str) -> str:\n        \"\"\"\n        Validate the name and return it. If name is empty or exceeds 33 characters in length, set to None.\n        :param name: str, the name to validate\n        :return: str, the validated name or None if invalid\n        \"\"\"\n        # Check if name is empty or exceeds 33 characters\n        if not name:\n            return None\n        if len(name) > 33:\n            return None\n        return name\n\n\n    def _validate_sex(self, sex: str) -> str:\n        \"\"\"\n        Validate the sex and return it. If sex is not Man, Woman, or UGM, set to None.\n        :param sex: str, the sex to validate\n        :return: str, the validated sex or None if invalid\n        \"\"\"\n        # Check if sex is empty or not one of the allowed values\n        if sex not in [\"Man\", \"Woman\", \"UGM\"]:\n  return None\n        return sex\n\n    def _validate_phoneNumber(self, phoneNumber: str) -> str:\n        \"\"\"\n        Validate the phone number and return it. If phoneNumber is empty or not an 11 digit number, set to None.\n        :param phoneNumber: str, the phone number to validate\n        :return: str, the validated phone number or None if invalid\n        \"\"\"\n        # Check if phoneNumber is empty or not an 11 digit number\n        if not phoneNumber:\n            return None\n        if len(phoneNumber) != 11 or not phoneNumber.isdigit():\n            return None\n        return phoneNumber\n"
    },
    {
        "id" : "71",
        "code" : "\nclass PushBoxGame:\n    \"\"\"\n    This class implements a functionality of a sokoban game, where the player needs to move boxes to designated targets in order to win.\n    \"\"\"\n\n    def __init__(self, map):\n        \"\"\"\n        Initialize the push box game with the map and various attributes.\n        :param map: list[str], the map of the push box game, represented as a list of strings.\n            Each character on the map represents a different element, including the following:\n            - '#' represents a wall that neither the player nor the box can pass through;\n            - 'O' represents the initial position of the player;\n            - 'G' represents the target position;\n            - 'X' represents the initial position of the box.\n        >>> map = [\"#####\", \"#O  #\", \"# X #\", \"#  G#\", \"#####\"]\n        >>> game = PushBoxGame(map)\n        \"\"\"\n        self.map = map\n        self.player_row = 0\n        self.player_col = 0\n        self.targets = []\n        self.boxes = []\n        self.target_count = 0\n        self.is_game_over = False\n        self.init_game()\n\n    def init_game(self):\n        \"\"\"\n        Initialize the game by setting the positions of the player, targets, and boxes based on the map.\n        >>> game = PushBoxGame([\"#####\", \"#O  #\", \"# X #\", \"#  G#\", \"#####\"])\n        >>> game.targets\n        [(3, 3)]\n        >>> game.boxes\n        [(2, 2)]\n        >>> game.player_row\n        1\n        >>> game.player_col\n        1\n        \"\"\"\n        for row in range(len(self.map)):\n            for col in range(len(self.map[row])):\n                if self.map[row][col] == \"O\":\n                    self.player_row = row\n                    self.player_col = col\n                elif self.map[row][col] == \"G\":\n                    self.targets.append((row, col))\n                    self.target_count += 1\n       elif self.map[row][col] == \"X\":\n                    self.boxes.append((row, col))\n\n    def check_win(self):\n        \"\"\"\n        Check if the game is won. The game is won when all the boxes are placed on target positions.\n        And update the value of self.is_game_over.\n        :return self.is_game_over: True if all the boxes are placed on target positions, or False otherwise.\n        >>> game = PushBoxGame([\"#####\", \"#O  #\", \"# X #\", \"#  G#\", \"#####\"])\n        >>> game.check_win()\n        \"\"\"\n        box_on_target_count = 0\n        for box in self.boxes:\n            if box in self.targets:\n                box_on_target_count += 1\n        if box_on_target_count == self.target_count:\n            self.is_game_over = True\n        return self.is_game_over\n\n\n    def move(self, direction):\n        \"\"\"\n        Move the player based on the specified direction and check if the game is won.\n        :param direction: str, the direction of the player's movement.\n            It can be 'w', 's', 'a', or 'd' representing up, down, left, or right respectively.\n\n        :return: True if the game is won, False otherwise.\n        >>> game = PushBoxGame([\"#####\", \"#O  #\", \"# X #\", \"#  G#\", \"#####\"])\n        >>> game.print_map()\n        # # # # #\n        # O     #\n        #   X   #\n        #     G #\n        # # # # #\n        >>> game.move('d')\n        False\n        >>> game.move('s')\n        False\n        >>> game.move('a')\n        False\n        >>> game.move('s')\n        False\n        >>> game.move('d')\n        True\n        \"\"\"\n        new_player_row = self.player_row\n        new_player_col = self.player_col\n\n        if direction == \"w\":\n            new_player_row -= 1\n        elif direction == \"s\":\n            new_player_row += 1\n        elif direction == \"a\":\n            new_player_col -= 1\n        elif direction == \"d\":\n            new_player_col += 1\n\n        if self.map[new_player_row][new_player_col] != \"#\":\n            if (new_player_row, new_player_col) in self.boxes:\n                new_box_row = new_player_row + (new_player_row - self.player_row)\n                new_box_col = new_player_col + (new_player_col - self.player_col)\n\n                if self.map[new_box_row][new_box_col] != \"#\":\n                    self.boxes.remove((new_player_row, new_player_col))\n                    self.boxes.append((new_box_row, new_box_col))\n                    self.player_row = new_player_row\n                    self.player_col = new_player_col\n            else:\n                self.player_row = new_player_row\n                self.player_col = new_player_col\n\n        return self.check_win()\n",
        "annotated_code" : "\nclass PushBoxGame:\n    \"\"\"\n    This class implements a functionality of a sokoban game, where the player needs to move boxes to designated targets in order to win.\n    \"\"\"\n\n    def __init__(self, map):\n        \"\"\"\n        Initialize the push box game with the map and various attributes.\n        :param map: list[str], the map of the push box game, represented as a list of strings.\n            Each character on the map represents a different element, including the following:\n            - '#' represents a wall that neither the player nor the box can pass through;\n            - 'O' represents the initial position of the player;\n            - 'G' represents the target position;\n            - 'X' represents the initial position of the box.\n        >>> map = [\"#####\", \"#O  #\", \"# X #\", \"#  G#\", \"#####\"]\n        >>> game = PushBoxGame(map)\n        \"\"\"\n        self.map = map\n        self.player_row = 0\n        self.player_col = 0\n        self.targets = []\n        self.boxes = []\n        self.target_count = 0\n        self.is_game_over = False\n        self.init_game()\n\n    def init_game(self):\n        \"\"\"\n        Initialize the game by setting the positions of the player, targets, and boxes based on the map.\n        >>> game = PushBoxGame([\"#####\", \"#O  #\", \"# X #\", \"#  G#\", \"#####\"])\n        >>> game.targets\n        [(3, 3)]\n        >>> game.boxes\n        [(2, 2)]\n        >>> game.player_row\n        1\n        >>> game.player_col\n        1\n        \"\"\"\n        # Initialize the game by setting the positions of the player, targets, and boxes based on the map.\n        for row in range(len(self.map)):\n            for col in range(len(self.map[row])):\n                if self.map[row][col] == \"O\":\n                    self.player_row = row\n                    self.player_col = col\n                elif self.map[row][col] == \"G\":\n                    self.targets.append((row, col))\n                    self.target_count += 1\n                elif self.map[row][col] == \"X\":\n                    self.boxes.append((row, col))\n\n    def check_win(self):\n        \"\"\"\n        Check if the game is won. The game is won when all the boxes are placed on target positions.\n        And update the value of self.is_game_over.\n        :return self.is_game_over: True if all the boxes are placed on target positions, or False otherwise.\n        >>> game = PushBoxGame([\"#####\", \"#O  #\", \"# X #\", \"#  G#\", \"#####\"])\n        >>> game.check_win()\n        \"\"\"\n        # Check if the game is won. The game is won when all the boxes are placed on target positions.\n        # And update the value of self.is_game_over.\n        box_on_target_count = 0\n        for box in self.boxes:\n            if box in self.targets:\n                box_on_target_count += 1\n        if box_on_target_count == self.target_count:\n            self.is_game_over = True\n        return self.is_game_over\n\n\n    def move(self, direction):\n        \"\"\"\n        Move the player based on the specified direction and check if the game is won.\n        :param direction: str, the direction of the player's movement.\n            It can be 'w', 's', 'a', or 'd' representing up, down, left, or right respectively.\n\n        :return: True if the game is won, False otherwise.\n        >>> game = PushBoxGame([\"#####\", \"#O  #\", \"# X #\", \"#  G#\", \"#####\"])\n        >>> game.print_map()\n        # # # # #\n        # O     #\n        #   X   #\n        #     G #\n        # # # # #\n        >>> game.move('d')\n        False\n        >>> game.move('s')\n        False\n        >>> game.move('a')\n        False\n        >>> game.move('s')\n        False\n        >>> game.move('d')\n        True\n        \"\"\"\n        # Move the player based on the specified direction and check if the game is won.\n        new_player_row = self.player_row\n        new_player_col = self.player_col\n\n        if direction == \"w\":\n            new_player_row -= 1\n        elif direction == \"s\":\n            new_player_row += 1\n        elif direction == \"a\":\n            new_player_col -= 1\n        elif direction == \"d\":\n            new_player_col += 1\n\n        if self.map[new_player_row][new_player_col] != \"#\":\n            if (new_player_row, new_player_col) in self.boxes:\n                new_box_row = new_player_row + (new_player_row - self.player_row)\n                new_box_col = new_player_col + (new_player_col - self.player_col)\n\n                if self.map[new_box_row][new_box_col] != \"#\":\n         self.boxes.remove((new_player_row, new_player_col))\n                    self.boxes.append((new_box_row, new_box_col))\n                    self.player_row = new_player_row\n          self.player_col = new_player_col\n            else:\n                self.player_row = new_player_row\n                self.player_col = new_player_col\n\n        return self.check_win()\n"
    },
    {
        "id" : "72",
        "code" : "\nimport re\n\nclass RegexUtils:\n    \"\"\"\n    The class provides to match, find all occurrences, split, and substitute text using regular expressions. It also includes predefined patterns, validating phone numbers and extracting email \naddresses.\n    \"\"\"\n\n\n    def match(self, pattern, text):\n        \"\"\"\n        Check if the text matches the regular expression\n        :param pattern: string, Regular expression pattern\n        :param text: string, Text to match\n        :return: True or False, representing whether the text matches the regular expression or not\n        >>> ru = RegexUtils()\n        >>> ru.match(r\\d{3}-\\d{3}-\\d{4', \"123-456-7890\")\n        True\n        \"\"\"\n        ans = re.match(pattern, text)\n        if ans:\n            return True\n        else:\n            return False\n\n    def findall(self, pattern, text):\n        \"\"\"\n        Find all matching substrings and return a list of all matching substrings\n        :param pattern: string, Regular expression pattern\n        :param text: string, Text to match\n        :return: list of string, List of all matching substrings\n        >>> ru = RegexUtils()\n        >>> ru.findall(r\\d{3}-\\d{3}-\\d{4', \"123-456-7890 abiguygusu 876-286-9876 kjgufwycs 987-762-9767\")\n        ['123-456-7890', '876-286-9876', '987-762-9767']\n        \"\"\"\n        return re.findall(pattern, text)\n\n    def split(self, pattern, text):\n        \"\"\"\n        Split text based on regular expression patterns and return a list of substrings\n        :param pattern: string, Regular expression pattern\n        :param text: string, Text to be split\n        :return: list of string, List of substrings after splitting\n        >>> ru = RegexUtils()\n        >>> ru.split(r\\d{3}-\\d{3}-\\d{4', \"123-456-7890 abiguygusu 876-286-9876 kjgufwycs 987-762-9767\")\n        ['', ' abiguygusu ', ' kjgufwycs ', '']\n        \"\"\"\n        return re.split(pattern, text)\n\n    def sub(self, pattern, replacement, text):\n        \"\"\"\n        Replace the substring matched by a regular expression with the specified string\n        :param pattern: string, Regular expression pattern\n        :param replacement: Text to replace with\n        :param text: string, Text to be replaced\n        :return: string, Text after replacement\n        >>> ru = RegexUtils()\n        >>> ru.sub(r\\d{3}-\\d{3}-\\d{4', 'phone num',  \"123-456-7890 abiguygusu 876-286-9876 kjgufwycs 987-762-9767\")\n        'phone num abiguygusu phone num kjgufwycs phone num'\n        \"\"\"\n        return re.sub(pattern, replacement, text)\n\n    def generate_email_pattern(self):\n        \"\"\"\n        Generate regular expression patterns that match email addresses\n        :return: string, regular expression patterns that match email addresses\n        >>> ru = RegexUtils()\n        >>> ru.generate_email_pattern()\n        [A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Z|a-z]{2,'\n        \"\"\"\n        pattern = r[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Z|a-z]{2,'\n        return pattern\n\n    def generate_phone_number_pattern(self):\n        \"\"\"\n        Generate regular expression patterns that match phone numbers\n        :return: string, regular expression patterns that match phone numbers\n        >>> ru = RegexUtils()\n        >>> ru.generate_phone_number_pattern()\n        \\d{3}-\\d{3}-\\d{4'\n        \"\"\"\n        pattern = r\\d{3}-\\d{3}-\\d{4'\n        return pattern\n\n    def generate_split_sentences_pattern(self):\n        \"\"\"\n        Generate regular expression patterns that match the middle characters of two sentences\n        :return: string, regular expression patterns that match the middle characters of two sentences\n        >>> ru = RegexUtils()\n        >>> ru.generate_split_sentences_pattern()\n        '[.!?][\\s]{1,2}(?=[A-Z])'\n        \"\"\"\n        pattern = r'[.!?][\\s]{1,2}(?=[A-Z])'\n        return pattern\n\n    def split_sentences(self, text):\n        \"\"\"\n        Split the text into a list of sentences without Punctuation except the last sentence\n        :param text: Text to be split\n        :return: Split Text List\n        >>> ru = RegexUtils()\n        >>> ru.split_sentences(\"Aaa. Bbbb? Ccc!\")\n        ['Aaa', 'Bbbb', 'Ccc!']\n        \"\"\"\n        pattern = self.generate_split_sentences_pattern()\n        return self.split(pattern, text)\n\n    def validate_phone_number(self, phone_number):\n        \"\"\"\n        Verify if the phone number is valid\n        :param phone_number: Phone number to be verified\n        :return: True or False, indicating whether the phone number is valid\n        >>> ru = RegexUtils()\n        >>> ru.validate_phone_number(\"123-456-7890\")\n        True\n        \"\"\"\n        pattern = self.generate_phone_number_pattern()\n        return self.match(pattern, phone_number)\n\n    def extract_email(self, text):\n        \"\"\"\n        Extract all email addresses from the text\n        :param text: string, input text\n        :return: list of string, All extracted email addresses\n        >>> ru = RegexUtils()\n        >>> ru.extract_email(\"abcdefg@163.com ygusyfysy@126.com wljduyuv@qq.com\")\n        ['abcdefg@163.com', 'ygusyfysy@126.com', 'wljduyuv@qq.com']\n        \"\"\"\n        pattern = self.generate_email_pattern()\n        return self.findall(pattern, text)\n",
        "annotated_code" : "\nimport re\n\nclass RegexUtils:\n    \"\"\"\n    The class provides to match, find all occurrences, split, and substitute text using regular expressions. It also includes predefined patterns, validating phone numbers and extracting email \naddresses.\n    \"\"\"\n\n\n    def match(self, pattern, text):\n        \"\"\"\n        Check if the text matches the regular expression\n        :param pattern: string, Regular expression pattern\n        :param text: string, Text to match\n        :return: True or False, representing whether the text matches the regular expression or not\n        >>> ru = RegexUtils()\n        >>> ru.match(r\\d{3}-\\d{3}-\\d{4', \"123-456-7890\")\n        True\n        \"\"\"\n        # Check if the text matches the regular expression pattern using re\n        ans = re.match(pattern, text)\n        if ans:\n            return True\n        else:\n            return False\n\n    def findall(self, pattern, text):\n        \"\"\"\n        Find all matching substrings and return a list of all matching substrings\n        :param pattern: string, Regular expression pattern\n        :param text: string, Text to match\n        :return: list of string, List of all matching substrings\n        >>> ru = RegexUtils()\n        >>> ru.findall(r\\d{3}-\\d{3}-\\d{4', \"123-456-7890 abiguygusu 876-286-9876 kjgufwycs 987-762-9767\")\n        ['123-456-7890', '876-286-9876', '987-762-9767']\n        \"\"\"\n        # Find all matching substrings using re and return them as a list\n        return re.findall(pattern, text)\n\n    def split(self, pattern, text):\n        \"\"\"\n        Split text based on regular expression patterns and return a list of substrings\n        :param pattern: string, Regular expression pattern\n        :param text: string, Text to be split\n        :return: list of string, List of substrings after splitting\n        >>> ru = RegexUtils()\n        >>> ru.split(r\\d{3}-\\d{3}-\\d{4', \"123-456-7890 abiguygusu 876-286-9876 kjgufwycs 987-762-9767\")\n        ['', ' abiguygusu ', ' kjgufwycs ', '']\n        \"\"\"\n        # Split the text based on the regular expression pattern using re and return the resulting list\n        return re.split(pattern, text)\n\n    def sub(self, pattern, replacement, text):\n        \"\"\"\n        Replace the substring matched by a regular expression with the specified string\n        :param pattern: string, Regular expression pattern\n        :param replacement: Text to replace with\n        :param text: string, Text to be replaced\n        :return: string, Text after replacement\n        >>> ru = RegexUtils()\n        >>> ru.sub(r\\d{3}-\\d{3}-\\d{4', 'phone num',  \"123-456-7890 abiguygusu 876-286-9876 kjgufwycs 987-762-9767\")\n        'phone num abiguygusu phone num kjgufwycs phone num'\n        \"\"\"\n        # Replace the substring matched by the regular expression with the specified string using re\n        return re.sub(pattern, replacement, text)\n\n    def generate_email_pattern(self):\n        \"\"\"\n        Generate regular expression patterns that match email addresses\n        :return: string, regular expression patterns that match email addresses\n        >>> ru = RegexUtils()\n        >>> ru.generate_email_pattern()\n        [A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Z|a-z]{2,'\n        \"\"\"\n        # Generate a regular expression pattern that matches email addresses\n        pattern = r[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Z|a-z]{2,'\n        return pattern\n\n    def generate_phone_number_pattern(self):\n        \"\"\"\n        Generate regular expression patterns that match phone numbers\n        :return: string, regular expression patterns that match phone numbers\n        >>> ru = RegexUtils()\n        >>> ru.generate_phone_number_pattern()\n        \\d{3}-\\d{3}-\\d{4'\n        \"\"\"\n        # Generate a regular expression pattern that matches phone numbers\n        pattern = r\\d{3}-\\d{3}-\\d{4'\n        return pattern\n\n    def generate_split_sentences_pattern(self):\n        \"\"\"\n        Generate regular expression patterns that match the middle characters of two sentences\n        :return: string, regular expression patterns that match the middle characters of two sentences\n        >>> ru = RegexUtils()\n        >>> ru.generate_split_sentences_pattern()\n        '[.!?][\\s]{1,2}(?=[A-Z])'\n        \"\"\"\n        # Generate a regular expression pattern that matches the middle characters of two sentences\n        pattern = r'[.!?][\\s]{1,2}(?=[A-Z])'\n        return pattern\n\n    def split_sentences(self, text):\n        \"\"\"\n        Split the text into a list of sentences without Punctuation except the last sentence\n        :param text: Text to be split\n        :return: Split Text List\n        >>> ru = RegexUtils()\n        >>> ru.split_sentences(\"Aaa. Bbbb? Ccc!\")\n        ['Aaa', 'Bbbb', 'Ccc!']\n        \"\"\"\n        # Split the text into a list of sentences using the generated pattern\n        pattern = self.generate_split_sentences_pattern()\n        return self.split(pattern, text)\n\n    def validate_phone_number(self, phone_number):\n        \"\"\"\n        Verify if the phone number is valid\n        :param phone_number: Phone number to be verified\n        :return: True or False, indicating whether the phone number is valid\n        >>> ru = RegexUtils()\n        >>> ru.validate_phone_number(\"123-456-7890\")\n        True\n        \"\"\"\n        # Validate the phone number using the generated pattern\n        pattern = self.generate_phone_number_pattern()\n        return self.match(pattern, phone_number)\n\n    def extract_email(self, text):\n        \"\"\"\n        Extract all email addresses from the text\n        :param text: string, input text\n        :return: list of string, All extracted email addresses\n        >>> ru = RegexUtils()\n        >>> ru.extract_email(\"abcdefg@163.com ygusyfysy@126.com wljduyuv@qq.com\")\n        ['abcdefg@163.com', 'ygusyfysy@126.com', 'wljduyuv@qq.com']\n        \"\"\"\n        # Extract all email addresses from the text using the generated pattern\n        pattern = self.generate_email_pattern()\n        return self.findall(pattern, text)\n"
    },
    {
        "id" : "73",
        "code" : "\nclass RPGCharacter:\n    \"\"\"\n    The class represents a role-playing game character, which allows to attack other characters, heal, gain experience, level up, and check if the character is alive.\n    \"\"\"\n\n    def __init__(self, name, hp, attack_power, defense, level=1):\n        \"\"\"\n        Initialize an RPG character object.\n        :param name: strm, the name of the character.\n        :param hp: int, The health points of the character.\n        :param attack_power: int, the attack power of the character.\n        :param defense: int, the defense points of the character.\n        :param level: int, the level of the character. Default is 1.\n        \"\"\"\n        self.name = name\n        self.hp = hp\n        self.attack_power = attack_power\n        self.defense = defense\n        self.level = level\n        self.exp = 0\n\n    def attack(self, other_character):\n        \"\"\"\n        Attack another character. The damage caused needs to offset the defense value.\n        :param other_character: str, The character being attacked.\n        >>> player_1 = RPGCharacter('player 1', 100, 10, 3)\n        >>> player_2 = RPGCharacter('player 2', 100, 7, 2)\n        >>> player_1.attack(player_2)\n        >>> player_2.hp\n        92\n        \"\"\"\n        damage = max(self.attack_power - other_character.defense, 1)\n        other_character.hp -= damage\n\n    def heal(self):\n        \"\"\"\n        Heal the character with 10 hp and the max hp is 100.\n        :return: int, the current health points after healing.\n        >>> player_1 = RPGCharacter('player 1', 93, 10, 3)\n        >>> player_1.heal()\n        100\n        \"\"\"\n        self.hp += 10\n        if self.hp > 100:\n            self.hp = 100\n        return self.hp\n\n    def gain_exp(self, amount):\n        \"\"\"\n        Gain experience points for the character and level_up when the exp has reached the values that is 100 times the current level\n        The experience that overflows should be used to calculate the next leve up untill exhausts\n        :param amount: int, the amount of experience points to gain.\n        >>> player_1 = RPGCharacter('player 1', 100, 10, 3)\n        >>> player_1.gain_exp(1100)\n        >>> player_1.exp\n        100\n        >>> player_1.level\n        5\n        \"\"\"\n        while amount != 0:\n            if self.exp + amount >= self.level * 100:\n                amount -= (self.level * 100 - self.exp)\n                self.level_up()\n            else:\n                self.exp += amount\n                amount = 0\n\n    def level_up(self):\n         \"\"\"\n        Level up the character and return to zero experience points, increase hp by 20 points, attack power and defense points by 5 points.\n        max level is 100\n        :return: tuple[int, int, int, int], the new level, health points, attack power, and defense points after leveling up.\n        >>> player_1 = RPGCharacter('player 1', 100, 10, 3)\n        >>> player_1.level_up()\n        (2, 120, 15, 8)\n        \"\"\"\n         if self.level < 100:\n            self.level += 1\n            self.exp = 0\n            self.hp += 20\n            self.attack_power += 5\n            self.defense += 5\n        return self.level, self.hp, self.attack_power, self.defense\n\n    def is_alive(self):\n        \"\"\"\n        Check if player is alive.\n        :return: True if the hp is larger than 0, or False otherwise.\n        >>> player_1 = RPGCharacter('player 1', 100, 10, 3)\n        >>> player_1.is_alive()\n        True\n        \"\"\"\n        return self.hp > 0\n",
        "annotated_code" : "\nclass RPGCharacter:\n    \"\"\"\n    The class represents a role-playing game character, which allows to attack other characters, heal, gain experience, level up, and check if the character is alive.\n    \"\"\"\n\n    def __init__(self, name, hp, attack_power, defense, level=1):\n        \"\"\"\n        Initialize an RPG character object.\n        :param name: strm, the name of the character.\n        :param hp: int, The health points of the character.\n        :param attack_power: int, the attack power of the character.\n        :param defense: int, the defense points of the character.\n        :param level: int, the level of the character. Default is 1.\n        \"\"\"\n        self.name = name\n        self.hp = hp\n        self.attack_power = attack_power\n        self.defense = defense\n        self.level = level\n        self.exp = 0\n\n    def attack(self, other_character):\n        \"\"\"\n        Attack another character. The damage caused needs to offset the defense value.\n        :param other_character: str, The character being attacked.\n        >>> player_1 = RPGCharacter('player 1', 100, 10, 3)\n        >>> player_2 = RPGCharacter('player 2', 100, 7, 2)\n        >>> player_1.attack(player_2)\n        >>> player_2.hp\n        92\n        \"\"\"\n        # Calculate the damage dealt to the other character\n        # The damage is the attack power minus the other character's defense, but at least 1 damage\n        damage = max(self.attack_power - other_character.defense, 1)\n        other_character.hp -= damage\n\n    def heal(self):\n        \"\"\"\n        Heal the character with 10 hp and the max hp is 100.\n        :return: int, the current health points after healing.\n        >>> player_1 = RPGCharacter('player 1', 93, 10, 3)\n        >>> player_1.heal()\n        100\n        \"\"\"\n        # Heal the character by 10 hp, but not exceeding the max hp of 100\n        self.hp += 10\n        if self.hp > 100:\n            self.hp = 100\n        return self.hp\n\n    def gain_exp(self, amount):\n        \"\"\"\n        Gain experience points for the character and level_up when the exp has reached the values that is 100 times the current level\n        The experience that overflows should be used to calculate the next leve up untill exhausts\n        :param amount: int, the amount of experience points to gain.\n        >>> player_1 = RPGCharacter('player 1', 100, 10, 3)\n        >>> player_1.gain_exp(1100)\n        >>> player_1.exp\n        100\n        >>> player_1.level\n        5\n        \"\"\"\n        # Gain experience points and level up if necessary\n        # The experience points are capped at 100 times the level\n        while amount != 0:\n            if self.exp + amount >= self.level * 100:\n                amount -= (self.level * 100 - self.exp)\n                self.level_up()\n            else:\n self.exp += amount\n                amount = 0\n\n    def level_up(self):\n        \"\"\"\n        Level up the character and return to zero experience points, increase hp by 20 points, attack power and defense points by 5 points.\n        max level is 100\n        :return: tuple[int, int, int, int], the new level, health points, attack power, and defense points after leveling up.\n        >>> player_1 = RPGCharacter('player 1', 100, 10, 3)\n        >>> player_1.level_up()\n        (2, 120, 15, 8)\n        \"\"\"\n        # Check if the character can level up\n        # The level is capped at 100\n        # The hp is increased by 20, attack power and defense points are increased by 5\n        # The experience points are reset to 0\n        if self.level < 100:\n            self.level += 1\n            self.exp = 0\n            self.hp += 20\n            self.attack_power += 5\n            self.defense += 5\n        return self.level, self.hp, self.attack_power, self.defense\n\n    def is_alive(self):\n        \"\"\"\n        Check if player is alive.\n        :return: True if the hp is larger than 0, or False otherwise.\n        >>> player_1 = RPGCharacter('player 1', 100, 10, 3)\n        >>> player_1.is_alive()\n        True\n        \"\"\"\n        # Check if the character is alive\n        # The character is alive if hp is greater than 0\n        return self.hp > 0\n"
    },
    {
        "id" : "74",
        "code" : "\nclass Server:\n    \"\"\"\n    This is a class as a server, which handles a white list, message sending and receiving, and information display.\n    \"\"\"\n\n\n    def __init__(self):\n        \"\"\"\n        Initialize the whitelist as an empty list, and initialize the sending and receiving information as an empty dictionary\n        \"\"\"\n        self.white_list = []\n        self.send_struct = {}\n        self.receive_struct = {}\n\n\n\n    def add_white_list(self, addr):\n        \"\"\"\n        Add an address to the whitelist and do nothing if it already exists\n        :param addr: int, address to be added\n        :return: new whitelist, return False if the address already exists\n        >>> server = Server()\n        >>> server.add_white_list(88)\n        [88]\n        \"\"\"\n        if addr in self.white_list:\n            return False\n        else:\n            self.white_list.append(addr)\n            return self.white_list\n\n    def del_white_list(self, addr):\n        \"\"\"\n        Remove an address from the whitelist and do nothing if it does not exist\n        :param addr: int, address to be deleted\n        :return: new whitelist, return False if the address does not exist\n        >>> server.add_white_list(88)\n        >>> server.del_white_list(88)\n        []\n        \"\"\"\n        if addr not in self.white_list:\n            return False\n        else:\n            self.white_list.remove(addr)\n            return self.white_list\n\n    def recv(self, info):\n        \"\"\"\n        Receive information containing address and content. If the address is on the whitelist, receive the content; otherwise, do not receive it\n        :param info: dict, information dictionary containing address and content\n        :return: if successfully received, return the content of the infomation; otherwise, return False\n        >>> server.recv({\"addr\":88,\"content\":\"abc\"})\n        abc\n        \"\"\"\n        if not isinstance(info, dict) or \"addr\" not in info or \"content\" not in info:\n            return -1\n        addr = info[\"addr\"]\n        content = info[\"content\"]\n        if addr not in self.white_list:\n            return False\n        else:\n            self.receive_struct = {\"addr\": addr, \"content\": content}\n            return self.receive_struct[\"content\"]\n\n    def send(self, info):\n        \"\"\"\n        Send information containing address and content\n        :param info: dict, information dictionary containing address and content\n        :return: if successfully sent, return nothing; otherwise, return a string indicating an error message\n        >>> server.send({\"addr\":66,\"content\":\"ABC\"})\n        self.send_struct = {\"addr\":66,\"content\":\"ABC\"}\n        \"\"\"\n        if not isinstance(info, dict) or \"addr\" not in info or \"content\" not in info:\n            return \"info structure is not correct\"\n        self.send_struct = {\"addr\": info[\"addr\"], \"content\": info[\"content\"]}\n\n    def show(self, type):\n        \"\"\"\n        Returns struct of the specified type\n        :param type: string, the type of struct to be returned, which can be 'send' or 'receive'\n        :return: if type is equal to 'send' or 'receive', return the corresponding struct; otherwise, return False\n        >>> server.recv({\"addr\":88,\"content\":\"abc\"})\n        >>> server.send({\"addr\":66,\"content\":\"ABC\"})\n        >>> server.show(\"send\")\n        {\"addr\":66,\"content\":\"ABC\"}\n        \"\"\"\n        if type == \"send\":\n            return self.send_struct\n        elif type == \"receive\":\n            return self.receive_struct\n        else:\n            return False\n",
        "annotated_code" : "\nclass Server:\n    \"\"\"\n    This is a class as a server, which handles a white list, message sending and receiving, and information display.\n    \"\"\"\n\n\n    def __init__(self):\n        \"\"\"\n        Initialize the whitelist as an empty list, and initialize the sending and receiving information as an empty dictionary\n        \"\"\"\n        self.white_list = []\n        self.send_struct = {}\n        self.receive_struct = {}\n\n\n\n    def add_white_list(self, addr):\n        \"\"\"\n        Add an address to the whitelist and do nothing if it already exists\n        :param addr: int, address to be added\n        :return: new whitelist, return False if the address already exists\n        >>> server = Server()\n        >>> server.add_white_list(88)\n        [88]\n        \"\"\"\n        # Add an address to the whitelist and do nothing if it already exists\n        if addr in self.white_list:\n            return False\n        else:\n            self.white_list.append(addr)\n            return self.white_list\n\n    def del_white_list(self, addr):\n        \"\"\"\n        Remove an address from the whitelist and do nothing if it does not exist\n        :param addr: int, address to be deleted\n        :return: new whitelist, return False if the address does not exist\n        >>> server.add_white_list(88)\n        >>> server.del_white_list(88)\n        []\n        \"\"\"\n        # Remove an address from the whitelist and do nothing if it does not exist\n        if addr not in self.white_list:\n            return False\n        else:\n            self.white_list.remove(addr)\n            return self.white_list\n\n    def recv(self, info):\n        \"\"\"\n        Receive information containing address and content. If the address is on the whitelist, receive the content; otherwise, do not receive it\n        :param info: dict, information dictionary containing address and content\n        :return: if successfully received, return the content of the infomation; otherwise, return False\n        >>> server.recv({\"addr\":88,\"content\":\"abc\"})\n        abc\n        \"\"\"\n        # Receive information containing address and content. If the address is on the whitelist, receive the content; otherwise, do not receive it\n        if not isinstance(info, dict) or \"addr\" not in info or \"content\" not in info:\n            return -1\n        addr = info[\"addr\"]\n        content = info[\"content\"]\n        if addr not in self.white_list:\n            return False\n        else:\n            self.receive_struct = {\"addr\": addr, \"content\": content}\n            return self.receive_struct[\"content\"]\n\n    def send(self, info):\n        \"\"\"\n        Send information containing address and content\n        :param info: dict, information dictionary containing address and content\n        :return: if successfully sent, return nothing; otherwise, return a string indicating an error message\n        >>> server.send({\"addr\":66,\"content\":\"ABC\"})\n        self.send_struct = {\"addr\":66,\"content\":\"ABC\"}\n        \"\"\"\n        # Send information containing address and content\n        # Check if the info is a dictionary and contains the required keys\n        if not isinstance(info, dict) or \"addr\" not in info or \"content\" not in info:\n            return \"info structure is not correct\"\n        self.send_struct = {\"addr\": info[\"addr\"], \"content\": info[\"content\"]}\n\n    def show(self, type):\n        \"\"\"\n        Returns struct of the specified type\n        :param type: string, the type of struct to be returned, which can be 'send' or 'receive'\n        :return: if type is equal to 'send' or 'receive', return the corresponding struct; otherwise, return False\n        >>> server.recv({\"addr\":88,\"content\":\"abc\"})\n        >>> server.send({\"addr\":66,\"content\":\"ABC\"})\n        >>> server.show(\"send\")\n        {\"addr\":66,\"content\":\"ABC\"}\n        \"\"\"\n        # Returns struct of the specified type\n        # Check if the type is valid\n        if type == \"send\":\n            return self.send_struct\n        elif type == \"receive\":\n            return self.receive_struct\n        else:\n            return False\n"
    },
    {
        "id" : "75",
        "code" : "\nclass ShoppingCart:\n    \"\"\"\n    The class manages items, their prices, quantities, and allows to for add, removie, view items, and calculate the total price.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the items representing the shopping list as an empty dictionary\n        \"\"\"\n        self.items = {}\n\n\n    def add_item(self, item, price, quantity=1):\n        \"\"\"\n        Add item information to the shopping list items, including price and quantity. The default quantity is 1\n        :param item: string, Item to be added\n        :param price: float, The price of the item\n        :param quantity:int, The number of items, defaults to 1\n        :return:None\n        >>> shoppingcart = ShoppingCart()\n        >>> shoppingcart.add_item(\"apple\", 1, 5)\n        self.items = {\"apple\":{\"price\":1, \"quantity\":5}}\n        \"\"\"\n        if item in self.items:\n            self.items[item] = {'price': price, 'quantity': quantity}\n        else:\n            self.items[item] = {'price': price, 'quantity': quantity}\n\n\n    def remove_item(self, item, quantity=1):\n        \"\"\"\n        Subtract the specified quantity of item from the shopping list items\n        :param item:string, Item to be subtracted in quantity\n        :param quantity:int, Quantity to be subtracted\n        :return:None\n        >>> shoppingcart.add_item(\"apple\", 1, 5)\n        >>> shoppingcart.remove_item(\"apple\", 3)\n        self.items = {\"apple\":{\"price\":1, \"quantity\":2}}\n        \"\"\"\n        if item in self.items:\n            self.items[item]['quantity'] -= quantity\n        else:\n            pass\n\n\n    def view_items(self) -> dict:\n        \"\"\"\n        Return the current shopping list items\n        :return:dict, the current shopping list items\n        >>> shoppingcart.add_item(\"apple\", 1, 5)\n        >>> shoppingcart.remove_item(\"apple\", 3)\n        >>> shoppingcart.view_items()\n        {\"apple\":{\"price\":1, \"quantity\":2}}\n        \"\"\"\n        return self.items\n\n\n    def total_price(self) -> float:\n        \"\"\"\n        Calculate the total price of all items in the shopping list, which is the quantity of each item multiplied by the price\n        :return:float, the total price of all items in the shopping list\n        >>> shoppingcart = ShoppingCart()\n        >>> shoppingcart.add_item(\"apple\", 1, 5)\n        >>> shoppingcart.add_item(\"banana\", 2, 3)\n        >>> shoppingcart.total_price()\n        11.0\n        \"\"\"\n        return sum([item['quantity'] * item['price'] for item in self.items.values()])\n",
        "annotated_code" : "\nclass ShoppingCart:\n    \"\"\"\n    The class manages items, their prices, quantities, and allows to for add, removie, view items, and calculate the total price.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the items representing the shopping list as an empty dictionary\n        \"\"\"\n        self.items = {}\n\n\n    def add_item(self, item, price, quantity=1):\n        \"\"\"\n        Add item information to the shopping list items, including price and quantity. The default quantity is 1\n        :param item: string, Item to be added\n        :param price: float, The price of the item\n        :param quantity:int, The number of items, defaults to 1\n        :return:None\n        >>> shoppingcart = ShoppingCart()\n        >>> shoppingcart.add_item(\"apple\", 1, 5)\n        self.items = {\"apple\":{\"price\":1, \"quantity\":5}}\n        \"\"\"\n        # Add item information to the shopping list items, including price and quantity\n        if item in self.items:\n            self.items[item] = {'price': price, 'quantity': quantity}\n        else:\n            self.items[item] = {'price': price, 'quantity': quantity}\n\n\n    def remove_item(self, item, quantity=1):\n        \"\"\"\n        Subtract the specified quantity of item from the shopping list items\n        :param item:string, Item to be subtracted in quantity\n        :param quantity:int, Quantity to be subtracted\n        :return:None\n        >>> shoppingcart.add_item(\"apple\", 1, 5)\n        >>> shoppingcart.remove_item(\"apple\", 3)\n        self.items = {\"apple\":{\"price\":1, \"quantity\":2}}\n        \"\"\"\n        # Subtract the specified quantity of item from the shopping list items\n        # If the item is not in the shopping list, do nothing\n        if item in self.items:\n            self.items[item]['quantity'] -= quantity\n        else:\n            pass\n\n\n    def view_items(self) -> dict:\n        \"\"\"\n        Return the current shopping list items\n        :return:dict, the current shopping list items\n        >>> shoppingcart.add_item(\"apple\", 1, 5)\n        >>> shoppingcart.remove_item(\"apple\", 3)\n        >>> shoppingcart.view_items()\n        {\"apple\":{\"price\":1, \"quantity\":2}}\n        \"\"\"\n        # Return the current shopping list items\n        return self.items\n\n\n    def total_price(self) -> float:\n        \"\"\"\n        Calculate the total price of all items in the shopping list, which is the quantity of each item multiplied by the price\n        :return:float, the total price of all items in the shopping list\n        >>> shoppingcart = ShoppingCart()\n        >>> shoppingcart.add_item(\"apple\", 1, 5)\n        >>> shoppingcart.add_item(\"banana\", 2, 3)\n        >>> shoppingcart.total_price()\n        11.0\n        \"\"\"\n        # Calculate the total price of all items in the shopping list\n        # which is the quantity of each item multiplied by the price\n        return sum([item['quantity'] * item['price'] for item in self.items.values()])\n"
    },
    {
        "id" : "76",
        "code" : "\nclass SignInSystem:\n    \"\"\"\n    This is a class as sigin in system, including adding users, signing in/out, checking sign-in status, and retrieving signed-in/not signed-in users.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the sign-in system.\n        \"\"\"\n        self.users = {}\n\n    def add_user(self, username):\n        \"\"\"\n        Add a user to the sign-in system if the user wasn't in the self.users.\n        And the initial state is False.\n        :param username: str, the username to be added.\n        :return: bool, True if the user is added successfully, False if the user already exists.\n        >>> signInSystem.add_user(\"mike\")\n        True\n        >>> signInSystem.add_user(\"mike\")\n        False\n        \"\"\"\n        if username in self.users:\n            return False\n        else:\n            self.users[username] = False\n            return True\n\n    def sign_in(self, username):\n        \"\"\"\n        Sign in a user if the user was in the self.users and change the state to True.\n        :param username: str, the username to be signed in.\n        :return: bool, True if the user is signed in successfully, False if the user does not exist.\n        >>> signInSystem.sign_in(\"mike\")\n        True\n        >>> signInSystem.sign_in(\"mik\")\n        False\n        \"\"\"\n        if username not in self.users:\n            return False\n        else:\n            self.users[username] = True\n            return True\n\n    def check_sign_in(self, username):\n        \"\"\"\n        Check if a user is signed in.\n        :param username: str, the username to be checked.\n        :return: bool, True if the user is signed in, False if the user does not exist or is not signed in.\n        >>> signInSystem.check_sign_in(\"jack\")\n        False\n        >>> signInSystem.add_user(\"jack\")\n        >>> signInSystem.check_sign_in(\"jack\")\n        >>> signInSystem.sign_in(\"jack\")\n        >>> signInSystem.check_sign_in(\"jack\")\n        True\n        \"\"\"\n        if username not in self.users:\n            return False\n        else:\n            if self.users[username]:\n                return True\n            else:\n                return False\n\n    def all_signed_in(self):\n        \"\"\"\n        Check if all users are signed in.\n        :return: bool, True if all users are signed in, False otherwise.\n        >>> signInSystem.add_user(\"jack\")\n        True\n        >>> signInSystem.sign_in(\"jack\")\n        >>> signInSystem.all_signed_in()\n        True\n        \"\"\"\n        if all(self.users.values()):\n            return True\n        else:\n            return False\n\n    def all_not_signed_in(self):\n        \"\"\"\n        Get a list of usernames that are not signed in.\n        :return: list[str], a list of usernames that are not signed in.\n        >>> signInSystem = SignInSystem()\n        >>> signInSystem.add_user(\"a\")\n        True\n        >>> signInSystem.add_user(\"b\")\n        True\n        >>> signInSystem.all_not_signed_in()\n        ['a', 'b']\n        \"\"\"\n        not_signed_in_users = []\n        for username, signed_in in self.users.items():\n            if not signed_in:\n                not_signed_in_users.append(username)\n        return not_signed_in_users\n",
        "annotated_code" : "\nclass SignInSystem:\n    \"\"\"\n    This is a class as sigin in system, including adding users, signing in/out, checking sign-in status, and retrieving signed-in/not signed-in users.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the sign-in system.\n        \"\"\"\n        self.users = {}\n\n    def add_user(self, username):\n        \"\"\"\n        Add a user to the sign-in system if the user wasn't in the self.users.\n        And the initial state is False.\n        :param username: str, the username to be added.\n        :return: bool, True if the user is added successfully, False if the user already exists.\n        >>> signInSystem.add_user(\"mike\")\n        True\n        >>> signInSystem.add_user(\"mike\")\n        False\n        \"\"\"\n        # Check if the user already exists in the system\n        # If the user exists, return False\n        # If the user does not exist, add the user with initial state False and return True\n        if username in self.users:\n            return False\n        else:\n            self.users[username] = False\n            return True\n\n    def sign_in(self, username):\n        \"\"\"\n        Sign in a user if the user was in the self.users and change the state to True.\n        :param username: str, the username to be signed in.\n        :return: bool, True if the user is signed in successfully, False if the user does not exist.\n        >>> signInSystem.sign_in(\"mike\")\n        True\n        >>> signInSystem.sign_in(\"mik\")\n        False\n        \"\"\"\n        # Check if the user exists in the system\n        # If the user does not exist, return False\n        # If the user exists, change the state to True and return True\n        if username not in self.users:\n            return False\n        else:\n            self.users[username] = True\n            return True\n\n    def check_sign_in(self, username):\n        \"\"\"\n        Check if a user is signed in.\n        :param username: str, the username to be checked.\n        :return: bool, True if the user is signed in, False if the user does not exist or is not signed in.\n        >>> signInSystem.check_sign_in(\"jack\")\n        False\n        >>> signInSystem.add_user(\"jack\")\n        >>> signInSystem.check_sign_in(\"jack\")\n        >>> signInSystem.sign_in(\"jack\")\n        >>> signInSystem.check_sign_in(\"jack\")\n        True\n        \"\"\"\n        # Check if the user exists in the system\n        # If the user does not exist, return False\n        # If the user exists, check the state and return True or False\n        # If the user is signed in, return True\n        # If the user is not signed in, return False\n        if username not in self.users:\n            return False\n        else:\n            if self.users[username]:\n                return True\n            else:\n                return False\n\n    def all_signed_in(self):\n        \"\"\"\n        Check if all users are signed in.\n        :return: bool, True if all users are signed in, False otherwise.\n        >>> signInSystem.add_user(\"jack\")\n        True\n        >>> signInSystem.sign_in(\"jack\")\n        >>> signInSystem.all_signed_in()\n        True\n        \"\"\"\n        # Check if all users are signed in\n        # If all users are signed in, return True\n        # If not all users are signed in, return False\n        if all(self.users.values()):\n            return True\n        else:\n            return False\n\n    def all_not_signed_in(self):\n        \"\"\"\n        Get a list of usernames that are not signed in.\n        :return: list[str], a list of usernames that are not signed in.\n        >>> signInSystem = SignInSystem()\n        >>> signInSystem.add_user(\"a\")\n        True\n        >>> signInSystem.add_user(\"b\")\n        True\n        >>> signInSystem.all_not_signed_in()\n        ['a', 'b']\n        \"\"\"\n        # Create a list to store usernames that are not signed in\n        # Iterate through the users dictionary and check the sign-in status\n        # If the user is not signed in, add the username to the list\n        # Return the list of usernames that are not signed in\n        not_signed_in_users = []\n        for username, signed_in in self.users.items():\n            if not signed_in:\n                not_signed_in_users.append(username)\n        return not_signed_in_users\n"
    },
    {
        "id" : "77",
        "code" : "\nimport random\n\nclass Snake:\n    \"\"\"\n    The class is a snake game, with allows snake to move and eat food, and also enables to reset, and generat a random food position.\n    \"\"\"\n\n    def __init__(self, SCREEN_WIDTH, SCREEN_HEIGHT, BLOCK_SIZE, food_position):\n        \"\"\"\n        Initialize the length of the snake, screen width, screen height, block size, snake head position, score, and food position.\n        :param SCREEN_WIDTH: int\n        :param SCREEN_HEIGHT: int\n        :param BLOCK_SIZE: int, Size of moving units\n        :param food_position: tuple, representing the position(x, y) of food.\n        \"\"\"\n        self.length = 1\n        self.SCREEN_WIDTH = SCREEN_WIDTH\n        self.SCREEN_HEIGHT = SCREEN_HEIGHT\n        self.BLOCK_SIZE = BLOCK_SIZE\n        self.positions = [((SCREEN_WIDTH / 2), (SCREEN_HEIGHT / 2))]\n        self.score = 0\n        self.food_position = food_position\n\n\n    def move(self, direction):\n        \"\"\"\n        Move the snake in the specified direction. If the new position of the snake's head is equal to the position of the food, then eat the food; If the position of the snake's head is equal \nto the position of its body, then start over, otherwise its own length plus one.\n        :param direction: tuple, representing the direction of movement (x, y).\n        :return: None\n        >>> snake.move((1,1))\n        self.length = 1\n        self.positions = [(51, 51), (50, 50)]\n        self.score = 10\n        \"\"\"\n        cur = self.positions[0]\n        x, y = direction\n\n        new = (\n            ((cur[0] + (x * self.BLOCK_SIZE)) % self.SCREEN_WIDTH),\n            (cur[1] + (y * self.BLOCK_SIZE)) % self.SCREEN_HEIGHT,\n        )\n\n        if new == self.food_position:\n            self.eat_food()\n\n        if len(self.positions) > 2 and new in self.positions[2:]:\n            self.reset()\n        else:\n            self.positions.insert(0, new)\n            if len(self.positions) > self.length:\n                self.positions.pop()\n\n\n    def random_food_position(self):\n        \"\"\"\n        Randomly generate a new food position, but don't place it on the snake.\n        :return: None, Change the food position\n        \"\"\"\n        while self.food_position in self.positions:\n            self.food_position = (random.randint(0, self.SCREEN_WIDTH // self.BLOCK_SIZE - 1) * self.BLOCK_SIZE,\n                                  random.randint(0, self.SCREEN_HEIGHT // self.BLOCK_SIZE - 1) * self.BLOCK_SIZE)\n\n\n    def reset(self):\n        \"\"\"\n        Reset the snake to its initial state. Set the length to 1, the snake head position to ((SCREEN_WIDTH/2), (SCREEN_HEIGHT/2)), the score to 0, and randomly generate new food position.    \n        :return: None\n        >>> snake = Snake(100, 100, 1, (51, 51))\n        >>> snake.reset()\n        self.length = 1\n        self.positions = [(50, 50)]\n        self.score = 0\n        self.random_food_position()\n        \"\"\"\n        self.length = 1\n        self.positions = [((self.SCREEN_WIDTH / 2), (self.SCREEN_HEIGHT / 2))]\n        self.score = 0\n        self.random_food_position()\n\n\n    def eat_food(self):\n        \"\"\"\n        Increase the length of the snake by 1 and increase the score by 100. Randomly generate a new food position, but\n        don't place it on the snake.\n        :return: None\n        >>> snake = Snake(100, 100, 1, (51, 51))\n        >>> snake.move((1,1))\n        >>> snake.eat_food()\n        self.length = 2\n        self.score = 10\n        \"\"\"\n        self.length += 1\n        self.score += 100\n        self.random_food_position()\n",
        "annotated_code" : "\nimport random\n\nclass Snake:\n    \"\"\"\n    The class is a snake game, with allows snake to move and eat food, and also enables to reset, and generat a random food position.\n    \"\"\"\n\n    def __init__(self, SCREEN_WIDTH, SCREEN_HEIGHT, BLOCK_SIZE, food_position):\n        \"\"\"\n        Initialize the length of the snake, screen width, screen height, block size, snake head position, score, and food position.\n        :param SCREEN_WIDTH: int\n        :param SCREEN_HEIGHT: int\n        :param BLOCK_SIZE: int, Size of moving units\n        :param food_position: tuple, representing the position(x, y) of food.\n        \"\"\"\n        self.length = 1\n        self.SCREEN_WIDTH = SCREEN_WIDTH\n        self.SCREEN_HEIGHT = SCREEN_HEIGHT\n        self.BLOCK_SIZE = BLOCK_SIZE\n        self.positions = [((SCREEN_WIDTH / 2), (SCREEN_HEIGHT / 2))]\n        self.score = 0\n        self.food_position = food_position\n\n\n    def move(self, direction):\n        \"\"\"\n        Move the snake in the specified direction. If the new position of the snake's head is equal to the position of the food, then eat the food; If the position of the snake's head is equal \nto the position of its body, then start over, otherwise its own length plus one.\n        :param direction: tuple, representing the direction of movement (x, y).\n        :return: None\n        >>> snake.move((1,1))\n        self.length = 1\n        self.positions = [(51, 51), (50, 50)]\n        self.score = 10\n        \"\"\"\n        # Move the snake in the specified direction\n        # If the new position of the snake's head is equal to the position of the food, then eat the food\n        # If the position of the snake's head is equal to the position of its body, then start over, otherwise its own length plus one.\n        cur = self.positions[0]\n        x, y = direction\n\n        new = (\n            ((cur[0] + (x * self.BLOCK_SIZE)) % self.SCREEN_WIDTH),\n            (cur[1] + (y * self.BLOCK_SIZE)) % self.SCREEN_HEIGHT,\n        )\n\n        if new == self.food_position:\n            self.eat_food()\n\n        if len(self.positions) > 2 and new in self.positions[2:]:\n            self.reset()\n        else:\n            self.positions.insert(0, new)\n            if len(self.positions) > self.length:\n   self.positions.pop()\n\n\n    def random_food_position(self):\n        \"\"\"\n        Randomly generate a new food position, but don't place it on the snake.\n        :return: None, Change the food position\n        \"\"\"\n        # Randomly generate a new food position, but don't place it on the snake.\n        while self.food_position in self.positions:\n            self.food_position = (random.randint(0, self.SCREEN_WIDTH // self.BLOCK_SIZE - 1) * self.BLOCK_SIZE,\n                                  random.randint(0, self.SCREEN_HEIGHT // self.BLOCK_SIZE - 1) * self.BLOCK_SIZE)\n\n\n    def reset(self):\n        \"\"\"\n        Reset the snake to its initial state. Set the length to 1, the snake head position to ((SCREEN_WIDTH/2), (SCREEN_HEIGHT/2)), the score to 0, and randomly generate new food position.    \n        :return: None\n        >>> snake = Snake(100, 100, 1, (51, 51))\n        >>> snake.reset()\n        self.length = 1\n        self.positions = [(50, 50)]\n        self.score = 0\n        self.random_food_position()\n        \"\"\"\n        # Reset the snake to its initial state\n        # Set the length to 1, the snake head position to ((SCREEN_WIDTH/2), (SCREEN_HEIGHT/2)), the score to 0, and randomly generate new food position.\n        self.length = 1\n        self.positions = [((self.SCREEN_WIDTH / 2), (self.SCREEN_HEIGHT / 2))]\n        self.score = 0\n        self.random_food_position()\n\n\n    def eat_food(self):\n        \"\"\"\n        Increase the length of the snake by 1 and increase the score by 100. Randomly generate a new food position, but\n        don't place it on the snake.\n        :return: None\n        >>> snake = Snake(100, 100, 1, (51, 51))\n        >>> snake.move((1,1))\n        >>> snake.eat_food()\n        self.length = 2\n        self.score = 10\n        \"\"\"\n        # Increase the length of the snake by 1 and increase the score by 100\n        # Randomly generate a new food position, but don't place it on the snake.\n        self.length += 1\n        self.score += 100\n        self.random_food_position()\n"
    },
    {
        "id" : "78",
        "code" : "\nimport re\n\nclass SplitSentence:\n    \"\"\"\n    The class allows to split sentences, count words in a sentence, and process a text file to find the maximum word count.\n    \"\"\"\n\n\n    def split_sentences(self, sentences_string):\n        \"\"\"\n        Split a string into a list of sentences. Sentences end with . or ? and with a space after that. Please note that Mr. also end with . but are not sentences.\n        :param sentences_string: string, string to split\n        :return:list, split sentence list\n        >>> ss = SplitSentence()\n        >>> ss.split_sentences(\"aaa aaaa. bb bbbb bbb? cccc cccc. dd ddd?\")\n        ['aaa aaaa.', 'bb bbbb bbb?', 'cccc cccc.', 'dd ddd?']\n        \"\"\"\n        sentences = re.split(r'(?<!\\w\\.\\w.)(?<![A-Z][a-z]\\.)(?<=\\.|\\?)\\s', sentences_string)\n        return sentences\n\n    def count_words(self, sentence):\n        \"\"\"\n        Count the number of words in a sentence. Note that words are separated by spaces and that punctuation marks and numbers are not counted as words.\n        :param sentence:string, sentence to be counted, where words are separated by spaces\n        :return:int, number of words in the sentence\n        >>> ss.count_words(\"abc def\")\n        2\n        \"\"\"\n        sentence = re.sub(r'[^a-zA-Z\\s]', '', sentence)\n        words = sentence.split()\n        return len(words)\n\n    def process_text_file(self, sentences_string):\n        \"\"\"\n        Given a text, return the number of words in the longest sentence\n        :param sentences_string: string, undivided long sentence\n        :return:int, the number of words in the longest sentence\n        >>> ss.process_text_file(\"aaa aaaa. bb bbbb bbb? cccc ccccccc cc ccc. dd ddd?\")\n        4\n        \"\"\"\n        sentences = self.split_sentences(sentences_string)\n        max_count = 0\n        for sentence in sentences:\n            count = self.count_words(sentence)\n            if count > max_count:\n                max_count = count\n\n        return max_count\n",
        "annotated_code" : "\nimport re\n\nclass SplitSentence:\n    \"\"\"\n    The class allows to split sentences, count words in a sentence, and process a text file to find the maximum word count.\n    \"\"\"\n\n\n    def split_sentences(self, sentences_string):\n        \"\"\"\n        Split a string into a list of sentences. Sentences end with . or ? and with a space after that. Please note that Mr. also end with . but are not sentences.\n        :param sentences_string: string, string to split\n        :return:list, split sentence list\n        >>> ss = SplitSentence()\n        >>> ss.split_sentences(\"aaa aaaa. bb bbbb bbb? cccc cccc. dd ddd?\")\n        ['aaa aaaa.', 'bb bbbb bbb?', 'cccc cccc.', 'dd ddd?']\n        \"\"\"\n        # Split the string into sentences using regex\n        # The regex looks for a period or question mark followed by a space, but not preceded by a word character (to avoid splitting on abbreviations like \"Mr.\")\n        sentences = re.split(r'(?<!\\w\\.\\w.)(?<![A-Z][a-z]\\.)(?<=\\.|\\?)\\s', sentences_string)\n        return sentences\n\n    def count_words(self, sentence):\n        \"\"\"\n        Count the number of words in a sentence. Note that words are separated by spaces and that punctuation marks and numbers are not counted as words.\n        :param sentence:string, sentence to be counted, where words are separated by spaces\n        :return:int, number of words in the sentence\n        >>> ss.count_words(\"abc def\")\n        2\n        \"\"\"\n        # Remove punctuation and numbers from the sentence\n        # and split the sentence into words\n        # Count the number of words\n        sentence = re.sub(r'[^a-zA-Z\\s]', '', sentence)\n        words = sentence.split()\n        return len(words)\n\n    def process_text_file(self, sentences_string):\n        \"\"\"\n        Given a text, return the number of words in the longest sentence\n        :param sentences_string: string, undivided long sentence\n        :return:int, the number of words in the longest sentence\n        >>> ss.process_text_file(\"aaa aaaa. bb bbbb bbb? cccc ccccccc cc ccc. dd ddd?\")\n        4\n        \"\"\"\n        # Given a string, split it into sentences using the split_sentences method\n        # and then count the number of words in each sentence using the count_words method\n        sentences = self.split_sentences(sentences_string)\n        max_count = 0\n        for sentence in sentences:\n            count = self.count_words(sentence)\n            if count > max_count:\n                max_count = count\n\n        return max_count\n"
    },
    {
        "id" : "79",
        "code" : "\nclass SQLGenerator:\n    \"\"\"\n    This class generates SQL statements for common operations on a table, such as SELECT, INSERT, UPDATE, and DELETE.\n    \"\"\"\n\n    def __init__(self, table_name):\n        \"\"\"\n        Initialize the table name.\n        :param table_name: str\n        \"\"\"\n        self.table_name = table_name\n\n    def select(self, fields=None, condition=None):\n        \"\"\"\n        Generates a SELECT SQL statement based on the specified fields and conditions.\n        :param fields: list, optional. Default is None. The list of fields to be queried.\n        :param condition: str, optional. Default is None. The condition expression for the query.\n        :return: str. The generated SQL statement.\n        >>> sql = SQLGenerator('table1')\n        >>> sql.select(['field1', 'field2'], 'filed3 = value1')\n        'SELECT field1, field2 FROM table1 WHERE filed3 = value1;'\n        \"\"\"\n        if fields is None:\n            fields = \"*\"\n        else:\n            fields = \", \".join(fields)\n        sql = f\"SELECT {fields} FROM {self.table_name}\"\n        if condition is not None:\n            sql += f\" WHERE {condition}\"\n        return sql + \";\"\n\n    def insert(self, data):\n        \"\"\"\n        Generates an INSERT SQL statement based on the given data.\n        :param data: dict. The data to be inserted, in dictionary form where keys are field names and values are field values.\n        :return: str. The generated SQL statement.\n        >>> sql.insert({'key1': 'value1', 'key2': 'value2'})\n        \"INSERT INTO table1 (key1, key2) VALUES ('value1', 'value2');\"\n        \"\"\"\n        fields = \", \".join(data.keys())\n        values = \", \".join([f\"'{value}'\" for value in data.values()])\n        sql = f\"INSERT INTO {self.table_name} ({fields}) VALUES ({values})\"\n        return sql + \";\"\n\n\n    def update(self, data, condition):\n        \"\"\"\n        Generates an UPDATE SQL statement based on the given data and condition.\n        :param data: dict. The data to be updated, in dictionary form where keys are field names and values are new field values.\n        :param condition: str. The condition expression for the update.\n        :return: str. The generated SQL statement.\n        >>> sql.update({'field1': 'new_value1', 'field2': 'new_value2'}, \"field3 = value1\")\n        \"UPDATE table1 SET field1 = 'new_value1', field2 = 'new_value2' WHERE field3 = value1;\"\n        \"\"\"\n        set_clause = \", \".join([f\"{field} = '{value}'\" for field, value in data.items()])\n        sql = f\"UPDATE {self.table_name} SET {set_clause} WHERE {condition}\"\n        return sql + \";\"\n\n    def delete(self, condition):\n        \"\"\"\n        Generates a DELETE SQL statement based on the given condition.\n        :param condition: str. The condition expression for the delete.\n        :return: str. The generated SQL statement.\n        >>> sql.delete(\"field1 = value1\")\n        'DELETE FROM table1 WHERE field1 = value1;'\n        \"\"\"\n        sql = f\"DELETE FROM {self.table_name} WHERE {condition}\"\n        return sql + \";\"\n\n    def select_female_under_age(self, age):\n        \"\"\"\n        Generates a SQL statement to select females under a specified age.\n        :param age: int. The specified age.\n        :return: str. The generated SQL statement.\n        >>> sql.select_female_under_age(30)\n        \"SELECT * FROM table1 WHERE age < 30 AND gender = 'female';\"\n        \"\"\"\n        condition = f\"age < {age} AND gender = 'female'\"\n        return self.select(condition=condition)\n\n    def select_by_age_range(self, min_age, max_age):\n        \"\"\"\n        Generates a SQL statement to select records within a specified age range.\n        :param min_age: int. The minimum age.\n        :param max_age: int. The maximum age.\n        :return: str. The generated SQL statement.\n        >>> sql.select_by_age_range(20, 30)\n        'SELECT * FROM table1 WHERE age BETWEEN 20 AND 30;'\n        \"\"\"\n        condition = f\"age BETWEEN {min_age} AND {max_age}\"\n        return self.select(condition=condition)\n",
        "annotated_code" : "\nclass SQLGenerator:\n    \"\"\"\n    This class generates SQL statements for common operations on a table, such as SELECT, INSERT, UPDATE, and DELETE.\n    \"\"\"\n\n    def __init__(self, table_name):\n        \"\"\"\n        Initialize the table name.\n        :param table_name: str\n        \"\"\"\n        self.table_name = table_name\n\n    def select(self, fields=None, condition=None):\n        \"\"\"\n        Generates a SELECT SQL statement based on the specified fields and conditions.\n        :param fields: list, optional. Default is None. The list of fields to be queried.\n        :param condition: str, optional. Default is None. The condition expression for the query.\n        :return: str. The generated SQL statement.\n        >>> sql = SQLGenerator('table1')\n        >>> sql.select(['field1', 'field2'], 'filed3 = value1')\n        'SELECT field1, field2 FROM table1 WHERE filed3 = value1;'\n        \"\"\"\n        # Generate the SQL statement based on the provided fields and condition\n        if fields is None:\n            fields = \"*\"\n        else:\n            fields = \", \".join(fields)\n        sql = f\"SELECT {fields} FROM {self.table_name}\"\n        if condition is not None:\n            sql += f\" WHERE {condition}\"\n        return sql + \";\"\n\n    def insert(self, data):\n        \"\"\"\n        Generates an INSERT SQL statement based on the given data.\n        :param data: dict. The data to be inserted, in dictionary form where keys are field names and values are field values.\n        :return: str. The generated SQL statement.\n        >>> sql.insert({'key1': 'value1', 'key2': 'value2'})\n        \"INSERT INTO table1 (key1, key2) VALUES ('value1', 'value2');\"\n        \"\"\"\n        # Generates an INSERT SQL statement based on the provided data\n        fields = \", \".join(data.keys())\n        values = \", \".join([f\"'{value}'\" for value in data.values()])\n        sql = f\"INSERT INTO {self.table_name} ({fields}) VALUES ({values})\"\n        return sql + \";\"\n\n\n    def update(self, data, condition):\n        \"\"\"\n        Generates an UPDATE SQL statement based on the given data and condition.\n        :param data: dict. The data to be updated, in dictionary form where keys are field names and values are new field values.\n        :param condition: str. The condition expression for the update.\n        :return: str. The generated SQL statement.\n        >>> sql.update({'field1': 'new_value1', 'field2': 'new_value2'}, \"field3 = value1\")\n        \"UPDATE table1 SET field1 = 'new_value1', field2 = 'new_value2' WHERE field3 = value1;\"\n        \"\"\"\n        # Generates an UPDATE SQL statement based on the provided data and condition\n        set_clause = \", \".join([f\"{field} = '{value}'\" for field, value in data.items()])\n        sql = f\"UPDATE {self.table_name} SET {set_clause} WHERE {condition}\"\n        return sql + \";\"\n\n    def delete(self, condition):\n        \"\"\"\n        Generates a DELETE SQL statement based on the given condition.\n        :param condition: str. The condition expression for the delete.\n        :return: str. The generated SQL statement.\n        >>> sql.delete(\"field1 = value1\")\n        'DELETE FROM table1 WHERE field1 = value1;'\n        \"\"\"\n        # Generates a DELETE SQL statement based on the given condition\n        sql = f\"DELETE FROM {self.table_name} WHERE {condition}\"\n        return sql + \";\"\n\n    def select_female_under_age(self, age):\n        \"\"\"\n        Generates a SQL statement to select females under a specified age.\n        :param age: int. The specified age.\n        :return: str. The generated SQL statement.\n        >>> sql.select_female_under_age(30)\n        \"SELECT * FROM table1 WHERE age < 30 AND gender = 'female';\"\n        \"\"\"\n        # Generates a SQL statement to select females under a specified age\n        condition = f\"age < {age} AND gender = 'female'\"\n        return self.select(condition=condition)\n\n    def select_by_age_range(self, min_age, max_age):\n        \"\"\"\n        Generates a SQL statement to select records within a specified age range.\n        :param min_age: int. The minimum age.\n        :param max_age: int. The maximum age.\n        :return: str. The generated SQL statement.\n        >>> sql.select_by_age_range(20, 30)\n        'SELECT * FROM table1 WHERE age BETWEEN 20 AND 30;'\n        \"\"\"\n        # Generates a SQL statement to select records within a specified age range\n        condition = f\"age BETWEEN {min_age} AND {max_age}\"\n        return self.select(condition=condition)\n"
    },
    {
        "id" : "80",
        "code" : "\nclass SQLQueryBuilder:\n    \"\"\"\n    This class provides to build SQL queries, including SELECT, INSERT, UPDATE, and DELETE statements.\n    \"\"\"\n\n\n    @staticmethod\n    def select(table, columns='*', where=None):\n        \"\"\"\n        Generate the SELECT SQL statement from the given parameters.\n        :param table: str, the query table in database.\n        :param columns: list of str, ['col1', 'col2'].\n        :param where: dict, {key1: value1, key2: value2 ...}. The query condition.\n        return query: str, the SQL query statement.\n        >>> SQLQueryBuilder.select('table1', columns = [\"col1\",\"col2\"], where = {\"age\": 15})\n        \"SELECT col1, col2 FROM table1 WHERE age='15'\"\n        \"\"\"\n        if columns != '*':\n            columns = ', '.join(columns)\n        query = f\"SELECT {columns} FROM {table}\"\n        if where:\n            query += \" WHERE \" + ' AND '.join(f\"{k}='{v}'\" for k, v in where.items())\n        return query\n\n    @staticmethod\n    def insert(table, data):\n        \"\"\"\n        Generate the INSERT SQL statement from the given parameters.\n        :param table: str, the table to be inserted in database.\n        :param data: dict, the key and value in SQL insert statement\n        :return query: str, the SQL insert statement.\n        >>> SQLQueryBuilder.insert('table1', {'name': 'Test', 'age': 14})\n        \"INSERT INTO table1 (name, age) VALUES ('Test', '14')\"\n        \"\"\"\n        keys = ', '.join(data.keys())\n        values = ', '.join(f\"'{v}'\" for v in data.values())\n        return f\"INSERT INTO {table} ({keys}) VALUES ({values})\"\n\n    @staticmethod\n    def delete(table, where=None):\n        \"\"\"\n        Generate the DELETE SQL statement from the given parameters.\n        :param table: str, the table that will be excuted with DELETE operation in database\n        :param where: dict, {key1: value1, key2: value2 ...}. The query condition.\n        :return query: str, the SQL delete statement.\n        >>> SQLQueryBuilder.delete('table1', {'name': 'Test', 'age': 14})\n        \"DELETE FROM table1 WHERE name='Test' AND age='14'\"\n        \"\"\"\n        query = f\"DELETE FROM {table}\"\n        if where:\n            query += \" WHERE \" + ' AND '.join(f\"{k}='{v}'\" for k, v in where.items())\n        return query\n\n    @staticmethod\n    def update(table, data, where=None):\n        \"\"\"\n        Generate the UPDATE SQL statement from the given parameters.\n        :param table: str, the table that will be excuted with UPDATE operation in database\n        :param data: dict, the key and value in SQL update statement\n        :param where: dict, {key1: value1, key2: value2 ...}. The query condition.\n        >>> SQLQueryBuilder.update('table1', {'name': 'Test2', 'age': 15}, where = {'name':'Test'})\n        \"UPDATE table1 SET name='Test2', age='15' WHERE name='Test'\"\n        \"\"\"\n        update_str = ', '.join(f\"{k}='{v}'\" for k, v in data.items())\n        query = f\"UPDATE {table} SET {update_str}\"\n        if where:\n   query += \" WHERE \" + ' AND '.join(f\"{k}='{v}'\" for k, v in where.items())\n        return query\n",
        "annotated_code" : "class SQLQueryBuilder:\n    \"\"\"\n    This class provides to build SQL queries, including SELECT, INSERT, UPDATE, and DELETE statements.\n    \"\"\"\n\n    @staticmethod\n    def select(table, columns='*', where=None):\n        \"\"\"\n        Generate the SELECT SQL statement from the given parameters.\n        :param table: str, the query table in database.\n        :param columns: list of str, ['col1', 'col2'].\n        :param where: dict, {key1: value1, key2: value2 ...}. The query condition.\n        return query: str, the SQL query statement.\n        >>> SQLQueryBuilder.select('table1', columns = [\"col1\",\"col2\"], where = {\"age\": 15})\n        \"SELECT col1, col2 FROM table1 WHERE age='15'\"\n        \"\"\"\n\n        if columns != '*':\n            columns = ', '.join(columns)\n        # Use the provided parameters to generate the SQL SELECT, FROM, WHERE clause\n        query = f\"SELECT {columns} FROM {table}\"\n        if where:\n            query += \" WHERE \" + ' AND '.join(f\"{k}='{v}'\" for k, v in where.items())\n        # Return the generated SQL query statement\n        return query\n\n    @staticmethod\n    def insert(table, data):\n        \"\"\"\n        Generate the INSERT SQL statement from the given parameters.\n        :param table: str, the table to be inserted in database.\n        :param data: dict, the key and value in SQL insert statement\n        :return query: str, the SQL insert statement.\n        >>> SQLQueryBuilder.insert('table1', {'name': 'Test', 'age': 14})\n        \"INSERT INTO table1 (name, age) VALUES ('Test', '14')\"\n        \"\"\"\n        # Use the keys of the data dictionary to generate the column names\n        keys = ', '.join(data.keys())\n        # Use the values of the data dictionary to generate the values for the columns\n        values = ', '.join(f\"'{v}'\" for v in data.values())\n        # Generate the SQL INSERT statement using the provided table name, keys as column names, and values as the values for the columns\n        return f\"INSERT INTO {table} ({keys}) VALUES ({values})\"\n\n    @staticmethod\n    def delete(table, where=None):\n        \"\"\"\n        Generate the DELETE SQL statement from the given parameters.\n        :param table: str, the table that will be excuted with DELETE operation in database\n        :param where: dict, {key1: value1, key2: value2 ...}. The query condition.\n        :return query: str, the SQL delete statement.\n        >>> SQLQueryBuilder.delete('table1', {'name': 'Test', 'age': 14})\n        \"DELETE FROM table1 WHERE name='Test' AND age='14'\"\n        \"\"\"\n        \n        # Use the provided table parameter to generate the SQL DELETE, FROM, clause\n        query = f\"DELETE FROM {table}\"\n        if where:\n            # Use the provided where parameter to generate the WHERE clause\n            query += \" WHERE \" + ' AND '.join(f\"{k}='{v}'\" for k, v in where.items())\n        \n        # Return the generated SQL query statement\n        return query\n\n    @staticmethod\n    def update(table, data, where=None):\n        \"\"\"\n        Generate the UPDATE SQL statement from the given parameters.\n        :param table: str, the table that will be excuted with UPDATE operation in database\n        :param data: dict, the key and value in SQL update statement\n        :param where: dict, {key1: value1, key2: value2 ...}. The query condition.\n        >>> SQLQueryBuilder.update('table1', {'name': 'Test2', 'age': 15}, where = {'name':'Test'})\n        \"UPDATE table1 SET name='Test2', age='15' WHERE name='Test'\"\n        \"\"\"\n        \n        update_str = ', '.join(f\"{k}='{v}'\" for k, v in data.items())\n        # Use the provided table and data parameters to generate the SQL UPDATE, SET, clause\n        query = f\"UPDATE {table} SET {update_str}\"\n        if where:\n            # Use the provided where parameter to generate the WHERE clause\n            query += \" WHERE \" + ' AND '.join(f\"{k}='{v}'\" for k, v in where.items())\n        \n        # Return the generated SQL query statement\n        return query"
    },
    {
        "id" : "81",
        "code" : "\nimport math\n\nclass Statistics3:\n    \"\"\"\n    This is a class that implements methods for calculating indicators such as median, mode, correlation matrix, and Z-score in statistics.\n    \"\"\"\n\n    @staticmethod\n    def median(data):\n        \"\"\"\n        calculates the median of the given list.\n        :param data: the given list, list.\n        :return: the median of the given list, float.\n        >>> statistics3 = Statistics3()\n        >>> statistics3.median([1, 2, 3, 4])\n        2.5\n\n        \"\"\"\n        sorted_data = sorted(data)\n        n = len(sorted_data)\n        if n % 2 == 1:\n            return sorted_data[n // 2]\n        else:\n            return (sorted_data[n // 2 - 1] + sorted_data[n // 2]) / 2\n\n    @staticmethod\n    def mode(data):\n        \"\"\"\n        calculates the mode of the given list.\n        :param data: the given list, list.\n        :return: the mode of the given list, list.\n        >>> statistics3 = Statistics3()\n        >>> statistics3.mode([1, 2, 3, 3])\n        [3]\n\n        \"\"\"\n        counts = {}\n        for value in data:\n            counts[value] = counts.get(value, 0) + 1\n        max_count = max(counts.values())\n        mode_values = [value for value, count in counts.items() if count == max_count]\n        return mode_values\n\n    @staticmethod\n    def correlation(x, y):\n        \"\"\"\n        calculates the correlation of the given list.\n        :param x: the given list, list.\n        :param y: the given list, list.\n        :return: the correlation of the given list, float.\n        >>> statistics3 = Statistics3()\n        >>> statistics3.correlation([1, 2, 3], [4, 5, 6])\n        1.0\n\n        \"\"\"\n        n = len(x)\n        mean_x = sum(x) / n\n        mean_y = sum(y) / n\n        numerator = sum((xi - mean_x) * (yi - mean_y) for xi, yi in zip(x, y))\n        denominator = math.sqrt(sum((xi - mean_x) ** 2 for xi in x) * sum((yi - mean_y) ** 2 for yi in y))\n        if denominator == 0:\n            return None\n        return numerator / denominator\n\n    @staticmethod\n    def mean(data):\n        \"\"\"\n        calculates the mean of the given list.\n        :param data: the given list, list.\n        :return: the mean of the given list, float.\n        >>> statistics3 = Statistics3()\n        >>> statistics3.mean([1, 2, 3])\n        2.0\n\n        \"\"\"\n        if len(data) == 0:\n            return None\n        return sum(data) / len(data)\n\n    @staticmethod\n    def correlation_matrix(data):\n        \"\"\"\n        calculates the correlation matrix of the given list.\n        :param data: the given list, list.\n        :return: the correlation matrix of the given list, list.\n        >>> statistics3 = Statistics3()\n        >>> statistics3.correlation_matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n        [[1.0, 1.0, 1.0], [1.0, 1.0, 1.0], [1.0, 1.0, 1.0]]\n\n        \"\"\"\n        matrix = []\n        for i in range(len(data[0])):\n            row = []\n            for j in range(len(data[0])):\n                column1 = [row[i] for row in data]\n                column2 = [row[j] for row in data]\n                correlation = Statistics3.correlation(column1, column2)\n                row.append(correlation)\n   matrix.append(row)\n        return matrix\n\n    @staticmethod\n    def standard_deviation(data):\n        \"\"\"\n        calculates the standard deviation of the given list.\n        :param data: the given list, list.\n        :return: the standard deviation of the given list, float.\n        >>> statistics3 = Statistics3()\n        >>> statistics3.standard_deviation([1, 2, 3])\n        1.0\n\n        \"\"\"\n        n = len(data)\n        if n < 2:\n            return None\n        mean_value = Statistics3.mean(data)\n        variance = sum((x - mean_value) ** 2 for x in data) / (n - 1)\n        return math.sqrt(variance)\n\n    @staticmethod\n    def z_score(data):\n        \"\"\"\n        calculates the z-score of the given list.\n        :param data: the given list, list.\n        :return: the z-score of the given list, list.\n        >>> statistics3 = Statistics3()\n        >>> statistics3.z_score([1, 2, 3, 4])\n        [-1.161895003862225, -0.3872983346207417, 0.3872983346207417, 1.161895003862225]\n\n        \"\"\"\n        mean = Statistics3.mean(data)\n        std_deviation = Statistics3.standard_deviation(data)\n        if std_deviation is None or std_deviation == 0:\n            return None\n        return [(x - mean) / std_deviation for x in data]\n",
        "annotated_code" : "import math\n\nclass Statistics3:\n    \"\"\"\n    This is a class that implements methods for calculating indicators such as median, mode, correlation matrix, and Z-score in statistics.\n    \"\"\"\n\n    @staticmethod\n    def median(data):\n        \"\"\"\n        calculates the median of the given list.\n        :param data: the given list, list.\n        :return: the median of the given list, float.\n        >>> statistics3 = Statistics3()\n        >>> statistics3.median([1, 2, 3, 4])\n        2.5\n\n        \"\"\"\n        \n        # Sort the input data\n        sorted_data = sorted(data)\n        n = len(sorted_data)\n\n        if n % 2 == 1:\n            # If the number of elements is odd, return the middle element\n            return sorted_data[n // 2]\n        else:\n            # If the number of elements is even, return the average of the two middle elements\n            return (sorted_data[n // 2 - 1] + sorted_data[n // 2]) / 2\n\n    @staticmethod\n    def mode(data):\n        \"\"\"\n        calculates the mode of the given list.\n        :param data: the given list, list.\n        :return: the mode of the given list, list.\n        >>> statistics3 = Statistics3()\n        >>> statistics3.mode([1, 2, 3, 3])\n        [3]\n\n        \"\"\"\n\n        counts = {}\n        # Count the occurrences of each value in the data\n        for value in data:\n            counts[value] = counts.get(value, 0) + 1\n        \n        # Find the maximum occurrence count\n        max_count = max(counts.values())\n        # Find the values that have the maximum occurrence count\n        mode_values = [value for value, count in counts.items() if count == max_count]\n        # Return the mode values\n        return mode_values\n\n    @staticmethod\n    def correlation(x, y):\n        \"\"\"\n        calculates the correlation of the given list.\n        :param x: the given list, list.\n        :param y: the given list, list.\n        :return: the correlation of the given list, float.\n        >>> statistics3 = Statistics3()\n        >>> statistics3.correlation([1, 2, 3], [4, 5, 6])\n        1.0\n\n        \"\"\"\n        \n        n = len(x)\n        # Calculate the mean of x and y\n        mean_x = sum(x) / n\n        mean_y = sum(y) / n\n        # Calculate the numerator and denominator for the correlation formula\n        # Use the math.sqrt function to calculate the square root for the denominator\n        numerator = sum((xi - mean_x) * (yi - mean_y) for xi, yi in zip(x, y))\n        denominator = math.sqrt(sum((xi - mean_x) ** 2 for xi in x) * sum((yi - mean_y) ** 2 for yi in y))\n\n        # Return None if the denominator is 0\n        if denominator == 0:\n            return None\n        # Return the correlation value\n        return numerator / denominator\n\n    @staticmethod\n    def mean(data):\n        \"\"\"\n        calculates the mean of the given list.\n        :param data: the given list, list.\n        :return: the mean of the given list, float.\n        >>> statistics3 = Statistics3()\n        >>> statistics3.mean([1, 2, 3])\n        2.0\n\n        \"\"\"\n        # Return None if the data is empty\n        if len(data) == 0:\n            return None\n        # Calculate the mean by dividing the sum of the data by the number of elements and return the result\n        return sum(data) / len(data)\n\n    @staticmethod\n    def correlation_matrix(data):\n        \"\"\"\n        calculates the correlation matrix of the given list.\n        :param data: the given list, list.\n        :return: the correlation matrix of the given list, list.\n        >>> statistics3 = Statistics3()\n        >>> statistics3.correlation_matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n        [[1.0, 1.0, 1.0], [1.0, 1.0, 1.0], [1.0, 1.0, 1.0]]\n\n        \"\"\"\n        \n        matrix = []\n        # Iterate through the data and calculate the correlation for each pair of columns\n        for i in range(len(data[0])):\n            row = []\n            for j in range(len(data[0])):\n                column1 = [row[i] for row in data]\n                column2 = [row[j] for row in data]\n                # Use the correlation class method to calculate the correlation between the two columns\n                correlation = Statistics3.correlation(column1, column2)\n                # Append the correlation to the row\n                row.append(correlation)\n            # Append the row to the matrix\n            matrix.append(row)\n        # Return the resultant correlation matrix\n        return matrix\n\n    @staticmethod\n    def standard_deviation(data):\n        \"\"\"\n        calculates the standard deviation of the given list.\n        :param data: the given list, list.\n        :return: the standard deviation of the given list, float.\n        >>> statistics3 = Statistics3()\n        >>> statistics3.standard_deviation([1, 2, 3])\n        1.0\n\n        \"\"\"\n        \n        n = len(data)\n        # Return None if the number of elements is less than 2\n        if n < 2:\n            return None\n        # Use the mean class method to calculate the mean of the data\n        mean_value = Statistics3.mean(data)\n        # Calculate the variance using the mean value\n        variance = sum((x - mean_value) ** 2 for x in data) / (n - 1)\n        # Use the math.sqrt function to calculate the square root of the variance and return the result\n        return math.sqrt(variance)\n\n    @staticmethod\n    def z_score(data):\n        \"\"\"\n        calculates the z-score of the given list.\n        :param data: the given list, list.\n        :return: the z-score of the given list, list.\n        >>> statistics3 = Statistics3()\n        >>> statistics3.z_score([1, 2, 3, 4])\n        [-1.161895003862225, -0.3872983346207417, 0.3872983346207417, 1.161895003862225]\n\n        \"\"\"\n        # Use the mean and standard_deviation class methods to get the mean and standard deviation of the data\n        mean = Statistics3.mean(data)\n        std_deviation = Statistics3.standard_deviation(data)\n\n        # Return None if the standard deviation is None or 0\n        if std_deviation is None or std_deviation == 0:\n            return None\n\n        # Calculate the z-score for each element in the data and return the resultant list\n        return [(x - mean) / std_deviation for x in data]"
    },
    {
        "id" : "82",
        "code" : "\nclass StockPortfolioTracker:\n    \"\"\"\n    This is a class as StockPortfolioTracker that allows to add stocks, remove stocks, buy stocks, sell stocks, calculate the total value of the portfolio, and obtain a summary of the portfolio.\n    \"\"\"\n\n    def __init__(self, cash_balance):\n        \"\"\"\n        Initialize the StockPortfolioTracker class with a cash balance and an empty portfolio.\n        \"\"\"\n        self.portfolio = []\n        self.cash_balance = cash_balance\n\n    def add_stock(self, stock):\n        \"\"\"\n        Add a stock to the portfolio.\n        :param stock: a dictionary with keys \"name\", \"price\", and \"quantity\"\n        >>> tracker = StockPortfolioTracker(10000.0)\n        >>> tracker.add_stock({\"name\": \"AAPL\", \"price\": 150.0, \"quantity\": 10})\n        >>> tracker.portfolio\n        [{'name': 'AAPL', 'price': 150.0, 'quantity': 10}]\n\n        \"\"\"\n        for pf in self.portfolio:\nif pf['name'] == stock['name']:\n                pf['quantity'] += stock['quantity']\n                return\n\n        self.portfolio.append(stock)\n\n    def remove_stock(self, stock):\n        \"\"\"\n        Remove a stock from the portfolio.\n        :param stock: a dictionary with keys \"name\", \"price\", and \"quantity\"\n        >>> tracker = StockPortfolioTracker(10000.0)\n        >>> tracker.portfolio = [{'name': 'AAPL', 'price': 150.0, 'quantity': 10}]\n        >>> tracker.remove_stock({\"name\": \"AAPL\", \"price\": 150.0, \"quantity\": 10})\n        True\n        >>> tracker.portfolio\n        []\n\n        \"\"\"\n        for pf in self.portfolio:\n            if pf['name'] == stock['name'] and pf['quantity'] >= stock['quantity']:\n pf['quantity'] -= stock['quantity']\n                if pf['quantity'] == 0:\n                    self.portfolio.remove(pf)\n                return True\n        return False\n\n    def buy_stock(self, stock):\n        \"\"\"\n        Buy a stock and add it to the portfolio.\n        :param stock: a dictionary with keys \"name\", \"price\", and \"quantity\"\n        :param quantity: the quantity of the stock to buy,int.\n        :return: True if the stock was bought successfully, False if the cash balance is not enough.\n        >>> tracker = StockPortfolioTracker(10000.0)\n        >>> tracker.buy_stock({\"name\": \"AAPL\", \"price\": 150.0, \"quantity\": 10})\n        True\n        >>> tracker.portfolio\n        [{'name': 'AAPL', 'price': 150.0, 'quantity': 10}]\n\n        \"\"\"\n        if stock['price'] * stock['quantity'] > self.cash_balance:\n            return False\n        else:\n            self.add_stock(stock)\n            self.cash_balance -= stock['price'] * stock['quantity']\n            return True\n\n    def sell_stock(self, stock):\n        \"\"\"\n        Sell a stock and remove it from the portfolio and add the cash to the cash balance.\n        :param stock: a dictionary with keys \"name\", \"price\", and \"quantity\"\n        :param quantity: the quantity of the stock to sell,int.\n        :return: True if the stock was sold successfully, False if the quantity of the stock is not enough.\n        >>> tracker = StockPortfolioTracker(10000.0)\n        >>> tracker.portfolio = [{'name': 'AAPL', 'price': 150.0, 'quantity': 10}]\n        >>> tracker.sell_stock({\"name\": \"AAPL\", \"price\": 150.0, \"quantity\": 10})\n        True\n        >>> tracker.portfolio\n        []\n\n        \"\"\"\n        if self.remove_stock(stock) == False:\n            return False\n        self.cash_balance += stock['price'] * stock['quantity']\n        return True\n\n    def calculate_portfolio_value(self):\n        \"\"\"\n        Calculate the total value of the portfolio.\n        :return: the total value of the portfolio, float.\n        >>> tracker = StockPortfolioTracker(10000.0)\n        >>> tracker.portfolio = [{'name': 'AAPL', 'price': 150.0, 'quantity': 10}]\n        >>> tracker.calculate_portfolio_value()\n        11500.0\n\n        \"\"\"\n        total_value = self.cash_balance\n        for stock in self.portfolio:\n            total_value += stock['price'] * stock['quantity']\n        return total_value\n\n    def get_portfolio_summary(self):\n        \"\"\"\n        Get a summary of the portfolio.\n        :return: a tuple of the total value of the portfolio and a list of dictionaries with keys \"name\" and \"value\"\n        >>> tracker = StockPortfolioTracker(10000.0)\n        >>> tracker.portfolio = [{'name': 'AAPL', 'price': 150.0, 'quantity': 10}]\n        >>> tracker.get_portfolio_summary()\n        (11500.0, [{'name': 'AAPL', 'value': 1500.0}])\n\n        \"\"\"\n        summary = []\n        for stock in self.portfolio:\n            value = self.get_stock_value(stock)\n            summary.append({\"name\": stock[\"name\"], \"value\": value})\n        portfolio_value = self.calculate_portfolio_value()\n        return portfolio_value, summary\n\n    def get_stock_value(self, stock):\n        \"\"\"\n        Get the value of a stock.\n        :param stock: a dictionary with keys \"name\", \"price\", and \"quantity\"\n        :return: the value of the stock, float.\n        >>> tracker = StockPortfolioTracker(10000.0)\n        >>> tracker.get_stock_value({\"name\": \"AAPL\", \"price\": 150.0, \"quantity\": 10})\n        1500.0\n\n        \"\"\"\n        return stock['price'] * stock['quantity']\n",
        "annotated_code" : "class StockPortfolioTracker:\n    \"\"\"\n    This is a class as StockPortfolioTracker that allows to add stocks, remove stocks, buy stocks, sell stocks, calculate the total value of the portfolio, and obtain a summary of the portfolio.\n    \"\"\"\n\n    def __init__(self, cash_balance):\n        \"\"\"\n        Initialize the StockPortfolioTracker class with a cash balance and an empty portfolio.\n        \"\"\"\n        self.portfolio = []\n        self.cash_balance = cash_balance\n\n    def add_stock(self, stock):\n        \"\"\"\n        Add a stock to the portfolio.\n        :param stock: a dictionary with keys \"name\", \"price\", and \"quantity\"\n        >>> tracker = StockPortfolioTracker(10000.0)\n        >>> tracker.add_stock({\"name\": \"AAPL\", \"price\": 150.0, \"quantity\": 10})\n        >>> tracker.portfolio\n        [{'name': 'AAPL', 'price': 150.0, 'quantity': 10}]\n\n        \"\"\"\n\n        # Iterate through the portfolio to check if the stock already exists\n        for pf in self.portfolio:\n            # If the stock exists, update the quantity and return\n            if pf['name'] == stock['name']:\n                pf['quantity'] += stock['quantity']\n                return\n\n        # If the stock does not exist, append it to the portfolio\n        self.portfolio.append(stock)\n\n    def remove_stock(self, stock):\n        \"\"\"\n        Remove a stock from the portfolio.\n        :param stock: a dictionary with keys \"name\", \"price\", and \"quantity\"\n        >>> tracker = StockPortfolioTracker(10000.0)\n        >>> tracker.portfolio = [{'name': 'AAPL', 'price': 150.0, 'quantity': 10}]\n        >>> tracker.remove_stock({\"name\": \"AAPL\", \"price\": 150.0, \"quantity\": 10})\n        True\n        >>> tracker.portfolio\n        []\n\n        \"\"\"\n\n        # Iterate through the portfolio to check if the stock exists\n        for pf in self.portfolio:\n            # Check if the stock exists and the quantity is greater than or equal to the quantity to be removed\n            if pf['name'] == stock['name'] and pf['quantity'] >= stock['quantity']:\n                # Remove the quantity from the stock\n                pf['quantity'] -= stock['quantity']\n                # If the quantity is 0, remove the stock from the portfolio\n                if pf['quantity'] == 0:\n                    self.portfolio.remove(pf)\n                # Return True to indicate the stock was removed successfully\n                return True\n            \n        # Return False to indicate the stock was not found in the portfolio\n        return False\n\n    def buy_stock(self, stock):\n        \"\"\"\n        Buy a stock and add it to the portfolio.\n        :param stock: a dictionary with keys \"name\", \"price\", and \"quantity\"\n        :param quantity: the quantity of the stock to buy,int.\n        :return: True if the stock was bought successfully, False if the cash balance is not enough.\n        >>> tracker = StockPortfolioTracker(10000.0)\n        >>> tracker.buy_stock({\"name\": \"AAPL\", \"price\": 150.0, \"quantity\": 10})\n        True\n        >>> tracker.portfolio\n        [{'name': 'AAPL', 'price': 150.0, 'quantity': 10}]\n\n        \"\"\"\n\n        # Check if the cash balance is enough to buy the stock\n        if stock['price'] * stock['quantity'] > self.cash_balance:\n            # If the cash balance is not enough, return False\n            return False\n        else:\n            # If the cash balance is enough, use the add_stock class method to add the stock to the portfolio\n            self.add_stock(stock)\n            # Update the cash balance by subtracting the stock price times quantity\n            self.cash_balance -= stock['price'] * stock['quantity']\n            # Return True to indicate the stock was bought successfully\n            return True\n\n    def sell_stock(self, stock):\n        \"\"\"\n        Sell a stock and remove it from the portfolio and add the cash to the cash balance.\n        :param stock: a dictionary with keys \"name\", \"price\", and \"quantity\"\n        :param quantity: the quantity of the stock to sell,int.\n        :return: True if the stock was sold successfully, False if the quantity of the stock is not enough.\n        >>> tracker = StockPortfolioTracker(10000.0)\n        >>> tracker.portfolio = [{'name': 'AAPL', 'price': 150.0, 'quantity': 10}]\n        >>> tracker.sell_stock({\"name\": \"AAPL\", \"price\": 150.0, \"quantity\": 10})\n        True\n        >>> tracker.portfolio\n        []\n\n        \"\"\"\n\n        # Use the remove_stock class method to remove the stock from the portfolio\n        # If the stock was not removed successfully, return False\n        if self.remove_stock(stock) == False:\n            return False\n        # If the stock was removed successfully, update the cash balance by adding the stock price times quantity\n        self.cash_balance += stock['price'] * stock['quantity']\n        # Return True to indicate the stock was sold successfully\n        return True\n\n    def calculate_portfolio_value(self):\n        \"\"\"\n        Calculate the total value of the portfolio.\n        :return: the total value of the portfolio, float.\n        >>> tracker = StockPortfolioTracker(10000.0)\n        >>> tracker.portfolio = [{'name': 'AAPL', 'price': 150.0, 'quantity': 10}]\n        >>> tracker.calculate_portfolio_value()\n        11500.0\n\n        \"\"\"\n\n        # Initialize the total value of the portfolio with the cash balance\n        total_value = self.cash_balance\n\n        # Iterate through the portfolio and add the value of each stock to the total value\n        for stock in self.portfolio:\n            total_value += stock['price'] * stock['quantity']\n        \n        # Return the total value of the portfolio\n        return total_value\n\n    def get_portfolio_summary(self):\n        \"\"\"\n        Get a summary of the portfolio.\n        :return: a tuple of the total value of the portfolio and a list of dictionaries with keys \"name\" and \"value\"\n        >>> tracker = StockPortfolioTracker(10000.0)\n        >>> tracker.portfolio = [{'name': 'AAPL', 'price': 150.0, 'quantity': 10}]\n        >>> tracker.get_portfolio_summary()\n        (11500.0, [{'name': 'AAPL', 'value': 1500.0}])\n\n        \"\"\"\n\n        summary = []\n\n        # Iterate through the portfolio and calculate the value of each stock\n        for stock in self.portfolio:\n            # Calculate the value of the stock using the get_stock_value class method\n            value = self.get_stock_value(stock)\n            # Append the stock name and value to the summary list\n            summary.append({\"name\": stock[\"name\"], \"value\": value})\n        \n        # Calculate the total value of the portfolio using the calculate_portfolio_value class method\n        portfolio_value = self.calculate_portfolio_value()\n        # Return a tuple of the total value of the portfolio and the summary list\n        return portfolio_value, summary\n\n    def get_stock_value(self, stock):\n        \"\"\"\n        Get the value of a stock.\n        :param stock: a dictionary with keys \"name\", \"price\", and \"quantity\"\n        :return: the value of the stock, float.\n        >>> tracker = StockPortfolioTracker(10000.0)\n        >>> tracker.get_stock_value({\"name\": \"AAPL\", \"price\": 150.0, \"quantity\": 10})\n        1500.0\n\n        \"\"\"\n        # Calculate the value of the stock by multiplying the price and the quantity and return the result\n        return stock['price'] * stock['quantity']"
    },
    {
        "id" : "83",
        "code" : "\nimport sqlite3\n\nclass StudentDatabaseProcessor:\n    \"\"\"\n    This is a class with database operation, including inserting student information, searching for student information by name, and deleting student information by name.\n    \"\"\"\n\n    def __init__(self, database_name):\n        \"\"\"\n        Initializes the StudentDatabaseProcessor object with the specified database name.\n        :param database_name: str, the name of the SQLite database.\n        \"\"\"\n        self.database_name = database_name\n\n    def create_student_table(self):\n        \"\"\"\n        Creates a \"students\" table in the database if it does not exist already.Fields include ID of type int, name of type str, age of type int, gender of type str, and grade of type int      \n        :return: None\n        >>> processor = StudentDatabaseProcessor(\"students.db\")\n        >>> processor.create_student_table()\n        \"\"\"\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n\n        create_table_query = \"\"\"\n        CREATE TABLE IF NOT EXISTS students (\n            id INTEGER PRIMARY KEY,\n            name TEXT,\n            age INTEGER,\n            gender TEXT,\n            grade INTEGER\n        )\n        \"\"\"\n        cursor.execute(create_table_query)\n\n        conn.commit()\n        conn.close()\n\n    def insert_student(self, student_data):\n        \"\"\"\n        Inserts a new student into the \"students\" table.\n        :param student_data: dict, a dictionary containing the student's information (name, age, gender, grade).\n        :return: None\n        >>> processor = StudentDatabaseProcessor(\"students.db\")\n        >>> processor.create_student_table()\n        >>> student_data = {'name': 'John', 'age': 15, 'gender': 'Male', 'grade': 9}\n        >>> processor.insert_student(student_data)\n        \"\"\"\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n\n        insert_query = \"\"\"\n        INSERT INTO students (name, age, gender, grade)\n        VALUES (?, ?, ?, ?)\n        \"\"\"\n        cursor.execute(insert_query,\n                       (student_data['name'], student_data['age'], student_data['gender'], student_data['grade']))\n\n        conn.commit()\n        conn.close()\n\n    def search_student_by_name(self, name):\n        \"\"\"\n        Searches for a student in the \"students\" table by their name.\n        :param name: str, the name of the student to search for.\n        :return: list of tuples, the rows from the \"students\" table that match the search criteria.\n        >>> processor = StudentDatabaseProcessor(\"students.db\")\n        >>> processor.create_student_table()\n        >>> result = processor.search_student_by_name(\"John\")\n        \"\"\"\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n\n        select_query = \"SELECT * FROM students WHERE name = ?\"\n        cursor.execute(select_query, (name,))\n        result = cursor.fetchall()\n\n        conn.close()\n\n        return result\n\n    def delete_student_by_name(self, name):\n        \"\"\"\n        Deletes a student from the \"students\" table by their name.\n        :param name: str, the name of the student to delete.\n        :return: None\n        >>> processor = StudentDatabaseProcessor(\"students.db\")\n        >>> processor.create_student_table()\n        >>> student_data = {'name': 'John', 'age': 15, 'gender': 'Male', 'grade': 9}\n        >>> processor.insert_student(student_data)\n        >>> processor.delete_student_by_name(\"John\")\n        \"\"\"\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n\n        delete_query = \"DELETE FROM students WHERE name = ?\"\n        cursor.execute(delete_query, (name,))\n\n        conn.commit()\n        conn.close()\n",
        "annotated_code" : "import sqlite3\n\nclass StudentDatabaseProcessor:\n    \"\"\"\n    This is a class with database operation, including inserting student information, searching for student information by name, and deleting student information by name.\n    \"\"\"\n\n    def __init__(self, database_name):\n        \"\"\"\n        Initializes the StudentDatabaseProcessor object with the specified database name.\n        :param database_name: str, the name of the SQLite database.\n        \"\"\"\n        self.database_name = database_name\n\n    def create_student_table(self):\n        \"\"\"\n        Creates a \"students\" table in the database if it does not exist already.Fields include ID of type int, name of type str, age of type int, gender of type str, and grade of type int      \n        :return: None\n        >>> processor = StudentDatabaseProcessor(\"students.db\")\n        >>> processor.create_student_table()\n        \"\"\"\n\n        # Use sqlite3.connect function to connect to the database\n        conn = sqlite3.connect(self.database_name)\n\n        # Use the conn's cursor method to create a cursor object\n        cursor = conn.cursor()\n\n        create_table_query = \"\"\"\n        CREATE TABLE IF NOT EXISTS students (\n            id INTEGER PRIMARY KEY,\n            name TEXT,\n            age INTEGER,\n            gender TEXT,\n            grade INTEGER\n        )\n        \"\"\"\n\n        # Use the execute method to execute the create_table_query\n        cursor.execute(create_table_query)\n\n        # Use the conn's commit method to save the changes\n        conn.commit()\n\n        # Use the conn's close method to close the connection\n        conn.close()\n\n    def insert_student(self, student_data):\n        \"\"\"\n        Inserts a new student into the \"students\" table.\n        :param student_data: dict, a dictionary containing the student's information (name, age, gender, grade).\n        :return: None\n        >>> processor = StudentDatabaseProcessor(\"students.db\")\n        >>> processor.create_student_table()\n        >>> student_data = {'name': 'John', 'age': 15, 'gender': 'Male', 'grade': 9}\n        >>> processor.insert_student(student_data)\n        \"\"\"\n        \n        # Use the sqlite3.connect method to connect to the database\n        conn = sqlite3.connect(self.database_name)\n\n        # Use the conn's cursor method to create a cursor object\n        cursor = conn.cursor()\n\n        insert_query = \"\"\"\n        INSERT INTO students (name, age, gender, grade)\n        VALUES (?, ?, ?, ?)\n        \"\"\"\n\n        # Use the cursor's execute method to execute the insert_query with the provided student_data\n        cursor.execute(insert_query,\n                       (student_data['name'], student_data['age'], student_data['gender'], student_data['grade']))\n\n        # Use the conn's commit method to save the changes\n        conn.commit()\n\n        # Use the conn's close method to close the connection\n        conn.close()\n\n    def search_student_by_name(self, name):\n        \"\"\"\n        Searches for a student in the \"students\" table by their name.\n        :param name: str, the name of the student to search for.\n        :return: list of tuples, the rows from the \"students\" table that match the search criteria.\n        >>> processor = StudentDatabaseProcessor(\"students.db\")\n        >>> processor.create_student_table()\n        >>> result = processor.search_student_by_name(\"John\")\n        \"\"\"\n        \n        # Use the sqlite3.connect method to connect to the database\n        conn = sqlite3.connect(self.database_name)\n\n        # Use the conn's cursor method to create a cursor object\n        cursor = conn.cursor()\n\n        select_query = \"SELECT * FROM students WHERE name = ?\"\n\n        # Use the cursor's execute method to execute the select_query with the provided name\n        cursor.execute(select_query, (name,))\n\n        # Use the cursor's fetchall method to fetch all the rows that match the search criteria\n        result = cursor.fetchall()\n\n        # Use the conn's close method to close the connection\n        conn.close()\n\n        # Return the result of the search query\n        return result\n\n    def delete_student_by_name(self, name):\n        \"\"\"\n        Deletes a student from the \"students\" table by their name.\n        :param name: str, the name of the student to delete.\n        :return: None\n        >>> processor = StudentDatabaseProcessor(\"students.db\")\n        >>> processor.create_student_table()\n        >>> student_data = {'name': 'John', 'age': 15, 'gender': 'Male', 'grade': 9}\n        >>> processor.insert_student(student_data)\n        >>> processor.delete_student_by_name(\"John\")\n        \"\"\"\n\n        # Use the sqlite3.connect method to connect to the database \n        conn = sqlite3.connect(self.database_name)\n\n        # Use the conn's cursor method to create a cursor object\n        cursor = conn.cursor()\n\n        delete_query = \"DELETE FROM students WHERE name = ?\"\n\n        # Use the cursor's execute method to execute the delete_query with the provided name\n        cursor.execute(delete_query, (name,))\n\n        # Use the conn's commit method to save the changes\n        conn.commit()\n\n        # Use the conn's close method to close the connection\n        conn.close()"
    },
    {
        "id" : "84",
        "code" : "\nimport json\n\nclass TextFileProcessor:\n    \"\"\"\n    The class handles reading, writing, and processing text files. It can read the file as JSON, read the raw text, write content to the file, and process the file by removing non-alphabetic characters.\n    \"\"\"\n\n    def __init__(self, file_path):\n        \"\"\"\n        Initialize the file path.\n        :param file_path: str\n        \"\"\"\n        self.file_path = file_path\n\n    def read_file_as_json(self):\n        \"\"\"\n        Read the self.file_path file as json format.\n        if the file content doesn't obey json format, the code will raise error.\n        :return data: dict if the file is stored as json format, or str/int/float.. according to the file content otherwise.\n        >>> textFileProcessor = TextFileProcessor('test.json')\n        >>> textFileProcessor.read_file_as_json()\n        {'name': 'test', 'age': 12}\n        >>> type(textFileProcessor.read_file_as_json())\n        <class 'dict'>\n        \"\"\"\n        with open(self.file_path, 'r') as file:\n            data = json.load(file)\n\n        return data\n\n    def read_file(self):\n        \"\"\"\n        Read the return the content of self.file_path file.\n        :return: the same return as the read() method\n        >>> textFileProcessor = TextFileProcessor('test.json')\n        >>> textFileProcessor.read_file()\n        '{\n    \"name\": \"test\",\n    \"age\": 12\n}'\n        \"\"\"\n        with open(self.file_path, 'r') as file:\n            return file.read()\n\n    def write_file(self, content):\n        \"\"\"\n        Write content into the self.file_path file, and overwrite if the file has already existed.\n        :param content: any content\n        >>> textFileProcessor = TextFileProcessor('test.json')\n        >>> textFileProcessor.write_file('Hello world!')\n        >>> textFileProcessor.read_file()\n        'Hello world!'\n        \"\"\"\n        with open(self.file_path, 'w') as file:\n            file.write(content)\n\n    def process_file(self):\n        \"\"\"\n        Read the self.file_path file and filter out non-alphabetic characters from the content string.\n        Overwrite the after-processed data into the same self.file_path file.\n        >>> textFileProcessor = TextFileProcessor('test.json')\n        >>> textFileProcessor.read_file()\n        '{\n    \"name\": \"test\",\n    \"age\": 12\n}'\n        >>> textFileProcessor.process_file()\n        'nametestage'\n        \"\"\"\n        content = self.read_file()\n        content = ''.join([char for char in content if char.isalpha()])\n        self.write_file(content)\n        return content\n",
        "annotated_code" : "import json\n\nclass TextFileProcessor:\n    \"\"\"\n    The class handles reading, writing, and processing text files. It can read the file as JSON, read the raw text, write content to the file, and process the file by removing non-alphabetic characters.\n    \"\"\"\n\n    def __init__(self, file_path):\n        \"\"\"\n        Initialize the file path.\n        :param file_path: str\n        \"\"\"\n        self.file_path = file_path\n\n    def read_file_as_json(self):\n        \"\"\"\n        Read the self.file_path file as json format.\n        if the file content doesn't obey json format, the code will raise error.\n        :return data: dict if the file is stored as json format, or str/int/float.. according to the file content otherwise.\n        >>> textFileProcessor = TextFileProcessor('test.json')\n        >>> textFileProcessor.read_file_as_json()\n        {'name': 'test', 'age': 12}\n        >>> type(textFileProcessor.read_file_as_json())\n        <class 'dict'>\n        \"\"\"\n\n        # Open the file in read mode\n        with open(self.file_path, 'r') as file:\n            # Use the load function to parse the JSON content of the file and store it in data\n            data = json.load(file)\n\n        # Return the parsed data\n        return data\n\n    def read_file(self):\n        \"\"\"\n        Read the return the content of self.file_path file.\n        :return: the same return as the read() method\n        >>> textFileProcessor = TextFileProcessor('test.json')\n        >>> textFileProcessor.read_file()\n        '{\n            \"name\": \"test\",\n            \"age\": 12\n        }'\n        \"\"\"\n\n        # Open the file in read mode\n        with open(self.file_path, 'r') as file:\n            # Use the file's read method to read the content and return it\n            return file.read()\n\n    def write_file(self, content):\n        \"\"\"\n        Write content into the self.file_path file, and overwrite if the file has already existed.\n        :param content: any content\n        >>> textFileProcessor = TextFileProcessor('test.json')\n        >>> textFileProcessor.write_file('Hello world!')\n        >>> textFileProcessor.read_file()\n        'Hello world!'\n        \"\"\"\n\n        # Open the file in write mode\n        with open(self.file_path, 'w') as file:\n            # Use the file's write method to write the content provided to the file\n            file.write(content)\n\n    def process_file(self):\n        \"\"\"\n        Read the self.file_path file and filter out non-alphabetic characters from the content string.\n        Overwrite the after-processed data into the same self.file_path file.\n        >>> textFileProcessor = TextFileProcessor('test.json')\n        >>> textFileProcessor.read_file()\n        '{\n            \"name\": \"test\",\n            \"age\": 12\n        }'\n        >>> textFileProcessor.process_file()\n        'nametestage'\n        \"\"\"\n\n        # Use the read_file class method to read the content of the file\n        content = self.read_file()\n\n        # Use a list comprehension to filter out non-alphabetic characters in content\n        content = ''.join([char for char in content if char.isalpha()])\n\n        # Use the write_file class method to write the filtered content back to the file\n        self.write_file(content)\n\n        # Return the filtered content\n        return content"
    },
    {
        "id" : "85",
        "code" : "\nimport time\n\nclass Thermostat:\n    \"\"\"\n    The class manages temperature control, including setting and retrieving the target temperature, adjusting the mode, and simulating temperature operation.\n    \"\"\"\n\n    def __init__(self, current_temperature, target_temperature, mode):\n        \"\"\"\n        initialize instances of the Thermostat class, including the current temperature, target temperature, and operating mode.\n        :param current_temperature: float\n        :param target_temperature: float\n        :param mode: str, the work mode\n        \"\"\"\n        self.current_temperature = current_temperature\n        self.target_temperature = target_temperature\n        self.mode = mode\n\n    def get_target_temperature(self):\n        \"\"\"\n        Get the target temperature of an instance of the Thermostat class.\n        :return self.current_temperature: int\n        >>> thermostat.get_target_temperature()\n        37.5\n        \"\"\"\n        return self.target_temperature\n\n    def set_target_temperature(self, temperature):\n        \"\"\"\n        Set the target temperature\n        :param temperature: float, the target temperature\n        >>> thermostat.set_target_temperature(37.6)\n        >>> thermostat.target_temperature\n        37.6\n        \"\"\"\n        self.target_temperature = temperature\n\n    def get_mode(self):\n        \"\"\"\n        Get the current work mode\n        :return mode: str, working mode. only ['heat', 'cool']\n        \"\"\"\n        return self.mode\n\n    def set_mode(self, mode):\n        \"\"\"\n        Get the current work mode\n        :param mode: str, working mode. only ['heat', 'cool']\n        >>> thermostat.set_mode('cool')\n        >>> thermostat.mode\n        'cool'\n        \"\"\"\n        if mode in ['heat', 'cool']:\n            self.mode = mode\n        else:\n            return False\n\n    def auto_set_mode(self):\n        \"\"\"\n        Automatically set the operating mode by comparing with the current temperature and target temperature. If the current temperature is lower than the target temperature, the operating mode is set to 'heat', otherwise it is set to 'cool'.\n        >>> thermostat = Thermostat(20.4, 37.5, 'cool')\n        >>> thermostat.auto_set_mode()\n        >>> thermostat.mode\n        'heat'\n        \"\"\"\n        if self.current_temperature < self.target_temperature:\n            self.mode = 'heat'\n        else:\n            self.mode = 'cool'\n\n    def auto_check_conflict(self):\n        \"\"\"\n        Check if there is a conflict between the operating mode and the relationship between the current temperature and the target temperature.\n        If there is a conflict, the operating mode will be adjusted automatically.\n        :return: True if mode isn't conflict with the relationship between the current temperature and the target temperature, or False otherwise.\n        >>> thermostat = Thermostat(20.4, 37.5, 'cool')\n        >>> thermostat.auto_check_conflict()\n        False\n        >>> thermostat.mode\n        'heat'\n        \"\"\"\n        if self.current_temperature > self.target_temperature:\n            if self.mode == 'cool':\n                return True\n            else:\n                self.auto_set_mode()\n                return False\n        else:\n            if self.mode == 'heat':\n                return True\n            else:\n                self.auto_set_mode()\n                return False\n\n    def simulate_operation(self):\n        \"\"\"\n        simulate the operation of Thermostat. It will automatically start the auto_set_mode method to set the operating mode,\n        and then automatically adjust the current temperature according to the operating mode until the target temperature is reached.\n        :return time: int, the time it took to complete the simulation.\n        >>> thermostat = Thermostat(20.4, 37.5, 'cool')\n        >>> thermostat.simulate_operation()\n        18\n        \"\"\"\n        self.auto_set_mode()\n        use_time = 0\n        if self.mode == 'heat':\n            while(self.current_temperature < self.target_temperature):\n                self.current_temperature += 1\n                use_time += 1\n        else:\n            while(self.current_temperature > self.target_temperature):\n                self.current_temperature -= 1\n                use_time += 1\n        return use_time\n",
        "annotated_code" : "class Thermostat:\n    \"\"\"\n    The class manages temperature control, including setting and retrieving the target temperature, adjusting the mode, and simulating temperature operation.\n    \"\"\"\n\n    def __init__(self, current_temperature, target_temperature, mode):\n        \"\"\"\n        initialize instances of the Thermostat class, including the current temperature, target temperature, and operating mode.\n        :param current_temperature: float\n        :param target_temperature: float\n        :param mode: str, the work mode\n        \"\"\"\n        self.current_temperature = current_temperature\n        self.target_temperature = target_temperature\n        self.mode = mode\n\n    def get_target_temperature(self):\n        \"\"\"\n        Get the target temperature of an instance of the Thermostat class.\n        :return self.current_temperature: int\n        >>> thermostat.get_target_temperature()\n        37.5\n        \"\"\"\n\n        # Return the target temperature\n        return self.target_temperature\n\n    def set_target_temperature(self, temperature):\n        \"\"\"\n        Set the target temperature\n        :param temperature: float, the target temperature\n        >>> thermostat.set_target_temperature(37.6)\n        >>> thermostat.target_temperature\n        37.6\n        \"\"\"\n\n        # Set the target temperature\n        self.target_temperature = temperature\n\n    def get_mode(self):\n        \"\"\"\n        Get the current work mode\n        :return mode: str, working mode. only ['heat', 'cool']\n        \"\"\"\n\n        # Return the current work mode\n        return self.mode\n\n    def set_mode(self, mode):\n        \"\"\"\n        Get the current work mode\n        :param mode: str, working mode. only ['heat', 'cool']\n        >>> thermostat.set_mode('cool')\n        >>> thermostat.mode\n        'cool'\n        \"\"\"\n\n        # Check if the mode is valid\n        if mode in ['heat', 'cool']:\n            # Set the current work mode to mode\n            self.mode = mode\n        else:\n        # Return False if the mode is not valid\n            return False\n\n    def auto_set_mode(self):\n        \"\"\"\n        Automatically set the operating mode by comparing with the current temperature and target temperature. If the current temperature is lower than the target temperature, the operating mode is set to 'heat', otherwise it is set to 'cool'.\n        >>> thermostat = Thermostat(20.4, 37.5, 'cool')\n        >>> thermostat.auto_set_mode()\n        >>> thermostat.mode\n        'heat'\n        \"\"\"\n\n        # Check if the current temperature is lower than the target temperature\n        if self.current_temperature < self.target_temperature:\n            # If it is, set the operating mode to 'heat'\n            self.mode = 'heat'\n        else:\n            # If it is not, set the operating mode to 'cool'\n            self.mode = 'cool'\n\n    def auto_check_conflict(self):\n        \"\"\"\n        Check if there is a conflict between the operating mode and the relationship between the current temperature and the target temperature.\n        If there is a conflict, the operating mode will be adjusted automatically.\n        :return: True if mode isn't conflict with the relationship between the current temperature and the target temperature, or False otherwise.\n        >>> thermostat = Thermostat(20.4, 37.5, 'cool')\n        >>> thermostat.auto_check_conflict()\n        False\n        >>> thermostat.mode\n        'heat'\n        \"\"\"\n\n        # Check if the current temperature is greater than the target temperature\n        if self.current_temperature > self.target_temperature:\n            # If it is, return True if the mode is 'cool', otherwise return False and adjust the mode with the auto_set_mode class method\n            if self.mode == 'cool':\n                return True\n            else:\n                self.auto_set_mode()\n                return False\n        else:\n            # If it isn't, return True if the mode is 'heat', otherwise return False and adjust the mode with the auto_set_mode class method\n            if self.mode == 'heat':\n                return True\n            else:\n                self.auto_set_mode()\n                return False\n\n    def simulate_operation(self):\n        \"\"\"\n        simulate the operation of Thermostat. It will automatically start the auto_set_mode method to set the operating mode,\n        and then automatically adjust the current temperature according to the operating mode until the target temperature is reached.\n        :return time: int, the time it took to complete the simulation.\n        >>> thermostat = Thermostat(20.4, 37.5, 'cool')\n        >>> thermostat.simulate_operation()\n        18\n        \"\"\"\n\n        # Use the auto_set_mode class method to set the operating mode\n        self.auto_set_mode()\n        use_time = 0\n        if self.mode == 'heat':\n            # If the current operating mode is 'heat', increase the current temperature by 1 until it reaches the target temperature and count the time\n            while(self.current_temperature < self.target_temperature):\n                self.current_temperature += 1\n                use_time += 1\n        else:\n            # If the current operating mode is 'cool', decrease the current temperature by 1 until it reaches the target temperature and count the time\n            while(self.current_temperature > self.target_temperature):\n                self.current_temperature -= 1\n                use_time += 1\n\n        # Return the time it took to complete the simulation\n        return use_time"
    },
    {
        "id" : "86",
        "code" : "\nclass TicTacToe:\n    \"\"\"\n    The class represents a game of Tic-Tac-Toe and its functions include making a move on the board, checking for a winner, and determining if the board is full.\n    \"\"\"\n\n    def __init__(self, N=3):\n        \"\"\"\n        Initialize a 3x3 game board with all empty spaces and current symble player, default is 'X'.\n        \"\"\"\n        self.board = [[' ' for _ in range(N)] for _ in range(3)]\n        self.current_player = 'X'\n\n    def make_move(self, row, col):\n        \"\"\"\n        Place the current player's mark at the specified position on the board and switch the mark.\n        :param row: int, the row index of the position\n        :param col: int, the column index of the position\n        :return: bool, indicating whether the move was successful or not\n        >>> ttt.current_player\n        'X'\n        >>> ttt.make_move(1, 1)\n        >>> ttt.current_player\n        'O'\n        \"\"\"\n        if self.board[row][col] == ' ':\n            self.board[row][col] = self.current_player\n            self.current_player = 'O' if self.current_player == 'X' else 'X'\n            return True\n        else:\n            return False\n\n    def check_winner(self):\n        \"\"\"\n        Check if there is a winner on the board in rows, columns and diagonals three directions\n        :return: str or None, the mark of the winner ('X' or 'O'), or None if there is no winner yet\n        >>> moves = [(1, 0), (2, 0), (1, 1), (2, 1), (1, 2)]\n        >>> for move in moves:\n        ...     ttt.make_move(move[0], move[1])\n        >>> ttt.check_winner()\n        'X'\n        \"\"\"\n        for row in self.board:\n            if row[0] == row[1] == row[2] != ' ':\n                return row[0]\n        for col in range(3):\n            if self.board[0][col] == self.board[1][col] == self.board[2][col] != ' ':\n                return self.board[0][col]\n        if self.board[0][0] == self.board[1][1] == self.board[2][2] != ' ':\n            return self.board[0][0]\n        if self.board[0][2] == self.board[1][1] == self.board[2][0] != ' ':\n  return self.board[0][2]\n        return None\n\n    def is_board_full(self):\n        \"\"\"\n        Check if the game board is completely filled.\n        :return: bool, indicating whether the game board is full or not\n        >>> ttt.is_board_full()\n        False\n        \"\"\"\n        for row in self.board:\n            if ' ' in row:\n                return False\n        return True\n",
        "annotated_code" : "class TicTacToe:\n    \"\"\"\n    The class represents a game of Tic-Tac-Toe and its functions include making a move on the board, checking for a winner, and determining if the board is full.\n    \"\"\"\n\n    def __init__(self, N=3):\n        \"\"\"\n        Initialize a 3x3 game board with all empty spaces and current symble player, default is 'X'.\n        \"\"\"\n        self.board = [[' ' for _ in range(N)] for _ in range(3)]\n        self.current_player = 'X'\n\n    def make_move(self, row, col):\n        \"\"\"\n        Place the current player's mark at the specified position on the board and switch the mark.\n        :param row: int, the row index of the position\n        :param col: int, the column index of the position\n        :return: bool, indicating whether the move was successful or not\n        >>> ttt.current_player\n        'X'\n        >>> ttt.make_move(1, 1)\n        >>> ttt.current_player\n        'O'\n        \"\"\"\n\n        # Check if the specified position is empty\n        if self.board[row][col] == ' ':\n            # If it is, place the current player's mark at that position\n            self.board[row][col] = self.current_player\n            # Switch the current player to the other player\n            self.current_player = 'O' if self.current_player == 'X' else 'X'\n            # Return True to indicate that the move was successful\n            return True\n        else:\n        # If the specified position is not empty, return False to indicate that the move was unsuccessful\n            return False\n\n    def check_winner(self):\n        \"\"\"\n        Check if there is a winner on the board in rows, columns and diagonals three directions\n        :return: str or None, the mark of the winner ('X' or 'O'), or None if there is no winner yet\n        >>> moves = [(1, 0), (2, 0), (1, 1), (2, 1), (1, 2)]\n        >>> for move in moves:\n        ...     ttt.make_move(move[0], move[1])\n        >>> ttt.check_winner()\n        'X'\n        \"\"\"\n\n        # Check each row for a winner\n        for row in self.board:\n            # If all three positions in a row are the same and not empty, return the mark of the winner\n            if row[0] == row[1] == row[2] != ' ':\n                return row[0]\n        \n        # Check each column for a winner\n        for col in range(3):\n            # If all three positions in a column are the same and not empty, return the mark of the winner\n            if self.board[0][col] == self.board[1][col] == self.board[2][col] != ' ':\n                return self.board[0][col]\n        # Check the two diagonals for a winner\n        if self.board[0][0] == self.board[1][1] == self.board[2][2] != ' ':\n            # If all three positions in the first diagonal are the same and not empty, return the mark of the winner\n            return self.board[0][0]\n        if self.board[0][2] == self.board[1][1] == self.board[2][0] != ' ':\n            # If all three positions in the second diagonal are the same and not empty, return the mark of the winner\n            return self.board[0][2]\n\n        # If there is no winner, return None\n        return None\n\n    def is_board_full(self):\n        \"\"\"\n        Check if the game board is completely filled.\n        :return: bool, indicating whether the game board is full or not\n        >>> ttt.is_board_full()\n        False\n        \"\"\"\n\n        # Iterate through each position in the board\n        for row in self.board:\n            if ' ' in row:\n                # If there are empty spaces, return False\n                return False\n        # If there are no empty spaces, return True\n        return True"
    },
    {
        "id" : "87",
        "code" : "\nimport datetime\nimport time\n\nclass TimeUtils:\n    \"\"\"\n    This is a time util class, including getting the current time and date, adding seconds to a datetime, converting between strings and datetime objects, calculating the time difference in minutes, and formatting a datetime object.\n    \"\"\"\n\n\n    def __init__(self):\n        \"\"\"\n        Get the current datetime\n        \"\"\"\n        self.datetime = datetime.datetime.now()\n\n    def get_current_time(self):\n        \"\"\"\n        Return the current time in the format of '%H:%M:%S'\n        :return: string\n        >>> timeutils = TimeUtils()\n        >>> timeutils.get_current_time()\n        \"19:19:22\"\n        \"\"\"\n        format = \"%H:%M:%S\"\n        return self.datetime.strftime(format)\n\n    def get_current_date(self):\n        \"\"\"\n        Return the current date in the format of \"%Y-%m-%d\"\n        :return: string\n        >>> timeutils.get_current_date()\n        \"2023-06-14\"\n        \"\"\"\n        format = \"%Y-%m-%d\"\n        return self.datetime.strftime(format)\n\n    def add_seconds(self, seconds):\n        \"\"\"\n        Add the specified number of seconds to the current time\n        :param seconds: int, number of seconds to add\n        :return: string, time after adding the specified number of seconds in the format '%H:%M:%S'\n        >>> timeutils.add_seconds(600)\n        \"19:29:22\"\n        \"\"\"\n        new_datetime = self.datetime + datetime.timedelta(seconds=seconds)\n        format = \"%H:%M:%S\"\n        return new_datetime.strftime(format)\n\n    def string_to_datetime(self, string):\n        \"\"\"\n        Convert the time string to a datetime instance\n        :param string: string, string before converting format\n        :return: datetime instance\n        >>> timeutils.string_to_datetime(\"2001-7-18 1:1:1\")\n        2001-07-18 01:01:01\n        \"\"\"\n        return datetime.datetime.strptime(string, \"%Y-%m-%d %H:%M:%S\")\n\n    def datetime_to_string(self, datetime):\n        \"\"\"\n        Convert a datetime instance to a string\n        :param datetime: the datetime instance to convert\n        :return: string, converted time string\n        >>> timeutils.datetime_to_string(timeutils.datetime)\n        \"2023-06-14 19:30:03\"\n        \"\"\"\n        return datetime.strftime(\"%Y-%m-%d %H:%M:%S\")\n\n    def get_minutes(self, string_time1, string_time2):\n        \"\"\"\n        Calculate how many minutes have passed between two times, and round the results to the nearest\n        :return: int, the number of minutes between two times, rounded off\n        >>> timeutils.get_minutes(\"2001-7-18 1:1:1\", \"2001-7-18 2:1:1\")\n        60\n        \"\"\"\n        time1 = self.string_to_datetime(string_time1)\n        time2 = self.string_to_datetime(string_time2)\n        return round((time2 - time1).seconds / 60)\n\n    def get_format_time(self, year, month, day, hour, minute, second):\n        \"\"\"\n        get format time\n        :param year: int\n        :param month: int\n        :param day: int\n        :param hour: int\n        :param minute: int\n        :param second: int\n        :return: formatted time string\n        >>> timeutils.get_format_time(2001, 7, 18, 1, 1, 1)\n        \"2001-07-18 01:01:01\"\n        \"\"\"\n        format = \"%Y-%m-%d %H:%M:%S\"\n        time_item = datetime.datetime(year, month, day, hour, minute, second)\n        return time_item.strftime(format)\n",
        "annotated_code" : "import datetime\n\nclass TimeUtils:\n    \"\"\"\n    This is a time util class, including getting the current time and date, adding seconds to a datetime, converting between strings and datetime objects, calculating the time difference in minutes, and formatting a datetime object.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Get the current datetime\n        \"\"\"\n\n        # Initialize the datetime attribute with the current datetime using the datetime.datetime.now function\n        self.datetime = datetime.datetime.now()\n\n    def get_current_time(self):\n        \"\"\"\n        Return the current time in the format of '%H:%M:%S'\n        :return: string\n        >>> timeutils = TimeUtils()\n        >>> timeutils.get_current_time()\n        \"19:19:22\"\n        \"\"\"\n        # Use the datetime.strftime function to format the datetime attribute in the format of '%H:%M:%S' and return the resultant string\n        format = \"%H:%M:%S\"\n        return self.datetime.strftime(format)\n\n    def get_current_date(self):\n        \"\"\"\n        Return the current date in the format of \"%Y-%m-%d\"\n        :return: string\n        >>> timeutils.get_current_date()\n        \"2023-06-14\"\n        \"\"\"\n\n        # Use the datetime.strftime function to format the datetime attribute in the format of \"%Y-%m-%d\" and return the resultant string\n        format = \"%Y-%m-%d\"\n        return self.datetime.strftime(format)\n\n    def add_seconds(self, seconds):\n        \"\"\"\n        Add the specified number of seconds to the current time\n        :param seconds: int, number of seconds to add\n        :return: string, time after adding the specified number of seconds in the format '%H:%M:%S'\n        >>> timeutils.add_seconds(600)\n        \"19:29:22\"\n        \"\"\"\n        # Use the datetime.timedelta function to add the specified number of seconds to the datetime attribute\n        # Use the new_datetime.strftime function to format the new datetime in the format of '%H:%M:%S' and return the resultant string\n        new_datetime = self.datetime + datetime.timedelta(seconds=seconds)\n        format = \"%H:%M:%S\"\n        return new_datetime.strftime(format)\n\n    def string_to_datetime(self, string):\n        \"\"\"\n        Convert the time string to a datetime instance\n        :param string: string, string before converting format\n        :return: datetime instance\n        >>> timeutils.string_to_datetime(\"2001-7-18 1:1:1\")\n        2001-07-18 01:01:01\n        \"\"\"\n\n        # Use the datetime.datetime.strptime function to parse string with the format of \"%Y-%m-%d %H:%M:%S\" and return the result datetime object \n        return datetime.datetime.strptime(string, \"%Y-%m-%d %H:%M:%S\")\n\n    def datetime_to_string(self, datetime):\n        \"\"\"\n        Convert a datetime instance to a string\n        :param datetime: the datetime instance to convert\n        :return: string, converted time string\n        >>> timeutils.datetime_to_string(timeutils.datetime)\n        \"2023-06-14 19:30:03\"\n        \"\"\"\n        # Use the datetime attribute's strftime function to return the datetime attribute as a string in the format of \"%Y-%m-%d %H:%M:%S\"\n        return datetime.strftime(\"%Y-%m-%d %H:%M:%S\")\n\n    def get_minutes(self, string_time1, string_time2):\n        \"\"\"\n        Calculate how many minutes have passed between two times, and round the results to the nearest\n        :return: int, the number of minutes between two times, rounded off\n        >>> timeutils.get_minutes(\"2001-7-18 1:1:1\", \"2001-7-18 2:1:1\")\n        60\n        \"\"\"\n\n        # Use the string_to_datetime class method to convert the string times to datetime objects\n        time1 = self.string_to_datetime(string_time1)\n        time2 = self.string_to_datetime(string_time2)\n\n        # Calculate the difference in minutes between the two datetime objects and return the rounded result\n        return round((time2 - time1).seconds / 60)\n\n    def get_format_time(self, year, month, day, hour, minute, second):\n        \"\"\"\n        get format time\n        :param year: int\n        :param month: int\n        :param day: int\n        :param hour: int\n        :param minute: int\n        :param second: int\n        :return: formatted time string\n        >>> timeutils.get_format_time(2001, 7, 18, 1, 1, 1)\n        \"2001-07-18 01:01:01\"\n        \"\"\"\n\n        # Use the datetime.datetime function to create a datetime object with the specified parameters\n        format = \"%Y-%m-%d %H:%M:%S\"\n        time_item = datetime.datetime(year, month, day, hour, minute, second)\n\n        # Use the time_item's strftime function to return the datetime object as a string in the format of \"%Y-%m-%d %H:%M:%S\"\n        return time_item.strftime(format)"
    },
    {
        "id" : "88",
        "code" : "\nfrom math import pi, fabs\n\nclass TriCalculator:\n    \"\"\"\n    The class allows to calculate trigonometric values, including cosine, sine, and tangent, using Taylor series approximations.\n    \"\"\"\n\n\n    def __init__(self):\n        pass\n\n    def cos(self, x):\n        \"\"\"\n        Calculate the cos value of the x-degree angle\n        :param x:float\n        :return:float\n        >>> tricalculator = TriCalculator()\n        >>> tricalculator.cos(60)\n        0.5\n        \"\"\"\n        return round(self.taylor(x, 50), 10)\n\n    def factorial(self, a):\n        \"\"\"\n        Calculate the factorial of a\n        :param a: int\n        :return: int\n        >>> tricalculator.factorial(5)\n        120\n        \"\"\"\n        b = 1\n        while a != 1:\n            b *= a\n            a -= 1\n        return b\n\n    def taylor(self, x, n):\n        \"\"\"\n        Finding the n-order Taylor expansion value of cos (x/180 * pi)\n        :param x: int\n        :param n: int\n        :return: float\n        >>> tricalculator.taylor(60, 50)\n        0.5000000000000001\n        \"\"\"\n        a = 1\n        x = x / 180 * pi\n        count = 1\n        for k in range(1, n):\n            if count % 2 != 0:\n                a -= (x ** (2 * k)) / self.factorial(2 * k)\n            else:\n                a += (x ** (2 * k)) / self.factorial(2 * k)\n            count += 1\n        return a\n\n    def sin(self, x):\n        \"\"\"\n        Calculate the sin value of the x-degree angle\n        :param x: float\n        :return: float\n        >>> tricalculator.sin(30)\n        0.5\n        \"\"\"\n        x = x / 180 * pi\n        g = 0\n        t = x\n        n = 1\n\n        while fabs(t) >= 1e-15:\n            g += t\n            n += 1\n            t = -t * x * x / (2 * n - 1) / (2 * n - 2)\n        return round(g, 10)\n\n\n    def tan(self, x):\n        \"\"\"\n        Calculate the tan value of the x-degree angle\n        :param x: float\n        :return: float\n        >>> tricalculator.tan(45)\n        1.0\n        \"\"\"\n        if self.cos(x) != 0:\n            result = self.sin(x) / self.cos(x)\n            return round(result, 10)\n        else:\n            return False\n",
        "annotated_code" : "from math import pi, fabs\n\nclass TriCalculator:\n    \"\"\"\n    The class allows to calculate trigonometric values, including cosine, sine, and tangent, using Taylor series approximations.\n    \"\"\"\n\n    def __init__(self):\n        pass\n\n    def cos(self, x):\n        \"\"\"\n        Calculate the cos value of the x-degree angle\n        :param x:float\n        :return:float\n        >>> tricalculator = TriCalculator()\n        >>> tricalculator.cos(60)\n        0.5\n        \"\"\"\n        # Use the taylor class method to calculate the cosine value and round it to 10 decimal places and return the result\n        return round(self.taylor(x, 50), 10)\n\n    def factorial(self, a):\n        \"\"\"\n        Calculate the factorial of a\n        :param a: int\n        :return: int\n        >>> tricalculator.factorial(5)\n        120\n        \"\"\"\n\n        # Calculate and return the factorial of the given number a\n        b = 1\n        while a != 1:\n            b *= a\n            a -= 1\n        return b\n\n    def taylor(self, x, n):\n        \"\"\"\n        Finding the n-order Taylor expansion value of cos (x/180 * pi)\n        :param x: int\n        :param n: int\n        :return: float\n        >>> tricalculator.taylor(60, 50)\n        0.5000000000000001\n        \"\"\"\n\n        # Initialize the approximation with the first term of the cosine Taylor series\n        a = 1\n        # Convert degrees to radians\n        x = x / 180 * pi\n        count = 1\n\n        # Loop over n - 1 terms\n        for k in range(1, n):\n            if count % 2 != 0:\n                # For odd-count terms, subtract the term\n                # Use the factorial class method to calculate the denominator of the term\n                a -= (x ** (2 * k)) / self.factorial(2 * k)\n            else:\n                # For even-count terms, add the term\n                # Use the factorial class method to calculate the denominator of the term\n                a += (x ** (2 * k)) / self.factorial(2 * k)\n\n            # Increment the counter\n            count += 1\n        \n        # Return the final Taylor series approximation for cos(x)\n        return a\n\n    def sin(self, x):\n        \"\"\"\n        Calculate the sin value of the x-degree angle\n        :param x: float\n        :return: float\n        >>> tricalculator.sin(30)\n        0.5\n        \"\"\"\n\n        # Convert degrees to radians\n        x = x / 180 * pi\n        g = 0\n        t = x\n        n = 1\n\n        # Loop until the absolute value of the term is less than 1e-15\n        while fabs(t) >= 1e-15:\n            # Add the term to the sum\n            g += t\n            # Increment the counter\n            n += 1\n            # Calculate the next term in the series\n            t = -t * x * x / (2 * n - 1) / (2 * n - 2)\n        # Return the final Taylor series approximation for sin(x) rounded to 10 decimal places\n        return round(g, 10)\n\n\n    def tan(self, x):\n        \"\"\"\n        Calculate the tan value of the x-degree angle\n        :param x: float\n        :return: float\n        >>> tricalculator.tan(45)\n        1.0\n        \"\"\"\n\n        # Use the cos class method to check if the cosine of x is not zero to avoid division by zero\n        if self.cos(x) != 0:\n            # Calculate the tangent as the ratio of sine to cosine and return the result rounded to 10 decimal places\n            result = self.sin(x) / self.cos(x)\n            return round(result, 10)\n        else:\n        # If the cosine of x is zero, return False to indicate that the tangent is undefined\n            return False"
    },
    {
        "id" : "89",
        "code" : "\nimport random\n\nclass TwentyFourPointGame:\n    \"\"\"\n    This ia a game of twenty-four points, which provides to generate four numbers and check whether player's expression is equal to 24.\n    \"\"\"\n\n    def __init__(self) -> None:\n        self.nums = []\n\n\n    def _generate_cards(self):\n        \"\"\"\n        Generate random numbers between 1 and 9 for the cards.\n        \"\"\"\n        for i in range(4):\n            self.nums.append(random.randint(1, 9))\n        assert len(self.nums) == 4\n\n\n    def get_my_cards(self):\n        \"\"\"\n        Get a list of four random numbers between 1 and 9 representing the player's cards.\n        :return: list of integers, representing the player's cards\n        >>> game = TwentyFourPointGame()\n        >>> game.get_my_cards()\n\n        \"\"\"\n        self.nums = []\n        self._generate_cards()\n        return self.nums\n    \n\n\n    def answer(self, expression):\n        \"\"\"\n        Check if a given mathematical expression using the cards can evaluate to 24.\n        :param expression: string, mathematical expression using the cards\n        :return: bool, True if the expression evaluates to 24, False otherwise\n        >>> game = TwentyFourPointGame()\n        >>> game.nums = [4, 3, 6, 6]\n        >>> ans = \"4*3+6+6\"\n        >>> ret = game.answer(ans)\n        True\n        \"\"\"\n        if expression == 'pass':\n            return self.get_my_cards()\n        statistic = {}\n        for c in expression:\n            if c.isdigit() and int(c) in self.nums:\n                statistic[c] = statistic.get(c, 0) + 1\n\n        nums_used = statistic.copy()\n\n        for num in self.nums:\n            if nums_used.get(str(num), -100) != -100 and nums_used[str(num)] > 0:\n                nums_used[str(num)] -= 1\n            else:\n                return False\n\n        if all(count == 0 for count in nums_used.values()) == True:\n            return self.evaluate_expression(expression)\n        else:\n            return False\n\n\n    def evaluate_expression(self, expression):\n        \"\"\"\n        Evaluate a mathematical expression and check if the result is 24.\n        :param expression: string, mathematical expression\n        :return: bool, True if the expression evaluates to 24, False otherwise\n        >>> game = TwentyFourPointGame()\n        >>> nums = [4, 3, 6, 6]\n        >>> ans = \"4*3+6+6\"\n        >>> ret = game.evaluate_expression(ans)\n        True\n        \"\"\"\n        try:\n            if eval(expression) == 24:\n                return True\n            else:\n                return False\n        except Exception as e:\n            return False\n",
        "annotated_code" : "import random\n\nclass TwentyFourPointGame:\n    \"\"\"\n    This ia a game of twenty-four points, which provides to generate four numbers and check whether player's expression is equal to 24.\n    \"\"\"\n\n    def __init__(self) -> None:\n        self.nums = []\n\n    def _generate_cards(self):\n        \"\"\"\n        Generate random numbers between 1 and 9 for the cards.\n        \"\"\"\n        # Use the random.randint function to generate 4 random numbers between 1 and 9 and append them to the nums list\n        for i in range(4):\n            self.nums.append(random.randint(1, 9))\n        \n        # Assert that the length of the nums list is 4\n        assert len(self.nums) == 4\n\n    def get_my_cards(self):\n        \"\"\"\n        Get a list of four random numbers between 1 and 9 representing the player's cards.\n        :return: list of integers, representing the player's cards\n        >>> game = TwentyFourPointGame()\n        >>> game.get_my_cards()\n\n        \"\"\"\n\n        # Use the _generate_cards class method to generate 4 random numbers between 1 and 9 and return the nums list\n        self.nums = []\n        self._generate_cards()\n        return self.nums\n\n    def answer(self, expression):\n        \"\"\"\n        Check if a given mathematical expression using the cards can evaluate to 24.\n        :param expression: string, mathematical expression using the cards\n        :return: bool, True if the expression evaluates to 24, False otherwise\n        >>> game = TwentyFourPointGame()\n        >>> game.nums = [4, 3, 6, 6]\n        >>> ans = \"4*3+6+6\"\n        >>> ret = game.answer(ans)\n        True\n        \"\"\"\n        \n        # If the expression is 'pass', return the result of the get_my_cards class method\n        if expression == 'pass':\n            return self.get_my_cards()\n        \n        # Use a dictionary to count the occurrences of each number in the expression\n        statistic = {}\n        for c in expression:\n            if c.isdigit() and int(c) in self.nums:\n                statistic[c] = statistic.get(c, 0) + 1\n\n        # Create a copy of the statistic dictionary to keep track of the numbers used\n        nums_used = statistic.copy()\n\n        # Check if each number in the nums list is in the nums_used dictionary and return False if any number is not present\n        for num in self.nums:\n            if nums_used.get(str(num), -100) != -100 and nums_used[str(num)] > 0:\n                nums_used[str(num)] -= 1\n            else:\n                return False\n        \n        # If all the counts in the nums_used dictionary are 0, evaluate the expression and return the result of the evaluate_expression class method\n        # Otherwise, return False\n        if all(count == 0 for count in nums_used.values()) == True:\n            return self.evaluate_expression(expression)\n        else:\n            return False\n\n\n    def evaluate_expression(self, expression):\n        \"\"\"\n        Evaluate a mathematical expression and check if the result is 24.\n        :param expression: string, mathematical expression\n        :return: bool, True if the expression evaluates to 24, False otherwise\n        >>> game = TwentyFourPointGame()\n        >>> nums = [4, 3, 6, 6]\n        >>> ans = \"4*3+6+6\"\n        >>> ret = game.evaluate_expression(ans)\n        True\n        \"\"\"\n\n        try:\n            # Use the eval function to evaluate the expression and return True if the result is 24 and False otherwise\n            if eval(expression) == 24:\n                return True\n            else:\n                return False\n        # Return False if there is an exception\n        except Exception as e:\n            return False"
    },
    {
        "id" : "90",
        "code" : "\nclass URLHandler:\n    \"\"\"\n    The class supports to handle URLs, including extracting the scheme, host, path, query parameters, and fragment.\n    \"\"\"\n\n    def __init__(self, url):\n        \"\"\"\n        Initialize URLHandler's URL\n        \"\"\"\n        self.url = url\n\n    def get_scheme(self):\n        \"\"\"\n        get the scheme of the URL\n        :return: string, If successful, return the scheme of the URL\n        >>> urlhandler = URLHandler(\"https://www.baidu.com/s?wd=aaa&rsv_spt=1#page\")\n        >>> urlhandler.get_scheme()\n        \"https\"\n        \"\"\"\n        scheme_end = self.url.find(\"://\")\n        if scheme_end != -1:\n            return self.url[:scheme_end]\n        return None\n\n\n    def get_host(self):\n        \"\"\"\n        Get the second part of the URL, which is the host domain name\n        :return: string, If successful, return the host domain name of the URL\n        >>> urlhandler = URLHandler(\"https://www.baidu.com/s?wd=aaa&rsv_spt=1#page\")\n        >>> urlhandler.get_host()\n        \"www.baidu.com\"\n        \"\"\"\n        scheme_end = self.url.find(\"://\")\n        if scheme_end != -1:\n            url_without_scheme = self.url[scheme_end + 3:]\n            host_end = url_without_scheme.find(\"/\")\n            if host_end != -1:\n                return url_without_scheme[:host_end]\n            return url_without_scheme\n        return None\n\n\n    def get_path(self):\n        \"\"\"\n        Get the third part of the URL, which is the address of the resource\n        :return: string, If successful, return the address of the resource of the URL\n        >>> urlhandler = URLHandler(\"https://www.baidu.com/s?wd=aaa&rsv_spt=1#page\")\n        >>> urlhandler.get_path()\n        \"/s?wd=aaa&rsv_spt=1#page\"\n        \"\"\"\n        scheme_end = self.url.find(\"://\")\n        if scheme_end != -1:\n            url_without_scheme = self.url[scheme_end + 3:]\n            host_end = url_without_scheme.find(\"/\")\n            if host_end != -1:\n                return url_without_scheme[host_end:]\n        return None\n\n\n    def get_query_params(self):\n        \"\"\"\n        Get the request parameters for the URL\n        :return: dict, If successful, return the request parameters of the URL\n        >>> urlhandler = URLHandler(\"https://www.baidu.com/s?wd=aaa&rsv_spt=1#page\")\n        >>> urlhandler.get_query_params()\n        {\"wd\": \"aaa\", \"rsv_spt\": \"1\"}\n        \"\"\"\n        query_start = self.url.find(\"?\")\n        fragment_start = self.url.find(\"#\")\n        if query_start != -1:\n            query_string = self.url[query_start + 1:fragment_start]\n            params = {}\n            if len(query_string) > 0:\n                param_pairs = query_string.split(\"&\")\n                for pair in param_pairs:\n                    key_value = pair.split(\"=\")\n                    if len(key_value) == 2:\n                        key, value = key_value\n                        params[key] = value\n            return params\n        return None\n\n\n    def get_fragment(self):\n        \"\"\"\n        Get the fragment after '#' in the URL\n        :return: string, If successful, return the fragment after '#' of the URL\n        >>> urlhandler = URLHandler(\"https://www.baidu.com/s?wd=aaa&rsv_spt=1#page\")\n        >>> urlhandler.get_fragment()\n        \"page\"\n        \"\"\"\n        fragment_start = self.url.find(\"#\")\n",
        "annotated_code" : "class URLHandler:\n    \"\"\"\n    The class supports to handle URLs, including extracting the scheme, host, path, query parameters, and fragment.\n    \"\"\"\n\n    def __init__(self, url):\n        \"\"\"\n        Initialize URLHandler's URL\n        \"\"\"\n        self.url = url\n\n    def get_scheme(self):\n        \"\"\"\n        get the scheme of the URL\n        :return: string, If successful, return the scheme of the URL\n        >>> urlhandler = URLHandler(\"https://www.baidu.com/s?wd=aaa&rsv_spt=1#page\")\n        >>> urlhandler.get_scheme()\n        \"https\"\n        \"\"\"\n\n        # Get the index of the scheme end\n        scheme_end = self.url.find(\"://\")\n        if scheme_end != -1:\n            # If the scheme is present, return the scheme part of the URL\n            return self.url[:scheme_end]\n        # If the scheme is not present, return None\n        return None\n\n\n    def get_host(self):\n        \"\"\"\n        Get the second part of the URL, which is the host domain name\n        :return: string, If successful, return the host domain name of the URL\n        >>> urlhandler = URLHandler(\"https://www.baidu.com/s?wd=aaa&rsv_spt=1#page\")\n        >>> urlhandler.get_host()\n        \"www.baidu.com\"\n        \"\"\"\n\n        # Get the index of the scheme end\n        scheme_end = self.url.find(\"://\")\n        if scheme_end != -1:\n            # If the scheme is present, extract the URL without the scheme\n            url_without_scheme = self.url[scheme_end + 3:]\n            # Get the index of the host end\n            host_end = url_without_scheme.find(\"/\")\n            if host_end != -1:\n                # If the host is present, return the host name part of the URL\n                return url_without_scheme[:host_end]\n            # If the host is not present, return the URL without the scheme\n            return url_without_scheme\n        # If the scheme is not present, return None\n        return None\n\n\n    def get_path(self):\n        \"\"\"\n        Get the third part of the URL, which is the address of the resource\n        :return: string, If successful, return the address of the resource of the URL\n        >>> urlhandler = URLHandler(\"https://www.baidu.com/s?wd=aaa&rsv_spt=1#page\")\n        >>> urlhandler.get_path()\n        \"/s?wd=aaa&rsv_spt=1#page\"\n        \"\"\"\n\n        # Get the index of the scheme end\n        scheme_end = self.url.find(\"://\")\n        if scheme_end != -1:\n            # If the scheme is present, extract the URL without the scheme\n            url_without_scheme = self.url[scheme_end + 3:]\n            # Get the index of the host end\n            host_end = url_without_scheme.find(\"/\") \n            if host_end != -1:\n                # If the host is present, return the path starting from the host end\n                return url_without_scheme[host_end:]\n        # If the scheme is not present, return None\n        return None\n\n\n    def get_query_params(self):\n        \"\"\"\n        Get the request parameters for the URL\n        :return: dict, If successful, return the request parameters of the URL\n        >>> urlhandler = URLHandler(\"https://www.baidu.com/s?wd=aaa&rsv_spt=1#page\")\n        >>> urlhandler.get_query_params()\n        {\"wd\": \"aaa\", \"rsv_spt\": \"1\"}\n        \"\"\"\n\n        # Get the start index of the query string and fragment\n        query_start = self.url.find(\"?\")\n        fragment_start = self.url.find(\"#\")\n        if query_start != -1:\n            # If the query string is present, extract it from the URL\n            query_string = self.url[query_start + 1:fragment_start]\n\n            params = {}\n            # If the query string is not empty, split it into key-value pairs\n            if len(query_string) > 0:\n                param_pairs = query_string.split(\"&\")\n                # Iterate over the key-value pairs and add them to the params dictionary\n                for pair in param_pairs:\n                    key_value = pair.split(\"=\")\n                    if len(key_value) == 2:\n                        key, value = key_value\n                        params[key] = value\n            # Return the params dictionary\n            return params\n        # If the query string is not present, return None\n        return None\n\n\n    def get_fragment(self):\n        \"\"\"\n        Get the fragment after '#' in the URL\n        :return: string, If successful, return the fragment after '#' of the URL\n        >>> urlhandler = URLHandler(\"https://www.baidu.com/s?wd=aaa&rsv_spt=1#page\")\n        >>> urlhandler.get_fragment()\n        \"page\"\n        \"\"\"\n\n        # Return the fragment after '#' in the URL\n        fragment_start = self.url.find(\"#\")\n        return self.url[fragment_start + 1:] if fragment_start != -1 else None"
    },
    {
        "id" : "91",
        "code" : "\nimport urllib.parse\n\nclass UrlPath:\n    \"\"\"\n    The  class is a utility for encapsulating and manipulating the path component of a URL, including adding nodes, parsing path strings, and building path strings with optional encoding.      \n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initializes the UrlPath object with an empty list of segments and a flag indicating the presence of an end tag.\n        \"\"\"\n        self.segments = []\n        self.with_end_tag = False\n\n    def add(self, segment):\n        \"\"\"\n        Adds a segment to the list of segments in the UrlPath.\n        :param segment: str, the segment to add.\n        >>> url_path = UrlPath()\n        >>> url_path.add('foo')\n        >>> url_path.add('bar')\n\n        url_path.segments = ['foo', 'bar']\n        \"\"\"\n        self.segments.append(self.fix_path(segment))\n\n\n    def parse(self, path, charset):\n        \"\"\"\n        Parses a given path string and populates the list of segments in the UrlPath.\n        :param path: str, the path string to parse.\n        :param charset: str, the character encoding of the path string.\n        >>> url_path = UrlPath()\n        >>> url_path.parse('/foo/bar/', 'utf-8')\n\n        url_path.segments = ['foo', 'bar']\n        \"\"\"\n        if path:\n            if path.endswith('/'):\n                self.with_end_tag = True\n\n            path = self.fix_path(path)\n            if path:\n                split = path.split('/')\n                for seg in split:\n        decoded_seg = urllib.parse.unquote(seg, encoding=charset)\n                    self.segments.append(decoded_seg)\n\n\n    @staticmethod\n    def fix_path(path):\n        \"\"\"\n        Fixes the given path string by removing leading and trailing slashes.\n        :param path: str, the path string to fix.\n        :return: str, the fixed path string.\n        >>> url_path = UrlPath()\n        >>> url_path.fix_path('/foo/bar/')\n        'foo/bar'\n\n        \"\"\"\n        if not path:\n            return ''\n\n        segment_str = path.strip('/')\n        return segment_str\n",
        "annotated_code" : "import urllib.parse\n\nclass UrlPath:\n    \"\"\"\n    The  class is a utility for encapsulating and manipulating the path component of a URL, including adding nodes, parsing path strings, and building path strings with optional encoding.      \n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initializes the UrlPath object with an empty list of segments and a flag indicating the presence of an end tag.\n        \"\"\"\n        self.segments = []\n        self.with_end_tag = False\n\n    def add(self, segment):\n        \"\"\"\n        Adds a segment to the list of segments in the UrlPath.\n        :param segment: str, the segment to add.\n        >>> url_path = UrlPath()\n        >>> url_path.add('foo')\n        >>> url_path.add('bar')\n\n        url_path.segments = ['foo', 'bar']\n        \"\"\"\n        # Adds a segment to the list of segments for the UrlPath.\n        # Use the fix_path class method to ensure the segment is properly formatted.\n        self.segments.append(self.fix_path(segment))\n\n\n    def parse(self, path, charset):\n        \"\"\"\n        Parses a given path string and populates the list of segments in the UrlPath.\n        :param path: str, the path string to parse.\n        :param charset: str, the character encoding of the path string.\n        >>> url_path = UrlPath()\n        >>> url_path.parse('/foo/bar/', 'utf-8')\n\n        url_path.segments = ['foo', 'bar']\n        \"\"\"\n\n        if path:\n            # If the path ends with a '/', set the with_end_tag flag to True.\n            if path.endswith('/'):\n                self.with_end_tag = True\n\n            # Use the fix_path class method to ensure the path is properly formatted.\n            path = self.fix_path(path)\n            if path:\n                # Split the path into segments using '/' as the delimiter.\n                split = path.split('/')\n                # Iterate over the segments\n                for seg in split:\n                    # Use the urllib.parse.unquote function to decode each segment with the specified charset.\n                    decoded_seg = urllib.parse.unquote(seg, encoding=charset)\n                    # Append the decoded segment to the list of segments.\n                    self.segments.append(decoded_seg)\n\n\n    @staticmethod\n    def fix_path(path):\n        \"\"\"\n        Fixes the given path string by removing leading and trailing slashes.\n        :param path: str, the path string to fix.\n        :return: str, the fixed path string.\n        >>> url_path = UrlPath()\n        >>> url_path.fix_path('/foo/bar/')\n        'foo/bar'\n\n        \"\"\"\n\n        # If the path is empty, return an empty string.\n        if not path:\n            return ''\n\n        # Remove leading and trailing slashes from the path string.\n        segment_str = path.strip('/')\n\n        # Return the fixed path string.\n        return segment_str"
    },
    {
        "id" : "92",
        "code" : "\nclass UserLoginDB:\n    \"\"\"\n    This is a database management class for user login verification, providing functions for inserting user information, searching user information, deleting user information, and validating user login.\n    \"\"\"\n\n    def __init__(self, db_name):\n        \"\"\"\n        Initializes the UserLoginDB object with the specified database name.\n        :param db_name: str, the name of the SQLite database.\n        \"\"\"\n        self.connection = sqlite3.connect(db_name)\n        self.cursor = self.connection.cursor()\n\n    def insert_user(self, username, password):\n        \"\"\"\n        Inserts a new user into the \"users\" table.\n        :param username: str, the username of the user.\n        :param password: str, the password of the user.\n        :return: None\n        >>> user_db = UserLoginDB(\"user_database.db\")\n        >>> user_db.create_table()\n        >>> user_db.insert_user('user1', 'pass1')\n        \"\"\"\n        self.cursor.execute(\"\"\"\n            INSERT INTO users (username, password)\n            VALUES (?, ?)\n        \"\"\", (username, password))\n        self.connection.commit()\n\n\n    def search_user_by_username(self, username):\n        \"\"\"\n        Searches for users in the \"users\" table by username.\n        :param username: str, the username of the user to search for.\n        :return:list of tuples, the rows from the \"users\" table that match the search criteria.\n        >>> user_db = UserLoginDB(\"user_database.db\")\n        >>> user_db.create_table()\n        >>> user_db.insert_user('user1', 'pass1')\n        >>> result = user_db.search_user_by_username('user1')\n        len(result) = 1\n        \"\"\"\n        self.cursor.execute(\"\"\"\n            SELECT * FROM users WHERE username = ?\n        \"\"\", (username,))\n        user = self.cursor.fetchone()\n        return user\n\n\n    def delete_user_by_username(self, username):\n        \"\"\"\n        Deletes a user from the \"users\" table by username.\n        :param username: str, the username of the user to delete.\n        :return: None\n        >>> user_db = UserLoginDB(\"user_database.db\")\n        >>> user_db.create_table()\n        >>> user_db.insert_user('user1', 'pass1')\n        >>> user_db.delete_user_by_username('user1')\n        \"\"\"\n        self.cursor.execute(\"\"\"\n            DELETE FROM users WHERE username = ?\n        \"\"\", (username,))\n        self.connection.commit()\n\n\n    def validate_user_login(self, username, password):\n        \"\"\"\n        Determine whether the user can log in, that is, the user is in the database and the password is correct\n        :param username:str, the username of the user to validate.\n        :param password:str, the password of the user to validate.\n        :return:bool, representing whether the user can log in correctly\n        >>> user_db = UserLoginDB(\"user_database.db\")\n        >>> user_db.create_table()\n        >>> user_db.insert_user('user1', 'pass1')\n        >>> user_db.validate_user_login('user1', 'pass1')\n        True\n        \"\"\"\n        user = self.search_user_by_username(username)\n        if user is not None and user[1] == password:\n            return True\n        return False\n",
        "annotated_code" : "import sqlite3\n\nclass UserLoginDB:\n    \"\"\"\n    This is a database management class for user login verification, providing functions for inserting user information, searching user information, deleting user information, and validating user login.\n    \"\"\"\n\n    def __init__(self, db_name):\n        \"\"\"\n        Initializes the UserLoginDB object with the specified database name.\n        :param db_name: str, the name of the SQLite database.\n        \"\"\"\n\n        # Use the connect function to create a connection to the database db_name.\n        self.connection = sqlite3.connect(db_name)\n\n        # Use the cursor function for the connection to create a cursor object.\n        self.cursor = self.connection.cursor()\n\n    def insert_user(self, username, password):\n        \"\"\"\n        Inserts a new user into the \"users\" table.\n        :param username: str, the username of the user.\n        :param password: str, the password of the user.\n        :return: None\n        >>> user_db = UserLoginDB(\"user_database.db\")\n        >>> user_db.create_table()\n        >>> user_db.insert_user('user1', 'pass1')\n        \"\"\"\n        # Use the execute function of the cursor to insert the provided username and password into the \"users\" table.\n        self.cursor.execute(\"\"\"\n            INSERT INTO users (username, password)\n            VALUES (?, ?)\n        \"\"\", (username, password))\n\n        # Use the commit function of the connection to save the changes to the database.\n        self.connection.commit()\n\n\n    def search_user_by_username(self, username):\n        \"\"\"\n        Searches for users in the \"users\" table by username.\n        :param username: str, the username of the user to search for.\n        :return:list of tuples, the rows from the \"users\" table that match the search criteria.\n        >>> user_db = UserLoginDB(\"user_database.db\")\n        >>> user_db.create_table()\n        >>> user_db.insert_user('user1', 'pass1')\n        >>> result = user_db.search_user_by_username('user1')\n        len(result) = 1\n        \"\"\"\n        # Use the execute function of the cursor to search for the user with the provided username in the \"users\" table.\n        self.cursor.execute(\"\"\"\n            SELECT * FROM users WHERE username = ?\n        \"\"\", (username,))\n\n        # Use the fetchone function of the cursor to retrieve the first row of the result set and return it.\n        user = self.cursor.fetchone()\n        return user\n\n\n    def delete_user_by_username(self, username):\n        \"\"\"\n        Deletes a user from the \"users\" table by username.\n        :param username: str, the username of the user to delete.\n        :return: None\n        >>> user_db = UserLoginDB(\"user_database.db\")\n        >>> user_db.create_table()\n        >>> user_db.insert_user('user1', 'pass1')\n        >>> user_db.delete_user_by_username('user1')\n        \"\"\"\n\n        # Use the execute function of the cursor to delete the user with the provided username from the \"users\" table.\n        self.cursor.execute(\"\"\"\n            DELETE FROM users WHERE username = ?\n        \"\"\", (username,))\n\n        # Use the commit function of the connection to save the changes to the database.\n        self.connection.commit()\n\n\n    def validate_user_login(self, username, password):\n        \"\"\"\n        Determine whether the user can log in, that is, the user is in the database and the password is correct\n        :param username:str, the username of the user to validate.\n        :param password:str, the password of the user to validate.\n        :return:bool, representing whether the user can log in correctly\n        >>> user_db = UserLoginDB(\"user_database.db\")\n        >>> user_db.create_table()\n        >>> user_db.insert_user('user1', 'pass1')\n        >>> user_db.validate_user_login('user1', 'pass1')\n        True\n        \"\"\"\n        # Use the search_user_by_username class method to get the user information for the provided username.\n        user = self.search_user_by_username(username)\n\n        # If the user exists and the provided password matches the stored password, return True.\n        if user is not None and user[1] == password:\n            return True\n        # Otherwise, return False.\n        return False"
    },
    {
        "id" : "93",
        "code" : "\nimport numpy as np\nfrom gensim import matutils\nfrom numpy import dot, array\n\nclass VectorUtil:\n    \"\"\"\n    The class provides vector operations, including calculating similarity, cosine similarities, average similarity, and IDF weights.\n    \"\"\"\n\n    @staticmethod\n    def similarity(vector_1, vector_2):\n        \"\"\"\n        Compute the cosine similarity between one vector and another vector.\n        :param vector_1: numpy.ndarray, Vector from which similarities are to be computed, expected shape (dim,).\n        :param vector_2: numpy.ndarray, Vector from which similarities are to be computed, expected shape (dim,).\n        :return: numpy.ndarray, Contains cosine distance between `vector_1` and `vector_2`\n        >>> vector_1 = np.array([1, 1])\n        >>> vector_2 = np.array([1, 0])\n        >>> VectorUtil.similarity(vector_1, vector_2)\n        0.7071067811865475\n        \"\"\"\n        return dot(matutils.unitvec(vector_1), matutils.unitvec(vector_2))\n\n\n    @staticmethod\n    def cosine_similarities(vector_1, vectors_all):\n        \"\"\"\n        Compute cosine similarities between one vector and a set of other vectors.\n        :param vector_1: numpy.ndarray, Vector from which similarities are to be computed, expected shape (dim,).\n        :param vectors_all: list of numpy.ndarray, For each row in vectors_all, distance from vector_1 is computed, expected shape (num_vectors, dim).\n        :return: numpy.ndarray, Contains cosine distance between `vector_1` and each row in `vectors_all`, shape (num_vectors,).\n        >>> vector1 = np.array([1, 2, 3])\n        >>> vectors_all = [np.array([4, 5, 6]), np.array([7, 8, 9])]\n        >>> VectorUtil.cosine_similarities(vector1, vectors_all)\n        [0.97463185 0.95941195]\n        \"\"\"\n        norm = np.linalg.norm(vector_1)\n        all_norms = np.linalg.norm(vectors_all, axis=1)\n        dot_products = dot(vectors_all, vector_1)\n        similarities = dot_products / (norm * all_norms)\n        return similarities\n\n\n    @staticmethod\n    def n_similarity(vector_list_1, vector_list_2):\n        \"\"\"\n        Compute cosine similarity between two sets of vectors.\n        :param vector_list_1: list of numpy vector\n        :param vector_list_2: list of numpy vector\n        :return: numpy.ndarray, Similarities between vector_list_1 and vector_list_2.\n        >>> vector_list1 = [np.array([1, 2, 3]), np.array([4, 5, 6])]\n        >>> vector_list2 = [np.array([7, 8, 9]), np.array([10, 11, 12])]\n        >>> VectorUtil.n_similarity(vector_list1, vector_list2)\n        0.9897287473881233\n        \"\"\"\n        if not (len(vector_list_1) and len(vector_list_2)):\n            raise ZeroDivisionError('At least one of the passed list is empty.')\n\n        return dot(matutils.unitvec(array(vector_list_1).mean(axis=0)),\n                   matutils.unitvec(array(vector_list_2).mean(axis=0)))\n\n\n    @staticmethod\n    def compute_idf_weight_dict(total_num, number_dict):\n        \"\"\"\n        Calculate log(total_num+1/count+1) for each count in number_dict\n        :param total_num: int\n        :param number_dict: dict\n        :return: dict\n        >>> num_dict = {'key1':0.1, 'key2':0.5}\n        >>> VectorUtil.compute_idf_weight_dict(2, num_dict)\n        {'key1': 1.0033021088637848, 'key2': 0.6931471805599453}\n        \"\"\"\n        index_2_key_map = {}\n\n        index = 0\n\n        count_list = []\n        for key, count in number_dict.items():\n            index_2_key_map[index] = key\n            count_list.append(count)\n            index = index + 1\n\n        a = np.array(count_list)\n        ## smooth, in case the divide by zero error\n        a = np.log((total_num + 1) / (a + 1))\n        result = {}\n\n        for index, w in enumerate(a):\n            key = index_2_key_map[index]\n            result[key] = w\n\n        return result\n",
        "annotated_code" : "import numpy as np\nfrom gensim import matutils\nfrom numpy import dot, array\n\nclass VectorUtil:\n    \"\"\"\n    The class provides vector operations, including calculating similarity, cosine similarities, average similarity, and IDF weights.\n    \"\"\"\n\n    @staticmethod\n    def similarity(vector_1, vector_2):\n        \"\"\"\n        Compute the cosine similarity between one vector and another vector.\n        :param vector_1: numpy.ndarray, Vector from which similarities are to be computed, expected shape (dim,).\n        :param vector_2: numpy.ndarray, Vector from which similarities are to be computed, expected shape (dim,).\n        :return: numpy.ndarray, Contains cosine distance between `vector_1` and `vector_2`\n        >>> vector_1 = np.array([1, 1])\n        >>> vector_2 = np.array([1, 0])\n        >>> VectorUtil.similarity(vector_1, vector_2)\n        0.7071067811865475\n        \"\"\"\n        # Use the dot function to calculate the dot product of the two vectors and return the result.\n        # Use the matutils.unitvec function to normalize the vectors before calculating the dot product.\n        return dot(matutils.unitvec(vector_1), matutils.unitvec(vector_2))\n\n\n    @staticmethod\n    def cosine_similarities(vector_1, vectors_all):\n        \"\"\"\n        Compute cosine similarities between one vector and a set of other vectors.\n        :param vector_1: numpy.ndarray, Vector from which similarities are to be computed, expected shape (dim,).\n        :param vectors_all: list of numpy.ndarray, For each row in vectors_all, distance from vector_1 is computed, expected shape (num_vectors, dim).\n        :return: numpy.ndarray, Contains cosine distance between `vector_1` and each row in `vectors_all`, shape (num_vectors,).\n        >>> vector1 = np.array([1, 2, 3])\n        >>> vectors_all = [np.array([4, 5, 6]), np.array([7, 8, 9])]\n        >>> VectorUtil.cosine_similarities(vector1, vectors_all)\n        [0.97463185 0.95941195]\n        \"\"\"\n\n        # Use the linalg.norm function to calculate the norm of vector_1 and the norms of all vectors in vectors_all.\n        norm = np.linalg.norm(vector_1)\n        all_norms = np.linalg.norm(vectors_all, axis=1)\n\n        # Use the dot function to calculate the dot product of vector_1 and each vector in vectors_all.\n        dot_products = dot(vectors_all, vector_1)\n\n        # Calculate the cosine similarities by dividing the dot products by the product of the calculated norms.\n        similarities = dot_products / (norm * all_norms)\n\n        # Return the calculated cosine similarities.\n        return similarities\n\n\n    @staticmethod\n    def n_similarity(vector_list_1, vector_list_2):\n        \"\"\"\n        Compute cosine similarity between two sets of vectors.\n        :param vector_list_1: list of numpy vector\n        :param vector_list_2: list of numpy vector\n        :return: numpy.ndarray, Similarities between vector_list_1 and vector_list_2.\n        >>> vector_list1 = [np.array([1, 2, 3]), np.array([4, 5, 6])]\n        >>> vector_list2 = [np.array([7, 8, 9]), np.array([10, 11, 12])]\n        >>> VectorUtil.n_similarity(vector_list1, vector_list2)\n        0.9897287473881233\n        \"\"\"\n\n        # If either of the vector lists is empty, raise a ZeroDivisionError.\n        if not (len(vector_list_1) and len(vector_list_2)):\n            raise ZeroDivisionError('At least one of the passed list is empty.')\n\n        # Use the dot function to calculate the dot product of the mean of vector_list_1 and the mean of vector_list_2 and return the result.\n        # Use the array function to convert the vector lists to numpy arrays.\n        # Use the matutils.unitvec function to normalize the vectors before calculating the dot product.\n        return dot(matutils.unitvec(array(vector_list_1).mean(axis=0)),\nmatutils.unitvec(array(vector_list_2).mean(axis=0)))\n\n\n    @staticmethod\n    def compute_idf_weight_dict(total_num, number_dict):\n        \"\"\"\n        Calculate log(total_num+1/count+1) for each count in number_dict\n        :param total_num: int\n        :param number_dict: dict\n        :return: dict\n        >>> num_dict = {'key1':0.1, 'key2':0.5}\n        >>> VectorUtil.compute_idf_weight_dict(2, num_dict)\n        {'key1': 1.0033021088637848, 'key2': 0.6931471805599453}\n        \"\"\"\n    \n        index_2_key_map = {}\n        index = 0\n        count_list = []\n\n        # Iterate through the items of the number_dict dictionary and store the index and key in index_2_key_map and the count in count_list.\n        for key, count in number_dict.items():\n            index_2_key_map[index] = key\n            count_list.append(count)\n            index = index + 1\n\n        # Use the np.array function to convert count_list to a numpy array.\n        a = np.array(count_list)\n        \n        # Use the np.log function to calculate the logarithm of (total_num + 1) divided by (a + 1).\n        a = np.log((total_num + 1) / (a + 1))\n\n\n        result = {}\n\n        # Iterate through the enumerated items of a and store the key derived from index_2_key_map and corresponding weight in the result dictionary.\n        for index, w in enumerate(a):\n            key = index_2_key_map[index]\n            result[key] = w\n\n        # Return the result dictionary.\n        return result"
    },
    {
        "id" : "94",
        "code" : "\nclass VendingMachine:\n    \"\"\"\n    This is a class to simulate a vending machine, including adding products, inserting coins, purchasing products, viewing balance, replenishing product inventory, and displaying product information.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initializes the vending machine's inventory and balance.\n        \"\"\"\n        self.inventory = {}\n        self.balance = 0\n\n    def add_item(self, item_name, price, quantity):\n        \"\"\"\n        Adds a product to the vending machine's inventory.\n        :param item_name: The name of the product to be added, str.\n        :param price: The price of the product to be added, float.\n        :param quantity: The quantity of the product to be added, int.\n        :return: None\n        >>> vendingMachine = VendingMachine()\n        >>> vendingMachine.add_item('Coke', 1.25, 10)\n        >>> vendingMachine.inventory\n        {'Coke': {'price': 1.25, 'quantity': 10}}\n\n        \"\"\"\n        if not self.restock_item(item_name, quantity):\n            self.inventory[item_name] = {'price': price, 'quantity': quantity}\n\n    def insert_coin(self, amount):\n        \"\"\"\n        Inserts coins into the vending machine.\n        :param amount: The amount of coins to be inserted, float.\n        :return: The balance of the vending machine after the coins are inserted, float.\n        >>> vendingMachine = VendingMachine()\n        >>> vendingMachine.insert_coin(1.25)\n        1.25\n\n        \"\"\"\n        self.balance += amount\n        return self.balance\n\n    def purchase_item(self, item_name):\n        \"\"\"\n        Purchases a product from the vending machine and returns the balance after the purchase and display purchase unsuccessful if the product is out of stock.\n        :param item_name: The name of the product to be purchased, str.\n        :return: If successful, returns the balance of the vending machine after the product is purchased, float,otherwise,returns False.\n        >>> vendingMachine = VendingMachine()\n        >>> vendingMachine.inventory = {'Coke': {'price': 1.25, 'quantity': 10}}\n        >>> vendingMachine.balance = 1.25\n        >>> vendingMachine.purchase_item('Coke')\n        0.0\n        >>> vendingMachine.purchase_item('Pizza')\n        False\n\n        \"\"\"\n        if item_name in self.inventory:\n            item = self.inventory[item_name]\n            if item['quantity'] > 0 and self.balance >= item['price']:\n    self.balance -= item['price']\n                item['quantity'] -= 1\n                return self.balance\n            else:\n                return False\n        else:\n            return False\n\n    def restock_item(self, item_name, quantity):\n        \"\"\"\n        Replenishes the inventory of a product already in the vending machine.\n        :param item_name: The name of the product to be replenished, str.\n        :param quantity: The quantity of the product to be replenished, int.\n        :return: If the product is already in the vending machine, returns True, otherwise, returns False.\n        >>> vendingMachine = VendingMachine()\n        >>> vendingMachine.inventory = {'Coke': {'price': 1.25, 'quantity': 10}}\n        >>> vendingMachine.restock_item('Coke', 10)\n        True\n        >>> vendingMachine.restock_item('Pizza', 10)\n        False\n\n        \"\"\"\n        if item_name in self.inventory:\n            self.inventory[item_name]['quantity'] += quantity\n            return True\n        else:\n            return False\n\n    def display_items(self):\n        \"\"\"\n        Displays the products in the vending machine.\n        :return: If the vending machine is empty, returns False, otherwise, returns a list of the products in the vending machine, str.\n        >>> vendingMachine = VendingMachine()\n        >>> vendingMachine.display_items()\n        False\n        >>> vendingMachine.inventory = {'Coke': {'price': 1.25, 'quantity': 10} }\n        >>> vendingMachine.display_items()\n        'Coke - $1.25 [10]'\n\n        \"\"\"\n        if not self.inventory:\n            return False\n        else:\n            items = []\n            for item_name, item_info in self.inventory.items():\n                items.append(f\"{item_name} - ${item_info['price']} [{item_info['quantity']}]\")\n            return \"\n\".join(items)\n",
        "annotated_code" : "class VendingMachine:\n    \"\"\"\n    This is a class to simulate a vending machine, including adding products, inserting coins, purchasing products, viewing balance, replenishing product inventory, and displaying product information.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initializes the vending machine's inventory and balance.\n        \"\"\"\n        self.inventory = {}\n        self.balance = 0\n\n    def add_item(self, item_name, price, quantity):\n        \"\"\"\n        Adds a product to the vending machine's inventory.\n        :param item_name: The name of the product to be added, str.\n        :param price: The price of the product to be added, float.\n        :param quantity: The quantity of the product to be added, int.\n        :return: None\n        >>> vendingMachine = VendingMachine()\n        >>> vendingMachine.add_item('Coke', 1.25, 10)\n        >>> vendingMachine.inventory\n        {'Coke': {'price': 1.25, 'quantity': 10}}\n\n        \"\"\"\n\n        # Use the restock_item class method to check if the item is not already in the inventory\n        if not self.restock_item(item_name, quantity):\n            # Update the item's quantity and price to the provided values.\n            self.inventory[item_name] = {'price': price, 'quantity': quantity}\n\n    def insert_coin(self, amount):\n        \"\"\"\n        Inserts coins into the vending machine.\n        :param amount: The amount of coins to be inserted, float.\n        :return: The balance of the vending machine after the coins are inserted, float.\n        >>> vendingMachine = VendingMachine()\n        >>> vendingMachine.insert_coin(1.25)\n        1.25\n\n        \"\"\"\n        # Updates the balance by adding the provided amount and return the updated balance.\n        self.balance += amount\n        return self.balance\n\n    def purchase_item(self, item_name):\n        \"\"\"\n        Purchases a product from the vending machine and returns the balance after the purchase and display purchase unsuccessful if the product is out of stock.\n        :param item_name: The name of the product to be purchased, str.\n        :return: If successful, returns the balance of the vending machine after the product is purchased, float,otherwise,returns False.\n        >>> vendingMachine = VendingMachine()\n        >>> vendingMachine.inventory = {'Coke': {'price': 1.25, 'quantity': 10}}\n        >>> vendingMachine.balance = 1.25\n        >>> vendingMachine.purchase_item('Coke')\n        0.0\n        >>> vendingMachine.purchase_item('Pizza')\n        False\n\n        \"\"\"\n\n        if item_name in self.inventory:\n            item = self.inventory[item_name]\n            # Check if the item's quantity is greater than 0 and the balance is sufficient.\n            if item['quantity'] > 0 and self.balance >= item['price']:\n                # Update the balance by subtracting the price of the product and update the quantity by subtracting 1.\n                self.balance -= item['price']\n                item['quantity'] -= 1\n                # Return the updated balance.\n                return self.balance\n            else:\n            # If the quantity is not greater than 0 or the balance is not sufficient, return False.\n                return False\n        else:\n        # If the product is not in the inventory, return False.\n            return False\n\n    def restock_item(self, item_name, quantity):\n        \"\"\"\n        Replenishes the inventory of a product already in the vending machine.\n        :param item_name: The name of the product to be replenished, str.\n        :param quantity: The quantity of the product to be replenished, int.\n        :return: If the product is already in the vending machine, returns True, otherwise, returns False.\n        >>> vendingMachine = VendingMachine()\n        >>> vendingMachine.inventory = {'Coke': {'price': 1.25, 'quantity': 10}}\n        >>> vendingMachine.restock_item('Coke', 10)\n        True\n        >>> vendingMachine.restock_item('Pizza', 10)\n        False\n\n        \"\"\"\n\n        # If the product is already in the inventory, update the quantity by adding the provided quantity and return True.\n        if item_name in self.inventory:\n            self.inventory[item_name]['quantity'] += quantity\n            return True\n        else:\n        # If the product is not in the inventory, return False.\n            return False\n\n    def display_items(self):\n        \"\"\"\n        Displays the products in the vending machine.\n        :return: If the vending machine is empty, returns False, otherwise, returns a list of the products in the vending machine, str.\n        >>> vendingMachine = VendingMachine()\n        >>> vendingMachine.display_items()\n        False\n        >>> vendingMachine.inventory = {'Coke': {'price': 1.25, 'quantity': 10} }\n        >>> vendingMachine.display_items()\n        'Coke - $1.25 [10]'\n\n        \"\"\"\n\n        # If the inventory is empty, return False.\n        if not self.inventory:\n            return False\n        else:\n        # If the inventory is not empty, return a string with a list of the products in the inventory.\n            items = []\n            for item_name, item_info in self.inventory.items():\n                items.append(f\"{item_name} - ${item_info['price']} [{item_info['quantity']}]\")\n            return \"\".join(items)"
    },
    {
        "id" : "95",
        "code" : "\nclass Warehouse:\n    \"\"\"\n    The class manages inventory and orders, including adding products, updating product quantities, retrieving product quantities, creating orders, changing order statuses, and tracking orders.    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize two fields.\n        self.inventory is a dict that stores the products.\n        self.inventory = {Product ID: Product}\n        self.orders is a dict that stores the products in a order.\n        self.orders = {Order ID: Order}\n        \"\"\"\n        self.inventory = {}  # Product ID: Product\n        self.orders = {}  # Order ID: Order\n\n    def add_product(self, product_id, name, quantity):\n        \"\"\"\n        Add product to inventory and plus the quantity if it has existed in inventory.\n        Or just add new product to dict otherwise.\n        :param product_id: int\n        :param name: str, product name\n        :param quantity: int, product quantity\n        >>> warehouse.add_product(1, \"product1\", 3)\n        >>> warehouse.inventory\n        {1: {'name': 'product1', 'quantity': 3}}\n        \"\"\"\n        if product_id not in self.inventory:\n            self.inventory[product_id] = {'name': name, 'quantity': quantity}\n        else:\n            self.inventory[product_id]['quantity'] += quantity\n\n    def update_product_quantity(self, product_id, quantity):\n        \"\"\"\n        According to product_id, add the quantity to the corresponding product in inventory.\n        >>> warehouse.add_product(1, \"product1\", 3)\n        >>> warehouse.update_product_quantity(1, -1)\n        >>> warehouse.inventory\n        {1: {'name': 'product1', 'quantity': 2}}\n        \"\"\"\n        if product_id in self.inventory:\n            self.inventory[product_id]['quantity'] += quantity\n\n    def get_product_quantity(self, product_id):\n        \"\"\"\n        Get the quantity of specific product by product_id.\n        :param product_id, int\n        :return: if the product_id is in inventory then return the corresponding quantity,\n                or False otherwise.\n        >>> warehouse.add_product(1, \"product1\", 3)\n        >>> warehouse.get_product_quantity(1)\n        3\n        >>> warehouse.get_product_quantity(2)\n        False\n        \"\"\"\n        if product_id in self.inventory:\n            return self.inventory[product_id]['quantity']\n        else:\n            return False\n\n    def create_order(self, order_id, product_id, quantity):\n        \"\"\"\n        Create a order which includes the infomation of product, like id and quantity.\n        And put the new order into self.orders.\n        The default value of status is 'Shipped'.\n        :param order_id: int\n        :param product_id: int\n        :param quantity: the quantity of product that be selected.\n        :return False: only if product_id is not in inventory or the quantity is not adequate\n        >>> warehouse.add_product(1, \"product1\", 3)\n        >>> warehouse.create_order(1, 1, 2)\n        >>> warehouse.orders\n        {1: {'product_id': 1, 'quantity': 2, 'status': 'Shipped'}}\n        >>> warehouse.create_order(1, 2, 2)\n        False\n        \"\"\"\n        if self.get_product_quantity(product_id) >= quantity:\n            self.update_product_quantity(product_id, -quantity)\n            self.orders[order_id] = {'product_id': product_id, 'quantity': quantity, 'status': 'Shipped'}\n        else:\n            return False\n\n    def change_order_status(self, order_id, status):\n        \"\"\"\n        Change the status of order if the input order_id is in self.orders.\n        :param order_id: int\n        :param status: str, the state that is going to change to\n        :return False: only if the order_id is not in self.orders\n        >>> warehouse.add_product(1, \"product1\", 3)\n        >>> warehouse.create_order(1, 1, 2)\n        >>> warehouse.change_order_status(1, \"done\")\n        >>> warehouse.orders\n        {1: {'product_id': 1, 'quantity': 2, 'status': 'done'}}\n        \"\"\"\n        if order_id in self.orders:\n            self.orders[order_id]['status'] = status\n        else:\n            return False\n\n    def track_order(self, order_id):\n        \"\"\"\n        Get the status of specific order.\n        :param order_id: int\n        :return False: only if the order_id is not in self.orders.\n        >>> warehouse.add_product(1, \"product1\", 3)\n        >>> warehouse.create_order(1, 1, 2)\n        >>> warehouse.track_order(1)\n        'Shipped'\n        \"\"\"\n        if order_id in self.orders:\n            return self.orders[order_id]['status']\n        else:\n            return False\n",
        "annotated_code" : "class Warehouse:\n    \"\"\"\n    The class manages inventory and orders, including adding products, updating product quantities, retrieving product quantities, creating orders, changing order statuses, and tracking orders.    \n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize two fields.\n        self.inventory is a dict that stores the products.\n        self.inventory = {Product ID: Product}\n        self.orders is a dict that stores the products in a order.\n        self.orders = {Order ID: Order}\n        \"\"\"\n        self.inventory = {}  # Product ID: Product\n        self.orders = {}  # Order ID: Order\n\n    def add_product(self, product_id, name, quantity):\n        \"\"\"\n        Add product to inventory and plus the quantity if it has existed in inventory.\n        Or just add new product to dict otherwise.\n        :param product_id: int\n        :param name: str, product name\n        :param quantity: int, product quantity\n        >>> warehouse.add_product(1, \"product1\", 3)\n        >>> warehouse.inventory\n        {1: {'name': 'product1', 'quantity': 3}}\n        \"\"\"\n\n        # If the product_id is not in the inventory, add it to the inventory with the provided name and quantity.\n        if product_id not in self.inventory:\n            self.inventory[product_id] = {'name': name, 'quantity': quantity}\n        else:\n        # If the product_id is already in the inventory, update the quantity by adding the provided quantity.\n            self.inventory[product_id]['quantity'] += quantity\n\n    def update_product_quantity(self, product_id, quantity):\n        \"\"\"\n        According to product_id, add the quantity to the corresponding product in inventory.\n        >>> warehouse.add_product(1, \"product1\", 3)\n        >>> warehouse.update_product_quantity(1, -1)\n        >>> warehouse.inventory\n        {1: {'name': 'product1', 'quantity': 2}}\n        \"\"\"\n\n        # If the product_id is in the inventory, update the quantity by adding the provided quantity.\n        if product_id in self.inventory:\n            self.inventory[product_id]['quantity'] += quantity\n\n    def get_product_quantity(self, product_id):\n        \"\"\"\n        Get the quantity of specific product by product_id.\n        :param product_id, int\n        :return: if the product_id is in inventory then return the corresponding quantity,\n                or False otherwise.\n        >>> warehouse.add_product(1, \"product1\", 3)\n        >>> warehouse.get_product_quantity(1)\n        3\n        >>> warehouse.get_product_quantity(2)\n        False\n        \"\"\"\n\n        # If the product_id is in the inventory, return the corresponding quantity for the product.\n        if product_id in self.inventory:\n            return self.inventory[product_id]['quantity']\n        else:\n        # If the product_id is not in inventory, return False.\n            return False\n\n    def create_order(self, order_id, product_id, quantity):\n        \"\"\"\n        Create a order which includes the infomation of product, like id and quantity.\n        And put the new order into self.orders.\n        The default value of status is 'Shipped'.\n        :param order_id: int\n        :param product_id: int\n        :param quantity: the quantity of product that be selected.\n        :return False: only if product_id is not in inventory or the quantity is not adequate\n        >>> warehouse.add_product(1, \"product1\", 3)\n        >>> warehouse.create_order(1, 1, 2)\n        >>> warehouse.orders\n        {1: {'product_id': 1, 'quantity': 2, 'status': 'Shipped'}}\n        >>> warehouse.create_order(1, 2, 2)\n        False\n        \"\"\"\n\n        # Use the get_product_quantity class method to check if the quantity for the product is greater than or equal to the provided quantity.\n        if self.get_product_quantity(product_id) >= quantity:\n            # Use the update_product_quantity class method to update the product quantity in the inventory by subtracting the provided quantity.\n            self.update_product_quantity(product_id, -quantity)\n\n            # Add the order to self.orders with the provided order_id, product_id, quantity, and Shipped status.\n            self.orders[order_id] = {'product_id': product_id, 'quantity': quantity, 'status': 'Shipped'}\n        else:\n        # If the quantity of the product in the inventory is less than the provided quantity, return False.\n            return False\n\n    def change_order_status(self, order_id, status):\n        \"\"\"\n        Change the status of order if the input order_id is in self.orders.\n        :param order_id: int\n        :param status: str, the state that is going to change to\n        :return False: only if the order_id is not in self.orders\n        >>> warehouse.add_product(1, \"product1\", 3)\n        >>> warehouse.create_order(1, 1, 2)\n        >>> warehouse.change_order_status(1, \"done\")\n        >>> warehouse.orders\n        {1: {'product_id': 1, 'quantity': 2, 'status': 'done'}}\n        \"\"\"\n\n        # If the order_id exists in the orders dictionary, update the status of the order to the provided status.\n        if order_id in self.orders:\n            self.orders[order_id]['status'] = status\n        else:\n        # If the order_id does not exist in the orders dictionary, return False.\n            return False\n\n    def track_order(self, order_id):\n        \"\"\"\n        Get the status of specific order.\n        :param order_id: int\n        :return False: only if the order_id is not in self.orders.\n        >>> warehouse.add_product(1, \"product1\", 3)\n        >>> warehouse.create_order(1, 1, 2)\n        >>> warehouse.track_order(1)\n        'Shipped'\n        \"\"\"\n\n        # If the order_id exists in the orders dictionary, return the status of the order.\n        if order_id in self.orders:\n            return self.orders[order_id]['status']\n        else:\n        # If the order_id does not exist in the orders dictionary, return False.\n            return False"
    },
    {
        "id" : "96",
        "code" : "\nclass WeatherSystem:\n    \"\"\"\n    This is a class representing a weather system that provides functionality to query weather information for a specific city and convert temperature units between Celsius and Fahrenheit.     \n    \"\"\"\n\n    def __init__(self, city) -> None:\n        \"\"\"\n        Initialize the weather system with a city name.\n        \"\"\"\n        self.temperature = None\n        self.weather = None\n        self.city = city\n        self.weather_list = {}\n\n    def query(self, weather_list, tmp_units = 'celsius'):\n        \"\"\"\n        Query the weather system for the weather and temperature of the city,and convert the temperature units based on the input parameter.\n        :param weather_list: a dictionary of weather information for different cities,dict.\n        :param tmp_units: the temperature units to convert to, str.\n        :return: the temperature and weather of the city, tuple.\n        >>> weatherSystem = WeatherSystem('New York')\n        >>> weather_list = {'New York': {'weather': 'sunny','temperature': 27,'temperature units': 'celsius'},'Beijing': {'weather': 'cloudy','temperature': 23,'temperature units': 'celsius'}} \n        >>> weatherSystem.query(weather_list)\n        (27, 'sunny')\n\n        \"\"\"\n        self.weather_list = weather_list\n        if self.city not in weather_list:\n            return False\n        else:\n            self.temperature = self.weather_list[self.city]['temperature']\n            self.weather = self.weather_list[self.city]['weather']\n        if self.weather_list[self.city]['temperature units'] != tmp_units:\n            if tmp_units == 'celsius':\n                return self.fahrenheit_to_celsius(), self.weather\n            elif tmp_units == 'fahrenheit':\n                return self.celsius_to_fahrenheit(), self.weather\n        else:\n            return self.temperature, self.weather\n\n    def set_city(self, city):\n        \"\"\"\n        Set the city of the weather system.\n        :param city: the city to set, str.\n        :return: None\n        >>> weatherSystem = WeatherSystem('New York')\n        >>> weatherSystem.set_city('Beijing')\n        >>> weatherSystem.city\n        'Beijing'\n\n        \"\"\"\n        self.city = city\n\n    def celsius_to_fahrenheit(self):\n        \"\"\"\n        Convert the temperature from Celsius to Fahrenheit.\n        :return: the temperature in Fahrenheit, float.\n        >>> weatherSystem = WeatherSystem('New York')\n        >>> weatherSystem.temperature = 27\n        >>> weatherSystem.celsius_to_fahrenheit()\n        80.6\n\n        \"\"\"\n        return (self.temperature * 9/5) + 32\n\n    def fahrenheit_to_celsius(self):\n        \"\"\"\n        Convert the temperature from Fahrenheit to Celsius.\n        :return: the temperature in Celsius, float.\n        >>> weatherSystem = WeatherSystem('New York')\n        >>> weatherSystem.temperature = 80.6\n        >>> weatherSystem.fahrenheit_to_celsius()\n        26.999999999999996\n\n        \"\"\"\n        return (self.temperature - 32) * 5/9\n",
        "annotated_code" : "class WeatherSystem:\n    \"\"\"\n    This is a class representing a weather system that provides functionality to query weather information for a specific city and convert temperature units between Celsius and Fahrenheit.     \n    \"\"\"\n\n    def __init__(self, city) -> None:\n        \"\"\"\n        Initialize the weather system with a city name.\n        \"\"\"\n        self.temperature = None\n        self.weather = None\n        self.city = city\n        self.weather_list = {}\n\n    def query(self, weather_list, tmp_units = 'celsius'):\n        \"\"\"\n        Query the weather system for the weather and temperature of the city,and convert the temperature units based on the input parameter.\n        :param weather_list: a dictionary of weather information for different cities,dict.\n        :param tmp_units: the temperature units to convert to, str.\n        :return: the temperature and weather of the city, tuple.\n        >>> weatherSystem = WeatherSystem('New York')\n        >>> weather_list = {'New York': {'weather': 'sunny','temperature': 27,'temperature units': 'celsius'},'Beijing': {'weather': 'cloudy','temperature': 23,'temperature units': 'celsius'}} \n        >>> weatherSystem.query(weather_list)\n        (27, 'sunny')\n\n        \"\"\"\n\n        # Set the weather_list attribute to the provided weather_list\n        self.weather_list = weather_list\n\n        # Return False if the city attribute is not in the weather_list\n        if self.city not in weather_list:\n            return False\n        else:\n        # Set the temperature and weather attributes for the city to the corresponding values from the weather_list\n            self.temperature = self.weather_list[self.city]['temperature']\n            self.weather = self.weather_list[self.city]['weather']\n        \n        # Use the fahrenheit_to_celsius or celsius_to_fahrenheit class methods to convert the temperature units if the temperature units in the weather_list are not equal to the provided tmp_units\n        # Return the resultant temperature and weather attributes\n        if self.weather_list[self.city]['temperature units'] != tmp_units:\n            if tmp_units == 'celsius':\n                return self.fahrenheit_to_celsius(), self.weather\n            elif tmp_units == 'fahrenheit':\n                return self.celsius_to_fahrenheit(), self.weather\n        else:\n            return self.temperature, self.weather\n\n    def set_city(self, city):\n        \"\"\"\n        Set the city of the weather system.\n        :param city: the city to set, str.\n        :return: None\n        >>> weatherSystem = WeatherSystem('New York')\n        >>> weatherSystem.set_city('Beijing')\n        >>> weatherSystem.city\n        'Beijing'\n\n        \"\"\"\n        # Set the city of the weather system to the provided city\n        self.city = city\n\n    def celsius_to_fahrenheit(self):\n        \"\"\"\n        Convert the temperature from Celsius to Fahrenheit.\n        :return: the temperature in Fahrenheit, float.\n        >>> weatherSystem = WeatherSystem('New York')\n        >>> weatherSystem.temperature = 27\n        >>> weatherSystem.celsius_to_fahrenheit()\n        80.6\n\n        \"\"\"\n        # Convert the temperature from Celsius to Fahrenheit and return the result\n        return (self.temperature * 9/5) + 32\n\n    def fahrenheit_to_celsius(self):\n        \"\"\"\n        Convert the temperature from Fahrenheit to Celsius.\n        :return: the temperature in Celsius, float.\n        >>> weatherSystem = WeatherSystem('New York')\n        >>> weatherSystem.temperature = 80.6\n        >>> weatherSystem.fahrenheit_to_celsius()\n        26.999999999999996\n\n        \"\"\"\n        # Convert the temperature from Fahrenheit to Celsius and return the result\n        return (self.temperature - 32) * 5/9"
    },
    {
        "id" : "97",
        "code" : "class Words2Numbers:\n    \"\"\"\n    The class provides a text-to-number conversion utility, allowing conversion of written numbers (in words) to their numerical representation.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the word lists and dictionaries required for conversion\n        \"\"\"\n        self.numwords = {}\n        self.units = [\n            \"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\",\n            \"nine\", \"ten\", \"eleven\", \"twelve\", \"thirteen\", \"fourteen\", \"fifteen\",\n            \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\",\n        ]\n        self.tens = [\"\", \"\", \"twenty\", \"thirty\", \"forty\", \"fifty\", \"sixty\", \"seventy\", \"eighty\", \"ninety\"]\n        self.scales = [\"hundred\", \"thousand\", \"million\", \"billion\", \"trillion\"]\n\n        self.numwords[\"and\"] = (1, 0)\n        for idx, word in enumerate(self.units):\n            self.numwords[word] = (1, idx)\n        for idx, word in enumerate(self.tens):\n            self.numwords[word] = (1, idx * 10)\n        for idx, word in enumerate(self.scales):\n            self.numwords[word] = (10 ** (idx * 3 or 2), 0)\n\n        self.ordinal_words = {'first': 1, 'second': 2, 'third': 3, 'fifth': 5, 'eighth': 8, 'ninth': 9, 'twelfth': 12}\n        self.ordinal_endings = [('ieth', 'y'), ('th', '')]\n\n\n    def text2int(self, textnum):\n        \"\"\"\n        Convert the word string to the corresponding integer string\n        :param textnum: string, the word string to be converted\n        :return: string, the final converted integer string\n        >>> w2n = Words2Numbers()\n        >>> w2n.text2int(\"thirty-two\")\n        \"32\"\n        \"\"\"\n\n        textnum = textnum.replace('-', ' ')\n\n        current = result = 0\n        curstring = \"\"\n        onnumber = False\n\n        for word in textnum.split():\n            if word in self.ordinal_words:\n                scale, increment = (1, self.ordinal_words[word])\n                current = current * scale + increment\n                onnumber = True\n            else:\n                for ending, replacement in self.ordinal_endings:\n                    if word.endswith(ending):\n                        word = \"%s%s\" % (word[:-len(ending)], replacement)\n                \n                if word not in self.numwords:\n                    if onnumber:\n                        curstring += repr(result + current) + \" \"\n                        curstring += word + \" \"\n                    result = current = 0\n                    onnumber = False\n                else:\n                    scale, increment = self.numwords[word]\n                    current = current * scale + increment\n                    if scale > 100:\n                        result += current\n                        current = 0\n                    onnumber = True\n\n        if onnumber:\n            curstring += repr(result + current)\n        \n        return curstring\n\n    def is_valid_input(self, textnum):\n        \"\"\"\n        Check if the input text contains only valid words that can be converted into numbers.\n        :param textnum: The input text containing words representing numbers.\n        :return: True if input is valid, False otherwise.\n        >>> w2n = Words2Numbers()\n        >>> w2n.is_valid_input(\"thirty-two\")\n        False\n        \"\"\"\n\n        textnum = textnum.replace('-', ' ')\n        \n        for word in textnum.split():\n            if word in self.ordinal_words:\n                continue\n            else:\n                for ending, replacement in self.ordinal_endings:\n                    if word.endswith(ending):\n                        word = \"%s%s\" % (word[:-len(ending)], replacement)\n                \n                if word not in self.numwords:\n                    return False\n        \n        return True",
        "annotated_code" : "class Words2Numbers:\n    \"\"\"\n    The class provides a text-to-number conversion utility, allowing conversion of written numbers (in words) to their numerical representation.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the word lists and dictionaries required for conversion\n        \"\"\"\n        self.numwords = {}\n        self.units = [\n            \"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\",\n            \"nine\", \"ten\", \"eleven\", \"twelve\", \"thirteen\", \"fourteen\", \"fifteen\",\n            \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\",\n        ]\n        self.tens = [\"\", \"\", \"twenty\", \"thirty\", \"forty\", \"fifty\", \"sixty\", \"seventy\", \"eighty\", \"ninety\"]\n        self.scales = [\"hundred\", \"thousand\", \"million\", \"billion\", \"trillion\"]\n\n        self.numwords[\"and\"] = (1, 0)\n        for idx, word in enumerate(self.units):\n            self.numwords[word] = (1, idx)\n        for idx, word in enumerate(self.tens):\n            self.numwords[word] = (1, idx * 10)\n        for idx, word in enumerate(self.scales):\n            self.numwords[word] = (10 ** (idx * 3 or 2), 0)\n\n        self.ordinal_words = {'first': 1, 'second': 2, 'third': 3, 'fifth': 5, 'eighth': 8, 'ninth': 9, 'twelfth': 12}\n        self.ordinal_endings = [('ieth', 'y'), ('th', '')]\n\n\n    def text2int(self, textnum):\n        \"\"\"\n        Convert the word string to the corresponding integer string\n        :param textnum: string, the word string to be converted\n        :return: string, the final converted integer string\n        >>> w2n = Words2Numbers()\n        >>> w2n.text2int(\"thirty-two\")\n        \"32\"\n        \"\"\"\n\n        # Replace hyphens with spaces for easier splitting\n        textnum = textnum.replace('-', ' ')\n\n        current = result = 0\n        curstring = \"\"\n        onnumber = False\n\n        # Iterate through each word in the textnum string\n        for word in textnum.split():\n            # Handle special ordinal words (e.g., \"first\" -> 1)\n            if word in self.ordinal_words:\n                scale, increment = (1, self.ordinal_words[word])\n                current = current * scale + increment\n                onnumber = True\n            else:\n            # Handle regular ordinal endings (\"twentieth\" -> \"twenty\")\n                for ending, replacement in self.ordinal_endings:\n                    if word.endswith(ending):\n                        word = \"%s%s\" % (word[:-len(ending)], replacement)\n                \n                # If the word is not recognized, finalize the current number and treat the word as-is\n                if word not in self.numwords:\n                    if onnumber:\n                        curstring += repr(result + current) + \" \"\n                        curstring += word + \" \"\n                    result = current = 0\n                    onnumber = False\n                else:\n                # If the word is valid, apply its (scale, increment)\n                    scale, increment = self.numwords[word]\n                    current = current * scale + increment\n                    # If scale is large (100+), move current to result immediately\n                    if scale > 100:\n                        result += current\n                        current = 0\n                    onnumber = True\n\n        # If the last word was part of a number, finalize it\n        if onnumber:\n            curstring += repr(result + current)\n        \n        # Return the final string representation of the number\n        return curstring\n\n    def is_valid_input(self, textnum):\n        \"\"\"\n        Check if the input text contains only valid words that can be converted into numbers.\n        :param textnum: The input text containing words representing numbers.\n        :return: True if input is valid, False otherwise.\n        >>> w2n = Words2Numbers()\n        >>> w2n.is_valid_input(\"thirty-two\")\n        False\n        \"\"\"\n\n        # Replace hyphens with spaces\n        textnum = textnum.replace('-', ' ')\n        \n        # Iterate through each word in the textnum string\n        for word in textnum.split():\n            # Skip valid ordinal words\n            if word in self.ordinal_words:\n                continue\n            else:\n            # Normalize possible ordinal endings (\"twentieth\" -> \"twenty\")\n                for ending, replacement in self.ordinal_endings:\n                    if word.endswith(ending):\n                        word = \"%s%s\" % (word[:-len(ending)], replacement)\n                \n                # If the normalized word is not in numwords, it's invalid\n                if word not in self.numwords:\n                    return False\n        \n        # Return True if all words are valid\n        return True"
    },
    {
        "id" : "98",
        "code" : "\nimport xml.etree.ElementTree as ET\n\n\nclass XMLProcessor:\n    \"\"\"\n    This is a class as XML files handler, including reading, writing, processing as well as finding elements in a XML file.\n    \"\"\"\n\n    def __init__(self, file_name):\n        \"\"\"\n        Initialize the XMLProcessor object with the given file name.\n        :param file_name:string, the name of the XML file to be processed.\n        \"\"\"\n        self.file_name = file_name\n        self.root = None\n\n    def read_xml(self):\n        \"\"\"\n        Reads the XML file and returns the root element.\n        :return: Element, the root element of the XML file.\n        >>> xml_processor = XMLProcessor('test.xml')\n        >>> root_element = xml_processor.read_xml()\n        >>> print(root_element)\n        <Element 'root' at 0x7f8e3b7eb180>\n        \"\"\"\n        try:\n            tree = ET.parse(self.file_name)\n            self.root = tree.getroot()\n            return self.root\n        except:\n            return None\n\n\n    def write_xml(self, file_name):\n        \"\"\"\n        Writes the XML data to the specified file.\n        :param file_name: string, the name of the file to write the XML data.\n        :return: bool, True if the write operation is successful, False otherwise.\n        >>> xml_processor = XMLProcessor('test.xml')\n        >>> root = xml_processor.read_xml()\n        >>> success = xml_processor.write_xml('output.xml')\n        >>> print(success)\n        True\n        \"\"\"\n        try:\n            tree = ET.ElementTree(self.root)\n            tree.write(file_name)\n            return True\n        except:\n            return False\n\n\n    def process_xml_data(self, file_name):\n        \"\"\"\n        Modifies the data in XML elements and writes the updated XML data to a new file.\n        :param file_name: string, the name of the file to write the modified XML data.\n        :return: bool, True if the write operation is successful, False otherwise.\n        >>> xml_processor = XMLProcessor('test.xml')\n        >>> root = xml_processor.read_xml()\n        >>> success = xml_processor.process_xml_data('processed.xml')\n        >>> print(success)\n        True\n        \"\"\"\n        for element in self.root.iter('item'):\n            text = element.text\n            element.text = text.upper()\n        return self.write_xml(file_name)\n\n\n    def find_element(self, element_name):\n        \"\"\"\n        Finds the XML elements with the specified name.\n        :param element_name: string, the name of the elements to find.\n        :return: list, a list of found elements with the specified name.\n        >>> xml_processor = XMLProcessor('test.xml')\n        >>> root = xml_processor.read_xml()\n        >>> items = xml_processor.find_element('item')\n        >>> for item in items:\n        >>>     print(item.text)\n        apple\n        banana\n        orange\n        \"\"\"\n        elements = self.root.findall(element_name)\n        return elements\n",
        "annotated_code" : "import xml.etree.ElementTree as ET\n\nclass XMLProcessor:\n    \"\"\"\n    This is a class as XML files handler, including reading, writing, processing as well as finding elements in a XML file.\n    \"\"\"\n\n    def __init__(self, file_name):\n        \"\"\"\n        Initialize the XMLProcessor object with the given file name.\n        :param file_name:string, the name of the XML file to be processed.\n        \"\"\"\n        self.file_name = file_name\n        self.root = None\n\n    def read_xml(self):\n        \"\"\"\n        Reads the XML file and returns the root element.\n        :return: Element, the root element of the XML file.\n        >>> xml_processor = XMLProcessor('test.xml')\n        >>> root_element = xml_processor.read_xml()\n        >>> print(root_element)\n        <Element 'root' at 0x7f8e3b7eb180>\n        \"\"\"\n\n        try:\n            # Use the parse function to parse the XML file into an ElementTree object\n            tree = ET.parse(self.file_name)\n            # Use the getroot method to get the root element of the XML tree, store it in the root attribute, and return it\n            self.root = tree.getroot()\n            return self.root\n        # If an error occurs, return None\n        except:\n            return None\n\n\n    def write_xml(self, file_name):\n        \"\"\"\n        Writes the XML data to the specified file.\n        :param file_name: string, the name of the file to write the XML data.\n        :return: bool, True if the write operation is successful, False otherwise.\n        >>> xml_processor = XMLProcessor('test.xml')\n        >>> root = xml_processor.read_xml()\n        >>> success = xml_processor.write_xml('output.xml')\n        >>> print(success)\n        True\n        \"\"\"\n\n        try:\n            # Use the ElementTree class to create an ElementTree object with the root element\n            tree = ET.ElementTree(self.root)\n            # Use the tree's write method to write the XML data to the provided file\n            tree.write(file_name)\n            # Return True to indicate that everything was successful\n            return True\n        # If an error occurs, return False\n        except:\n            return False\n\n\n    def process_xml_data(self, file_name):\n        \"\"\"\n        Modifies the data in XML elements and writes the updated XML data to a new file.\n        :param file_name: string, the name of the file to write the modified XML data.\n        :return: bool, True if the write operation is successful, False otherwise.\n        >>> xml_processor = XMLProcessor('test.xml')\n        >>> root = xml_processor.read_xml()\n        >>> success = xml_processor.process_xml_data('processed.xml')\n        >>> print(success)\n        True\n        \"\"\"\n\n        # Iterate through each item in the XML tree\n        for element in self.root.iter('item'):\n            # Convert the text of the element to uppercase and update the element's text\n            text = element.text\n            element.text = text.upper()\n        # Use the write_xml class method to write the modified XML data to the provided new file and return the result\n        return self.write_xml(file_name)\n\n\n    def find_element(self, element_name):\n        \"\"\"\n        Finds the XML elements with the specified name.\n        :param element_name: string, the name of the elements to find.\n        :return: list, a list of found elements with the specified name.\n        >>> xml_processor = XMLProcessor('test.xml')\n        >>> root = xml_processor.read_xml()\n        >>> items = xml_processor.find_element('item')\n        >>> for item in items:\n        >>>     print(item.text)\n        apple\n        banana\n        orange\n        \"\"\"\n\n        # Use the findall function to find all the elements with the provided name in the XML tree and return the resultant list\n        elements = self.root.findall(element_name)\n        return elements"
    },
    {
        "id" : "99",
        "code" : "\nimport zipfile\n\n\nclass ZipFileProcessor:\n    \"\"\"\n    This is a compressed file processing class that provides the ability to read and decompress compressed files\n    \"\"\"\n\n    def __init__(self, file_name):\n        \"\"\"\n        Initialize file name\n        :param file_name:string\n        \"\"\"\n        self.file_name = file_name\n\n    def read_zip_file(self):\n        \"\"\"\n        Get open file object\n        :return:If successful, returns the open file object; otherwise, returns None\n        >>> zfp = ZipFileProcessor(\"aaa.zip\")\n        >>> file = zfp.read_zip_file()\n        \"\"\"\n        try:\n            zip_file = zipfile.ZipFile(self.file_name, 'r')\n            return zip_file\n        except:\n            return None\n\n    def extract_all(self, output_path):\n        \"\"\"\n        Extract all zip files and place them in the specified path\n        :param output_path: string, The location of the extracted file\n        :return: True or False, representing whether the extraction operation was successful\n        >>> zfp = ZipFileProcessor(\"aaa.zip\")\n        >>> zfp.extract_all(\"result/aaa\")\n        \"\"\"\n        try:\n            with zipfile.ZipFile(self.file_name, 'r') as zip_file:\n                zip_file.extractall(output_path)\n            return True\n        except:\n            return False\n\n    def extract_file(self, file_name, output_path):\n        \"\"\"\n        Extract the file with the specified name from the zip file and place it in the specified path\n        :param file_name:string, The name of the file to be uncompressed\n        :param output_path:string, The location of the extracted file\n        :return: True or False, representing whether the extraction operation was successful\n        >>> zfp = ZipFileProcessor(\"aaa.zip\")\n        >>> zfp.extract_file(\"bbb.txt\", \"result/aaa\")\n        \"\"\"\n        try:\n            with zipfile.ZipFile(self.file_name, 'r') as zip_file:\n                zip_file.extract(file_name, output_path)\n            return True\n        except:\n            return False\n\n    def create_zip_file(self, files, output_file_name):\n        \"\"\"\n        Compress the specified file list into a zip file and place it in the specified path\n        :param files:list of string, List of files to compress\n        :param output_file_name: string, Specified output path\n        :return:True or False, representing whether the compression operation was successful\n        >>> zfp = ZipFileProcessor(\"aaa.zip\")\n        >>> zfp.create_zip_file([\"bbb.txt\", \"ccc,txt\", \"ddd.txt\"], \"output/bcd\")\n        \"\"\"\n        try:\n            with zipfile.ZipFile(output_file_name, 'w') as zip_file:\n                for file in files:\n                    zip_file.write(file)\n            return True\n        except:\n            return False\n",
        "annotated_code" : "import zipfile\n\nclass ZipFileProcessor:\n    \"\"\"\n    This is a compressed file processing class that provides the ability to read and decompress compressed files\n    \"\"\"\n\n    def __init__(self, file_name):\n        \"\"\"\n        Initialize file name\n        :param file_name:string\n        \"\"\"\n        self.file_name = file_name\n\n    def read_zip_file(self):\n        \"\"\"\n        Get open file object\n        :return:If successful, returns the open file object; otherwise, returns None\n        >>> zfp = ZipFileProcessor(\"aaa.zip\")\n        >>> file = zfp.read_zip_file()\n        \"\"\"\n        try:\n            # Use the ZipFile class to open the zip file specified in the file name in read mode and return the zip file object\n            zip_file = zipfile.ZipFile(self.file_name, 'r')\n            return zip_file\n        # If an error occurs, return None\n        except:\n            return None\n\n    def extract_all(self, output_path):\n        \"\"\"\n        Extract all zip files and place them in the specified path\n        :param output_path: string, The location of the extracted file\n        :return: True or False, representing whether the extraction operation was successful\n        >>> zfp = ZipFileProcessor(\"aaa.zip\")\n        >>> zfp.extract_all(\"result/aaa\")\n        \"\"\"\n\n        try:\n            # Use the ZipFile class to obtain the zip file object for the zip file specified in the file name in read mode\n            with zipfile.ZipFile(self.file_name, 'r') as zip_file:\n                # Use the extractall function to extract all files in the zip file and place them in the specified output path\n                zip_file.extractall(output_path)\n            # Return True to indicate that everything was successful\n            return True\n        # If an error occurs, return False\n        except:\n            return False\n\n    def extract_file(self, file_name, output_path):\n        \"\"\"\n        Extract the file with the specified name from the zip file and place it in the specified path\n        :param file_name:string, The name of the file to be uncompressed\n        :param output_path:string, The location of the extracted file\n        :return: True or False, representing whether the extraction operation was successful\n        >>> zfp = ZipFileProcessor(\"aaa.zip\")\n        >>> zfp.extract_file(\"bbb.txt\", \"result/aaa\")\n        \"\"\"\n\n        try:\n            # Use the ZipFile class to obtain the zip file object for the zip file specified in the file name in read mode\n            with zipfile.ZipFile(self.file_name, 'r') as zip_file:\n                # Use the extract function to extract the file with the provided file name from the zip file and place it in the specified output path\n                zip_file.extract(file_name, output_path)\n            # Return True to indicate that everything was successful\n            return True\n         # If an error occurs, return False\n        except:\n            return False\n\n    def create_zip_file(self, files, output_file_name):\n        \"\"\"\n        Compress the specified file list into a zip file and place it in the specified path\n        :param files:list of string, List of files to compress\n        :param output_file_name: string, Specified output path\n        :return:True or False, representing whether the compression operation was successful\n        >>> zfp = ZipFileProcessor(\"aaa.zip\")\n        >>> zfp.create_zip_file([\"bbb.txt\", \"ccc,txt\", \"ddd.txt\"], \"output/bcd\")\n        \"\"\"\n\n        try:\n            # Use the ZipFile class to obtain the zip file object for the zip file specified in the output file name in write mode\n            with zipfile.ZipFile(output_file_name, 'w') as zip_file:\n                # Iterate through the list of provided files\n                for file in files:\n                    # Use the write function to compress and write each file to the zip file,\n                    zip_file.write(file)\n            # Return True to indicate that everything was successful\n            return True\n        # If an error occurs, return False\n        except:\n            return False"
    }
]