import argparse
import json
from gpt4.execution import Execution as ExecutionGPT4
from claude.execution import Execution as ExecutionClaude

def args_init():
    parser = argparse.ArgumentParser()
    parser.add_argument(
        "--openai_key",
        type=str,
        default="openai_key",
        help="need openai key if using or GPT-4",
    )
    parser.add_argument(
        "--openai_base",
        type=str,
        default="openai_base",
        help="need openai base if using GPT-4",
    )
    parser.add_argument(
        "--claude_key",
        type=str,
        default="claude_key",
        help="need claude key if using claude",
    )
    args = parser.parse_args()
    return args

def load_input_data(file_path):
  try:
    with open(file_path, 'r') as file:
      return json.load(file)
  except FileNotFoundError:
    print(f"Error: File not found at {file_path}")
  except json.JSONDecodeError as e:
    print(f"Error: Failed to decode JSON - {e}")

def write_output_data(result, model):
  try:
    with open("../output/" + model + "/output.json", 'w') as file:
      json.dump(result, file)
  except Exception as e:
    print(f"Error: Failed to write output data - {e}")

def generatePrompt(target_code):
    prompt = "You are a professional software engineer and expert at code documentation. Below are examples of methods in 4 different Python classes that have been annotated with inline comments.\n\nYour task is to follow the same style and add inline comments to the methods in the target class provided below:\n\nDo **not** modify the existing code or docstrings. Only provide inline comments to the class methods in the same style as the examples below. Return the newly annotated target Python class without any other additional text.\n\n---\n\n### Example 1: DiscountStrategy Class\nclass DiscountStrategy:\n\n    \"\"\"\n    This is a class that allows to use different discount strategy based on shopping credit or shopping cart in supermarket.\n    \"\"\"\n\n    def __init__(self, customer, cart, promotion=None):\n        \"\"\"\n        Initialize the DiscountStrategy with customer information, a cart of items, and an optional promotion.\n        :param customer: dict, customer information\n        :param cart: list of dicts, a cart of items with details\n        :param promotion: function, optional promotion applied to the order\n        >>> customer = {'name': 'John Doe', 'fidelity': 1200}\n        >>> cart = [{'product': 'product', 'quantity': 14, 'price': 23.5}]\n        >>> DiscountStrategy(customer, cart, DiscountStrategy.FidelityPromo)\n\n        \"\"\"\n\n        self.customer = customer\n        self.cart = cart\n        self.promotion = promotion\n\n        # Calculate the total cost of items in the cart and store it in self.__total\n        self.__total = self.total()\n\n    def total(self):\n        \"\"\"\n        Calculate the total cost of items in the cart.\n        :return: float, total cost of items\n        >>> customer = {'name': 'John Doe', 'fidelity': 1200}\n        >>> cart = [{'product': 'product', 'quantity': 14, 'price': 23.5}]\n        >>> ds = DiscountStrategy(customer, cart)\n        >>> ds.total()\n        329.0\n\n        \"\"\"\n\n        # Calculate the total cost of items in the cart\n        self.__total = sum(item['quantity'] * item['price'] for item in self.cart)\n\n        # Return the total cost\n        return self.__total\n\n\n    def due(self):\n        \"\"\"\n        Calculate the final amount to be paid after applying the discount.\n        :return: float, final amount to be paid\n        >>> customer = {'name': 'John Doe', 'fidelity': 1200}\n        >>> cart = [{'product': 'product', 'quantity': 14, 'price': 23.5}]\n        >>> ds = DiscountStrategy(customer, cart, DiscountStrategy.FidelityPromo)\n        >>> ds.due()\n        312.55\n\n        \"\"\"\n\n        # Calculate the discount based on the promotion\n        if self.promotion is None:\n            discount = 0\n        else:\n            discount = self.promotion(self)\n        \n        # Return the final amount to be paid after applying the discount\n        return self.__total - discount\n\n\n    @staticmethod\n    def FidelityPromo(order):\n        \"\"\"\n        Calculate the discount based on the fidelity points of the customer.Customers with over 1000 points can enjoy a 5% discount on the entire order.\n        :param order: object, the order to apply the discount to\n        :return: float, discount amount\n        >>> customer = {'name': 'John Doe', 'fidelity': 1200}\n        >>> cart = [{'product': 'product', 'quantity': 14, 'price': 23.5}]\n        >>> order = DiscountStrategy(customer, cart, DiscountStrategy.FidelityPromo)\n        >>> DiscountStrategy.FidelityPromo(order)\n        16.45\n\n        \"\"\"\n\n        # If the fidelity points are over 1000, apply a 5% discount on the total order\n        # Otherwise, no discount is applied\n        # Return the discount amount\n        return order.total() * 0.05 if order.customer['fidelity'] >= 1000 else 0\n\n\n    @staticmethod\n    def BulkItemPromo(order):\n        \"\"\"\n        Calculate the discount based on bulk item quantity in the order.In the same order, if the quantity of a single item reaches 20 or more, each item will enjoy a 10% discount.\n        :param order: object, the order to apply the discount to\n        :return: float, discount amount\n        >>> customer = {'name': 'John Doe', 'fidelity': 1200}\n        >>> cart = [{'product': 'product', 'quantity': 20, 'price': 23.5}]\n        >>> order = DiscountStrategy(customer, cart, DiscountStrategy.BulkItemPromo)\n        >>> DiscountStrategy.BulkItemPromo(order)\n        47.0\n\n        \"\"\"\n\n        discount = 0\n\n        # Iterate through each item in the cart\n        for item in order.cart:\n            # If the quantity of a single item is 20 or more, apply a 10% discount\n            if item['quantity'] >= 20:\n                discount += item['quantity'] * item['price'] * 0.1\n\n        # Return the total discount amount\n        return discount\n\n\n    @staticmethod\n    def LargeOrderPromo(order):\n        \"\"\"\n        Calculate the discount based on the number of different products in the order.If the quantity of different products in the order reaches 10 or more, the entire order will enjoy a 7% discount.\n        :param order: object, the order to apply the discount to\n        :return: float, discount amount\n        >>> customer = {'name': 'John Doe', 'fidelity': 1200}\n        >>> cart = [{'product': 'product', 'quantity': 14, 'price': 23.5}]\n        >>> order = DiscountStrategy(customer, cart, DiscountStrategy.LargeOrderPromo)\n        >>> DiscountStrategy.LargeOrderPromo(order)\n        0.0\n\n        \"\"\"\n\n        # If the number of different products in the order is 10 or more, apply a 7% discount on the total order\n        # Otherwise, no discount is applied\n        # Return the discount amount\n        return order.total() * 0.07 if len({item['product'] for item in order.cart}) >= 10 else 0\n\n---\n\n### Example 2: BigNumCalculator Class\nclass BigNumCalculator:\n    \"\"\"\n    This is a class that implements big number calculations, including adding, subtracting and multiplying.\n    \"\"\"\n\n    @staticmethod\n    def add(num1, num2):\n        \"\"\"\n        Adds two big numbers.\n        :param num1: The first number to add,str.\n        :param num2: The second number to add,str.\n        :return: The sum of the two numbers,str.\n        >>> bigNum = BigNumCalculator()\n        >>> bigNum.add(\"12345678901234567890\", \"98765432109876543210\")\n        '111111111011111111100'\n\n        \"\"\"\n\n        # Pad the numbers with leading zeros to make them the same length\n        max_length = max(len(num1), len(num2))\n        num1 = num1.zfill(max_length)\n        num2 = num2.zfill(max_length)\n\n        # Initialize carry and result\n        carry = 0\n        result = []\n\n        # Perform addition from the last digit to the first\n        for i in range(max_length - 1, -1, -1):\n\n            # Calculate the sum of the digits and the carry\n            digit_sum = int(num1[i]) + int(num2[i]) + carry\n\n            # Update the carry and the digit to be added to the result\n            carry = digit_sum // 10\n            digit = digit_sum % 10\n            result.insert(0, str(digit))\n\n        # If there's a carry left after the last addition, add it to the result\n        if carry > 0:\n            result.insert(0, str(carry))\n\n        # Return the result as a string\n        return ''.join(result)\n\n    @staticmethod\n    def subtract(num1, num2):\n        \"\"\"\n        Subtracts two big numbers.\n        :param num1: The first number to subtract,str.\n        :param num2: The second number to subtract,str.\n        :return: The difference of the two numbers,str.\n        >>> bigNum = BigNumCalculator()\n        >>> bigNum.subtract(\"12345678901234567890\", \"98765432109876543210\")\n        '-86419753208641975320'\n\n        \"\"\"\n        negative = False\n\n        # Check if the first number is smaller than the second\n        # If so, swap them and set the negative flag\n        # If the lengths are equal, compare the numbers as floats\n        if len(num1) < len(num2):\n            num1, num2 = num2, num1\n            negative = True\n        elif len(num1) > len(num2):\n            negative = False\n        else:\n            # If the first number is smaller, swap them and set the negative flag\n            if float(num1) < float(num2):\n                num1, num2 = num2, num1\n                negative = True\n\n        # Pad the numbers with leading zeros to make them the same length\n        max_length = max(len(num1), len(num2))\n        num1 = num1.zfill(max_length)\n        num2 = num2.zfill(max_length)\n\n        # Initialize the borrow and result\n        borrow = 0\n        result = []\n\n        # Perform subtraction from the last digit to the first\n        for i in range(max_length - 1, -1, -1):\n\n            # Calculate the difference of the digits and the borrow\n            digit_diff = int(num1[i]) - int(num2[i]) - borrow\n\n            # If the difference is negative, borrow from the next digit\n            if digit_diff < 0:\n                digit_diff += 10\n                borrow = 1\n            # Otherwise, set the borrow to 0\n            else:\n                borrow = 0\n\n            # Insert the digit at the beginning of the result\n            result.insert(0, str(digit_diff))\n\n        # Remove leading zeros from the result\n        while len(result) > 1 and result[0] == '0':\n            result.pop(0)\n\n        # If the result is negative, insert the negative sign at the beginning\n        if negative:\n            result.insert(0, '-')\n\n        # Return the result as a string\n        return ''.join(result)\n\n    @staticmethod\n    def multiply(num1, num2):\n        \"\"\"\n        Multiplies two big numbers.\n        :param num1: The first number to multiply,str.\n        :param num2: The second number to multiply,str.\n        :return: The product of the two numbers,str.\n        >>> bigNum = BigNumCalculator()\n        >>> bigNum.multiply(\"12345678901234567890\", \"98765432109876543210\")\n        '1219326311370217952237463801111263526900'\n\n        \"\"\"\n\n        # Initialize the lengths of the numbers and the result as a list of zeros\n        len1, len2 = len(num1), len(num2)\n        result = [0] * (len1 + len2)\n\n        # Perform multiplication from the last digit of each number\n        for i in range(len1 - 1, -1, -1):\n            for j in range(len2 - 1, -1, -1):\n\n                # Calculate the product of the digits and their positions\n                mul = int(num1[i]) * int(num2[j])\n                p1, p2 = i + j, i + j + 1\n\n                # Add the product to the result at the correct position\n                total = mul + result[p2]\n\n                # Update the result with the carry and the digit\n                result[p1] += total // 10\n                result[p2] = total % 10\n\n        # Remove leading zeros from the result\n        start = 0\n        while start < len(result) - 1 and result[start] == 0:\n            start += 1\n\n        # Return the result as a string\n        return ''.join(map(str, result[start:]))\n\n---\n\n### Example 3: VectorUtil Class\nimport numpy as np\nfrom gensim import matutils\nfrom numpy import dot, array\n\nclass VectorUtil:\n    \"\"\"\n    The class provides vector operations, including calculating similarity, cosine similarities, average similarity, and IDF weights.\n    \"\"\"\n\n    @staticmethod\n    def similarity(vector_1, vector_2):\n        \"\"\"\n        Compute the cosine similarity between one vector and another vector.\n        :param vector_1: numpy.ndarray, Vector from which similarities are to be computed, expected shape (dim,).\n        :param vector_2: numpy.ndarray, Vector from which similarities are to be computed, expected shape (dim,).\n        :return: numpy.ndarray, Contains cosine distance between `vector_1` and `vector_2`\n        >>> vector_1 = np.array([1, 1])\n        >>> vector_2 = np.array([1, 0])\n        >>> VectorUtil.similarity(vector_1, vector_2)\n        0.7071067811865475\n        \"\"\"\n        # Use the dot function to calculate the dot product of the two vectors and return the result.\n        # Use the matutils.unitvec function to normalize the vectors before calculating the dot product.\n        return dot(matutils.unitvec(vector_1), matutils.unitvec(vector_2))\n\n\n    @staticmethod\n    def cosine_similarities(vector_1, vectors_all):\n        \"\"\"\n        Compute cosine similarities between one vector and a set of other vectors.\n        :param vector_1: numpy.ndarray, Vector from which similarities are to be computed, expected shape (dim,).\n        :param vectors_all: list of numpy.ndarray, For each row in vectors_all, distance from vector_1 is computed, expected shape (num_vectors, dim).\n        :return: numpy.ndarray, Contains cosine distance between `vector_1` and each row in `vectors_all`, shape (num_vectors,).\n        >>> vector1 = np.array([1, 2, 3])\n        >>> vectors_all = [np.array([4, 5, 6]), np.array([7, 8, 9])]\n        >>> VectorUtil.cosine_similarities(vector1, vectors_all)\n        [0.97463185 0.95941195]\n        \"\"\"\n\n        # Use the linalg.norm function to calculate the norm of vector_1 and the norms of all vectors in vectors_all.\n        norm = np.linalg.norm(vector_1)\n        all_norms = np.linalg.norm(vectors_all, axis=1)\n\n        # Use the dot function to calculate the dot product of vector_1 and each vector in vectors_all.\n        dot_products = dot(vectors_all, vector_1)\n\n        # Calculate the cosine similarities by dividing the dot products by the product of the calculated norms.\n        similarities = dot_products / (norm * all_norms)\n\n        # Return the calculated cosine similarities.\n        return similarities\n\n\n    @staticmethod\n    def n_similarity(vector_list_1, vector_list_2):\n        \"\"\"\n        Compute cosine similarity between two sets of vectors.\n        :param vector_list_1: list of numpy vector\n        :param vector_list_2: list of numpy vector\n        :return: numpy.ndarray, Similarities between vector_list_1 and vector_list_2.\n        >>> vector_list1 = [np.array([1, 2, 3]), np.array([4, 5, 6])]\n        >>> vector_list2 = [np.array([7, 8, 9]), np.array([10, 11, 12])]\n        >>> VectorUtil.n_similarity(vector_list1, vector_list2)\n        0.9897287473881233\n        \"\"\"\n\n        # If either of the vector lists is empty, raise a ZeroDivisionError.\n        if not (len(vector_list_1) and len(vector_list_2)):\n            raise ZeroDivisionError('At least one of the passed list is empty.')\n\n        # Use the dot function to calculate the dot product of the mean of vector_list_1 and the mean of vector_list_2 and return the result.\n        # Use the array function to convert the vector lists to numpy arrays.\n        # Use the matutils.unitvec function to normalize the vectors before calculating the dot product.\n        return dot(matutils.unitvec(array(vector_list_1).mean(axis=0)),\nmatutils.unitvec(array(vector_list_2).mean(axis=0)))\n\n\n    @staticmethod\n    def compute_idf_weight_dict(total_num, number_dict):\n        \"\"\"\n        Calculate log(total_num+1/count+1) for each count in number_dict\n        :param total_num: int\n        :param number_dict: dict\n        :return: dict\n        >>> num_dict = {'key1':0.1, 'key2':0.5}\n        >>> VectorUtil.compute_idf_weight_dict(2, num_dict)\n        {'key1': 1.0033021088637848, 'key2': 0.6931471805599453}\n        \"\"\"\n    \n        index_2_key_map = {}\n        index = 0\n        count_list = []\n\n        # Iterate through the items of the number_dict dictionary and store the index and key in index_2_key_map and the count in count_list.\n        for key, count in number_dict.items():\n            index_2_key_map[index] = key\n            count_list.append(count)\n            index = index + 1\n\n        # Use the np.array function to convert count_list to a numpy array.\n        a = np.array(count_list)\n        \n        # Use the np.log function to calculate the logarithm of (total_num + 1) divided by (a + 1).\n        a = np.log((total_num + 1) / (a + 1))\n\n\n        result = {}\n\n        # Iterate through the enumerated items of a and store the key derived from index_2_key_map and corresponding weight in the result dictionary.\n        for index, w in enumerate(a):\n            key = index_2_key_map[index]\n            result[key] = w\n\n        # Return the result dictionary.\n        return result\n\n---\n\n### Example 4: AccessGatewayFilter Class\nimport logging\nimport datetime\n\nclass AccessGatewayFilter:\n    \"\"\"\n    This class is a filter used for accessing gateway filtering, primarily for authentication and access log recording.\n    \"\"\"\n\n    def __init__(self):\n        pass\n\n    def filter(self, request):\n        \"\"\"\n        Filter the incoming request based on certain rules and conditions.\n        :param request: dict, the incoming request details\n        :return: bool, True if the request is allowed, False otherwise\n        >>> filter = AccessGatewayFilter()\n        >>> filter.filter({'path': '/login', 'method': 'POST'})\n        True\n\n        >>> filter = AccessGatewayFilter()\n        >>> filter.filter({'path': '/abc', 'method': 'POST', 'headers': {'Authorization': {'user': {'name': 'user1', 'level': 3, 'address': 'address1'}, 'jwt': 'user2' + str(datetime.date.today() - datetime.timedelta(days=365))}}})\n        True\n\n        \"\"\"\n\n        # Extract the URI from the request\n        request_uri = request['path'] \n\n        # Use the is_start_with class method to return True if the request URI starts with valid prefixes\n        if self.is_start_with(request_uri):\n            return True\n\n        try:\n            # Use the get_jwt_user class method to attempt to extract the user authorization information from the request\n            authorization = self.get_jwt_user(request)\n            user = authorization['user']\n\n            # If the user has a sufficient access level (greater than 2) use the set_current_user_info_and_log class method to log the user access info and return True\n            if user['level'] > 2:\n                self.set_current_user_info_and_log(user)\n                return True\n        except:\n            # Return False in the case that any exception comes up\n            return False\n\n        # Return False if none of the above criteria to return True is met\n        return False\n\n    def is_start_with(self, request_uri):\n        \"\"\"\n        Check if the request URI starts with certain prefixes.\n        Currently, the prefixes being checked are \"/api\" and \"/login\".\n        :param request_uri: str, the URI of the request\n        :return: bool, True if the URI starts with certain prefixes, False otherwise\n        >>> filter = AccessGatewayFilter()\n        >>> filter.is_start_with('/api/data')\n        True\n\n        \"\"\"\n        \n        # A list of valid URI prefixes\n        start_with = [\"/api\", \"/login\"]\n        \n        # Return True if request_uri starts with any of the valid URI prefixes \n        for s in start_with:\n            if request_uri.startswith(s):\n                return True\n            \n        # Return False if none of the above criteria to return True is met\n        return False\n\n    def get_jwt_user(self, request):\n        \"\"\"\n        Get the user information from the JWT token in the request.\n        :param request: dict, the incoming request details\n        :return: dict or None, the user information if the token is valid, None otherwise\n        >>> filter = AccessGatewayFilter()\n        >>> filter.get_jwt_user({'headers': {'Authorization': {'user': {'name': 'user1'}, 'jwt': 'user1'+str(datetime.date.today())}}})\n        {'user': {'name': 'user1'}\n\n        \"\"\"\n         \n        # Extract the user information and the jwt token from the request\n        authorization = request['headers']['Authorization']\n        user = authorization['user']\n        jwt = authorization['jwt'] \n\n        # Check if the start of the jwt token matches the user's name\n        if jwt.startswith(user['name']):\n            # Use the datetime.datetime.strptime method to convert the string jwt date in the \"%Y-%m-%d\" format to a datetime object\n            jwt_str_date = jwt.split(user['name'])[1] \n            jwt_date = datetime.datetime.strptime(jwt_str_date, \"%Y-%m-%d\") \n\n            # Use the datetime.datetime.today() method to get the current date and use the datetime.timedelta method to check if the difference between the current date and the jwt date is 3 days or more\n            if datetime.datetime.today() - jwt_date >= datetime.timedelta(days=3):\n                return None\n\n        # Return the authorization information \n        return authorization\n\n    def set_current_user_info_and_log(self, user):\n        \"\"\"\n        Set the current user information and log the access.\n        :param user: dict, the user information\n        :return: None\n        >>> filter = AccessGatewayFilter()\n        >>> user = {'name': 'user1', 'address': '127.0.0.1'}\n        >>> filter.set_current_user_info_and_log(user)\n\n        \"\"\"\n        # Extract the name and host IP address from user\n        name = user[name] \n        host = user['address']\n        \n        # Use the logging.log method to log the userâ€™s name, user's address, and the current time at the INFO level\n        logging.log(msg=name + host + str(datetime.datetime.now()), level=1)\n\n---\n\n### Target Class: \n"
    return prompt + target_code

if __name__ == '__main__':
    args = args_init()
    file_path = "../input_data/dataset.json"
    dataset = load_input_data(file_path)
    prompt_examples = [0, 33, 9, 93]
    result = []
    exe = None
    model = ""
    if args.openai_key != "openai_key":
        exe = ExecutionGPT4(args=args)
        model = "gpt-4"
    else:
        exe = ExecutionClaude(args=args)
        model = "claude"

    for item in dataset:
       if int(item['id']) in prompt_examples:
          continue
       prompt = generatePrompt(item['code'])
       output = exe.execute(prompt=prompt)
       result.append({"id" : item['id'], "llm_annotated_code" : output})

    write_output_data(result, model)